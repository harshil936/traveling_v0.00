(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('breeze-client')) :
    typeof define === 'function' && define.amd ? define('breeze-client/mixin-get-entity-graph', ['exports', 'breeze-client'], factory) :
    (global = global || self, factory((global['breeze-client'] = global['breeze-client'] || {}, global['breeze-client']['mixin-get-entity-graph'] = {}), global['breeze-client']));
}(this, (function (exports, breezeClient) { 'use strict';

    //#region Copyright, Version, and Description
    function mixinEntityGraph(emclass) {
        var proto = breezeClient.EntityManager.prototype;
        if (!proto.getEntityGraph) {
            proto.getEntityGraph = getEntityGraph;
        }
    }
    mixinEntityGraph(breezeClient.EntityManager);
    function getEntityGraph(roots, expand) {
        if (roots instanceof breezeClient.EntityQuery) {
            var newRoots = this.executeQueryLocally(roots);
            return getEntityGraphCore(newRoots, expand || roots.expandClause);
        }
        else {
            return getEntityGraphCore(roots, expand);
        }
    }
    function getEntityGraphCore(root, expand) {
        var entityGroupMap;
        var graph = [];
        var rootType;
        var roots = Array.isArray(root) ? root : [root];
        addToGraph(roots); // removes dups & nulls
        roots = graph.slice(); // copy of de-duped roots
        if (roots.length) {
            getRootInfo();
            getExpand();
            buildGraph();
        }
        return graph;
        function addToGraph(entities) {
            entities.forEach(function (entity) {
                if (entity && graph.indexOf(entity) < 0) {
                    graph.push(entity);
                }
            });
        }
        function getRootInfo() {
            var compatTypes;
            roots.forEach(function (root, ix) {
                var aspect;
                if (!root || !(aspect = root.entityAspect)) {
                    throw getRootErr(ix, 'is not an entity');
                }
                if (aspect.entityState === breezeClient.EntityState.Detached) {
                    throw getRootErr(ix, 'is a detached entity');
                }
                var em = aspect.entityManager;
                if (entityGroupMap) {
                    if (entityGroupMap !== em._entityGroupMap) {
                        throw getRootErr(ix, "has a different 'EntityManager' than other roots");
                    }
                }
                else {
                    entityGroupMap = em._entityGroupMap;
                }
                getRootType(root, ix);
            });
            function getRootErr(ix, msg) {
                return new Error("'getEntityGraph' root[" + ix + "] " + msg);
            }
            function getRootType(root, ix) {
                var thisType = root.entityType;
                if (!rootType) {
                    rootType = thisType;
                    return;
                }
                else if (rootType === thisType) {
                    return;
                }
                // Types differs. Look for closest common base type
                // does thisType derive from current rootType?
                var baseType = rootType;
                do {
                    compatTypes = compatTypes || baseType.getSelfAndSubtypes();
                    if (compatTypes.indexOf(thisType) > -1) {
                        rootType = baseType;
                        return;
                    }
                    baseType = baseType.baseEntityType;
                    compatTypes = null;
                } while (baseType);
                // does current rootType derives from thisType?
                baseType = thisType;
                do {
                    compatTypes = baseType.getSelfAndSubtypes();
                    if (compatTypes.indexOf(rootType) > -1) {
                        rootType = baseType;
                        return;
                    }
                    baseType = baseType.baseEntityType;
                } while (baseType);
                throw getRootErr(ix, "is not EntityType-compatible with other roots");
            }
        }
        function getExpand() {
            try {
                if (!expand) {
                    expand = [];
                }
                else if (typeof expand === 'string') {
                    // tricky because Breeze expandClause not exposed publically
                    expand = new breezeClient.EntityQuery().expand(expand).expandClause;
                }
                if (expand instanceof breezeClient.ExpandClause && expand.propertyPaths) { // expand clause
                    expand = expand.propertyPaths;
                }
                else if (Array.isArray(expand)) {
                    if (!expand.every(function (elem) { return typeof elem === 'string'; })) {
                        throw '';
                    }
                }
                else {
                    throw '';
                }
            }
            catch (_) {
                throw new Error("expand must be an expand string, array of string paths, or a query expand clause");
            }
        }
        function buildGraph() {
            if (expand && expand instanceof Array && expand.length) {
                var fns = expand.map(makePathFn);
                fns.forEach(function (fn) { fn(roots); });
            }
        }
        // Make function to get entities along a single expand path
        // such as 'Orders.OrderDetails.Product'
        function makePathFn(path) {
            var fns = [], segments = path.split('.'), type = rootType;
            for (var i = 0, slen = segments.length; i < slen; i++) {
                var f = makePathSegmentFn(type, segments[i]);
                type = f.navType;
                fns.push(f);
            }
            return function pathFn(entities) {
                for (var j = 0, flen = fns.length; j < flen; j++) {
                    var elen = entities.length;
                    if (elen === 0) {
                        return;
                    } // nothing left to explore
                    // fn to get related entities for this path segment
                    var fn = fns[j];
                    // get entities related by this path segment
                    var related = [];
                    for (var k = 0; k < elen; k++) {
                        related = related.concat(fn(entities[k]));
                    }
                    addToGraph(related);
                    if (j >= flen - 1) {
                        return;
                    } // no more path segments
                    // reset entities to deduped related entities
                    entities = [];
                    for (var l = 0, rlen = related.length; l < rlen; l++) {
                        var r = related[l];
                        if (entities.indexOf(r) < 0) {
                            entities.push(r);
                        }
                    }
                }
            };
        }
        // Make function to get entities along a single expand path segment
        // such as the 'OrderDetails' in the 'Orders.OrderDetails.Product' path
        function makePathSegmentFn(baseType, segment) {
            var baseTypeName, fn = undefined, navType;
            try {
                baseTypeName = baseType.name;
                var nav = baseType.getNavigationProperty(segment);
                var fkName_1 = nav.foreignKeyNames[0];
                if (!nav) {
                    throw new Error(segment + " is not a navigation property of " + baseTypeName);
                }
                navType = nav.entityType;
                // add derived types
                var navTypes = navType.getSelfAndSubtypes();
                var grps_1 = []; // non-empty groups for these types
                navTypes.forEach(function (t) {
                    var grp = entityGroupMap[t.name];
                    if (grp && grp._entities.length > 0) {
                        grps_1.push(grp);
                    }
                });
                var grpCount_1 = grps_1.length;
                if (grpCount_1 === 0) {
                    // no related entities in cache
                    fn = function () { return []; };
                }
                else if (fkName_1) {
                    fn = function (entity) {
                        var val = null;
                        try {
                            var keyValue = entity.getProperty(fkName_1);
                            for (var i = 0; i < grpCount_1; i += 1) {
                                val = grps_1[i]._entities[grps_1[i]._indexMap[keyValue]];
                                if (val) {
                                    break;
                                }
                            }
                        }
                        catch (e) {
                            rethrow(e);
                        }
                        return val;
                    };
                }
                else {
                    fkName_1 = nav.inverse ?
                        nav.inverse.foreignKeyNames[0] :
                        nav.invForeignKeyNames[0];
                    if (!fkName_1) {
                        throw new Error("No inverse keys");
                    }
                    fn = function (entity) {
                        var vals = [];
                        try {
                            var keyValue_1 = entity.entityAspect.getKey().values[0];
                            grps_1.forEach(function (grp) {
                                vals = vals.concat(grp._entities.filter(function (en) {
                                    return en && en.getProperty(fkName_1) === keyValue_1;
                                }));
                            });
                        }
                        catch (e) {
                            rethrow(e);
                        }
                        return vals;
                    };
                }
                fn.navType = navType;
                fn.path = segment;
            }
            catch (err) {
                rethrow(err);
            }
            return fn;
            function rethrow(e) {
                var typeName = baseTypeName || baseType;
                var error = new Error("'getEntityGraph' can't expand '" + segment + "' for " + typeName);
                error.innerError = e;
                throw error;
            }
        }
    }

    exports.mixinEntityGraph = mixinEntityGraph;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=breeze-client-mixin-get-entity-graph.umd.js.map
