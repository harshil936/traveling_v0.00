{"version":3,"sources":["ng://breeze-client/adapter-model-library-backing-store/adapter-model-library-backing-store.ts"],"names":["core","breeze.core","ModelLibraryBackingStoreAdapter","this","name","register","config","breeze.config","registerAdapter","initializeAdapterInstance","prototype","initialize","getTrackablePropertyNames","entity","names","p","val","isFunction","push","initializeEntityPrototype","proto","getProperty","propertyName","setProperty","value","stype","entityType","complexType","extra","_extra","alreadyWrapped","alreadyWrappedProps","getProperties","forEach","prop","descr","propName","wrapPropDescription","property","hasOwnProperty","nextProto","Object","getPrototypeOf","propDescr","getOwnPropertyDescriptor","configurable","set","newDescr","get","bind","_$interceptor","arguments","length","rawSet","enumerable","makePropDescription","defineProperty","movePropDefsToProto","startTracking","bs","instance","getBackingStore","isUnmapped","getPropertyDescriptor","movePropsToBackingStore","breeze.EntityAspect","isEntity","breeze.DataProperty","isComplexProperty","isScalar","dataType","_createInstanceCore","breeze.makeComplexArray","undefined","defaultValue","breeze.makePrimitiveArray","isNavigationProperty","Error","breeze.makeRelationArray","isSettable","pendingStores","_pendingBackingStores","_backingStore","accessorFn","getAccessorFn","getPendingBackingStore","pending","backingStore","processPendingStores","arrayFirst"],"mappings":"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","sourcesContent":["import * as breeze from 'breeze-client';\r\n\r\nlet core = breeze.core;\r\n\r\nexport class ModelLibraryBackingStoreAdapter implements breeze.ModelLibraryAdapter {\r\n  name: string;\r\n\r\n  constructor() {\r\n    this.name = \"backingStore\";\r\n  }\r\n\r\n  static register(config?: breeze.BreezeConfig) {\r\n    config = config || breeze.config;\r\n    config.registerAdapter(\"modelLibrary\", ModelLibraryBackingStoreAdapter);\r\n    return config.initializeAdapterInstance(\"modelLibrary\", \"backingStore\", true) as ModelLibraryBackingStoreAdapter;\r\n  }\r\n\r\n  initialize() {\r\n  }\r\n\r\n  getTrackablePropertyNames(entity: breeze.Entity) {\r\n    let names: string[] = [];\r\n    for (let p in entity) {\r\n      if (p === \"entityAspect\" || p === \"entityType\") continue;\r\n      if (p === \"_$typeName\" || p === \"_pendingSets\" || p === \"_backingStore\") continue;\r\n      let val = entity[p];\r\n      if (!core.isFunction(val)) {\r\n        names.push(p);\r\n      }\r\n    }\r\n    return names;\r\n  }\r\n\r\n  // This method is called during Metadata initialization\r\n  initializeEntityPrototype(proto: any) {\r\n\r\n    proto.getProperty = function (propertyName: string) {\r\n      return this[propertyName];\r\n    };\r\n\r\n    proto.setProperty = function (propertyName: string, value: any) {\r\n      //if (!this._backingStore.hasOwnProperty(propertyName)) {\r\n      //    throw new Error(\"Unknown property name:\" + propertyName);\r\n      //}\r\n      this[propertyName] = value;\r\n      // allow setProperty chaining.\r\n      return this;\r\n    };\r\n\r\n    movePropDefsToProto(proto);\r\n  }\r\n\r\n  // This method is called when an EntityAspect is first created - this will occur as part of the entityType.createEntity call.\r\n  // which can be called either directly or via standard query materialization\r\n\r\n  // entity is either an entity or a complexObject\r\n  startTracking(entity: breeze.StructuralObject, proto: any) {\r\n    // can't touch the normal property sets within this method - access the backingStore directly instead.\r\n    let bs = movePropsToBackingStore(entity);\r\n\r\n    // assign default values to the entity\r\n    let stype = breeze.EntityAspect.isEntity(entity) ? entity.entityType : entity.complexType;\r\n    stype.getProperties().forEach(function (prop) {\r\n\r\n      let propName = prop.name;\r\n      let val = entity[propName];\r\n\r\n      if (prop instanceof breeze.DataProperty) {\r\n        if (prop.isComplexProperty) {\r\n          if (prop.isScalar) {\r\n            val = (prop.dataType as breeze.ComplexType)._createInstanceCore(entity, prop);\r\n          } else {\r\n            val = breeze.makeComplexArray([], entity, prop);\r\n          }\r\n        } else if (!prop.isScalar) {\r\n          val = breeze.makePrimitiveArray([], entity, prop);\r\n        } else if (val === undefined) {\r\n          val = prop.defaultValue;\r\n        }\r\n\r\n      } else if (prop.isNavigationProperty) {\r\n        if (val !== undefined && val !== null) {\r\n          throw new Error(\"Cannot assign a navigation property in an entity ctor.: \" + propName);\r\n        }\r\n        if (prop.isScalar) {\r\n          // TODO: change this to nullstob later.\r\n          val = null;\r\n        } else {\r\n          val = breeze.makeRelationArray([], entity as breeze.Entity, prop);\r\n        }\r\n      } else {\r\n        throw new Error(\"unknown property: \" + propName);\r\n      }\r\n      // can't touch the normal property sets within this method (IE9 Bug) - so we access the backingStore directly instead.\r\n      // otherwise we could just do\r\n      // entity[propName] = val\r\n      // after all of the interception logic had been injected.\r\n      if ((prop as breeze.DataProperty).isSettable || prop.isNavigationProperty) {\r\n        bs[propName] = val;\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nbreeze.config.registerAdapter(\"modelLibrary\", ModelLibraryBackingStoreAdapter);\r\n\r\n// private methods\r\n\r\n// This method is called during Metadata initialization to correctly \"wrap\" properties.\r\nfunction movePropDefsToProto(proto: any) {\r\n  let stype = (proto.entityType || proto.complexType) as breeze.StructuralType;\r\n  let extra = stype._extra;\r\n\r\n  let alreadyWrapped = extra.alreadyWrappedProps || {};\r\n\r\n  stype.getProperties().forEach(function (prop) {\r\n    let propName = prop.name;\r\n    // we only want to wrap props that haven't already been wrapped\r\n    if (alreadyWrapped[propName]) return;\r\n\r\n    // If property is already defined on the prototype then wrap it in another propertyDescriptor.\r\n    // otherwise create a propDescriptor for it.\r\n    let descr: any;\r\n    if (propName in proto) {\r\n      descr = wrapPropDescription(proto, prop);\r\n    } else {\r\n      descr = makePropDescription(proto, prop);\r\n    }\r\n    // descr will be null for a wrapped descr that is not configurable\r\n    if (descr != null) {\r\n      Object.defineProperty(proto, propName, descr);\r\n    }\r\n    alreadyWrapped[propName] = true;\r\n  });\r\n  extra.alreadyWrappedProps = alreadyWrapped;\r\n}\r\n\r\n// This method is called when an instance is first created via materialization or createEntity.\r\n// this method cannot be called while a 'defineProperty' accessor is executing\r\n// because of IE bug mentioned above.\r\n\r\nfunction movePropsToBackingStore(instance: any) {\r\n\r\n  let bs = getBackingStore(instance);\r\n  let proto = Object.getPrototypeOf(instance);\r\n  let stype = (proto.entityType || proto.complexType) as breeze.StructuralType;\r\n  stype.getProperties().forEach(function (prop) {\r\n    let propName = prop.name;\r\n    if (prop.isUnmapped) {\r\n      // insure that any unmapped properties that were added after entityType\r\n      // was first created are wrapped with a property descriptor.\r\n      if (!core.getPropertyDescriptor(proto, propName)) {\r\n        let descr = makePropDescription(proto, prop);\r\n        Object.defineProperty(proto, propName, descr);\r\n      }\r\n    }\r\n    if (!instance.hasOwnProperty(propName)) return;\r\n    // pulls off the value, removes the instance property and then rewrites it via ES5 accessor\r\n    let value = instance[propName];\r\n    delete instance[propName];\r\n    instance[propName] = value;\r\n  });\r\n  return bs;\r\n}\r\n\r\nfunction makePropDescription(proto: any, property: breeze.EntityProperty) {\r\n  let propName = property.name;\r\n  let pendingStores = proto._pendingBackingStores;\r\n  if (!pendingStores) {\r\n    pendingStores = [];\r\n    proto._pendingBackingStores = pendingStores;\r\n  }\r\n  let descr = {\r\n    get: function () {\r\n      let bs = this._backingStore || getBackingStore(this);\r\n      return bs[propName];\r\n    },\r\n    set: function (value: any) {\r\n      // IE9 cannot touch instance._backingStore here\r\n      let bs = this._backingStore || getPendingBackingStore(this);\r\n      let accessorFn = getAccessorFn(bs, propName);\r\n      this._$interceptor(property, value, accessorFn);\r\n    },\r\n    enumerable: true,\r\n    configurable: true\r\n  };\r\n\r\n  (descr.set as any).rawSet = function (value: any) {\r\n    let bs = this._backingStore || getPendingBackingStore(this);\r\n    let accessorFn = getAccessorFn(bs, propName);\r\n    accessorFn(value);\r\n  };\r\n  return descr;\r\n\r\n}\r\n\r\nfunction getAccessorFn(bs: {}, propName: string): any {\r\n  return function () {\r\n    if (arguments.length === 0) {\r\n      return bs[propName];\r\n    } else {\r\n      bs[propName] = arguments[0];\r\n      return undefined;\r\n    }\r\n  };\r\n}\r\n\r\nfunction wrapPropDescription(proto: any, property: breeze.EntityProperty): any {\r\n  if (!proto.hasOwnProperty(property.name)) {\r\n    let nextProto = Object.getPrototypeOf(proto);\r\n    return wrapPropDescription(nextProto, property);\r\n  }\r\n\r\n  let propDescr = Object.getOwnPropertyDescriptor(proto, property.name);\r\n  if (!propDescr) return undefined;\r\n  // if not configurable; we can't touch it - so leave.\r\n  if (!propDescr.configurable) return undefined;\r\n  // if a data descriptor - don't change it - this is basically a static property - i.e. defined on every instance of the type with the same value.\r\n  if (propDescr.value) return undefined;\r\n  // if a read only property descriptor - no need to change it.\r\n  if (!propDescr.set) return undefined;\r\n\r\n  let localAccessorFn = function (entity: any) {\r\n    return function () {\r\n      if (!propDescr) return undefined;\r\n      if (arguments.length === 0) {\r\n        return propDescr.get!.bind(entity)();\r\n      } else {\r\n        let set = propDescr.set;\r\n        let rawSet = (set as any).rawSet || set;\r\n        rawSet.bind(entity)(arguments[0]);\r\n        return undefined;\r\n      }\r\n    };\r\n  };\r\n\r\n  let newDescr = {\r\n    get: function () {\r\n      if (!propDescr) return undefined;\r\n      return propDescr.get!.bind(this)();\r\n    },\r\n    set: function (value: any) {\r\n      this._$interceptor(property, value, localAccessorFn(this));\r\n    },\r\n    enumerable: propDescr.enumerable,\r\n    configurable: true\r\n  };\r\n  (newDescr.set as any).rawSet = propDescr.set;\r\n  return newDescr;\r\n}\r\n\r\n\r\nfunction getBackingStore(instance: any) {\r\n  let proto = Object.getPrototypeOf(instance);\r\n  processPendingStores(proto);\r\n  let bs = instance._backingStore;\r\n  if (!bs) {\r\n    bs = {};\r\n    instance._backingStore = bs;\r\n  }\r\n  return bs;\r\n}\r\n\r\n// workaround for IE9 bug where instance properties cannot be changed when executing a property 'set' method.\r\nfunction getPendingBackingStore(instance: any) {\r\n  let proto = Object.getPrototypeOf(instance);\r\n  let pendingStores = proto._pendingBackingStores;\r\n  let pending = core.arrayFirst(pendingStores, function (pending) {\r\n    return pending.entity === instance;\r\n  });\r\n  if (pending) return (pending as any).backingStore;\r\n  let bs = {};\r\n  pendingStores.push({ entity: instance, backingStore: bs });\r\n  return bs;\r\n}\r\n\r\nfunction processPendingStores(proto: any) {\r\n  let pendingStores = proto._pendingBackingStores;\r\n  if (pendingStores) {\r\n    pendingStores.forEach(function (pending: any) {\r\n      pending.entity._backingStore = pending.backingStore;\r\n    });\r\n    pendingStores.length = 0;\r\n  }\r\n}\r\n\r\n"]}