{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","ng://breeze-client/src/enum.ts","ng://breeze-client/src/core.ts","ng://breeze-client/src/assert-param.ts","ng://breeze-client/src/event.ts","ng://breeze-client/src/config.ts","ng://breeze-client/src/data-service.ts","ng://breeze-client/src/validate.ts","ng://breeze-client/src/data-type.ts","ng://breeze-client/src/entity-state.ts","ng://breeze-client/src/entity-action.ts","ng://breeze-client/src/entity-key.ts","ng://breeze-client/src/query-options.ts","ng://breeze-client/src/predicate.ts","ng://breeze-client/src/entity-query.ts","ng://breeze-client/src/entity-aspect.ts","ng://breeze-client/src/naming-convention.ts","ng://breeze-client/src/csdl-metadata-parser.ts","ng://breeze-client/src/local-query-comparison-options.ts","ng://breeze-client/src/default-property-interceptor.ts","ng://breeze-client/src/entity-metadata.ts","ng://breeze-client/src/abstract-data-service-adapter.ts","ng://breeze-client/src/validation-options.ts","ng://breeze-client/src/save-options.ts","ng://breeze-client/src/key-generator.ts","ng://breeze-client/src/entity-group.ts","ng://breeze-client/src/mapping-context.ts","ng://breeze-client/src/unattached-children-map.ts","ng://breeze-client/src/entity-manager.ts","ng://breeze-client/src/interface-registry.ts","ng://breeze-client/src/observable-array.ts","ng://breeze-client/src/relation-array.ts","ng://breeze-client/src/complex-array.ts","ng://breeze-client/src/primitive-array.ts","ng://breeze-client/src/breeze.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","BreezeEnum","propertiesObj","_this","keys","forEach","key","getSymbols","resolveSymbols","map","ks","symbol","getNames","name","fromName","_resolvedNamesAndSymbols","result","symb","contains","sym","toString","toJSON","_$typeName","uncurry","arraySlice","slice","isES5Supported","getPrototypeOf","defineProperty","Éµ0","getPropDescriptor","obj","propertyName","getOwnPropertyDescriptor","nextObj","updateWithDefaults","target","defaults","name_2","undefined","requireLibCore","libName","win","window","global","lib","require","defined","classof","toLowerCase","isFunction","camelEdges","f","Function","apply","parent","F","core","getOwnPropertyValues","source","name_1","getPropertyDescriptor","objectForEach","kvFn","objectFirst","kvPredicate","objectMap","results","extend","propNames","propName","propEq","propsEq","property1Name","property2Name","pluck","items","fn","includeNull","isArray","result_1","v","ix","resolveProperties","sources","propertyNames","pn","src","val","setAsDefault","ctor","defaultInstance","getArray","arr","toArray","item","arrayEquals","a1","a2","equalsFn","arrayFirst","array","predicate","j","arrayIndexOf","arrayRemoveItem","predicateOrItem","shouldRemoveMultiple","removed","splice","arrayZip","callback","Math","min","arrayAddItemUnique","indexOf","arrayFlatMap","mapFn","requireLib","libNames","errMessage","arrNames","split","Error","using","property","tempValue","originalValue","wrapExecution","startFn","endFn","state","memoize","args","hash","currentArg","JSON","stringify","getUuid","replace","c","random","durationToSeconds","duration","struct","exec","ymdhmsIndexes","factors","seconds","digit","isSettable","pd","writable","set","isDate","isNaN","getTime","isDateString","s","test","isGuid","isDuration","isEmpty","isNumeric","parseFloat","isFinite","identity","x","noop","stringStartsWith","str","prefix","stringEndsWith","suffix","formatString","params","_i","pattern","RegExp","match","index","titleCase","text","charAt","toUpperCase","toJson","template","aliases","defaultValue","some","toJSONSafe","replacer","_$visited","newObj","prop","toJSONSafeReplacer","Param","_applyOne","instance","MESSAGE_PREFIX","_contexts","isObject","isTypeOf","isBoolean","isString","isNumber","isNonEmptyString","addContext","msg","typeName","isInstanceOf","type","hasProperty","isEnumOf","enumType","isRequired","allowNull","isOptional","prevContext","isOptionalMessage","isNonEmptyArray","mustNotBeEmpty","isArrayMessage","or","_context","check","ok","self","contexts","pop","context","getMessage","_addContext","that","message","join","withDefault","whereParam","applyAll","checkOnly","parentTypeName","allowUnknownProperty","config","clone","throwConfigError","assertParam","pc","every","v1","arrayDescr","curContext","setContext","ConfigParam","param","assertConfig","publishCore","data","errorCallback","subscribers","_subscribers","_defaultErrorCallback","BreezeEvent","publisher","defaultErrorCallback","unsubscribe","unsubKey","subs","__eventNameMap","publish","publishAsync","_isEnabled","setTimeout","subscribe","__nextUnsubKey","clear","bubbleEvent","getParentFn","_getEventParent","enable","eventName","isEnabled","ob","_$eventMap","eventMap","parent_1","Event","InterfaceDef","_implMap","registerCtor","adapterName","getImpl","getFirstImpl","kv","getDefaultInstance","BreezeConfig","functionRegistry","typeRegistry","objectRegistry","stringifyPad","interfaceInitialized","noEval","_a","registerAdapter","interfaceName","adapterCtor","implName","getInterfaceDef","getAdapter","idef","impl","_$impl","initializeAdapterInstance","isDefault","_initializeAdapterInstanceCore","getAdapterInstance","registerFunction","fnName","_$fnName","registerType","getRegisteredFunction","lcName","_interfaceRegistry","k","setQ","q","console","warn","_storeObject","_fetchObject","interfaceDef","inst","initialize","checkForRecomposition","interfaceInitializedArgs","DataService","updateWithConfig","resolve","dataServices","hasServerMetadata","useJsonp","ds","serviceName","adapterInstance","jsonResultsAdapter","uriBuilder","uriBuilderName","_normalizeServiceName","trim","substr","fromJSON","json","JsonResultsAdapter","qualifyUrl","startsWith","url","dsConfig","jsConfig","extractResultsDefault","extractSaveResultsDefault","extractKeyMappingsDefault","extractDeletedKeysDefault","entities","Entities","keyMappings","KeyMappings","deletedKeys","DeletedKeys","rootContext","displayName","resolveProperty","Validator","valFn","_baseContext","messageTemplate","messageTemplates","validate","additionalContext","currentContext","ValidationError","vars","ownPropertiesOnly","_","valOrFn","formatTemplate","js","validatorName","register","validator","registerFactory","validatorFactory","bool","creditCard","date","emailAddress","guid","integer","integerRange","maxLength","number","phone","regularExpression","required","string","stringLength","ctx","allowEmptyStrings","minLength","allowString","double","single","parseInt","floor","int64","int32","intRangeValidatorCtor","int16","byte","none","Date","parse","luhn","expression","makeRegExpValidator","minValue","maxValue","max","defaultMessage","re","luhnArr","incNum","counter","odd","temp","String","errorMessage","getKey","isServerError","validatorOrErrorName","_localTimeRegex","DataType","_super","tslib_1.__extends","getComparableFn","dataType","normalize","Time","fromEdmDataType","dt","parts","simpleName","Byte","Undefined","fromValue","DateTime","Guid","Boolean","Double","parseTimeFromServer","__edmType","ms","parseDateAsUTC","parseRawValue","_resetConstants","constants","stringPrefix","nextNumber","nextNumberIncrement","parseDateFromServer","coerceToString","fmtOData","fmtString","getNext","getNextString","Int64","isInteger","quoteJsonOData","coerceToInt","makeFloatFmt","getNextNumber","Int32","fmtInt","Int16","Decimal","isFloat","coerceToFloat","Single","coerceToDate","parseRawDate","fmtDateTime","getNextDateTime","getConcurrencyValue","getConcurrencyDateTime","DateTimeOffset","fmtDateTimeOffset","fmtTime","coerceToBool","fmtBoolean","coerceToGuid","fmtGuid","getNextGuid","Binary","fmtBinary","parseRawBinary","fmtUndefined","dt2","sourceTypeName","round","fmtSuffix","toISOString","throwError","$value","validatorCtor","getValidatorCtor","EntityState","isUnchanged","Unchanged","isAdded","Added","isModified","Modified","isDeleted","Deleted","isDetached","Detached","isUnchangedOrModified","isAddedModifiedOrDeleted","EntityAction","isAttach","_isAttach","isDetach","_isDetach","isModification","_isModification","Attach","AttachOnQuery","AttachOnImport","Detach","MergeOnQuery","MergeOnImport","MergeOnSave","PropertyChange","EntityStateChange","AcceptChanges","RejectChanges","Clear","EntityKey","entityType","keyValues","EntityType","subtypes","getSelfAndSubtypes","_subtypes","filter","st","isAbstract","keyProperties","kp","values","_keyInGroup","createKeyString","metadataStore","_getStructuralType","equals","entityKey","altEntityType","k1","k2","_isEmpty","ENTITY_KEY_DELIMITER","MergeStrategy","PreserveChanges","OverwriteChanges","SkipMerge","Disallowed","FetchStrategy","FromServer","FromLocalCache","QueryOptions","_updateWithConfig","queryOptionsArray","qoConfig","mergeStrategy","fetchStrategy","includeDeleted","Predicate","bind","arg","createPredicateFromArray","PassthruPredicate","createPredicateFromObject","_validate","usesNameOnServer","and","pred","AndOrPredicate","not","argsForAndOrPredicates","UnaryPredicate","toJSONExt","_entityType","visit","toJSONVisitor","toFunction","toFunctionVisitor","visitor","visitorMethodName","toNameOnServer","_initialize","opMap","aliasMap","op","updateAliasMap","_resolveOp","okIfNotFound","opStr","operator","preds","BinaryPredicate","expr","AnyAllPredicate","createPredicateFromKeyValue","alias","expr1","expr2","expr1Source","expr2Source","expr1Context","createExpr","LitExpr","expr2Context","isRHS","eq","ne","lt","le","gt","ge","startswith","endswith","in","exprSource","isAnonymous","any","all","PredicateExpression","hasExplicitDataType","resolveDataType","PropExpr","propertyPath","props","getPropertiesOnPath","DataProperty","FnExpr","exprs","qf","_funcMap","localFn","exprStr","toupper","tolower","substring","pos","substringof","find","s1","s2","indexof","ceiling","ceil","second","getSeconds","minute","getMinutes","day","getDate","month","getMonth","year","getFullYear","RX_IDENTIFIER","RX_COMMA_DELIM1","RX_COMMA_DELIM2","DELIM","fromCharCode","exprContext","isProperty","parseLitOrPropExpr","regex","tokens","token","repl","parseExpr","argSource","commaMatchStr","newContext_1","isFnArg","a","parseFnExpr","firstChar","unquotedValue","isExtended","passthruPredicate","unaryPredicate","predFn","entity","binaryPredicate","expr1Fn","expr2Fn","lqco","mc","v2","stringEquals","isCaseSensitive","stringContains","getBinaryPredicateFn","localQueryComparisonOptions","andOrPredicate","predFns","reduce","prev","cur","anyAllPredicate","exprFn","newContext","anyAllPredFn","getAnyAllPredicateFn","litExpr","propExpr","properties","getProperty","EntityAspect","getPropertyPathValue","fnExpr","exprFns","usesSql92CompliantStringComparison","predVal","expr1Val","expr2Val","predVals","combine","exprVal","useExplicitDataType","clientPropertyPathToServer","exprVals","j1","j2","EntityQuery","resourceName","resourceName,from","resultEntityType,toType","wherePredicate,where","orderByClause,orderBy","OrderByClause","selectClause,select","SelectClause","expandClause,expand","ExpandClause","skipCount,skip","takeCount,take","parameters","inlineCountEnabled,inlineCount","noTrackingEnabled,noTracking","queryOptions","fromEntityType","wherePredicate","orderByClause","selectClause","skipCount","takeCount","expandClause","inlineCountEnabled","noTrackingEnabled","entityManager","from","toType","where","orderBy","propertyPaths","isDescending","normalizePropertyPaths","orderByDesc","select","skip","count","top","take","expand","withParameters","inlineCount","enabled","useNameOnServer","noTracking","processUsing","dataService","execute","executeQuery","executeLocally","executeQueryLocally","propertyPathFn","toJSONExtFn","from,resourceName","toType,resultEntityType","where,wherePredicate","orderBy,orderByClause","select,selectClause","expand,expandClause","skip,skipCount","take,takeCount","inlineCount,inlineCountEnabled","noTracking,noTrackingEnabled","fromEntities","isEntity","ents","firstEntity","defaultResourceName","predParts","FilterQueryOp","Equals","buildPredicate","em","entityAspect","fromEntityKey","buildKeyPredicate","_getFromEntityType","throwErrorIfNotFound","entityTypeName","getEntityTypeNameForResourceName","_getToEntityType","skipFromCheck","resultEntityType","_toUri","buildUri","fromEntityNavigation","navigationProperty","navProperty","_checkNavProperty","isScalar","foreignKeyNames","relatedKeyValues","fkName","inverseNp","inverse","invForeignKeyNames","buildNavigationPredicate","copy","pp","keyProps","NotEquals","GreaterThan","LessThan","GreaterThanOrEqual","LessThanOrEqual","Contains","StartsWith","EndsWith","Any","All","In","IsTypeOf","BooleanQueryOp","And","Or","Not","isDesc","clauses","OrderByItem","getComparer","orderByFuncs","obc","entity1","entity2","lastProperty","propDataType","parentType","value1","value2","_pathNames","path","setUnchanged","setEntityState","setModified","setDeleted","setDetached","entityGroup","entityState","isBeingSaved","originalValues","hasValidationErrors","_validationErrors","validationErrorsChanged","propertyChanged","_$entityType","entityCtor","getEntityCtor","interfaceRegistry","modelLibrary","startTracking","nextValue_1","forceRefresh","_entityKey","acceptChanges","_checkOperation","detachEntity","entityChanged","entityAction","rejectChanges","rejectChangesCore","_notifyStateChange","_linkRelatedEntities","getPropertyPath","setAdded","needsSave","clearOriginalValues","hasTempKey","removeFromRelations","group","_detach","loadNavigationProperty","query","then","_markAsLoaded","Promise","reject","markNavigationPropertyAsLoaded","isNavigationPropertyLoaded","_loadedNps","navPropName","validateEntity","_processValidationOpAndPublish","validateTarget","validateProperty","getPropertyValue","complexAspect","_validateProperty","getValidationErrors","isEntityProperty","propertyName_1","ve","addValidationError","validationError","_addValidationError","removeValidationError","validationErrorOrKey","_removeValidationError","clearValidationErrors","valError","_pendingValidationResult","getParentKey","fkNames","fkValues","fkn","shift","operationName","getAllValidators","validationFn","added","_nullInstance","aspect","stype","complexType","setProperty","complexProperties","cp","cos","_rejectChanges","removeFromRelationsCore","navigationProperties","np","npValue","collection","coIndex","getEntityAspect","getProperties","isComplexProperty","pv","cv","ComplexAspect","complexObject","parentProperty","complexCtor","getCtor","_acceptChanges","NamingConvention","ncConfig","serverPropertyNameToClient","serverPropertyName","clientPropertyNameToServer","clientPropertyName","camelCase","completeParseCsdlEntityType","csdlEntityType","schema","schemas","keyNamesOnServer","propertyRef","parseCsdlDataProperty","csdlProperty","association","csdlNavProperty","containingSchema","assocFullName","parseTypeNameWithSchema","relationship","assocNamespace","namespace","assocSchema","assocName","shortTypeName","assocs","assoc","getAssociation","toEnd","end","assocEnd","role","toRole","multiplicity","constraint","referentialConstraint","cfg","nameOnServer","associationName","principal","dependent","fromRole","invForeignKeyNamesOnServer","foreignKeyNamesOnServer","NavigationProperty","_addPropertyCore","parseCsdlNavProperty","addEntityType","_entityTypeResourceMap","deferredTypes","_deferredTypes","deferrals","dp","typeParts","parseCsdlSimpleProperty","enumTypes","baseTypeName","isEdmxEnumType","extensions","ext","attributes","attr","isODataEnumType","isEnumType","complexTypeName","isNullable","parseCsdlComplexProperty","dataProperty","typeValidator","validators","validatorArgs","addValidators","nullable","isPartOfKey","autoGeneratedKeyType","AutoGeneratedKeyType","None","extension","isIdentityProperty","Identity","concurrencyMode","rawTypeName","warnings","MetadataStore","parseTypeName","cSpaceOSpaceMapping","ns","getNamespaceFor","makeTypeHash","shortName","mapping","fullName","CsdlMetadataParser","altMetadata","mappings","newMap_1","entityContainer","container","entitySet","setEntityTypeForResourceName","ct","csdlComplexType","ComplexType","parseCsdlComplexType","et","abstract","baseType","parseCsdlEntityType","badNavProps","getIncompleteNavigationProperties","npa","importMetadata","LocalQueryComparisonOptions","lqcoConfig","caseInsensitiveSQL","defaultPropertyInterceptor","newValue","rawAccessorFn","oldValue","nv","localAspect","inProcess","_inProcess","dataProperties","setDpValueComplex","isDataProperty","isLoading","newKey","findEntityByKey","oldKey","_findEntityGroup","_replaceKey","relatedNavProp","relatedNavigationProperty","relatedEntity","_unattachedChildrenMap","addChild","inverseNavigationProperty","_inKeyFixup","invNavProp","relatedArray","updateStateAndValidate","propertyIx_1","iv","inverseForeignKeyProperties","baseEntityType","invFkProp","_updateFkVal","setDpValueSimple","inverseProp","newAspect","attachEntity","oldSiblings","pkValues_1","relatedDataProperties","keyProp","relatedDataProp","relatedValue","setNpValue","propChangedArgs","isRejectingChanges","postChangeEvents","isUnmapped","validationOptions","validateOnPropertyChange","_resourceEntityTypeMap","_structuralTypeMap","_shortNameMap","_ctorRegistry","_incompleteTypeMap","_incompleteComplexTypeMap","_id","__id","metadataFetched","setProperties","addDataService","shouldOverwrite","_getDataServiceIndex","structuralType","isComplexType","_updateFromBase","_updateNames","_mappedPropertiesCount","_updateCps","_updateNps","defResourceName","exportMetadata","metadataVersion","namingConvention","structuralTypes","resourceEntityTypeMap","exportedMetadata","allowMerge","metadataAsString","metadataJson","ncName","lqcoName","realDs","qualifyTypeName","custom","mergeProps","mergeStructuralType","completeStructuralTypeFromJson","structuralTypeFromJson","incompleteTypeMap","exportedString","hasMetadataFor","getDataService","fetchMetadata","rawMetadata","trackUnmappedType","interceptor","_setCtor","registerEntityTypeCtor","structuralTypeName","aCtor","initFn","noTrackingFn","qualifiedTypeName","getQualifiedTypeName","getAsEntityType","getStructuralType","getAsComplexType","getEntityType","qualTypeName","getEntityTypes","typeMap","types","getTypesFromMap","entityTypeOrName","ANONTYPE_PREFIX","typeHash","_checkEntityType","normalizeTypeName","jsonProps","jsonProp","structTypeName","throwIfNotFound","isQualifiedTypeName","etConfig","__nextAnonIx","foreignKeyProperties","concurrencyProperties","unmappedProperties","addProperties","isSubtypeOf","bt","addProperty","newprop","stype_1","isNavigationProperty","newDp","baseProperty","newNp","shouldResolve","isFrozen","_addDataProperty","_addNavigationProperty","tryResolveNp","updateClientServerNames","_extra","alreadyWrappedProps","proto_1","_ctor","initializeEntityPrototype","createEntity","initialValues","_$eref","_createInstanceCore","_updateTargetFromRaw","getRawValueFromConfig","navEntityType_1","relatedEntities_1","_initializeInstance","ctInstance","ctInst","_initialized","ctorRegistry","ctorType","createCtor","createEmptyCtor","instanceProto","calcUnmappedProperties","_$interceptor","addValidator","getPropertyNames","getDataProperty","getNavigationProperty","useServerName","delimiter","fn_1","getEntityKeyFromRawEntity","rawEntity","rawValueFn","raw","rawVal","oldVal","complexType_1","newVal","rawCo","newCo","coEquals","rv","rawAspect","targetAspect","originalValuesMap","extraMetadata","localPropsOnly","nc","resolveCp","clientPropName","serverPropName","clientName","serverNames","cName","sName","testName","serverName","clientNames","co1","co2","_resolveNp","incompleteNps","metadataPropNames","getTrackablePropertyNames","newProp_1","createInstance","getRawValueFromServer","getRawValueFromClient","baseProp","formatName","setInverse","getInverse","_inverse","invNp","throwSetInverseError","altNp","invFkName","fkProp","invEntityType","np2","parentEntityType","fkProps","fkPropCollection","resolveRelated","KeyGenerator","proto","propObj","AbstractDataServiceAdapter","changeRequestInterceptor","DefaultChangeRequestInterceptor","visitNode","ajaxImpl","ajax","success","httpResponse","metadata","errMsg","handleHttpError","mappingContext","adapter","getUrl","rData","Results","InlineCount","crossDomain","saveChanges","saveContext","saveBundle","saveBundleSer","_prepareSaveBundle","bundle","contentType","Errors","errors","saveResult","_prepareSaveResult","_createChangeRequestInterceptor","cri","isFn","pre","post","getRequest","_catchNoConnectionError","err","status","messagePrefix","errObj","entityErrors","Message","ExceptionMessage","EntityErrors","tmp_1","InnerException","errorName","ErrorName","EntityTypeName","KeyValues","PropertyName","ErrorMessage","propNameFn_1","createError","request","requests","ValidationOptions","validateOnAttach","validateOnSave","validateOnQuery","options","SaveOptions","allowConcurrentSaves","_tempIdMap","generateTempKeyValue","valueIfAvail","nextId","propEntry","_getPropEntry","keyMap","getNextFn","getTempKeys","keyValue","isTempKey","createIfMissing","EntityGroup","_indexMap","_entities","_emptyIndexes","keyInGroup","targetEntity","wasUnchanged","rawServerEntity","helper","unwrapInstance","hasChanges","unchanged","len","getChanges","changes","getEntities","entityStates","entityState_1","getFilter","_clear","fkPropName","_fixupKey","realValue","keyPropName","MappingContext","refMap","deferredFns","uriString","visitAndMerge","nodes","nodeContext","jra","node","meta","nodeType","processMeta","mergeOptions","processDeferred","assignFn","ignore","nodeRefId","refValue_1","resolveEntityRef","processNoMerge","nodeId","_$meta","isSaving","targetEntityState","updateEntityNoMerge","updateEntity","wasLoaded","action","_attachEntityCore","mergeEntity","passThru","keyFn","processAnonType","refValue","updateEntityRef","uriKey","mergeRelatedEntityCore","mergeRelatedEntitiesCore","updateRelatedEntity","mergeRelatedEntity","relatedEntities","inverseProperty","originalRelatedEntities","updateRelatedEntityInCollection","mergeRelatedEntities","relatedRawEntity","relatedRawEntities","origValues_1","UnattachedChildrenMap","parentEntityKey","child","tuple","getTuple","children","removeChildren","parentEntityKeyString","tuples","t","getTuples","allTuples","baseKey","getTuplesByString","EntityManager","emConfig","unwrapOriginalValues","unwrapChangedValues","hasChangesChanged","isCtor","defaultQueryOptions","defaultSaveOptions","saveOptions","defaultValidationOptions","configParam","keyGeneratorCtor","keyGenerator","importEntities","exported","exportEntities","exportConfig","includeMetadata","asString","exportBundle","entitiesOrEntityTypes","entityGroupMap","first","entityTypes","checkEntityTypes","_entityGroupMap","tempKeys","newGroupMap","resultGroup","dps","serializerFn","getSerializerFn","rawEntities","structuralObjectToJson","so","dpName","coDps_1","tempNavPropNames","exportTempKeyInfo","exportEntityGroup","exportEntityGroups","metadataStoreName","importConfig","metadataVersionFn","tempKeyMap","entitiesToLink","impConfig","_pendingPubs","_hasChangesAction","jsonGroup","mergeAdds","newTempKey","getMappedKey","npName","oldFkValue","fk","newFk","importEntityGroup","findOrCreateEntityGroup","tempKeyMapping","_setHasChanges","createEmptyCopy","addEntity","esSymbol","msSymbol","_inProcessEntity","manager","attachedEntity","ek","keyPropsWithDefaultValues","checkEntityKey","related","attachRelatedEntities","promiseWithCallbacks","executeQueryCore","executeQueryLocallyCore","entitiesToSave","getEntitiesToSave","serverKeys","clearServerErrors","saveChangesValidateOnClient","processSavedEntities","savedEntities","fixupKeys","ekey","candidates","nextValue","updateConcurrencyProperty","updateConcurrencyProperties","markIsBeingSaved","serverError","clientError","saveError","serverErrors","serr","processServerErrors","failedEntities","getEntityByKey","createEntityKey","fetchEntityByKey","fetchEntityByKeyCore","nextKeyValue","_hasChanges","_hasChangesCore","getEntityGroups","eg","getChangesCore","aspects","entTypes","entityGroups","selected","getEntitiesCore","entStates","es","validateEntityStates","ecArgs","hadChanges","unattachedMap","keystring","tpl","childToParentNp","parentToChildNp","unattachedChildren","onlyChild","currentChildren_1","currentChildren_2","_push","parentKey","fkValue","checkLocalCacheFirst","remainingArgs","foundIt","fromCache","etName","flag","promise","km","groupMap","results_1","qr","mappingContext_1","validateOnQuery_1","extractResults","markLoadedNavPath","ea","arrayChanged","markLoadedNavProps","retrievedEntities","structObj","transformFn","rawObject","unmapped","co","__unmapped","nextTarget","unwrappedCo","unwrappedCos","cpHasOriginalValues","coOrCos","structuralObject","coHasOriginalValues","_origValues","groups","findOrCreateEntityGroups","filterFunc","newFilterFunc","orderByComparer","sort","selectFn","InterfaceRegistry","initializeAdapterInstances","irConfig","eventArgs","pendingPubs","_getPendingPubs","_pendingArgs","sourceValue","targetValue","combineArgs","processAdds","obsArray","adds","_processAdds","processRemoves","removes","_processRemoves","observableArray","mixin","_inProgress","goodAdds","_getGoodAdds","_beforeChange","objPrototype","unshift","newArgs","updateEntityState","initializeParent","relationArrayMixin","load","parentEntity","relationArray","navProp","_addsInProcess","fkPropNames_1","keyProps_1","checkForDups","add","getGoodAdds","addsInProcess","startIx","childEntity","pks_1","inp","makeRelationArray","arrX","complexArrayMixin","complexArray","coAspect","clearAspect","makeComplexArray","primitiveArrayMixin","makePrimitiveArray","breeze","version"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/*\r\n * Copyright 2012-2019 IdeaBlade, Inc.  All Rights Reserved.  \r\n * Use, reproduction, distribution, and modification of this code is subject to the terms and \r\n * conditions of the IdeaBlade Breeze license, available at http://www.breezejs.com/license\r\n *\r\n * Author: Jay Traband\r\n */\r\n\r\n/**\r\nBase class for all Breeze enumerations, such as EntityState, DataType, FetchStrategy, MergeStrategy etc.\r\nA Breeze Enum is a namespaced set of constant values.  Each Enum consists of a group of related constants, called 'symbols'.\r\nUnlike enums in some other environments, each 'symbol' can have both methods and properties.\r\n>     class DayOfWeek extends BreezeEnum {\r\n>       dayIndex: number;\r\n>       isWeekend?: boolean;\r\n>       nextDay() {\r\n>         let nextIndex = (this.dayIndex + 1) % 7;\r\n>         return DayOfWeek.getSymbols()[nextIndex];\r\n>       }\r\n>\r\n>       static Monday = new DayOfWeek( { dayIndex: 0});\r\n>       static Tuesday = new DayOfWeek( { dayIndex: 1 });\r\n>       static Wednesday = new DayOfWeek( { dayIndex: 2 });\r\n>       static Thursday = new DayOfWeek( { dayIndex: 3 });\r\n>       static Friday = new DayOfWeek( { dayIndex: 4 });\r\n>       static Saturday = new DayOfWeek( { dayIndex: 5, isWeekend: true });\r\n>       static Sunday = new DayOfWeek( { dayIndex: 6, isWeekend: true });\r\n>     }\r\n>\r\n>     describe(\"DayOfWeek\", () => {\r\n>       test(\"should support full enum capabilities\", function() {\r\n>         // // custom methods\r\n>         let dowSymbols = DayOfWeek.getSymbols();\r\n>         expect(dowSymbols.length).toBe(7);\r\n>         expect(DayOfWeek.Monday.nextDay()).toBe(DayOfWeek.Tuesday);\r\n>         expect(DayOfWeek.Sunday.nextDay()).toBe(DayOfWeek.Monday);\r\n>       // // custom properties\r\n>         expect(DayOfWeek.Tuesday.isWeekend).toBe(undefined);\r\n>         expect(DayOfWeek.Saturday.isWeekend).toBe(true);\r\n>       // // Standard enum capabilities\r\n>         expect(DayOfWeek.Thursday instanceof DayOfWeek).toBe(true);\r\n>         expect(BreezeEnum.isSymbol(DayOfWeek.Wednesday)).toBe(true);\r\n>         expect(DayOfWeek.contains(DayOfWeek.Thursday)).toBe(true);\r\n>         expect(DayOfWeek.Friday.toString()).toBe(\"Friday\");\r\n>       });\r\n>   });\r\nNote that we have Error['x'] = ... in some places in the code to prevent Terser from optimizing out some important calls.\r\n@dynamic\r\n*/\r\nexport class BreezeEnum {\r\n  // // TODO: think about CompositeEnum (flags impl).\r\n  /** The name of this symbol */\r\n  name: string;\r\n  /** Type of the enum; set in prototype of each enum */\r\n  _$typeName: string;\r\n  /** @hidden @internal */\r\n  static _resolvedNamesAndSymbols: { name: string, symbol: BreezeEnum }[];\r\n\r\n  /**  */\r\n  constructor(propertiesObj?: Object) {\r\n    if (propertiesObj) {\r\n      Object.keys(propertiesObj).forEach((key) => this[key] = propertiesObj[key]);\r\n    }\r\n  }\r\n\r\n  /**\r\n  Returns all of the symbols contained within this Enum.\r\n  >     let symbols = DayOfWeek.getSymbols();\r\n  @return All of the symbols contained within this Enum.\r\n  **/\r\n  static getSymbols() {\r\n    return this.resolveSymbols().map(ks => ks.symbol);\r\n  }\r\n\r\n  /**\r\n  Returns the names of all of the symbols contained within this Enum.\r\n  >     let symbols = DayOfWeek.getNames();\r\n  @return  All of the names of the symbols contained within this Enum.\r\n  **/\r\n  static getNames() {\r\n    return this.resolveSymbols().map(ks => ks.name);\r\n  }\r\n\r\n  /**\r\n  Returns an Enum symbol given its name.\r\n  >     let dayOfWeek = DayOfWeek.from(\"Thursday\");\r\n  >     // nowdayOfWeek === DayOfWeek.Thursday\r\n  @param name - Name for which an enum symbol should be returned.\r\n  @return The symbol that matches the name or 'undefined' if not found.\r\n  **/\r\n  static fromName(name: string) {\r\n    return this[name];\r\n  }\r\n\r\n  /**\r\n  Seals this enum so that no more symbols may be added to it. This should only be called after all symbols\r\n  have already been added to the Enum. This method also sets the 'name' property on each of the symbols.\r\n  >     DayOfWeek.resolveSymbols();\r\n  **/\r\n  static resolveSymbols() {\r\n    if (this._resolvedNamesAndSymbols) return this._resolvedNamesAndSymbols;\r\n    let result: {name: string, symbol: BreezeEnum }[] = [];\r\n\r\n    for (let key in this) {\r\n      if (this.hasOwnProperty(key)) {\r\n        let symb = this[key];\r\n        if (symb instanceof BreezeEnum) {\r\n          result.push( { name: key, symbol: symb });\r\n          this[key] = symb;\r\n          symb.name = key;\r\n        }\r\n      }\r\n    }\r\n    this._resolvedNamesAndSymbols = result;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n  Returns whether an Enum contains a specified symbol.\r\n  >     let symbol = DayOfWeek.Friday;\r\n  >     if (DayOfWeek.contains(symbol)) {\r\n  >         // do something\r\n  >     }\r\n  @param sym - Object or symbol to test.\r\n  @return Whether this Enum contains the specified symbol.\r\n  **/\r\n  static contains(sym: BreezeEnum) {\r\n    if (!(sym instanceof BreezeEnum)) {\r\n      return false;\r\n    }\r\n\r\n    return this[sym.name] != null;\r\n  }\r\n\r\n\r\n  // /**\r\n  // Checks if an object is an Enum 'symbol'. Use the 'contains' method instead of this one \r\n  // if you want to test for a specific Enum. \r\n  // >     if (Enum.isSymbol(DayOfWeek.Wednesday)) {\r\n  // >       // do something ...\r\n  // >     };\r\n  // **/\r\n  // static isSymbol(obj: any) {\r\n  //   return obj instanceof BreezeEnum;\r\n  // };\r\n\r\n  /** Returns the string name of this Enum */\r\n  toString() {\r\n    return this.name;\r\n  }\r\n\r\n  /** Return enum name and symbol name */\r\n  toJSON() {\r\n    return {\r\n      _$typeName: this['_$typeName'] || (this.constructor as any).name,\r\n      name: this.name\r\n    };\r\n  }\r\n\r\n}\r\n\r\n\r\n","/** See if this comment will make it into .d.ts */\r\nimport { BreezeEnum } from './enum';\r\ndeclare var global: any;\r\ndeclare var window: any;\r\n\r\nexport interface ErrorCallback {\r\n    (error: Error): void;\r\n}\r\n\r\nexport interface Callback {\r\n    (data: any): void;\r\n}\r\n\r\n// type Predicate = (i: any) => boolean;\r\ntype Predicate<T> = (i: T) => boolean;\r\n\r\nlet hasOwnProperty: (obj: Object, key: string) => boolean = uncurry(Object.prototype.hasOwnProperty);\r\nlet arraySlice: (ar: any[], start?: number, end?: number) => any[] = uncurry(Array.prototype.slice);\r\nlet isES5Supported: boolean = function () {\r\n    try {\r\n        return !!(Object.getPrototypeOf && Object.defineProperty({}, 'x', {}));\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n} ();\r\n\r\n// iterate over object\r\nfunction objectForEach(obj: Object, kvFn: (key: string, val: any) => any) {\r\n    for (let key in obj) {\r\n        if (hasOwnProperty(obj, key)) {\r\n            kvFn(key, obj[key]);\r\n        }\r\n    }\r\n}\r\n\r\nfunction objectMap(obj: Object, kvFn?: (key: string, val: any) => any): any[] {\r\n    let results: any[] = [];\r\n    for (let key in obj) {\r\n        if (hasOwnProperty(obj, key)) {\r\n            let result = kvFn ? kvFn(key, obj[key]) : obj[key];\r\n            if (result !== undefined) {\r\n                results.push(result);\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}\r\n\r\nfunction objectFirst(obj: Object, kvPredicate: (key: string, val: any) => boolean): { key: string, value: any } | null {\r\n    for (let key in obj) {\r\n        if (hasOwnProperty(obj, key)) {\r\n            let value = obj[key];\r\n            if (kvPredicate(key, value)) {\r\n                return { key: key, value: value };\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction arrayFlatMap<T, U>(arr: T[], mapFn: (arg: T) => U[]) {\r\n    return Array.prototype.concat.apply([], arr.map(mapFn)) as U[];\r\n}\r\n\r\nfunction isSettable(obj: Object, propertyName: string): boolean {\r\n    let pd = getPropDescriptor(obj, propertyName);\r\n    if (pd == null) return true;\r\n    return !!(pd.writable || pd.set);\r\n}\r\n\r\nfunction getPropDescriptor(obj: Object, propertyName: string): PropertyDescriptor | undefined {\r\n    if (!isES5Supported) return undefined;\r\n\r\n    if (obj.hasOwnProperty(propertyName)) {\r\n        return Object.getOwnPropertyDescriptor(obj, propertyName);\r\n    } else {\r\n        let nextObj = Object.getPrototypeOf(obj);\r\n        if (nextObj == null) return undefined;\r\n        return getPropDescriptor(nextObj, propertyName);\r\n    }\r\n}\r\n\r\n// Functional extensions\r\n\r\n/** can be used like: persons.filter(propEq(\"firstName\", \"John\")) */\r\nfunction propEq(propertyName: string, value: any): (obj: Object) => boolean {\r\n    return function (obj: any) {\r\n        return obj[propertyName] === value;\r\n    };\r\n}\r\n\r\n/** can be used like: persons.filter(propEq(\"firstName\", \"FirstName\", \"John\")) */\r\nfunction propsEq(property1Name: string, property2Name: string, value: any): (obj: Object) => boolean {\r\n    return function (obj: any) {\r\n        return obj[property1Name] === value || obj[property2Name] === value;\r\n    };\r\n}\r\n\r\n/** can be used like persons.map(pluck(\"firstName\")) */\r\nfunction pluck(propertyName: any): (obj: Object) => any {\r\n    return function (obj: any) {\r\n        return obj[propertyName];\r\n    };\r\n}\r\n\r\n// end functional extensions\r\n\r\n/** Return an array of property values from source */\r\nfunction getOwnPropertyValues(source: Object): any[] {\r\n    let result: any[] = [];\r\n    for (let name in source) {\r\n        if (hasOwnProperty(source, name)) {\r\n            result.push(source[name]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/** Copy properties from source to target. Returns target. */\r\nfunction extend(target: Object, source: Object, propNames?: string[]): Object {\r\n    if (!source) return target;\r\n    if (propNames) {\r\n        propNames.forEach(function (propName) {\r\n            target[propName] = source[propName];\r\n        });\r\n    } else {\r\n        for (let propName in source) {\r\n            if (hasOwnProperty(source, propName)) {\r\n                target[propName] = source[propName];\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}\r\n\r\n/** Copy properties from defaults iff undefined on target.  Returns target. */\r\nfunction updateWithDefaults(target: Object, defaults: Object): any {\r\n    for (let name in defaults) {\r\n        if (target[name] === undefined) {\r\n            target[name] = defaults[name];\r\n        }\r\n    }\r\n    return target;\r\n}\r\n\r\n/** Set ctor.defaultInstance to an instance of ctor with properties from target.\r\n    We want to insure that the object returned by ctor.defaultInstance is always immutable\r\n    Use 'target' as the primary template for the ctor.defaultInstance;\r\n    Use current 'ctor.defaultInstance' as the template for any missing properties\r\n    creates a new instance for ctor.defaultInstance\r\n    returns target unchanged */\r\nfunction setAsDefault(target: Object, ctor: { new (...args: any[]): any, defaultInstance?: any }): any {\r\n    ctor.defaultInstance = updateWithDefaults(new ctor(target), ctor.defaultInstance);\r\n    return target;\r\n}\r\n\r\n/**\r\n    'source' is an object that will be transformed into another\r\n    'template' is a map where the\r\n       keys: are the keys to return\r\n         if a key contains ','s then the key is treated as a delimited string with first of the\r\n         keys being the key to return and the others all valid aliases for this key\r\n       'values' are either\r\n           1) the 'default' value of the key\r\n           2) a function that takes in the source value and should return the value to set\r\n         The value from the source is then set on the target,\r\n         after first passing thru the fn, if provided, UNLESS:\r\n           1) it is the default value\r\n           2) it is undefined ( nulls WILL be set)\r\n    'target' is optional\r\n       - if it exists then properties of the target will be set ( overwritten if the exist)\r\n       - if it does not exist then a new object will be created as filled.\r\n    'target is returned.\r\n*/\r\nfunction toJson(source: Object, template: Object, target: Object = {}): Object {\r\n\r\n    for (let key in template) {\r\n        let aliases = key.split(\",\");\r\n        let defaultValue = template[key];\r\n        // using some as a forEach with a 'break'\r\n        aliases.some(function (propName) {\r\n            if (!(propName in source)) return false;\r\n            let value = source[propName];\r\n            // there is a functional property defined with this alias ( not what we want to replace).\r\n            if (typeof value === 'function') return false;\r\n            // '==' is deliberate here - idea is that null or undefined values will never get serialized\r\n            // if default value is set to null.\r\n            // tslint:disable-next-line\r\n            if (value == defaultValue) return true;\r\n            if (Array.isArray(value) && value.length === 0) return true;\r\n            if (typeof (defaultValue) === \"function\") {\r\n                value = defaultValue(value);\r\n            } else if (typeof (value) === \"object\") {\r\n                if (value && value instanceof BreezeEnum) {\r\n                    value = value.name;\r\n                }\r\n            }\r\n            if (value === undefined) return true;\r\n            target[aliases[0]] = value;\r\n            return true;\r\n        });\r\n    }\r\n    return target;\r\n}\r\n\r\n/** Replacer function for toJSONSafe, when serializing entities.  Excludes entityAspect and other internal properties. */\r\nfunction toJSONSafeReplacer(prop: string, val: any) {\r\n    if (prop === \"entityAspect\" || prop === \"complexAspect\" || prop === \"entityType\" || prop === \"complexType\"\r\n        || prop === \"getProperty\" || prop === \"setProperty\"\r\n        || prop === \"constructor\" || prop.charAt(0) === '_' || prop.charAt(0) === '$') return;\r\n    return val;\r\n}\r\n\r\n/** Safely perform toJSON logic on objects with cycles. */\r\nfunction toJSONSafe(obj: any, replacer?: (prop: string, value: any) => any): any {\r\n    if (obj !== Object(obj)) return obj; // primitive value\r\n    if (obj._$visited) return undefined;\r\n    if (obj.toJSON) {\r\n        let newObj = obj.toJSON();\r\n        if (newObj !== Object(newObj)) return newObj; // primitive value\r\n        if (newObj !== obj) return toJSONSafe(newObj, replacer);\r\n        // toJSON returned the object unchanged.\r\n        obj = newObj;\r\n    }\r\n    obj._$visited = true;\r\n    let result: any;\r\n    if (obj instanceof Array) {\r\n        result = obj.map(function (o: any) {\r\n            return toJSONSafe(o, replacer);\r\n        });\r\n    } else if (typeof (obj) === \"function\") {\r\n        result = undefined;\r\n    } else {\r\n        result = {};\r\n        for (let prop in obj) {\r\n            if (prop === \"_$visited\") continue;\r\n            let val = obj[prop];\r\n            if (replacer) {\r\n                val = replacer(prop, val);\r\n                if (val === undefined) continue;\r\n            }\r\n            val = toJSONSafe(val, replacer);\r\n            if (val === undefined) continue;\r\n            result[prop] = val;\r\n        }\r\n    }\r\n    delete obj._$visited;\r\n    return result;\r\n}\r\n\r\n/** Resolves the values of a list of properties by checking each property in multiple sources until a value is found. */\r\nfunction resolveProperties(sources: Object[], propertyNames: string[]): any {\r\n    let r = {};\r\n    let length = sources.length;\r\n    propertyNames.forEach(function (pn) {\r\n        for (let i = 0; i < length; i++) {\r\n            let src = sources[i];\r\n            if (src) {\r\n                let val = src[pn];\r\n                if (val !== undefined) {\r\n                    r[pn] = val;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return r;\r\n}\r\n\r\n\r\n// array functions\r\n\r\nfunction toArray(item: any): any[] {\r\n    if (item == null) {\r\n        return [];\r\n    } else if (Array.isArray(item)) {\r\n        return item;\r\n    } else {\r\n        return [item];\r\n    }\r\n}\r\n\r\n/** a version of Array.map that doesn't require an array, i.e. works on arrays and scalars. */\r\n// function map<T, U>(items: T | T[], fn: (v: T, ix?: number) => U, includeNull?: boolean): U | U[] {\r\n function map<T>(items: T | T[], fn: (v: T, ix?: number) => any, includeNull?: boolean): any | any[] {\r\n    // whether to return nulls in array of results; default = true;\r\n    includeNull = includeNull == null ? true : includeNull;\r\n    if (items == null) return items;\r\n    // let result: U[];\r\n    if (Array.isArray(items)) {\r\n        let result: any[] = [];\r\n        items.forEach(function (v: any, ix: number) {\r\n            let r = fn(v, ix);\r\n            if (r != null || includeNull) {\r\n                result[ix] = r;\r\n            }\r\n        });\r\n        return result;\r\n    } else {\r\n        let result = fn(items);\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\n/** Return first element matching predicate */\r\nfunction arrayFirst<T>(array: T[], predicate: Predicate<any>): T;\r\nfunction arrayFirst<T>(array: T[], predicate: Predicate<T>) {\r\n    for (let i = 0, j = array.length; i < j; i++) {\r\n        if (predicate(array[i])) {\r\n            return array[i];\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/** Return index of first element matching predicate */\r\nfunction arrayIndexOf<T>(array: T[], predicate: Predicate<any>): number;\r\nfunction arrayIndexOf<T>(array: T[], predicate: Predicate<T>): number {\r\n    for (let i = 0, j = array.length; i < j; i++) {\r\n        if (predicate(array[i])) return i;\r\n    }\r\n    return -1;\r\n}\r\n\r\n/** Add item if not already in array */\r\nfunction arrayAddItemUnique<T>(array: T[], item: T) {\r\n    let ix = array.indexOf(item);\r\n    if (ix === -1) array.push(item);\r\n}\r\n\r\n/** Remove items from the array\r\n * @param array\r\n * @param predicateOrItem - item to remove, or function to determine matching item\r\n * @param shouldRemoveMultiple - true to keep removing after first match, false otherwise\r\n */\r\nfunction arrayRemoveItem<T>(array: T[], predicateOrItem: T | Predicate<T> , shouldRemoveMultiple?: boolean) {\r\n    let predicate = (isFunction(predicateOrItem) ? predicateOrItem : undefined) as Predicate<T>;\r\n    let lastIx = array.length - 1;\r\n    let removed = false;\r\n    for (let i = lastIx; i >= 0; i--) {\r\n        if (predicate ? predicate(array[i]) : (array[i] === predicateOrItem)) {\r\n            array.splice(i, 1);\r\n            removed = true;\r\n            if (!shouldRemoveMultiple) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return removed;\r\n}\r\n\r\n/** Combine array elements using the callback.  Returns array with length == min(a1.length, a2.length) */\r\nfunction arrayZip(a1: any[], a2: any[], callback: (x1: any, x2: any) => any): any[] {\r\n    let result: any[] = [];\r\n    let n = Math.min(a1.length, a2.length);\r\n    for (let i = 0; i < n; ++i) {\r\n        result.push(callback(a1[i], a2[i]));\r\n    }\r\n    return result;\r\n}\r\n\r\n//function arrayDistinct(array) {\r\n//    array = array || [];\r\n//    let result = [];\r\n//    for (let i = 0, j = array.length; i < j; i++) {\r\n//        if (result.indexOf(array[i]) < 0)\r\n//            result.push(array[i]);\r\n//    }\r\n//    return result;\r\n//}\r\n\r\n// Not yet needed\r\n//// much faster but only works on array items with a toString method that\r\n//// returns distinct string for distinct objects.  So this is safe for arrays with primitive\r\n//// types but not for arrays with object types, unless toString() has been implemented.\r\n//function arrayDistinctUnsafe(array) {\r\n//    let o = {}, i, l = array.length, r = [];\r\n//    for (i = 0; i < l; i += 1) {\r\n//        let v = array[i];\r\n//        o[v] = v;\r\n//    }\r\n//    for (i in o) r.push(o[i]);\r\n//    return r;\r\n//}\r\n\r\nfunction arrayEquals(a1: any[], a2: any[], equalsFn?: (x1: any, x2: any) => boolean): boolean {\r\n    //Check if the arrays are undefined/null\r\n    if (!a1 || !a2) return false;\r\n\r\n    if (a1.length !== a2.length) return false;\r\n\r\n    //go thru all the vars\r\n    for (let i = 0; i < a1.length; i++) {\r\n        //if the let is an array, we need to make a recursive check\r\n        //otherwise we'll just compare the values\r\n        if (Array.isArray(a1[i])) {\r\n            if (!arrayEquals(a1[i], a2[i])) return false;\r\n        } else {\r\n            if (equalsFn) {\r\n                if (!equalsFn(a1[i], a2[i])) return false;\r\n            } else {\r\n                if (a1[i] !== a2[i]) return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// end of array functions\r\n\r\n/** Returns an array for a source and a prop, and creates the prop if needed. */\r\nfunction getArray(source: Object, propName: string): any[] {\r\n    let arr = source[propName];\r\n    if (!arr) {\r\n        arr = [];\r\n        source[propName] = arr;\r\n    }\r\n    return arr;\r\n}\r\n\r\n/** Calls requireLibCore on semicolon-separated libNames */\r\nfunction requireLib(libNames: string, errMessage?: string) {\r\n    let arrNames = libNames.split(\";\");\r\n    for (let i = 0, j = arrNames.length; i < j; i++) {\r\n        let lib = requireLibCore(arrNames[i]);\r\n        if (lib) return lib;\r\n    }\r\n    if (errMessage) {\r\n        throw new Error(\"Unable to initialize \" + libNames + \".  \" + errMessage);\r\n    }\r\n}\r\n\r\n\r\n\r\n/** Returns the 'libName' module if loaded or else returns undefined */\r\nfunction requireLibCore(libName: string) {\r\n    let win = window || (global ? global.window : undefined);\r\n    if (!win) return; // Must run in a browser. Todo: add commonjs support\r\n\r\n    // get library from browser globals if we can\r\n    let lib = win[libName];\r\n    if (lib) return lib;\r\n\r\n    // if require exists, maybe require can get it.\r\n    // This method is synchronous so it can't load modules with AMD.\r\n    // It can only obtain modules from require that have already been loaded.\r\n    // Developer should bootstrap such that the breeze module\r\n    // loads after all other libraries that breeze should find with this method\r\n    // See documentation\r\n    let r = win.require;\r\n    if (r) { // if require exists\r\n        if (r.defined) { // require.defined is not standard and may not exist\r\n            // require.defined returns true if module has been loaded\r\n            return r.defined(libName) ? r(libName) : undefined;\r\n        } else {\r\n            // require.defined does not exist so we have to call require('libName') directly.\r\n            // The require('libName') overload is synchronous and does not load modules.\r\n            // It throws an exception if the module isn't already loaded.\r\n            try {\r\n                return r(libName);\r\n            } catch (e) {\r\n                // require('libName') threw because module not loaded\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** Execute fn while obj has tempValue for property */\r\nfunction using(obj: Object, property: string, tempValue: any, fn: () => any) {\r\n    let originalValue = obj[property];\r\n    if (tempValue === originalValue) {\r\n        return fn();\r\n    }\r\n    obj[property] = tempValue;\r\n    try {\r\n        return fn();\r\n    } finally {\r\n        if (originalValue === undefined) {\r\n            delete obj[property];\r\n        } else {\r\n            obj[property] = originalValue;\r\n        }\r\n    }\r\n}\r\n\r\n/** Call state = startFn(), call fn(), call endFn(state) */\r\nfunction wrapExecution(startFn: () => any, endFn: (state: any) => any, fn: () => any) {\r\n    let state: any;\r\n    try {\r\n        state = startFn();\r\n        return fn();\r\n    } catch (e) {\r\n        if (typeof (state) === 'object') {\r\n            state.error = e;\r\n        }\r\n        throw e;\r\n    } finally {\r\n        endFn(state);\r\n    }\r\n}\r\n\r\n/** Remember & return the value of fn() when it was called with its current args */\r\nfunction memoize(fn: any): any {\r\n    return function () {\r\n        let args = arraySlice(<any>arguments),\r\n            hash = \"\",\r\n            i = args.length,\r\n            currentArg: any = null;\r\n        while (i--) {\r\n            currentArg = args[i];\r\n            hash += (currentArg === Object(currentArg)) ? JSON.stringify(currentArg) : currentArg;\r\n            fn.memoize || (fn.memoize = {});\r\n        }\r\n        return (hash in fn.memoize) ?\r\n            fn.memoize[hash] :\r\n            fn.memoize[hash] = fn.apply(this, args);\r\n    };\r\n}\r\n\r\nfunction getUuid(): string {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        // tslint:disable-next-line\r\n        let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n        return v.toString(16);\r\n    });\r\n}\r\n\r\nfunction durationToSeconds(duration: string) {\r\n    // basic algorithm from https://github.com/nezasa/iso8601-js-period\r\n    if (typeof duration !== \"string\") throw new Error(\"Invalid ISO8601 duration '\" + duration + \"'\");\r\n\r\n    // regex splits as follows - grp0, grp1, y, m, d, grp2, h, m, s\r\n    //                           0     1     2  3  4  5     6  7  8\r\n    let struct = /^P((\\d+Y)?(\\d+M)?(\\d+D)?)?(T(\\d+H)?(\\d+M)?(\\d+S)?)?$/.exec(duration);\r\n    if (!struct) throw new Error(\"Invalid ISO8601 duration '\" + duration + \"'\");\r\n\r\n    let ymdhmsIndexes = [2, 3, 4, 6, 7, 8]; // -> grp1,y,m,d,grp2,h,m,s\r\n    let factors = [31104000, // year (360*24*60*60)\r\n        2592000,             // month (30*24*60*60)\r\n        86400,               // day (24*60*60)\r\n        3600,                // hour (60*60)\r\n        60,                  // minute (60)\r\n        1];                  // second (1)\r\n\r\n    let seconds = 0;\r\n    for (let i = 0; i < 6; i++) {\r\n        let digit = struct[ymdhmsIndexes[i]];\r\n        // remove letters, replace by 0 if not defined\r\n        digit = <any>(digit ? +digit.replace(/[A-Za-z]+/g, '') : 0);\r\n        seconds += <any>digit * factors[i];\r\n    }\r\n    return seconds;\r\n\r\n}\r\n\r\n// is functions\r\n\r\nfunction noop() {\r\n    // does nothing\r\n}\r\n\r\nfunction identity(x: any): any {\r\n    return x;\r\n}\r\n\r\nfunction classof(o: any) {\r\n    if (o === null) {\r\n        return \"null\";\r\n    }\r\n    if (o === undefined) {\r\n        return \"undefined\";\r\n    }\r\n    return Object.prototype.toString.call(o).slice(8, -1).toLowerCase();\r\n}\r\n\r\nfunction isDate(o: any) {\r\n    return classof(o) === \"date\" && !isNaN(o.getTime());\r\n}\r\n\r\nfunction isDateString(s: string) {\r\n    // let rx = /^(\\d{4}|[+\\-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+\\-])(\\d{2})(?::(\\d{2}))?)?)?$/;\r\n    let rx = /^((\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z)))$/;\r\n    return (typeof s === \"string\") && rx.test(s);\r\n}\r\n\r\nfunction isFunction(o: any) {\r\n    return classof(o) === \"function\";\r\n}\r\n\r\n// function isString(o: any) {\r\n//     return (typeof o === \"string\");\r\n// }\r\n\r\n// function isObject(o: any) {\r\n//     return (typeof o === \"object\");\r\n// }\r\n\r\nfunction isGuid(value: any) {\r\n    return (typeof value === \"string\") && /[a-fA-F\\d]{8}-(?:[a-fA-F\\d]{4}-){3}[a-fA-F\\d]{12}/.test(value);\r\n}\r\n\r\nfunction isDuration(value: any) {\r\n    return (typeof value === \"string\") && /^(-|)?P[T]?[\\d\\.,\\-]+[YMDTHS]/.test(value);\r\n}\r\n\r\nfunction isEmpty(obj: any) {\r\n    if (obj === null || obj === undefined) {\r\n        return true;\r\n    }\r\n    for (let key in obj) {\r\n        if (hasOwnProperty(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction isNumeric(n: any) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n}\r\n\r\n\r\n\r\n// end of is Functions\r\n\r\n// string functions\r\n\r\nfunction stringStartsWith(str: string, prefix: string) {\r\n    // returns true for empty string or null prefix\r\n    if ((!str)) return false;\r\n    if (prefix === \"\" || prefix == null) return true;\r\n    return str.indexOf(prefix, 0) === 0;\r\n}\r\n\r\nfunction stringEndsWith(str: string, suffix: string) {\r\n    // returns true for empty string or null suffix\r\n    if ((!str)) return false;\r\n    if (suffix === \"\" || suffix == null) return true;\r\n    return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n}\r\n\r\n// Based on fragment from Dean Edwards' Base 2 library\r\n/** format(\"a %1 and a %2\", \"cat\", \"dog\") -> \"a cat and a dog\" */\r\nfunction formatString(str: string, ...params: any[]) {\r\n    let args = arguments;\r\n    let pattern = RegExp(\"%([1-\" + (arguments.length - 1) + \"])\", \"g\");\r\n    return str.replace(pattern, function (match, index) {\r\n        return args[index];\r\n    });\r\n}\r\n\r\n// See http://stackoverflow.com/questions/7225407/convert-camelcasetext-to-camel-case-text\r\n/** Change text to title case with spaces, e.g. 'myPropertyName12' to 'My Property Name 12' */\r\nlet camelEdges = /([A-Z](?=[A-Z][a-z])|[^A-Z](?=[A-Z])|[a-zA-Z](?=[^a-zA-Z]))/g;\r\nfunction titleCaseSpace(text: string) {\r\n    text = text.replace(camelEdges, '$1 ');\r\n    text = text.charAt(0).toUpperCase() + text.slice(1);\r\n    return text;\r\n}\r\n\r\n// end of string functions\r\n\r\n// See Mark Millerâs explanation of what this does.\r\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\r\nfunction uncurry(f: any) {\r\n    let call = Function.call;\r\n    return function () {\r\n        return call.apply(f, arguments);\r\n    };\r\n}\r\n\r\n// shims\r\n\r\nif (!Object.create) {\r\n    Object.create = function (parent: any) {\r\n        let F = <any>function () {\r\n        };\r\n        F.prototype = parent;\r\n        return new F();\r\n    };\r\n}\r\n\r\n// // not all methods above are exported\r\nexport const core = {\r\n    isES5Supported: isES5Supported,\r\n    hasOwnProperty: hasOwnProperty,\r\n    getOwnPropertyValues: getOwnPropertyValues,\r\n    getPropertyDescriptor: getPropDescriptor,\r\n    objectForEach: objectForEach,\r\n    objectFirst: objectFirst,\r\n    objectMap: objectMap, // TODO: replace this with something strongly typed.\r\n    extend: extend,\r\n    propEq: propEq,\r\n    propsEq: propsEq,\r\n    pluck: pluck,\r\n    map: map,\r\n    resolveProperties: resolveProperties,\r\n    setAsDefault: setAsDefault,\r\n    updateWithDefaults: updateWithDefaults,\r\n    getArray: getArray,\r\n    toArray: toArray,\r\n    arrayEquals: arrayEquals,\r\n    arraySlice: arraySlice,\r\n    arrayFirst: arrayFirst,\r\n    arrayIndexOf: arrayIndexOf,\r\n    arrayRemoveItem: arrayRemoveItem,\r\n    arrayZip: arrayZip,\r\n    arrayAddItemUnique: arrayAddItemUnique,\r\n    arrayFlatMap: arrayFlatMap,\r\n\r\n    requireLib: requireLib,\r\n    using: using,\r\n    wrapExecution: wrapExecution,\r\n\r\n    memoize: memoize,\r\n    getUuid: getUuid,\r\n    durationToSeconds: durationToSeconds,\r\n\r\n    isSettable: isSettable,\r\n\r\n    isDate: isDate,\r\n    isDateString: isDateString,\r\n    isGuid: isGuid,\r\n    isDuration: isDuration,\r\n    isFunction: isFunction,\r\n    isEmpty: isEmpty,\r\n    isNumeric: isNumeric,\r\n\r\n    identity: identity,\r\n    noop: noop,\r\n\r\n    stringStartsWith: stringStartsWith,\r\n    stringEndsWith: stringEndsWith,\r\n    formatString: formatString,\r\n    titleCase: titleCaseSpace,\r\n\r\n    toJson: toJson,\r\n    toJSONSafe: toJSONSafe,\r\n    toJSONSafeReplacer: toJSONSafeReplacer,\r\n};\r\n\r\nexport interface ErrorCallback {\r\n    (error: any): void;\r\n}\r\n\r\n\r\n// Unused\r\n/*\r\n// returns true for booleans, numbers, strings and dates\r\n// false for null, and non-date objects, functions, and arrays\r\nfunction isPrimitive(obj: any) {\r\n    if (obj == null) return false;\r\n    // true for numbers, strings, booleans and null, false for objects\r\n    if (obj != Object(obj)) return true;\r\n    return isDate(obj);\r\n}\r\n\r\n*/","import { BreezeEnum } from './enum';\r\nimport { core  } from './core';\r\n\r\n/** @hidden @internal */\r\nexport interface IParamContext {\r\n    typeName?: string;\r\n    type?: Function;\r\n    prevContext?: IParamContext;\r\n    msg?: string | ((context: IParamContext, v: any) => string);\r\n    mustNotBeEmpty?: boolean;\r\n    enumType?: BreezeEnum;\r\n    propertyName?: string;\r\n    allowNull?: boolean;\r\n    fn?(context: IParamContext, v: any): boolean;\r\n}\r\n\r\n/** @hidden @internal */\r\nexport interface IConfigParam {\r\n    config: any;\r\n    params: Param[];\r\n    whereParam: (propName: string) => Param;\r\n}\r\n\r\n/** @hidden @internal */\r\nexport class Param {\r\n    // The %1 parameter\r\n    // is required\r\n    // must be a %2\r\n    // must be an instance of %2\r\n    // must be an instance of the %2 enumeration\r\n    // must have a %2 property\r\n    // must be an array where each element\r\n    // is optional or\r\n\r\n    v: any;\r\n    name: string;\r\n    defaultValue: any;\r\n    parent: IConfigParam;\r\n    /** @hidden @internal */\r\n    _context: IParamContext;\r\n    /** @hidden @internal */\r\n    _contexts: IParamContext[];\r\n\r\n    constructor(v: any, name: string) {\r\n        this.v = v;\r\n        this.name = name;\r\n        this._contexts = [<any>null];\r\n    }\r\n\r\n    isObject(): Param {\r\n        return this.isTypeOf('object');\r\n    }\r\n\r\n    isBoolean(): Param {\r\n        return this.isTypeOf('boolean');\r\n    }\r\n\r\n    isString(): Param {\r\n        return this.isTypeOf('string');\r\n    }\r\n\r\n    isNumber(): Param {\r\n        return this.isTypeOf('number');\r\n    }\r\n\r\n    isFunction(): Param {\r\n        return this.isTypeOf('function');\r\n    }\r\n\r\n    isNonEmptyString(): Param {\r\n        return addContext(this, {\r\n            fn: isNonEmptyString,\r\n            msg: \"must be a nonEmpty string\"\r\n        });\r\n    }\r\n\r\n\r\n    isTypeOf(typeName: string): Param {\r\n        return addContext(this, {\r\n            fn: isTypeOf,\r\n            typeName: typeName,\r\n            msg: \"must be a '\" + typeName + \"'\"\r\n        });\r\n    }\r\n\r\n\r\n    isInstanceOf(type: Function, typeName?: string): Param {\r\n        typeName = typeName || type.prototype._$typeName;\r\n        return addContext(this, {\r\n            fn: isInstanceOf,\r\n            type: type,\r\n            typeName: typeName,\r\n            msg: \"must be an instance of '\" + typeName + \"'\"\r\n        });\r\n    }\r\n\r\n\r\n    hasProperty(propertyName: string): Param {\r\n        return addContext(this, {\r\n            fn: hasProperty,\r\n            propertyName: propertyName,\r\n            msg: \"must have a '\" + propertyName + \"' property\"\r\n        });\r\n    }\r\n\r\n\r\n    isEnumOf(enumType: any): Param {\r\n        return addContext(this, {\r\n            fn: isEnumOf,\r\n            enumType: enumType,\r\n            msg: \"must be an instance of the '\" + (enumType.name || 'unknown') + \"' enumeration\"\r\n        });\r\n    }\r\n\r\n    isRequired(allowNull: boolean = false): Param {\r\n        return addContext(this, {\r\n            fn: isRequired,\r\n            allowNull: allowNull,\r\n            msg: \"is required\"\r\n        });\r\n    }\r\n\r\n    isOptional(): Param {\r\n        let context = {\r\n            fn: isOptional,\r\n            prevContext: <any>null,\r\n            msg: isOptionalMessage\r\n        };\r\n        return addContext(this, context);\r\n    }\r\n\r\n    isNonEmptyArray(): Param {\r\n        return this.isArray(true);\r\n    }\r\n\r\n    isArray(mustNotBeEmpty?: boolean): Param {\r\n        let context = {\r\n            fn: isArray,\r\n            mustNotBeEmpty: mustNotBeEmpty,\r\n            prevContext: <any>null,\r\n            msg: isArrayMessage\r\n        };\r\n        return addContext(this, context);\r\n    }\r\n\r\n    or() {\r\n        this._contexts.push(<any>null);\r\n        this._context = <any>null;\r\n        return this;\r\n    }\r\n\r\n    check(defaultValue?: any) {\r\n        let ok = exec(this);\r\n        if (ok === undefined) return;\r\n        if (!ok) {\r\n            throw new Error(this.getMessage());\r\n        }\r\n\r\n        if (this.v !== undefined) {\r\n            return this.v;\r\n        } else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /** @hidden @internal */\r\n    // called from outside this file.\r\n    _addContext(context: IParamContext) {\r\n        return addContext(this, context);\r\n    }\r\n\r\n    getMessage() {\r\n        let that = this;\r\n        let message = this._contexts.map(function (context) {\r\n            return getMessage(context, that.v);\r\n        }).join(\", or it \");\r\n        return core.formatString(this.MESSAGE_PREFIX, this.name) + \" \" + message;\r\n    }\r\n\r\n    withDefault(defaultValue: any) {\r\n        this.defaultValue = defaultValue;\r\n        return this;\r\n    }\r\n\r\n    whereParam(propName: string) {\r\n        return this.parent.whereParam(propName);\r\n    }\r\n\r\n    applyAll(instance: any, checkOnly: boolean = false) {\r\n        let parentTypeName = instance._$typeName;\r\n        let allowUnknownProperty = (parentTypeName && this.parent.config._$typeName === parentTypeName);\r\n\r\n        let clone = core.extend({}, this.parent.config);\r\n        this.parent.params.forEach(function (p) {\r\n            if (!allowUnknownProperty) delete clone[p.name];\r\n            try {\r\n                p.check();\r\n            } catch (e) {\r\n                throwConfigError(instance, e.message);\r\n            }\r\n            (!checkOnly) && p._applyOne(instance);\r\n        });\r\n        // should be no properties left in the clone\r\n        if (!allowUnknownProperty) {\r\n            for (let key in clone) {\r\n                // allow props with an undefined value\r\n                if (clone[key] !== undefined) {\r\n                    throwConfigError(instance, core.formatString(\"Unknown property: '%1'.\", key));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @hidden @internal */\r\n    _applyOne = function (this: Param, instance: any) {\r\n        if (this.v !== undefined) {\r\n            instance[this.name] = this.v;\r\n        } else {\r\n            if (this.defaultValue !== undefined) {\r\n                instance[this.name] = this.defaultValue;\r\n            }\r\n        }\r\n    };\r\n\r\n    MESSAGE_PREFIX = \"The '%1' parameter \";\r\n\r\n}\r\n\r\n/** @hidden @internal */\r\nexport let assertParam = function (v: any, name: string) {\r\n    return new Param(v, name);\r\n};\r\n\r\nfunction isTypeOf(context: IParamContext, v: any) {\r\n    if (v == null) return false;\r\n    if (typeof (v) === context.typeName) return true;\r\n    return false;\r\n}\r\n\r\nfunction isNonEmptyString(context: IParamContext, v: any) {\r\n    if (v == null) return false;\r\n    return (typeof (v) === 'string') && v.length > 0;\r\n}\r\n\r\nfunction isInstanceOf(context: IParamContext, v: any) {\r\n    if (v == null || context.type == null) return false;\r\n    return (v instanceof context.type);\r\n}\r\n\r\nfunction isEnumOf(context: IParamContext, v: any) {\r\n    if (v == null || context.enumType == null ) return false;\r\n    return (context.enumType as any).contains(v);\r\n}\r\n\r\nfunction hasProperty(context: IParamContext, v: any) {\r\n    if (v == null || context.propertyName == null) return false;\r\n    return (v[context.propertyName] !== undefined);\r\n}\r\n\r\nfunction isRequired(context: IParamContext, v: any) {\r\n    if (context.allowNull) {\r\n        return v !== undefined;\r\n    } else {\r\n        return v != null;\r\n    }\r\n}\r\n\r\nfunction isOptional(context: IParamContext, v: any) {\r\n    if (v == null) return true;\r\n    let prevContext = context.prevContext;\r\n    if (prevContext && prevContext.fn) {\r\n        return prevContext.fn(prevContext, v);\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction isOptionalMessage(context: IParamContext, v: any) {\r\n    let prevContext = context.prevContext;\r\n    let element = prevContext ? \" or it \" + getMessage(prevContext, v) : \"\";\r\n    return \"is optional\" + element;\r\n}\r\n\r\nfunction isArray(context: IParamContext, v: any) {\r\n    if (!Array.isArray(v)) {\r\n        return false;\r\n    }\r\n    if (context.mustNotBeEmpty) {\r\n        if (v.length === 0) return false;\r\n    }\r\n    // allow standalone is array call.\r\n    let prevContext = context.prevContext;\r\n    if (!prevContext) return true;\r\n\r\n    let pc = <any>prevContext;\r\n    return v.every(function (v1: any) {\r\n        return pc.fn && pc.fn(pc, v1);\r\n    });\r\n}\r\n\r\nfunction isArrayMessage(context: IParamContext, v: any) {\r\n    let arrayDescr = context.mustNotBeEmpty ? \"a nonEmpty array\" : \"an array\";\r\n    let prevContext = context.prevContext;\r\n    let element = prevContext ? \" where each element \" + getMessage(prevContext, v) : \"\";\r\n    return \" must be \" + arrayDescr + element;\r\n}\r\n\r\nfunction getMessage(context: IParamContext, v: any) {\r\n    let msg = context.msg;\r\n    if (typeof (msg) === \"function\") {\r\n        msg = (<any>msg)(context, v);\r\n    }\r\n    return msg;\r\n}\r\n\r\nfunction addContext(that: Param, context: IParamContext) {\r\n    if (that._context) {\r\n        let curContext = that._context;\r\n\r\n        while (curContext.prevContext != null) {\r\n            curContext = curContext.prevContext;\r\n        }\r\n\r\n        if (curContext.prevContext === null) {\r\n            curContext.prevContext = context;\r\n            // just update the prevContext but don't change the curContext.\r\n            return that;\r\n        } else if (context.prevContext == null) {\r\n            context.prevContext = that._context;\r\n        } else {\r\n            throw new Error(\"Illegal construction - use 'or' to combine checks\");\r\n        }\r\n    }\r\n    return setContext(that, context);\r\n}\r\n\r\nfunction setContext(that: Param, context: IParamContext) {\r\n    that._contexts[that._contexts.length - 1] = context;\r\n    that._context = context;\r\n    return that;\r\n}\r\n\r\n\r\nfunction exec(self: Param) {\r\n    // clear off last one if null\r\n    let contexts = self._contexts;\r\n    if (contexts[contexts.length - 1] == null) {\r\n        contexts.pop();\r\n    }\r\n    if (contexts.length === 0) {\r\n        return undefined;\r\n    }\r\n    return contexts.some(function (context: IParamContext) {\r\n        return context.fn ? context.fn(context, self.v) : false;\r\n    });\r\n}\r\n\r\nfunction throwConfigError(instance: any, message: string) {\r\n    throw new Error(core.formatString(\"Error configuring an instance of '%1'. %2\", (instance && instance._$typeName) || \"object\", message));\r\n}\r\n\r\nclass ConfigParam {\r\n    config: any;\r\n    params: Param[];\r\n    constructor(config: Object) {\r\n        if (typeof (config) !== \"object\") {\r\n            throw new Error(\"Configuration parameter should be an object, instead it is a: \" + typeof (config));\r\n        }\r\n        this.config = config;\r\n        this.params = [];\r\n    }\r\n\r\n    whereParam(propName: string) {\r\n        let param = new Param(this.config[propName], propName);\r\n        param.parent = this;\r\n        this.params.push(param);\r\n        return param;\r\n    }\r\n}\r\n\r\n/** @hidden @internal */\r\nexport let assertConfig = function (config: Object) {\r\n    return new ConfigParam(config) as IConfigParam;\r\n};\r\n\r\n\r\n// Param is exposed so that additional 'is' methods can be added to the prototype.\r\n(core as any).Param = Param;\r\n(core as any).assertParam = assertParam;\r\n(core as any).assertConfig = assertConfig;\r\n","import { core } from './core';\r\nimport { assertParam } from './assert-param';\r\n\r\nfunction publishCore<T>(that: BreezeEvent<T>, data: T, errorCallback?: (e: Error) => any) {\r\n  let subscribers = that._subscribers;\r\n  if (!subscribers) return true;\r\n  // subscribers from outer scope.\r\n  subscribers.forEach(function (s) {\r\n    try {\r\n      s.callback(data);\r\n    } catch (e) {\r\n      e.context = \"unable to publish on topic: \" + that.name;\r\n      if (errorCallback) {\r\n        errorCallback(e);\r\n      } else if (that._defaultErrorCallback) {\r\n        that._defaultErrorCallback(e);\r\n      } else {\r\n        fallbackErrorHandler(e);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction fallbackErrorHandler(e: Error) {\r\n  // TODO: maybe log this\r\n  // for now do nothing;\r\n}\r\n\r\n\r\n/** @hidden @internal */\r\nexport interface Subscription {\r\n  unsubKey: number;\r\n  callback: (data: any) => any;\r\n}\r\n\r\n/**\r\nClass to support basic event publication and subscription semantics.\r\n@dynamic\r\n**/\r\nexport class BreezeEvent<T> {\r\n  /** @hidden @internal */\r\n  static __eventNameMap = {};\r\n  /** @hidden @internal */\r\n  static __nextUnsubKey = 1;\r\n  /** The name of this Event */\r\n  name: string;\r\n  /** The object doing the publication. i.e. the object to which this event is attached. */\r\n  publisher: Object;\r\n\r\n  /** @hidden @internal */\r\n  _subscribers: Subscription[];\r\n  /** @hidden @internal */\r\n  _defaultErrorCallback: (e: Error) => any;\r\n\r\n\r\n  /**\r\n  Constructor for an Event\r\n  >     salaryEvent = new BreezeEvent(\"salaryEvent\", person);\r\n  @param name - The name of the event.\r\n  @param publisher - The object that will be doing the publication. i.e. the object to which this event is attached.\r\n  @param defaultErrorCallback - Function to call when an error occurs during subscription execution. \r\n  If omitted then subscriber notification failures will be ignored.\r\n  **/\r\n  constructor(name: string, publisher: Object, defaultErrorCallback?: (e: Error) => any) {\r\n    assertParam(name, \"eventName\").isNonEmptyString().check();\r\n    assertParam(publisher, \"publisher\").isObject().check();\r\n\r\n    this.name = name;\r\n    // register the name\r\n    BreezeEvent.__eventNameMap[name] = true;\r\n    this.publisher = publisher;\r\n    if (defaultErrorCallback) {\r\n      this._defaultErrorCallback = defaultErrorCallback;\r\n    }\r\n  }\r\n\r\n  /**\r\n  Publish data for this event.\r\n  >      // Assume 'salaryEvent' is previously constructed Event\r\n  >      salaryEvent.publish( { eventType: \"payRaise\", amount: 100 });\r\n\r\n  This event can also be published asychronously\r\n  >      salaryEvent.publish( { eventType: \"payRaise\", amount: 100 }, true);\r\n\r\n  And we can add a handler in case the subscriber 'mishandles' the event.\r\n  >      salaryEvent.publish( { eventType: \"payRaise\", amount: 100 }, true, function(error) {\r\n  >          // do something with the 'error' object\r\n  >      });\r\n  @param data - Data to publish\r\n  @param publishAsync - (default=false) Whether to publish asynchonously or not.\r\n  @param errorCallback - Function to be called for any errors that occur during publication. If omitted,\r\n  errors will be eaten.\r\n  @return false if event is disabled; true otherwise.\r\n  **/\r\n  publish(data: T, publishAsync: boolean = false, errorCallback?: (e: Error) => any) {\r\n\r\n    if (!BreezeEvent._isEnabled(this.name, this.publisher)) return false;\r\n\r\n    if (publishAsync === true) {\r\n      setTimeout(publishCore, 0, this, data, errorCallback);\r\n    } else {\r\n      publishCore(this, data, errorCallback);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  Publish data for this event asynchronously.\r\n  >      // Assume 'salaryEvent' is previously constructed Event\r\n  >      salaryEvent.publishAsync( { eventType: \"payRaise\", amount: 100 });\r\n\r\n  And we can add a handler in case the subscriber 'mishandles' the event.\r\n  >      salaryEvent.publishAsync( { eventType: \"payRaise\", amount: 100 }, function(error) {\r\n  >          // do something with the 'error' object\r\n  >      });\r\n  @param data - Data to publish\r\n  @param errorCallback - Function to be called for any errors that occur during publication. If omitted,\r\n  errors will be eaten.\r\n  **/\r\n  publishAsync(data: T, errorCallback: (e: Error) => any) {\r\n    this.publish(data, true, errorCallback);\r\n  }\r\n\r\n  /**\r\n  Subscribe to this event.\r\n  >      // Assume 'salaryEvent' is previously constructed Event\r\n  >      salaryEvent.subscribe(function (eventArgs) {\r\n  >          if (eventArgs.eventType === \"payRaise\") {\r\n  >              // do something\r\n  >          }\r\n  >      });\r\n\r\n  There are several built in Breeze events, such as [[EntityAspect.propertyChanged]], [[EntityAspect.validationErrorsChanged]] as well.\r\n  >      // Assume order is a preexisting 'order' entity\r\n  >      order.entityAspect.propertyChanged.subscribe(function (pcEvent) {\r\n  >          if ( pcEvent.propertyName === \"OrderDate\") {\r\n  >              // do something\r\n  >          }\r\n  >      });\r\n  @param callback- Function to be called whenever 'data' is published for this event.\r\n  @param callback.data - {Object} Whatever 'data' was published.  This should be documented on the specific event.\r\n  @return This is a key for 'unsubscription'.  It can be passed to the 'unsubscribe' method.\r\n  **/\r\n  subscribe(callback: (data: T) => any) {\r\n    if (!this._subscribers) {\r\n      this._subscribers = [];\r\n    }\r\n\r\n    let unsubKey = BreezeEvent.__nextUnsubKey;\r\n    this._subscribers.push({ unsubKey: unsubKey, callback: callback });\r\n    ++BreezeEvent.__nextUnsubKey;\r\n    return unsubKey;\r\n  }\r\n\r\n  /**\r\n  Unsubscribe from this event.\r\n  >      // Assume order is a preexisting 'order' entity\r\n  >      let token = order.entityAspect.propertyChanged.subscribe(function (pcEvent) {\r\n  >              // do something\r\n  >      });\r\n  >      // sometime later\r\n  >      order.entityAspect.propertyChanged.unsubscribe(token);\r\n  @param unsubKey - The value returned from the 'subscribe' method may be used to unsubscribe here.\r\n  @return Whether unsubscription occured. This will return false if already unsubscribed or if the key simply\r\n  cannot be found.\r\n  **/\r\n  unsubscribe = function (unsubKey: number) {\r\n    if (!this._subscribers) return false;\r\n    let subs = this._subscribers;\r\n    let ix = core.arrayIndexOf(subs, function (s) {\r\n      return s.unsubKey === unsubKey;\r\n    });\r\n    if (ix !== -1) {\r\n      subs.splice(ix, 1);\r\n      if (subs.length === 0) {\r\n        this._subscribers = null;\r\n      }\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /** remove all subscribers */\r\n  clear() {\r\n    this._subscribers = <any>null;\r\n  }\r\n\r\n  /** event bubbling - document later. */\r\n\r\n  // null or undefined 'getParentFn' means Event does not need to bubble i.e. that it is always enabled - .\r\n  static bubbleEvent(target: any, getParentFn?: (() => any)) {\r\n    target._getEventParent = getParentFn || null;\r\n  }\r\n\r\n  /**\r\n  Enables or disables the named event for an object and all of its children.\r\n  >      BreezeEvent.enable(âpropertyChangedâ, myEntityManager, false)\r\n\r\n  will disable all EntityAspect.propertyChanged events within a EntityManager.\r\n  >      BreezeEvent.enable(âpropertyChangedâ, myEntityManager, true)\r\n\r\n  will enable all EntityAspect.propertyChanged events within a EntityManager.\r\n  >      BreezeEvent.enable(âpropertyChangedâ, myEntity.entityAspect, false)\r\n\r\n  will disable EntityAspect.propertyChanged events for a specific entity.\r\n  >      BreezeEvent.enable(âpropertyChangedâ, myEntity.entityAspect, null)\r\n\r\n  will removes any enabling / disabling at the entity aspect level so now any 'Event.enable' calls at the EntityManager level,\r\n  made either previously or in the future, will control notification.\r\n  >      BreezeEvent.enable(âvalidationErrorsChangedâ, myEntityManager, function(em) {\r\n  >          return em.customTag === âblueâ;\r\n  >      })\r\n\r\n\r\n  will either enable or disable myEntityManager based on the current value of a âcustomTagâ property on myEntityManager.\r\n  Note that this is dynamic, changing the customTag value will cause events to be enabled or disabled immediately.\r\n  @param eventName - The name of the event.\r\n  @param target - The object at which enabling or disabling will occur.  All event notifications that occur to this object or\r\n  children of this object will be enabled or disabled.\r\n  @param isEnabled - A boolean, a null or a function that returns either a boolean or a null.\r\n  **/\r\n static enable(eventName: string, obj: Object, isEnabled: boolean | ((x: any) => boolean)) {\r\n    assertParam(eventName, \"eventName\").isNonEmptyString().check();\r\n    assertParam(obj, \"obj\").isObject().check();\r\n    assertParam(isEnabled, \"isEnabled\").isBoolean().isOptional().or().isFunction().check();\r\n    let ob = <any>obj;\r\n    if (!ob._$eventMap) {\r\n      ob._$eventMap = {};\r\n    }\r\n    ob._$eventMap[eventName] = isEnabled;\r\n  }\r\n\r\n  /**\r\n  Returns whether for a specific event and a specific object and its children, notification is enabled or disabled or not set.\r\n  >      BreezeEvent.isEnabled(âpropertyChangedâ, myEntityManager)\r\n  > \r\n  @param eventName - The name of the event.\r\n  @param target - The object for which we want to know if notifications are enabled.\r\n  @return A null is returned if this value has not been set.\r\n  **/\r\n  static isEnabled(eventName: string, obj: Object) {\r\n    assertParam(eventName, \"eventName\").isNonEmptyString().check();\r\n    assertParam(obj, \"obj\").isObject().check();\r\n    // null is ok - it just means that the object is at the top level.\r\n    if ((<any>obj)._getEventParent === undefined) {\r\n      throw new Error(\"This object does not support event enabling/disabling\");\r\n    }\r\n    // return ctor._isEnabled(getFullEventName(eventName), obj);\r\n    return BreezeEvent._isEnabled(eventName, 3);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  static _isEnabled = function (eventName: string, obj: Object) {\r\n    let isEnabled: any = null;\r\n    let ob = <any>obj;\r\n    let eventMap = ob._$eventMap;\r\n    if (eventMap) {\r\n      isEnabled = eventMap[eventName];\r\n    }\r\n    if (isEnabled != null) {\r\n      if (typeof isEnabled === 'function') {\r\n        return !!isEnabled(obj);\r\n      } else {\r\n        return !!isEnabled;\r\n      }\r\n    } else {\r\n      let parent = ob._getEventParent && ob._getEventParent();\r\n      if (parent) {\r\n        return !!this._isEnabled(eventName, parent);\r\n      } else {\r\n        // default if not explicitly disabled.\r\n        return true;\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n}\r\n\r\n// legacy support - deliberately not typed\r\n(core as any).Event = BreezeEvent;","import { core } from './core';\r\nimport { assertParam  } from './assert-param';\r\nimport { BreezeEvent } from './event';\r\n\r\n/** @hidden */\r\nexport interface AdapterCtor<T extends BaseAdapter> { new (...args: any[]): T; }\r\n/** @hidden */\r\nexport interface IDef<T extends BaseAdapter> { ctor: AdapterCtor<T>; defaultInstance?: T; }\r\n\r\nexport type AdapterType = 'dataService'|'modelLibrary'|'ajax'|'uriBuilder';\r\n\r\nexport class InterfaceDef<T extends BaseAdapter> {\r\n\r\n    name: string;\r\n    defaultInstance?: T;\r\n    /** @hidden @internal */\r\n    _implMap: { [name: string]: IDef<T> };\r\n\r\n    constructor(name: string) {\r\n        this.name = name;\r\n        this.defaultInstance = undefined;\r\n        this._implMap = {};\r\n    }\r\n\r\n    /** Define an implementation of the given adaptername */\r\n    registerCtor(adapterName: string, ctor: AdapterCtor<T>): void {\r\n        this._implMap[adapterName.toLowerCase()] = { ctor: ctor, defaultInstance: undefined };\r\n    }\r\n\r\n    /** Return the definition for the given adapterName */\r\n    getImpl(adapterName: string): IDef<T> {\r\n        return this._implMap[adapterName.toLowerCase()];\r\n    }\r\n\r\n    /** Return the first implementation for this InterfaceDef */\r\n    getFirstImpl(): IDef<T> {\r\n        let kv = core.objectFirst(this._implMap, function () {\r\n            return true;\r\n        });\r\n        return kv ? kv.value : null;\r\n    }\r\n\r\n    getDefaultInstance() {\r\n        return this.defaultInstance as T;\r\n    }\r\n}\r\n\r\nexport interface BaseAdapter {\r\n    /** @hidden @internal */\r\n    _$impl?: any;\r\n    name: string;\r\n    initialize(): void;\r\n    checkForRecomposition?: (context: any) => void;\r\n}\r\n\r\nexport class BreezeConfig {\r\n    functionRegistry = {};\r\n    typeRegistry = {};\r\n    objectRegistry = {};\r\n    interfaceInitialized: BreezeEvent<{ interfaceName: string, instance: BaseAdapter, isDefault: boolean }>;\r\n\r\n    stringifyPad = '';\r\n    /** whether to prohibit eval() and Function() in breeze code */\r\n    noEval: boolean;\r\n    /** @hidden @internal */\r\n    _interfaceRegistry: any;  // will be set in adapter-interfaces. untyped here to avoid circularity issues.\r\n\r\n    constructor() {\r\n        this.interfaceInitialized = new BreezeEvent(\"interfaceInitialized\", this);\r\n        if (this.noEval === undefined) {\r\n            try {\r\n                Error['x'] = Function('');\r\n                this.noEval = false; // eval succeeded\r\n            } catch {\r\n                this.noEval = true; // eval failed, probably due to CSP\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n    Method use to register implementations of standard breeze interfaces.  Calls to this method are usually\r\n    made as the last step within an adapter implementation.\r\n    @method registerAdapter\r\n    @param interfaceName {String} - one of the following interface names: \"ajax\", \"dataService\", \"modelLibrary\", \"uriBuilder\"\r\n    @param adapterCtor {Function} - an ctor function that returns an instance of the specified interface.\r\n    **/\r\n    registerAdapter<T extends BaseAdapter>(interfaceName: AdapterType, adapterCtor: AdapterCtor<T>) {\r\n        assertParam(interfaceName, \"interfaceName\").isNonEmptyString().check();\r\n        assertParam(adapterCtor, \"adapterCtor\").isFunction().check();\r\n        // this impl will be thrown away after the name is retrieved.\r\n        let impl = new adapterCtor();\r\n        let implName = impl.name;\r\n        if (!implName) {\r\n            throw new Error(\"Unable to locate a 'name' property on the constructor passed into the 'registerAdapter' call.\");\r\n        }\r\n        let idef = this.getInterfaceDef(interfaceName);\r\n        idef.registerCtor(implName, adapterCtor);\r\n    }\r\n\r\n    /**\r\n    Returns the ctor function used to implement a specific interface with a specific adapter name.\r\n    @method getAdapter\r\n    @param interfaceName {String} One of the following interface names: \"ajax\", \"dataService\", \"modelLibrary\", \"uriBuilder\"\r\n    @param [adapterName] {String} The name of any previously registered adapter. If this parameter is omitted then\r\n    this method returns the \"default\" adapter for this interface. If there is no default adapter, then a null is returned.\r\n    @return {Function|null} Returns either a ctor function or null.\r\n    **/\r\n    getAdapter(interfaceName: AdapterType, adapterName: string) {\r\n        let idef = this.getInterfaceDef(interfaceName);\r\n        if (adapterName) {\r\n            let impl = idef.getImpl(adapterName);\r\n            return impl ? impl.ctor : null;\r\n        } else {\r\n            return idef.defaultInstance ? idef.defaultInstance._$impl.ctor : null;\r\n        }\r\n    }\r\n\r\n    /**\r\n    Initializes a single adapter implementation. Initialization means either newing a instance of the\r\n    specified interface and then calling \"initialize\" on it or simply calling \"initialize\" on the instance\r\n    if it already exists.\r\n    @method initializeAdapterInstance\r\n    @param interfaceName {String} The name of the interface to which the adapter to initialize belongs.\r\n    @param adapterName {String} - The name of a previously registered adapter to initialize.\r\n    @param [isDefault=true] {Boolean} - Whether to make this the default \"adapter\" for this interface.\r\n    @return {an instance of the specified adapter}\r\n    **/\r\n    initializeAdapterInstance(interfaceName: AdapterType, adapterName: string, isDefault: boolean = true) {\r\n        isDefault = isDefault === undefined ? true : isDefault;\r\n        assertParam(interfaceName, \"interfaceName\").isNonEmptyString().check();\r\n        assertParam(adapterName, \"adapterName\").isNonEmptyString().check();\r\n        assertParam(isDefault, \"isDefault\").isBoolean().check();\r\n\r\n        let idef = this.getInterfaceDef(interfaceName);\r\n        let impl = idef.getImpl(adapterName);\r\n        if (!impl) {\r\n            throw new Error(\"Unregistered adapter.  Interface: \" + interfaceName + \" AdapterName: \" + adapterName);\r\n        }\r\n\r\n        return this._initializeAdapterInstanceCore(idef, impl, isDefault);\r\n    }\r\n\r\n    /**\r\n    Returns the adapter instance corresponding to the specified interface and adapter names.\r\n    @method getAdapterInstance\r\n    @param interfaceName {String} The name of the interface.\r\n    @param [adapterName] {String} - The name of a previously registered adapter.  If this parameter is\r\n    omitted then the default implementation of the specified interface is returned. If there is\r\n    no defaultInstance of this interface, then the first registered instance of this interface is returned.\r\n    @return {an instance of the specified adapter}\r\n    @internal\r\n    **/\r\n    getAdapterInstance<T extends BaseAdapter>(interfaceName: AdapterType, adapterName?: string) {\r\n        let idef = this.getInterfaceDef<T>(interfaceName);\r\n        let impl: IDef<T>;\r\n\r\n        let isDefault = adapterName == null || adapterName === \"\";\r\n        if (isDefault) {\r\n            if (idef.defaultInstance) return idef.defaultInstance;\r\n            impl = idef.getFirstImpl();\r\n        } else {\r\n            impl = idef.getImpl(adapterName!);\r\n        }\r\n        if (!impl) return undefined;\r\n        if (impl.defaultInstance) {\r\n            return impl.defaultInstance;\r\n        } else {\r\n            return this._initializeAdapterInstanceCore(idef, impl, isDefault);\r\n        }\r\n    }\r\n\r\n    /** this is needed for reflection purposes when deserializing an object that needs a fn or ctor.\r\n        Used to register validators. */\r\n    registerFunction(fn: Function, fnName: string) {\r\n        assertParam(fn, \"fn\").isFunction().check();\r\n        assertParam(fnName, \"fnName\").isString().check();\r\n        if (fn.prototype) {\r\n            fn.prototype._$fnName = fnName;\r\n        }\r\n        this.functionRegistry[fnName] = fn;\r\n    }\r\n\r\n    registerType(ctor: Function, typeName: string) {\r\n        assertParam(ctor, \"ctor\").isFunction().check();\r\n        assertParam(typeName, \"typeName\").isString().check();\r\n        if (ctor.prototype) {\r\n            ctor.prototype._$typeName = typeName;\r\n        }\r\n        this.typeRegistry[typeName] = ctor;\r\n    }\r\n\r\n    getRegisteredFunction(fnName: string) {\r\n        return this.functionRegistry[fnName];\r\n    }\r\n\r\n    getInterfaceDef<T extends BaseAdapter>(interfaceName: string) {\r\n        let lcName = interfaceName.toLowerCase();\r\n        // source may be null\r\n        let kv = core.objectFirst(this._interfaceRegistry || {}, function (k, v) {\r\n            return k.toLowerCase() === lcName;\r\n        });\r\n        if (!kv) {\r\n            throw new Error(\"Unknown interface name: \" + interfaceName);\r\n        }\r\n        return <InterfaceDef<T>>kv.value;\r\n    }\r\n\r\n    /** @deprecated @internal no-op kept for backward compatibility */\r\n    setQ(q: any) {\r\n        console && console.warn(\"setQ does nothing; ES6 Promise support is required - use a shim if necessary.\");\r\n    }\r\n\r\n    /** @hidden @internal */\r\n    _storeObject(obj: Object, type: string | Function, name: string) {\r\n        // uncomment this if we make this public.\r\n        //assertParam(obj, \"obj\").isObject().check();\r\n        //assertParam(name, \"objName\").isString().check();\r\n        let key = (typeof (type) === \"string\" ? type : type.prototype._$typeName) + \".\" + name;\r\n        this.objectRegistry[key] = obj;\r\n    }\r\n\r\n    /** @hidden @internal */\r\n    _fetchObject(type: string | Function, name: string) {\r\n        if (!name) return undefined;\r\n        let key = (typeof (type) === \"string\" ? type : type.prototype._$typeName) + \".\" + name;\r\n        let result = this.objectRegistry[key];\r\n        if (!result) {\r\n            throw new Error(\"Unable to locate a registered object by the name: \" + key);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /** @hidden @internal */\r\n    _initializeAdapterInstanceCore<T extends BaseAdapter>(interfaceDef: InterfaceDef<T>, impl: IDef<T>, isDefault: boolean) {\r\n        let instance: T;\r\n        let inst = impl.defaultInstance;\r\n        if (!inst) {\r\n            instance = new (impl.ctor)();\r\n            impl.defaultInstance = instance;\r\n            instance._$impl = impl;\r\n        } else {\r\n            instance = inst;\r\n        }\r\n\r\n        instance.initialize();\r\n\r\n        if (isDefault) {\r\n            // next line needs to occur before any recomposition\r\n            interfaceDef.defaultInstance = instance;\r\n        }\r\n\r\n        // recomposition of other impls will occur here.\r\n        this.interfaceInitialized.publish({ interfaceName: interfaceDef.name, instance: instance, isDefault: true });\r\n\r\n        if (instance.checkForRecomposition != null) {\r\n            // now register for own dependencies.\r\n            this.interfaceInitialized.subscribe((interfaceInitializedArgs) => {\r\n                // TODO: why '!'s needed here for typescript to compile correctly???\r\n                instance.checkForRecomposition!(interfaceInitializedArgs);\r\n            });\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n}\r\n\r\nexport const config = new BreezeConfig();\r\n\r\n// legacy\r\n(core as any).config = config;\r\n\r\n\r\n\r\n","import { EntityType, NavigationProperty } from './entity-metadata';\r\nimport { DataServiceAdapter, UriBuilderAdapter } from './interface-registry';\r\nimport { KeyMapping } from './entity-manager';\r\nimport { MappingContext } from './mapping-context';\r\nimport { assertConfig } from './assert-param';\r\nimport { config } from './config';\r\nimport { core } from './core';\r\n\r\n/** Configuration info to be passed to the [[DataService]] constructor */\r\nexport interface DataServiceConfig {\r\n  /** The serviceName for this DataService.  **/\r\n  serviceName?: string;\r\n  /** The adapter name for the [[IDataServiceAdapter]] to be used with this service.  **/\r\n  adapterName?: string;\r\n  /** The adapter name for the [[IUriBuilderAdapter]] to be used with this service.  **/\r\n  uriBuilderName?: string;\r\n  /** Whether the server can provide metadata for this service.  **/\r\n  hasServerMetadata?: boolean;\r\n  /** The [[JsonResultsAdapter]] used to process the results of any query against this DataService.  **/\r\n  jsonResultsAdapter?: JsonResultsAdapter;\r\n  /** Whether to use JSONP when performing a 'GET' request against this service.  **/\r\n  useJsonp?: boolean;\r\n}\r\n/**\r\nA DataService instance is used to encapsulate the details of a single 'service'; this includes a serviceName, a dataService adapterInstance,\r\nand whether the service has server side metadata.\r\n\r\nYou can construct an EntityManager with either a serviceName or a DataService instance, if you use a serviceName then a DataService\r\nis constructed for you.  (It can also be set via the EntityManager.setProperties method).\r\n\r\nThe same applies to the MetadataStore.fetchMetadata method, i.e. it takes either a serviceName or a DataService instance.\r\n\r\nEach metadataStore contains a list of DataServices, each accessible via its âserviceNameâ.\r\n( see MetadataStore.getDataService and MetadataStore.addDataService).  The âaddDataServiceâ method is called internally\r\nanytime a MetadataStore.fetchMetadata call occurs with a new dataService ( or service name).\r\n\r\n**/\r\nexport class DataService {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // actually put on prototype.\r\n  /** The serviceName for this DataService. __Read Only__ **/\r\n  serviceName: string;\r\n  /** The adapter name for the [[IDataServiceAdapter]] to be used with this service. __Read Only__  **/\r\n  adapterName: string;\r\n  /**  The [[IDataServiceAdapter]] implementation instance associated with this EntityManager. __Read Only__  **/\r\n  adapterInstance?: DataServiceAdapter;\r\n  /** The adapter name for the [[IUriBuilderAdapter]] to be used with this service. __Read Only__  **/\r\n  uriBuilderName: string;\r\n  /**  The [[IUriBuilderAdapter]] implementation instance associated with this EntityManager. __Read Only__  **/\r\n  uriBuilder?: UriBuilderAdapter;\r\n  /** Whether the server can provide metadata for this service. __Read Only__   **/\r\n  hasServerMetadata: boolean;\r\n  /** The [[JsonResultsAdapter]] used to process the results of any query against this DataService. __Read Only__ **/\r\n  jsonResultsAdapter: JsonResultsAdapter;\r\n  /** Whether to use JSONP when performing a 'GET' request against this service. __Read Only__  **/\r\n  useJsonp: boolean;\r\n\r\n  /**   DataService constructor\r\n  >     var dataService = new DataService({\r\n  >         serviceName: altServiceName,\r\n  >         hasServerMetadata: false\r\n  >     });\r\n\r\n  >     var metadataStore = new MetadataStore({\r\n  >         namingConvention: NamingConvention.camelCase\r\n  >     });\r\n\r\n  >     return new EntityManager({\r\n  >         dataService: dataService,\r\n  >         metadataStore: metadataStore\r\n  >     });\r\n  @param config - A configuration object.\r\n  **/\r\n  constructor(config?: DataServiceConfig) {\r\n    updateWithConfig(this, config);\r\n  }\r\n\r\n\r\n  /**\r\n  Returns a copy of this DataService with the specified properties applied.\r\n  @param config - The configuration object to apply to create a new DataService.\r\n  **/\r\n  using(config: DataServiceConfig) {\r\n    if (!config) return this;\r\n    let result = new DataService(this);\r\n    return updateWithConfig(result, config);\r\n  }\r\n\r\n  static resolve(dataServices: DataService[]) {\r\n    // final defaults\r\n    // Deliberate use of 'as any' below.\r\n    (dataServices as any).push({\r\n      hasServerMetadata: true,\r\n      useJsonp: false\r\n    });\r\n    let ds = new DataService(core.resolveProperties(dataServices,\r\n        [\"serviceName\", \"adapterName\", \"uriBuilderName\", \"hasServerMetadata\", \"jsonResultsAdapter\", \"useJsonp\"]));\r\n\r\n    if (!ds.serviceName) {\r\n      throw new Error(\"Unable to resolve a 'serviceName' for this dataService\");\r\n    }\r\n    ds.adapterInstance = ds.adapterInstance || config.getAdapterInstance<DataServiceAdapter>(\"dataService\", ds.adapterName);\r\n    ds.jsonResultsAdapter = ds.jsonResultsAdapter || ds.adapterInstance!.jsonResultsAdapter;\r\n    ds.uriBuilder = ds.uriBuilder || config.getAdapterInstance<UriBuilderAdapter>(\"uriBuilder\", ds.uriBuilderName);\r\n    return ds;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  static _normalizeServiceName(serviceName: string) {\r\n    serviceName = serviceName.trim();\r\n    if (serviceName.substr(-1) !== \"/\") {\r\n      return serviceName + '/';\r\n    } else {\r\n      return serviceName;\r\n    }\r\n  }\r\n\r\n  /**  */\r\n  toJSON() {\r\n    // don't use default value here - because we want to be able to distinguish undefined props for inheritence purposes.\r\n    return core.toJson(this, {\r\n      serviceName: null,\r\n      adapterName: null,\r\n      uriBuilderName: null,\r\n      hasServerMetadata: null,\r\n      jsonResultsAdapter: function (v: any) {\r\n        return v && v.name;\r\n      },\r\n      useJsonp: null\r\n    });\r\n  }\r\n\r\n  static fromJSON(json: any) {\r\n    json.jsonResultsAdapter = config._fetchObject(JsonResultsAdapter, json.jsonResultsAdapter);\r\n    return new DataService(json);\r\n  }\r\n\r\n  /**\r\n   Returns a url for this dataService with the specified suffix. This method handles dataService names either\r\n   with or without trailing '/'s.  If the suffix starts with \"http\" then it will be returned as-is.\r\n   @method qualifyUrl\r\n   @param suffix {String} The resulting url.\r\n   @return {a Url string}\r\n   **/\r\n  qualifyUrl(suffix: string) {\r\n    if (suffix && suffix.startsWith(\"http\")) {\r\n      return suffix;\r\n    }\r\n    let url = this.serviceName;\r\n    // remove any trailing \"/\"\r\n    if (core.stringEndsWith(url, \"/\")) {\r\n      url = url.substr(0, url.length - 1);\r\n    }\r\n    // ensure that it ends with \"/\" + suffix\r\n    suffix = \"/\" + suffix;\r\n    if (!core.stringEndsWith(url, suffix)) {\r\n      url = url + suffix;\r\n    }\r\n    return url;\r\n  }\r\n\r\n}\r\nDataService.prototype._$typeName = \"DataService\";\r\n\r\nfunction updateWithConfig(obj: DataService, dsConfig?: DataServiceConfig) {\r\n  if (dsConfig) {\r\n    assertConfig(dsConfig)\r\n        .whereParam(\"serviceName\").isOptional()\r\n        .whereParam(\"adapterName\").isString().isOptional()\r\n        .whereParam(\"uriBuilderName\").isString().isOptional()\r\n        .whereParam(\"hasServerMetadata\").isBoolean().isOptional()\r\n        .whereParam(\"jsonResultsAdapter\").isInstanceOf(JsonResultsAdapter).isOptional()\r\n        .whereParam(\"useJsonp\").isBoolean().isOptional()\r\n        .applyAll(obj);\r\n    obj.serviceName = obj.serviceName && DataService._normalizeServiceName(obj.serviceName);\r\n    obj.adapterInstance = obj.adapterName ?  config.getAdapterInstance<DataServiceAdapter>(\"dataService\", obj.adapterName) : undefined;\r\n    obj.uriBuilder = obj.uriBuilderName ? config.getAdapterInstance<UriBuilderAdapter>(\"uriBuilder\", obj.uriBuilderName) : undefined;\r\n  }\r\n  return obj;\r\n}\r\n\r\nexport interface NodeMeta {\r\n  entityType?: EntityType;\r\n  nodeId?: string;\r\n  nodeRefId?: string;\r\n  ignore?: boolean;\r\n  passThru?: boolean;\r\n  extraMetadata?: any;\r\n}\r\n\r\nexport interface NodeContext {\r\n  nodeType: string;\r\n  propertyName?: string;\r\n  navigationProperty?: NavigationProperty;\r\n}\r\n\r\n/** Configuration info to be passed to the [[JsonResultsAdapter]] constructor */\r\nexport interface JsonResultsAdapterConfig {\r\n  /** The name of this adapter.  This name is used to uniquely identify and locate this instance when an 'exported' JsonResultsAdapter is later imported. */\r\n  name: string;\r\n  /** A Function that is called once per query operation to extract the 'payload' from any json received over the wire. \r\n  This method has a default implementation which to simply return the \"results\" property from any json returned as a result of executing the query. \r\n  */\r\n  extractResults?: Function;\r\n  /** A function that is called once per save operation to extract the entities from any json received over the wire.  Must return an array.\r\n  This method has a default implementation which simply returns the \"entities\" property from any json returned as a result of executing the save. */\r\n  extractSaveResults?: Function;\r\n  /** A function that is called once per save operation to extract the key mappings from any json received over the wire.  Must return an array.\r\n  This method has a default implementation which simply returns the \"keyMappings\" property from any json returned as a result of executing the save. */\r\n  extractKeyMappings?: (data: {}) => KeyMapping[];\r\n  /** A function that is called once per save operation to extract any deleted keys from any json received over the wire.  Must return an array.\r\n  This method has a default implementation which simply returns an empty array. */\r\n  extractDeletedKeys?: (data: {}) => any[]; // TODO: refine\r\n  /** A visitor method that will be called on each node of the returned payload. */\r\n  visitNode?: (v: any, mc?: MappingContext, nodeContext?: NodeContext) => NodeMeta;\r\n\r\n}\r\n\r\n/**\r\nA JsonResultsAdapter instance is used to provide custom extraction and parsing logic on the json results returned by any web service.\r\nThis facility makes it possible for breeze to talk to virtually any web service and return objects that will be first class 'breeze' citizens.\r\n**/\r\nexport class JsonResultsAdapter {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // actually put on prototype.\r\n  /** The name of this adapter.  This name is used to uniquely identify and locate this instance when an 'exported' JsonResultsAdapter is later imported. */\r\n  name: string;\r\n  /** A Function that is called once per query operation to extract the 'payload' from any json received over the wire. \r\n  This method has a default implementation which simply returns the \"results\" property from any json returned as a result of executing the query. */\r\n  extractResults: Function; // TODO - refine\r\n  /** A function that is called once per save operation to extract the entities from any json received over the wire.  Must return an array.\r\n  This method has a default implementation which simply returns the \"entities\" property from any json returned as a result of executing the save. */\r\n  extractSaveResults: Function;\r\n    /** A function that is called once per save operation to extract the key mappings from any json received over the wire.  Must return an array.\r\n  This method has a default implementation which simply returns the \"keyMappings\" property from any json returned as a result of executing the save. */\r\n  extractKeyMappings:  (data: {}) => KeyMapping[];\r\n  /** A function that is called once per save operation to extract any deleted keys from any json received over the wire.  Must return an array.\r\n  This method has a default implementation which is to simply returns the \"deletedKeys\" property from any json returned as a result of executing the save. */\r\n  extractDeletedKeys?: (data: {}) => any[]; // TODO: refine\r\n  /** A visitor method that will be called on each node of the returned payload. */\r\n  visitNode: Function;\r\n\r\n  /**\r\n  JsonResultsAdapter constructor\r\n\r\n  @example\r\n      //\r\n      var jsonResultsAdapter = new JsonResultsAdapter({\r\n          name: \"test1e\",\r\n          extractResults: function(json) {\r\n              return json.results;\r\n          },\r\n          visitNode: function(node, mappingContext, nodeContext) {\r\n              var entityType = normalizeTypeName(node.$type);\r\n              var propertyName = nodeContext.propertyName;\r\n              var ignore = propertyName && propertyName.substr(0, 1) === \"$\";\r\n\r\n              return {\r\n                  entityType: entityType,\r\n                  nodeId: node.$id,\r\n                  nodeRefId: node.$ref,\r\n                  ignore: ignore,\r\n                  passThru: false // default\r\n              };\r\n          }\r\n      });\r\n\r\n      var dataService = new DataService( {\r\n              serviceName: \"breeze/foo\",\r\n              jsonResultsAdapter: jsonResultsAdapter\r\n      });\r\n\r\n      var entityManager = new EntityManager( {\r\n          dataService: dataService\r\n      });\r\n\r\n  @param config - A configuration object.\r\n\r\n  **/\r\n  constructor(jsConfig: JsonResultsAdapterConfig) {\r\n    if (arguments.length !== 1) {\r\n      throw new Error(\"The JsonResultsAdapter ctor should be called with a single argument that is a configuration object.\");\r\n    }\r\n\r\n    assertConfig(jsConfig)\r\n        .whereParam(\"name\").isNonEmptyString()\r\n        .whereParam(\"extractResults\").isFunction().isOptional().withDefault(extractResultsDefault)\r\n        .whereParam(\"extractSaveResults\").isFunction().isOptional().withDefault(extractSaveResultsDefault)\r\n        .whereParam(\"extractKeyMappings\").isFunction().isOptional().withDefault(extractKeyMappingsDefault)\r\n        .whereParam(\"extractDeletedKeys\").isFunction().isOptional().withDefault(extractDeletedKeysDefault)\r\n        .whereParam(\"visitNode\").isFunction()\r\n        .applyAll(this);\r\n    config._storeObject(this, \"JsonResultsAdapter\", this.name);\r\n  }\r\n\r\n}\r\nJsonResultsAdapter.prototype._$typeName = \"JsonResultsAdapter\";\r\n\r\nfunction extractResultsDefault(data: any) {\r\n  return data.results;\r\n}\r\n\r\nfunction extractSaveResultsDefault(data: any) {\r\n  return data.entities || data.Entities || [];\r\n}\r\n\r\nfunction extractKeyMappingsDefault(data: any) {\r\n  return data.keyMappings || data.KeyMappings || [];\r\n}\r\n\r\nfunction extractDeletedKeysDefault(data: any) {\r\n  return data.deletedKeys || data.DeletedKeys || [];\r\n}\r\n\r\n","import { core } from './core';\r\nimport { assertParam } from './assert-param';\r\nimport { config } from './config';\r\n\r\nexport const INT16_MIN = -32768;\r\nexport const INT16_MAX = 32767;\r\n\r\nexport const INT32_MIN = -2147483648;\r\nexport const INT32_MAX = 2147483647;\r\n\r\nexport const BYTE_MIN = 0;\r\nexport const BYTE_MAX = 255;\r\n\r\nexport interface ValidationContext {\r\n  property?: any;\r\n  propertyName?: string;\r\n  value?: any;\r\n}\r\n\r\nexport interface ValidationFn {\r\n    (value: any, context?: any): boolean;\r\n}\r\n\r\n// add common props and methods for every validator 'context' here.\r\nlet rootContext = {\r\n  displayName: function (context: ValidationContext) {\r\n    if (context.property) {\r\n      return context.property.resolveProperty(\"displayName\") || context.propertyName || context.property.name;\r\n    } else {\r\n      return \"Value\";\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\nInstances of the Validator class provide the logic to validate another object and provide a description of any errors\r\nencountered during the validation process.  They are typically associated with a 'validators' property on the following types: [[EntityType]],\r\n[[DataProperty]] or [[NavigationProperty]].\r\n\r\nA number of property level validators are registered automatically, i.e added to each DataProperty.validators property\r\nbased on [[DataProperty]] metadata.  For example,\r\n\r\n- DataProperty.dataType -> one of the 'dataType' validator methods such as Validator.int64, Validator.date, Validator.bool etc.\r\n- DataProperty.maxLength -> Validator.maxLength\r\n- DataProperty.isNullable -> Validator.required (if not nullable)\r\n\r\n@class Validator\r\n**/\r\n\r\n/**\r\nValidator constructor - This method is used to create create custom validations.  Several\r\nbasic \"Validator\" construction methods are also provided as static methods to this class. These methods\r\nprovide a simpler syntax for creating basic validations.\r\n\r\nMany of these stock validators are inspired by and implemented to conform to the validators defined at\r\nhttp://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.aspx\r\n\r\nSometimes a custom validator will be required.\r\n@example\r\nMost validators will be 'property' level validators, like this.\r\n@example\r\n    // v is this function is the value to be validated, in this case a \"country\" string.\r\n    var valFn = function (v) {\r\n        if (v == null) return true;\r\n        return (core.stringStartsWith(v, \"US\"));\r\n    };\r\n    var countryValidator = new Validator(\"countryIsUS\", valFn, {\r\n        displayName: \"Country\", \r\n        messageTemplate: \"'%displayName%' must start with 'US'\" \r\n    });\r\n\r\n    // Now plug it into Breeze.\r\n    // Assume em1 is a preexisting EntityManager.\r\n    var custType = metadataStore.getEntityType(\"Customer\");\r\n    var countryProp = custType.getProperty(\"Country\");\r\n    // Note that validator is added to a 'DataProperty' validators collection.\r\n    prop.validators.push(countryValidator);\r\nEntity level validators are also possible\r\n@example\r\n    function isValidZipCode(value) {\r\n        var re = /^\\d{5}([\\-]\\d{4})?$/;\r\n        return (re.test(value));\r\n    }\r\n\r\n    // v in this case will be a Customer entity\r\n    var valFn = function (v) {\r\n        // This validator only validates US Zip Codes.\r\n        if ( v.getProperty(\"Country\") === \"USA\") {\r\n            var postalCode = v.getProperty(\"PostalCode\");\r\n            return isValidZipCode(postalCode);\r\n        }\r\n        return true;\r\n    };\r\n    var zipCodeValidator = new Validator(\"zipCodeValidator\", valFn,\r\n        { messageTemplate: \"For the US, this is not a valid PostalCode\" });\r\n\r\n    // Now plug it into Breeze.\r\n    // Assume em1 is a preexisting EntityManager.\r\n    var custType = em1.metadataStore.getEntityType(\"Customer\");\r\n    // Note that validator is added to an 'EntityType' validators collection.\r\n    custType.validators.push(zipCodeValidator);\r\nWhat is commonly needed is a way of creating a parameterized function that will itself\r\nreturn a new Validator.  This requires the use of a 'context' object.\r\n@example\r\n    // create a function that will take in a config object\r\n    // and will return a validator\r\n    var numericRangeValidator = function(context) {\r\n        var valFn = function(v, ctx) {\r\n            if (v == null) return true;\r\n            if (typeof(v) !== \"number\") return false;\r\n            if (ctx.min != null && v < ctx.min) return false;\r\n            if (ctx.max != null && v > ctx.max) return false;\r\n            return true;\r\n        };\r\n        // The last parameter below is the 'context' object that will be passed into the 'ctx' parameter above\r\n        // when this validator executes. Several other properties, such as displayName will get added to this object as well.\r\n        return new Validator(\"numericRange\", valFn, {\r\n            messageTemplate: \"'%displayName%' must be a number between the values of %min% and %max%\",\r\n            min: context.min,\r\n            max: context.max\r\n        });\r\n    };\r\n    // Assume that freightProperty is a DataEntityProperty that describes numeric values.\r\n    // register the validator\r\n    freightProperty.validators.push(numericRangeValidator({ min: 100, max: 500 }));\r\n\r\nBreeze substitutes context values and functions for the tokens in the messageTemplate when preparing the runtime error message;\r\n'displayName' is a pre-defined context function that is always available.\r\n\r\nPlease note that Breeze substitutes the empty string for falsey parameters. That usually works in your favor.\r\nSometimes it doesn't as when the 'min' value is zero in which case the message text would have a hole\r\nwhere the 'min' value goes, saying: \"... an integer between the values of and ...\". That is not what you want.\r\n\r\nTo avoid this effect, you may can bake certain of the context values into the 'messageTemplate' itself\r\nas shown in this revision to the pertinent part of the previous example:\r\n@example\r\n    // ... as before\r\n    // ... but bake the min/max values into the message template.\r\n    var template = breeze.core.formatString(\r\n        \"'%displayName%' must be a number between the values of %1 and %2\",\r\n        context.min, context.max);\r\n    return new Validator(\"numericRange\", valFn, {\r\n        messageTemplate: template,\r\n        min: context.min,\r\n        max: context.max\r\n    });\r\n\r\n@method <ctor> Validator\r\n@param name {String} The name of this validator.\r\n@param validatorFn {Function} A function to perform validation.\r\n\r\nvalidatorFn(value, context)\r\n@param validatorFn.value {Object} Value to be validated\r\n@param validatorFn.context {Object} The same context object passed into the constructor with the following additional properties if not\r\notherwise specified.\r\n@param validatorFn.context.value {Object} The value being validated.\r\n@param validatorFn.context.name {String} The name of the validator being executed.\r\n@param validatorFn.context.displayName {String} This will be either the value of the property's 'displayName' property or\r\nthe value of its 'name' property or the string 'Value'\r\n@param validatorFn.context.messageTemplate {String} This will either be the value of Validator.messageTemplates[ {this validators name}] or null. Validator.messageTemplates\r\nis an object that is keyed by validator name and that can be added to in order to 'register' your own message for a given validator.\r\nThe following property can also be specified for any validator to force a specific errorMessage string\r\n@param [validatorFn.context.message] {String} If this property is set it will be used instead of the 'messageTemplate' property when an\r\nerror message is generated.\r\n\r\n@param [context] {Object} A free form object whose properties will made available during the validation and error message creation process.\r\nThis object will be passed into the Validator's validation function whenever 'validate' is called. See above for a description\r\nof additional properties that will be automatically added to this object if not otherwise specified.\r\n@dynamic\r\n**/\r\nexport class Validator {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // on proto\r\n\r\n  name: string;\r\n  valFn: ValidationFn;\r\n  context: ValidationContext;\r\n  currentContext: any;\r\n  private _baseContext: any;\r\n\r\n  constructor(name: string, valFn: ValidationFn, context?: any) {\r\n    // _baseContext is what will get serialized\r\n    this._baseContext = context || {};\r\n    this._baseContext.name = name;\r\n    context = core.extend(Object.create(rootContext), this._baseContext);\r\n    context.messageTemplate = context.messageTemplate || Validator.messageTemplates[name];\r\n    this.name = name;\r\n    this.valFn = valFn;\r\n    this.context = context;\r\n  }\r\n\r\n  /**\r\n  The name of this validator.\r\n\r\n  __readOnly__\r\n  @property name {String}\r\n  **/\r\n\r\n  /**\r\n  The context for this validator.\r\n\r\n  This object will typically contain at a minimum the following properties. \"name\", \"displayName\", and \"message\" or \"messageTemplate\".\r\n  __readOnly__\r\n  @property context {Object}\r\n  **/\r\n\r\n\r\n  /**\r\n  Run this validator against the specified value.  This method will usually be called internally either\r\n  automatically by an property change, entity attach, query or save operation, or manually as a result of\r\n  a validateEntity call on the EntityAspect. The resulting ValidationResults are available via the\r\n  EntityAspect.getValidationErrors method.\r\n\r\n  However, you can also call a validator directly either for testing purposes or some other reason if needed.\r\n  @example\r\n      // using one of the predefined validators\r\n      var validator = Validator.maxLength({ maxLength: 5, displayName: \"City\" });\r\n      // should be ok because \"asdf\".length < 5\r\n      var result = validator.validate(\"asdf\");\r\n      ok(result === null);\r\n      result = validator.validate(\"adasdfasdf\");\r\n      // extract all of the properties of the 'result'\r\n      var errMsg = result.errorMessage;\r\n      var context = result.context;\r\n      var sameValidator = result.validator;\r\n  @method validate\r\n  @param value {Object} Value to validate\r\n  @param additionalContext {Object} Any additional contextual information that the Validator\r\n  can make use of.\r\n  @return {ValidationError|null} A ValidationError if validation fails, null otherwise\r\n  **/\r\n  validate(value: any, additionalContext?: any) {\r\n    let currentContext: ValidationContext; // { value?: Object };\r\n    if (additionalContext) {\r\n      currentContext = core.extend(Object.create(this.context), additionalContext);\r\n    } else {\r\n      currentContext = this.context;\r\n    }\r\n    this.currentContext = currentContext;\r\n\r\n    try {\r\n      if (this.valFn(value, currentContext)) {\r\n        return null;\r\n      } else {\r\n        currentContext.value = value;\r\n        return new ValidationError(this, currentContext, this.getMessage());\r\n      }\r\n    } catch (e) {\r\n      return new ValidationError(this, currentContext, \"Exception occured while executing this validator: \" + this.name);\r\n    }\r\n  }\r\n\r\n\r\n  // context.value is not avail unless validate was called first.\r\n\r\n  /**\r\n  Returns the message generated by the most recent execution of this Validator.\r\n  @example\r\n      var v0 = Validator.maxLength({ maxLength: 5, displayName: \"City\" });\r\n      v0.validate(\"adasdfasdf\");\r\n      var errMessage = v0.getMessage());\r\n  @method getMessage\r\n  @return {String}\r\n  **/\r\n  getMessage() {\r\n    try {\r\n      let context = this.currentContext;\r\n      let message = context.message;\r\n      if (message) {\r\n        if (typeof (message) === \"function\") {\r\n          return message(context);\r\n        } else {\r\n          return message;\r\n        }\r\n      } else if (context.messageTemplate) {\r\n        return formatTemplate(context.messageTemplate, context);\r\n      } else {\r\n        return \"invalid value: \" + (this.name || \"{unnamed validator}\");\r\n      }\r\n    } catch (e) {\r\n      return \"Unable to format error message\" + e.toString();\r\n    }\r\n  }\r\n\r\n  toJSON() {\r\n    return this._baseContext;\r\n  }\r\n\r\n  /**\r\n  Creates a validator instance from a JSON object or an array of instances from an array of JSON objects.\r\n  @method fromJSON\r\n  @static\r\n  @param json {Object} JSON object that represents the serialized version of a validator.\r\n  **/\r\n  public static fromJSON(json: any): any {\r\n    if (Array.isArray(json)) {\r\n      return json.map(function (js) {\r\n        return Validator.fromJSON(js);\r\n      });\r\n    }\r\n    if (json instanceof Validator) {\r\n      return json;\r\n    }\r\n    let validatorName = \"Validator.\" + json.name;\r\n    let fn = config.getRegisteredFunction(validatorName);\r\n    if (!fn) {\r\n      throw new Error(\"Unable to locate a validator named:\" + json.name);\r\n    }\r\n    return fn(json);\r\n  }\r\n\r\n  /**\r\n  Register a validator instance so that any deserialized metadata can reference it.\r\n  @method register\r\n  @static\r\n  @param validator {Validator} Validator to register.\r\n  **/\r\n  public static register(validator: Validator) {\r\n    config.registerFunction(function () {\r\n      return validator;\r\n    }, \"Validator.\" + validator.name);\r\n  }\r\n\r\n  /**\r\n  Register a validator factory so that any deserialized metadata can reference it.\r\n  @method registerFactory\r\n  @static\r\n  @param validatorFactory {Function} A function that optionally takes a context property and returns a Validator instance.\r\n  @param name {String} The name of the validator.\r\n  **/\r\n  public static registerFactory(validatorFactory: (options?: any) => Validator, name: string) {\r\n    config.registerFunction(validatorFactory, \"Validator.\" + name);\r\n  }\r\n\r\n  /**\r\n  Map of standard error message templates keyed by validator name.\r\n  You can add to or modify this object to customize the template used for any validation error message.\r\n  @example\r\n      // v is this function is the value to be validated, in this case a \"country\" string.\r\n      var valFn = function (v) {\r\n          if (v == null) return true;\r\n          return (core.stringStartsWith(v, \"US\"));\r\n      };\r\n      var countryValidator = new Validator(\"countryIsUS\", valFn, { displayName: \"Country\" });\r\n      Validator.messageTemplates.countryIsUS = \"'%displayName%' must start with 'US'\";\r\n      // This will have a similar effect to this\r\n      var countryValidator = new Validator(\"countryIsUS\", valFn, {\r\n          displayName: \"Country\", \r\n          messageTemplate: \"'%displayName%' must start with 'US'\" \r\n      });\r\n  @property messageTemplates {Object}\r\n  @static\r\n  **/\r\n  public static messageTemplates = {\r\n    bool: \"'%displayName%' must be a 'true' or 'false' value\",\r\n    creditCard: \"The %displayName% is not a valid credit card number\",\r\n    date: \"'%displayName%' must be a date\",\r\n    duration: \"'%displayName%' must be a ISO8601 duration string, such as 'P3H24M60S'\",\r\n    emailAddress: \"The %displayName% '%value%' is not a valid email address\",\r\n    guid: \"'%displayName%' must be a GUID\",\r\n    integer: \"'%displayName%' must be an integer\",\r\n    integerRange: \"'%displayName%' must be an integer between the values of %minValue% and %maxValue%\",\r\n    maxLength: \"'%displayName%' must be a string with %maxLength% characters or less\",\r\n    number: \"'%displayName%' must be a number\",\r\n    phone: \"The %displayName% '%value%' is not a valid phone number\",\r\n    regularExpression: \"The %displayName% '%value%' does not match '%expression%'\",\r\n    required: \"'%displayName%' is required\",\r\n    string: \"'%displayName%' must be a string\",\r\n    stringLength: \"'%displayName%' must be a string with between %minLength% and %maxLength% characters\",\r\n    url: \"The %displayName% '%value%' is not a valid url\"\r\n  };\r\n\r\n  /**\r\n  Returns a standard 'required value' Validator\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var custType = em1.metadataStore.getEntityType(\"Customer\");\r\n      var regionProperty - custType.getProperty(\"Region\");\r\n      // Makes \"Region\" on Customer a required property.\r\n      regionProperty.validators.push(Validator.required());\r\n      // or to allow empty strings\r\n      regionProperty.validators.push(Validator.required({ allowEmptyStrings: true }););\r\n  @method required\r\n  @static\r\n  @param context {Object}\r\n  @param [context.allowEmptyStrings] {Boolean} If this parameter is omitted or false then empty strings do NOT pass validation.\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static required = function(context?: any) {\r\n    let valFn = function (v: any, ctx: any) {\r\n      if (typeof v === \"string\") {\r\n        if (ctx && ctx.allowEmptyStrings) return true;\r\n        return v.length > 0;\r\n      } else {\r\n        return v != null;\r\n      }\r\n    };\r\n    return new Validator(\"required\", valFn, context);\r\n  };\r\n\r\n  /**\r\n  Returns a standard maximum string length Validator; the maximum length must be specified\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var custType = em1.metadataStore.getEntityType(\"Customer\");\r\n      var regionProperty - custType.getProperty(\"Region\");\r\n      // Validates that the value of the Region property on Customer will be less than or equal to 5 characters.\r\n      regionProperty.validators.push(Validator.maxLength( {maxLength: 5}));\r\n  @method maxLength\r\n  @static\r\n  @param context {Object}\r\n  @param context.maxLength {Integer}\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static maxLength = function(context: any) {\r\n    let valFn = function (v: any, ctx: any) {\r\n      if (v == null) return true;\r\n      if (typeof (v) !== \"string\") return false;\r\n      return v.length <= ctx.maxLength;\r\n    };\r\n    return new Validator(\"maxLength\", valFn, context);\r\n  };\r\n\r\n  /**\r\n  Returns a standard string length Validator; both minimum and maximum lengths must be specified.\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var custType = em1.metadataStore.getEntityType(\"Customer\");\r\n      var regionProperty - custType.getProperty(\"Region\");\r\n      // Validates that the value of the Region property on Customer will be\r\n      // between 2 and 5 characters\r\n      regionProperty.validators.push(Validator.stringLength( {minLength: 2, maxLength: 5});\r\n  @method stringLength\r\n  @static\r\n  @param context {Object}\r\n  @param context.maxLength {Integer}\r\n  @param context.minLength {Integer}\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static stringLength = function (context: any) {\r\n    let valFn = function (v: any, ctx: any) {\r\n      if (v == null) return true;\r\n      if (typeof (v) !== \"string\") return false;\r\n      if (ctx.minLength != null && v.length < ctx.minLength) return false;\r\n      if (ctx.maxLength != null && v.length > ctx.maxLength) return false;\r\n      return true;\r\n    };\r\n    return new Validator(\"stringLength\", valFn, context);\r\n  };\r\n\r\n  /**\r\n  Returns a standard string dataType Validator.\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var custType = em1.metadataStore.getEntityType(\"Customer\");\r\n      var regionProperty - custType.getProperty(\"Region\");\r\n      // Validates that the value of the Region property on Customer is a string.\r\n      regionProperty.validators.push(Validator.string());\r\n  @method string\r\n  @static\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static string = function () {\r\n    let valFn = function (v: any) {\r\n      if (v == null) return true;\r\n      return (typeof v === \"string\");\r\n    };\r\n    return new Validator(\"string\", valFn);\r\n  };\r\n\r\n  /**\r\n  Returns a Guid data type Validator.\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var custType = em1.metadataStore.getEntityType(\"Customer\");\r\n      var customerIdProperty - custType.getProperty(\"CustomerID\");\r\n      // Validates that the value of the CustomerID property on Customer is a Guid.\r\n      customerIdProperty.validators.push(Validator.guid());\r\n  @method guid\r\n  @static\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static guid = function () {\r\n    let valFn = function (v: any) {\r\n      if (v == null) return true;\r\n      return core.isGuid(v);\r\n    };\r\n    return new Validator(\"guid\", valFn);\r\n  };\r\n\r\n  /**\r\n  Returns a ISO 8601 duration string  Validator.\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var eventType = em1.metadataStore.getEntityType(\"Event\");\r\n      var elapsedTimeProperty - eventType.getProperty(\"ElapsedTime\");\r\n      // Validates that the value of the ElapsedTime property on Customer is a duration.\r\n      elapsedTimeProperty.validators.push(Validator.duration());\r\n  @method duration\r\n  @static\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static duration = function () {\r\n    let valFn = function (v: any) {\r\n      if (v == null) return true;\r\n      return core.isDuration(v);\r\n    };\r\n    return new Validator(\"duration\", valFn);\r\n  };\r\n\r\n  /**\r\n  Returns a standard numeric data type Validator.\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var orderType = em1.metadataStore.getEntityType(\"Order\");\r\n      var freightProperty - orderType.getProperty(\"Freight\");\r\n      // Validates that the value of the Freight property on Order is a number.\r\n      freightProperty.validators.push(Validator.number());\r\n  @method number\r\n  @static\r\n  @return {Validator} A new Validator\r\n  **/\r\n\r\n    // TODO: may need to have seperate logic for single.\r\n  public static number = function(context?: any) {\r\n    let valFn = function (v: any, ctx: any) {\r\n      if (v == null) return true;\r\n      if (typeof v === \"string\" && ctx && ctx.allowString) {\r\n        v = parseFloat(v);\r\n      }\r\n      return (typeof v === \"number\" && !isNaN(v));\r\n    };\r\n    return new Validator(\"number\", valFn, context);\r\n  };\r\n  public static double = Validator.number;\r\n  public static single = Validator.number;\r\n\r\n  /**\r\n  Returns a standard large integer data type - 64 bit - Validator.\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var orderType = em1.metadataStore.getEntityType(\"Order\");\r\n      var freightProperty - orderType.getProperty(\"Freight\");\r\n      // Validates that the value of the Freight property on Order is within the range of a 64 bit integer.\r\n      freightProperty.validators.push(Validator.int64());\r\n  @method int64\r\n  @static\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static integer = function(context: any) {\r\n    let valFn = function (v: any, ctx: any) {\r\n      if (v == null) return true;\r\n      if (typeof v === \"string\" && ctx && ctx.allowString) {\r\n        v = parseInt(v, 10);\r\n      }\r\n      return (typeof v === \"number\") && (!isNaN(v)) && Math.floor(v) === v;\r\n    };\r\n    return new Validator(\"integer\", valFn, context);\r\n  };\r\n  public static int64 = Validator.integer;\r\n\r\n  /**\r\n  Returns a standard 32 bit integer data type Validator.\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var orderType = em1.metadataStore.getEntityType(\"Order\");\r\n      var freightProperty - orderType.getProperty(\"Freight\");\r\n      freightProperty.validators.push(Validator.int32());\r\n  @method int32\r\n  @static\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static int32 = function(context: any) {\r\n    return intRangeValidatorCtor(\"int32\", INT32_MIN, INT32_MAX, context)();\r\n  };\r\n\r\n  /**\r\n  Returns a standard 16 bit integer data type Validator.\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var orderType = em1.metadataStore.getEntityType(\"Order\");\r\n      var freightProperty - orderType.getProperty(\"Freight\");\r\n      // Validates that the value of the Freight property on Order is within the range of a 16 bit integer.\r\n      freightProperty.validators.push(Validator.int16());\r\n  @method int16\r\n  @static\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static int16 = function(context: any) {\r\n    return intRangeValidatorCtor(\"int16\", INT16_MIN, INT16_MAX, context)();\r\n  };\r\n\r\n  /**\r\n  Returns a standard byte data type Validator. (This is a integer between 0 and 255 inclusive for js purposes).\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var orderType = em1.metadataStore.getEntityType(\"Order\");\r\n      var freightProperty - orderType.getProperty(\"Freight\");\r\n      // Validates that the value of the Freight property on Order is within the range of a 16 bit integer.\r\n      // Probably not a very good validation to place on the Freight property.\r\n      regionProperty.validators.push(Validator.byte());\r\n  @method byte\r\n  @static\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static byte = function(context: any) {\r\n    return intRangeValidatorCtor(\"byte\", BYTE_MIN, BYTE_MAX, context)();\r\n  };\r\n\r\n  /**\r\n  Returns a standard boolean data type Validator.\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var productType = em1.metadataStore.getEntityType(\"Product\");\r\n      var discontinuedProperty - productType.getProperty(\"Discontinued\");\r\n      // Validates that the value of the Discontinued property on Product is a boolean\r\n      discontinuedProperty.validators.push(Validator.bool());\r\n  @method bool\r\n  @static\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static bool = function() {\r\n    let valFn = function (v: any) {\r\n      if (v == null) return true;\r\n      return (v === true) || (v === false);\r\n    };\r\n    return new Validator(\"bool\", valFn);\r\n  };\r\n\r\n  public static none = function() {\r\n    let valFn = function (v: any) {\r\n      return true;\r\n    };\r\n    return new Validator(\"none\", valFn);\r\n  };\r\n\r\n  /**\r\n  Returns a standard date data type Validator.\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager.\r\n      var orderType = em1.metadataStore.getEntityType(\"Order\");\r\n      var orderDateProperty - orderType.getProperty(\"OrderDate\");\r\n      // Validates that the value of the OrderDate property on Order is a date\r\n      // Probably not a very good validation to place on the Freight property.\r\n      orderDateProperty.validators.push(Validator.date());\r\n  @method date\r\n  @static\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static date = function() {\r\n    let valFn = function (v: any) {\r\n      if (v == null) return true;\r\n      if (typeof v === \"string\") {\r\n        try {\r\n          return !isNaN(Date.parse(v));\r\n          // old code\r\n          // return __isDate(new Date(v));\r\n        } catch (e) {\r\n          return false;\r\n        }\r\n      } else {\r\n        return core.isDate(v);\r\n      }\r\n    };\r\n    return new Validator(\"date\", valFn);\r\n  };\r\n\r\n  /**\r\n  Returns a credit card number validator\r\n  Performs a luhn algorithm checksum test for plausability\r\n  catches simple mistakes; only service knows for sure\r\n  @example\r\n      // Assume em is a preexisting EntityManager.\r\n      var personType = em.metadataStore.getEntityType(\"Person\");\r\n      var creditCardProperty = personType.getProperty(\"creditCard\");\r\n      // Validates that the value of the Person.creditCard property is credit card.\r\n      creditCardProperty.validators.push(Validator.creditCard());\r\n  @method creditCard\r\n  @static\r\n  @param [context] {Object} optional parameters to pass through to validation constructor\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static creditCard = function(context?: any) {\r\n    function valFn(v: any) {\r\n      if (v == null || v === '') return true;\r\n      if (typeof (v) !== 'string') return false;\r\n      v = v.replace(/(\\-|\\s)/g, \"\"); // remove dashes and spaces\r\n      if (!v || /\\D/.test(v)) return false; // all digits, not empty\r\n      return luhn(v);\r\n    }\r\n    return new Validator('creditCard', valFn, context);\r\n  };\r\n\r\n\r\n  /**\r\n  Returns a regular expression validator; the expression must be specified\r\n  @example\r\n      // Add validator to a property. Assume em is a preexisting EntityManager.\r\n      var customerType = em.metadataStore.getEntityType(\"Customer\");\r\n      var regionProperty = customerType.getProperty(\"Region\");\r\n      // Validates that the value of Customer.Region is 2 char uppercase alpha.\r\n      regionProperty.validators.push(Validator.regularExpression( {expression: '^[A-Z]{2}$'} );\r\n  @method regularExpression\r\n  @static\r\n  @param context {Object}\r\n  @param context.expression {String} String form of the regular expression to apply\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static regularExpression = function(context?: any) {\r\n    function valFn(v: any, ctx: any) {\r\n      // do not invalidate if empty; use a separate required test\r\n      if (v == null || v === '') return true;\r\n      if (typeof (v) !== 'string') return false;\r\n      try {\r\n        let re = new RegExp(ctx.expression);\r\n        return re.test(v);\r\n      } catch (e) {\r\n        throw new Error('Missing or invalid expression parameter to regExp validator');\r\n      }\r\n    }\r\n    return new Validator('regularExpression', valFn, context);\r\n  };\r\n\r\n  /**\r\n  Returns the email address validator\r\n  @example\r\n      // Assume em is a preexisting EntityManager.\r\n      var personType = em.metadataStore.getEntityType(\"Person\");\r\n      var emailProperty = personType.getProperty(\"email\");\r\n      // Validates that the value of the Person.email property is an email address.\r\n      emailProperty.validators.push(Validator.emailAddress());\r\n  @method emailAddress\r\n  @static\r\n  @param [context] {Object} optional parameters to pass through to validation constructor\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static emailAddress = function(context?: any) {\r\n    // See https://github.com/srkirkland/DataAnnotationsExtensions/blob/master/DataAnnotationsExtensions/EmailAttribute.cs\r\n    let reEmailAddress = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?$/i;\r\n    return makeRegExpValidator('emailAddress', reEmailAddress, null, context);\r\n  };\r\n\r\n  /**\r\n  Returns the phone validator\r\n  Provides basic assertions on the format and will help to eliminate most nonsense input\r\n  Matches:\r\n  International dialing prefix: {{}, +, 0, 0000} (with or without a trailing break character, if not '+': [-/. ])\r\n  > ((\\+)|(0(\\d+)?[-/.\\s]))\r\n  Country code: {{}, 1, ..., 999} (with or without a trailing break character: [-/. ])\r\n  > [1-9]\\d{,2}[-/.\\s]?\r\n  Area code: {(0), ..., (000000), 0, ..., 000000} (with or without a trailing break character: [-/. ])\r\n  > ((\\(\\d{1,6}\\)|\\d{1,6})[-/.\\s]?)?\r\n  Local: {0, ...}+ (with or without a trailing break character: [-/. ])\r\n  > (\\d+[-/.\\s]?)+\\d+\r\n  @example\r\n      // Assume em is a preexisting EntityManager.\r\n      var customerType = em.metadataStore.getEntityType(\"Customer\");\r\n      var phoneProperty = customerType.getProperty(\"phone\");\r\n      // Validates that the value of the Customer.phone property is phone.\r\n      phoneProperty.validators.push(Validator.phone());\r\n  @method phone\r\n  @static\r\n  @param [context] {Object} optional parameters to pass through to validation constructor\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static phone = function (context?: any) {\r\n    // See https://github.com/srkirkland/DataAnnotationsExtensions/blob/master/DataAnnotationsExtensions/Expressions.cs\r\n    let rePhone = /^((\\+|(0(\\d+)?[-/.\\s]?))[1-9]\\d{0,2}[-/.\\s]?)?((\\(\\d{1,6}\\)|\\d{1,6})[-/.\\s]?)?(\\d+[-/.\\s]?)+\\d+$/;\r\n    return makeRegExpValidator('phone', rePhone, null, context);\r\n  };\r\n\r\n  /**\r\n  Returns the URL (protocol required) validator\r\n  @example\r\n      // Assume em is a preexisting EntityManager.\r\n      var personType = em.metadataStore.getEntityType(\"Person\");\r\n      var websiteProperty = personType.getProperty(\"website\");\r\n      // Validates that the value of the Person.website property is a URL.\r\n      websiteProperty.validators.push(Validator.url());\r\n  @method url\r\n  @static\r\n  @param [context] {Object} optional parameters to pass through to validation constructor\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static url = function (context?: any) {\r\n    //See https://github.com/srkirkland/DataAnnotationsExtensions/blob/master/DataAnnotationsExtensions/UrlAttribute.cs\r\n    let reUrlProtocolRequired = /^(https?|ftp):\\/\\/(((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-fA-F]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|([a-zA-Z][\\-a-zA-Z0-9]*)|((([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-fA-F]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-fA-F]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-fA-F]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-fA-F]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/;\r\n    return makeRegExpValidator('url', reUrlProtocolRequired, null, context);\r\n  };\r\n\r\n  /**\r\n  Creates a regular expression validator with a fixed expression.\r\n  Many of the stock validators are built with this factory method.\r\n  Their expressions are often derived from\r\n  https://github.com/srkirkland/DataAnnotationsExtensions/blob/master/DataAnnotationsExtensions\r\n  You can try many of them at http://dataannotationsextensions.org/\r\n  @example\r\n      // Make a zipcode validator\r\n      function zipValidator = Validator.makeRegExpValidator(\r\n      \"zipVal,\r\n      /^\\d{5}([\\-]\\d{4})?$/,\r\n      \"The %displayName% '%value%' is not a valid U.S. zipcode\");\r\n      // Register it.\r\n      Validator.register(zipValidator);\r\n      // Add it to a data property. Assume em is a preexisting EntityManager.\r\n      var custType = em.metadataStore.getEntityType(\"Customer\");\r\n      var zipProperty = custType.getProperty(\"PostalCode\");\r\n      zipProperty.validators.push(zipValidator);\r\n  @method makeRegExpValidator\r\n  @static\r\n  @param validatorName {String} name of this validator\r\n  @param expression {String | RegExp} regular expression to apply\r\n  @param [defaultMessage] {String} default message for failed validations\r\n  @param [context] {Object} optional parameters to pass through to validation constructor\r\n  @return {Validator} A new Validator\r\n  **/\r\n  public static makeRegExpValidator = makeRegExpValidator;\r\n\r\n}\r\nValidator.prototype._$typeName = \"Validator\";\r\n\r\n// register all validators\r\nError['x'] = core.objectForEach(Validator, function (key: string, value: any) {\r\n  if (typeof (value) !== \"function\") {\r\n    return;\r\n  }\r\n  if (key === \"fromJSON\" || key === \"register\" ||\r\n      key === \"registerFactory\" || key === \"makeRegExpValidator\") {\r\n    return;\r\n  }\r\n\r\n  config.registerFunction(value, \"Validator.\" + key);\r\n});\r\n\r\nfunction formatTemplate(template: string, vars: Object, ownPropertiesOnly: boolean = false) {\r\n  if (!vars) return template;\r\n  return template.replace(/%([^%]+)%/g, function (_, key) {\r\n    let valOrFn: any;\r\n    if (ownPropertiesOnly) {\r\n      valOrFn = vars.hasOwnProperty(key) ? vars[key] : '';\r\n    } else {\r\n      valOrFn = vars[key];\r\n    }\r\n    if (valOrFn != null) {\r\n      if (core.isFunction(valOrFn)) {\r\n        return valOrFn(vars);\r\n      } else {\r\n        return valOrFn;\r\n      }\r\n    } else {\r\n      return \"\";\r\n    }\r\n  });\r\n}\r\n\r\nfunction intRangeValidatorCtor(validatorName: string, minValue: number, maxValue: number, context: any) {\r\n  context = context || {};\r\n  if (minValue !== undefined) { context.min = minValue; }\r\n  if (maxValue !== undefined) { context.max = maxValue; }\r\n  let templateExists = context.messageTemplate || Validator.messageTemplates[validatorName];\r\n  if (!templateExists) {\r\n    Validator.messageTemplates[validatorName] = core.formatString(\"'%displayName%' must be an integer between the values of %1 and %2\",\r\n        minValue, maxValue);\r\n  }\r\n  return function () {\r\n    let valFn = function (v: any, ctx: any) {\r\n      if (v == null) return true;\r\n      if (typeof v === \"string\" && ctx && ctx.allowString) {\r\n        v = parseInt(v, 0);\r\n      }\r\n      if ((typeof v === \"number\") && (!isNaN(v)) && Math.floor(v) === v) {\r\n        if (minValue != null && v < minValue) {\r\n          return false;\r\n        }\r\n        if (maxValue != null && v > maxValue) {\r\n          return false;\r\n        }\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    return new Validator(validatorName, valFn, context);\r\n  };\r\n}\r\n\r\nexport function makeRegExpValidator(validatorName: string, expression: RegExp, defaultMessage?: string | null, context?: any) {\r\n  if (defaultMessage) {\r\n    Validator.messageTemplates[validatorName] = defaultMessage;\r\n  }\r\n  let re = (typeof (expression) === 'string') ? new RegExp(expression) : expression;\r\n  let valFn = function (v: any) {\r\n    // do not invalidate if empty; use a separate required test\r\n    if (v == null || v === '') return true;\r\n    if (typeof (v) !== 'string') return false;\r\n    return re.test(v);\r\n  };\r\n  return new Validator(validatorName, valFn, context);\r\n}\r\n\r\n// http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers#JavaScript\r\n\r\n// function luhn(a: string, b: number, c: number, d: number, e: number) {\r\n//   for (d = +a[b = a.length - 1], e = 0; b--; ) {\r\n//     c = +a[b], d += ++e % 2 ? 2 * c % 10 + (c > 4) : c;\r\n//   }\r\n//   return !(d % 10);\r\n// };\r\n\r\nlet  luhn = (function() {\r\n  let luhnArr = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];\r\n  return function(str: string) \t{\r\n    let counter = 0;\r\n    let incNum: number;\r\n    let odd = false;\r\n    let temp = String(str).replace(/[^\\d]/g, \"\");\r\n    if ( temp.length === 0) return false;\r\n    for (let i = temp.length - 1; i >= 0; --i)  {\r\n      incNum = parseInt(temp.charAt(i), 10);\r\n      counter += (odd = !odd) ? incNum : luhnArr[incNum];\r\n    }\r\n    return (counter % 10 === 0);\r\n  };\r\n})();\r\n\r\n/**\r\nA ValidationError is used to describe a failed validation.\r\n\r\n@class ValidationError\r\n**/\r\n\r\n/**\r\nConstructs a new ValidationError\r\n@method <ctor> ValidationError\r\n\r\n@param validator {Validator || null} The Validator used to create this error, if any.\r\n@param context { ContextObject || null} The Context object used in conjunction with the Validator to create this error.\r\n@param errorMessage { String} The actual error message\r\n@param [key] {String} An optional key used to define a key for this error. One will be created automatically if not provided here.\r\n**/\r\nexport class ValidationError {\r\n  validator?: Validator;\r\n  key: string;\r\n  context: any;\r\n  errorMessage: string;\r\n  property: any; // IProperty\r\n  propertyName: string;\r\n  isServerError: boolean;\r\n\r\n  constructor(validator: Validator | null, context: any, errorMessage: string, key?: string) {\r\n    // Error is with isInstanceOf(Validator)\r\n    assertParam(validator, \"validator\").isOptional().isInstanceOf(Validator).check();\r\n    assertParam(errorMessage, \"errorMessage\").isNonEmptyString().check();\r\n    assertParam(key, \"key\").isOptional().isNonEmptyString().check();\r\n    this.validator = validator || undefined;\r\n    context = context || {};\r\n    this.context = context;\r\n    this.errorMessage = errorMessage;\r\n\r\n    this.property = context.property;\r\n    this.propertyName = context.propertyName || (context.property && context.property.name);\r\n\r\n    if (key) {\r\n      this.key = key;\r\n    } else {\r\n      this.key = ValidationError.getKey(validator || errorMessage, this.propertyName);\r\n    }\r\n    this.isServerError = false;\r\n  }\r\n\r\n\r\n  /**\r\n  The Validator associated with this ValidationError.\r\n\r\n  __readOnly__\r\n  @property validator {Validator}\r\n  **/\r\n\r\n  /**\r\n  A 'context' object associated with this ValidationError.\r\n\r\n  __readOnly__\r\n  @property context {Object}\r\n  **/\r\n\r\n  /**\r\n  The DataProperty or NavigationProperty associated with this ValidationError.\r\n\r\n  __readOnly__\r\n  @property property {DataProperty|NavigationProperty}\r\n  **/\r\n\r\n  /**\r\n  The property name associated with this ValidationError. This will be a \"property path\" for any properties of a complex object.\r\n\r\n  __readOnly__\r\n  @property propertyName {String}\r\n  **/\r\n\r\n  /**\r\n  The error message associated with the ValidationError.\r\n\r\n  __readOnly__\r\n  @property errorMessage {string}\r\n  **/\r\n\r\n  /**\r\n  The key by which this validation error may be removed from a collection of ValidationErrors.\r\n\r\n  __readOnly__\r\n  @property key {string}\r\n  **/\r\n\r\n  /**\r\n  Whether this is a server error.\r\n\r\n  __readOnly__\r\n  @property isServerError {bool}\r\n  **/\r\n\r\n\r\n  /**\r\n  Composes a ValidationError 'key' given a validator or an errorName and an optional propertyName\r\n  @method getKey\r\n  @static\r\n  @param validator {ValidatorOrErrorKey} A Validator or an \"error name\" if no validator is available.\r\n  @param [propertyName] A property name\r\n  @return {String} A ValidationError 'key'\r\n  **/\r\n  public static getKey(validatorOrErrorName: Validator | string, propertyName?: string) {\r\n    let name = (typeof validatorOrErrorName === 'string') ? validatorOrErrorName : validatorOrErrorName.name;\r\n    return name + (propertyName ? \":\" + propertyName : \"\");\r\n  }\r\n\r\n}\r\n\r\n\r\n","import { core } from './core';\r\nimport { BreezeEnum } from './enum';\r\nimport { Validator } from './validate';\r\n\r\nlet _localTimeRegex = /.\\d{3}$/;\r\n\r\n/**  \r\nDataType is an 'Enum' containing all of the supported data types.\r\n@dynamic\r\n**/\r\nexport class DataType extends BreezeEnum {\r\n  /** The default value of this DataType. __Read Only__ **/\r\n  defaultValue?: any;\r\n  /** Whether this is a 'numeric' DataType. __Read Only__ **/\r\n  isNumeric?: boolean;\r\n  /** Whether this is an 'integer' DataType. __Read Only__ **/\r\n  isInteger?: boolean;\r\n  /** Whether to quote the json value when formatting this DataType for OData. */\r\n  quoteJsonOData?: boolean;\r\n  /** The constructor function to create a [[Validator]] to be used in validating instances of this DataType. */\r\n  validatorCtor?(context?: any): Validator;\r\n  /** \r\n  Optional function to normalize a data value for comparison, if its value cannot be used directly. \r\n  Note that this will be called each time a property is changed, so make it fast.\r\n  @return value appropriate for this DataType\r\n  **/\r\n  normalize?(value: any): any;\r\n  /**\r\n  Optional function to convert a raw (server) value from string to this DataType.\r\n  @return value appropriate for this DataType\r\n  **/\r\n  parseRawValue?(value: any): any;\r\n  /**\r\n  Optional function to convert a value from string to this DataType.  Note that this will be called each time a property is changed, so make it fast.\r\n  @return value appropriate for this DataType \r\n  **/\r\n  parse?(source: any, sourceTypeName: string): any;\r\n  /** \r\n  Optional function to format this DataType for OData queries.\r\n  @return value appropriate for OData query   \r\n  **/\r\n  fmtOData?(value: any): any;\r\n  /** \r\n  Optional function to get the next value for key generation, if this datatype is used as a key.  Uses an internal table of previous values.\r\n  @return value appropriate for this DataType \r\n  **/\r\n  getNext?(): any;\r\n  /**\r\n  Optional function to get the next value when the datatype is used as a concurrency property.\r\n  @param previousValue\r\n  @return the next concurrency value, which may be a function of the previousValue.\r\n  **/\r\n  getConcurrencyValue?(previousValue?: any): any;\r\n\r\n  static parseDateFromServer = (value: any) => DataType.parseDateAsUTC(value);\r\n  // same effect as above but doesn't give right TSDOC.\r\n  // static parseDateFromServer = DataType.parseDateAsUTC;\r\n\r\n  /** @hidden @internal */\r\n  static constants: { stringPrefix: string, nextNumber: number, nextNumberIncrement: number };\r\n\r\n  static String = new DataType({\r\n    defaultValue: \"\",\r\n    parse: coerceToString,\r\n    fmtOData: fmtString,\r\n    getNext: getNextString\r\n  });\r\n\r\n  static Int64 = new DataType({\r\n    defaultValue: 0,\r\n    isNumeric: true,\r\n    isInteger: true,\r\n    quoteJsonOData: true,\r\n    parse: coerceToInt,\r\n    fmtOData: makeFloatFmt(\"L\"),\r\n    getNext: getNextNumber\r\n  });\r\n\r\n  static Int32 = new DataType({\r\n    defaultValue: 0,\r\n    isNumeric: true,\r\n    isInteger: true,\r\n    parse: coerceToInt,\r\n    fmtOData: fmtInt,\r\n    getNext: getNextNumber\r\n  });\r\n\r\n  static Int16 = new DataType({\r\n    defaultValue: 0,\r\n    isNumeric: true,\r\n    isInteger: true,\r\n    parse: coerceToInt,\r\n    fmtOData: fmtInt,\r\n    getNext: getNextNumber\r\n  });\r\n\r\n  static Byte = new DataType({\r\n    defaultValue: 0,\r\n    isNumeric: true,\r\n    isInteger: true,\r\n    parse: coerceToInt,\r\n    fmtOData: fmtInt\r\n  });\r\n\r\n  static Decimal = new DataType({\r\n    defaultValue: 0,\r\n    isNumeric: true,\r\n    quoteJsonOData: true,\r\n    isFloat: true,\r\n    parse: coerceToFloat,\r\n    fmtOData: makeFloatFmt(\"m\"),\r\n    getNext: getNextNumber\r\n  });\r\n\r\n  static Double = new DataType({\r\n    defaultValue: 0,\r\n    isNumeric: true,\r\n    isFloat: true,\r\n    parse: coerceToFloat,\r\n    fmtOData: makeFloatFmt(\"d\"),\r\n    getNext: getNextNumber\r\n  });\r\n\r\n  static Single = new DataType({\r\n    defaultValue: 0,\r\n    isNumeric: true,\r\n    isFloat: true,\r\n    parse: coerceToFloat,\r\n    fmtOData: makeFloatFmt(\"f\"),\r\n    getNext: getNextNumber\r\n  });\r\n\r\n  static DateTime = new DataType({\r\n    defaultValue: new Date(1900, 0, 1),\r\n    isDate: true,\r\n    parse: coerceToDate,\r\n    parseRawValue: parseRawDate,\r\n    normalize: function (value: any) { return value && value.getTime && value.getTime(); }, // dates don't perform equality comparisons properly\r\n    fmtOData: fmtDateTime,\r\n    getNext: getNextDateTime,\r\n    getConcurrencyValue: getConcurrencyDateTime\r\n  });\r\n\r\n  static DateTimeOffset = new DataType({\r\n    defaultValue: new Date(1900, 0, 1),\r\n    isDate: true,\r\n    parse: coerceToDate,\r\n    parseRawValue: parseRawDate,\r\n    normalize: function (value: any) { return value && value.getTime && value.getTime(); }, // dates don't perform equality comparisons properly\r\n    fmtOData: fmtDateTimeOffset,\r\n    getNext: getNextDateTime,\r\n    getConcurrencyValue: getConcurrencyDateTime\r\n  });\r\n\r\n  static Time = new DataType({\r\n    defaultValue: \"PT0S\",\r\n    fmtOData: fmtTime,\r\n    parseRawValue: DataType.parseTimeFromServer\r\n  });\r\n\r\n  static Boolean = new DataType({\r\n    defaultValue: false,\r\n    parse: coerceToBool,\r\n    fmtOData: fmtBoolean\r\n  });\r\n\r\n  static Guid = new DataType({\r\n    defaultValue: \"00000000-0000-0000-0000-000000000000\",\r\n    parse: coerceToGuid,\r\n    fmtOData: fmtGuid,\r\n    getNext: getNextGuid,\r\n    parseRawValue: function (val: string) { return val.toLowerCase(); },\r\n    getConcurrencyValue: core.getUuid\r\n  });\r\n\r\n  static Binary = new DataType({\r\n    defaultValue: null,\r\n    fmtOData: fmtBinary,\r\n    parseRawValue: parseRawBinary\r\n  });\r\n\r\n  static Undefined = new DataType({\r\n    defaultValue: undefined,\r\n    fmtOData: fmtUndefined\r\n  });\r\n\r\n  static getComparableFn(dataType?: DataType) {\r\n    if (dataType && dataType.normalize) {\r\n      return dataType.normalize;\r\n    } else if (dataType === DataType.Time) {\r\n      // durations must be converted to compare them\r\n      return function (value: any) {\r\n        return value && core.durationToSeconds(value);\r\n      };\r\n    } else {\r\n      // TODO: __identity\r\n      return function (value: any) {\r\n        return value;\r\n      };\r\n    }\r\n  }\r\n\r\n  /** Returns the DataType for a specified EDM type name.\r\n  **/\r\n  static fromEdmDataType(typeName: string) {\r\n    let dt: DataType | undefined;\r\n    let parts = typeName.split(\".\");\r\n    if (parts.length > 1) {\r\n      let simpleName = parts[1];\r\n      if (simpleName === \"image\") {\r\n        // hack\r\n        dt = DataType.Byte;\r\n      } else if (parts.length === 2) {\r\n        dt = DataType.fromName(simpleName) || DataType.Undefined;\r\n      } else {\r\n        // enum\r\n        // dt = DataType.Int32;\r\n        dt = DataType.String;\r\n      }\r\n    }\r\n\r\n    return dt;\r\n  }\r\n\r\n  /** Returns the DataType for a specified input. */\r\n  static fromValue(val: any) {\r\n    if (core.isDate(val)) return DataType.DateTime;\r\n    switch (typeof val) {\r\n      case \"string\":\r\n        if (core.isGuid(val)) return DataType.Guid;\r\n        // the >3 below is a hack to insure that if we are inferring datatypes that\r\n        // very short strings that are valid but unlikely ISO encoded Time's are treated as strings instead.\r\n        else if (core.isDuration(val) && val.length > 3) return DataType.Time;\r\n        else if (core.isDateString(val)) return DataType.DateTime;\r\n        return DataType.String;\r\n      case \"boolean\":\r\n        return DataType.Boolean;\r\n      case \"number\":\r\n        return DataType.Double;\r\n    }\r\n    return DataType.Undefined;\r\n  }\r\n\r\n  static parseTimeFromServer(source: any) {\r\n    if (typeof source === 'string') {\r\n      return source;\r\n    }\r\n    // ODATA v3 format\r\n    if (source && source.__edmType === 'Edm.Time') {\r\n      let seconds = Math.floor(source.ms / 1000);\r\n      return 'PT' + seconds + 'S';\r\n    }\r\n    return source;\r\n  }\r\n\r\n  static parseDateAsUTC(source: any) {\r\n    if (typeof source === 'string') {\r\n      // convert to UTC string if no time zone specifier.\r\n      let isLocalTime = _localTimeRegex.test(source);\r\n      // var isLocalTime = !hasTimeZone(source);\r\n      source = isLocalTime ? source + 'Z' : source;\r\n    }\r\n    source = new Date(Date.parse(source));\r\n    return source;\r\n  }\r\n\r\n\r\n  /** Returns a raw value converted to the specified DataType */\r\n  static parseRawValue(val: any, dataType?: DataType) {\r\n    // undefined values will be the default for most unmapped properties EXCEPT when they are set\r\n    // in a jsonResultsAdapter ( an unusual use case).\r\n    if (val === undefined) return undefined;\r\n    if (!val) return val;\r\n    if (dataType && dataType.parseRawValue) {\r\n      val = dataType.parseRawValue(val);\r\n    }\r\n    return val;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  // used during initialization; visible on instance for testing purposes.\r\n  static _resetConstants() {\r\n    DataType.constants = {\r\n      stringPrefix: \"K_\",\r\n      nextNumber: -1,\r\n      nextNumberIncrement: -1\r\n    };\r\n  }\r\n\r\n  // NOT YET NEEDED --------------------------------------------------\r\n  // var _utcOffsetMs = (new Date()).getTimezoneOffset() * 60000;\r\n\r\n  //DataType.parseDateAsLocal = function (source) {\r\n  //    var dt = DataType.parseDatesAsUTC(source);\r\n  //    if (__isDate(dt)) {\r\n  //        dt = new Date(dt.getTime() + _utcOffsetMs);\r\n  //    }\r\n  //    return dt;\r\n  //};\r\n}\r\nDataType.prototype._$typeName = \"DataType\";\r\nError['x'] = DataType._resetConstants();\r\nError['x'] = DataType.resolveSymbols();\r\nError['x'] = DataType.getSymbols().forEach((sym: DataType) => sym.validatorCtor = getValidatorCtor(sym));\r\n\r\n// private functions;\r\n\r\n\r\nfunction getValidatorCtor(dataType: DataType) {\r\n  switch (dataType) {\r\n    case DataType.String:\r\n      return Validator.string;\r\n    case DataType.Int64:\r\n      return Validator.int64;\r\n    case DataType.Int32:\r\n      return Validator.int32;\r\n    case DataType.Int16:\r\n      return Validator.int16;\r\n    case DataType.Decimal:\r\n      return Validator.number;\r\n    case DataType.Double:\r\n      return Validator.number;\r\n    case DataType.Single:\r\n      return Validator.number;\r\n    case DataType.DateTime:\r\n      return Validator.date;\r\n    case DataType.DateTimeOffset:\r\n      return Validator.date;\r\n    case DataType.Boolean:\r\n      return Validator.bool;\r\n    case DataType.Guid:\r\n      return Validator.guid;\r\n    case DataType.Byte:\r\n      return Validator.byte;\r\n    case DataType.Binary:\r\n      // TODO: don't quite know how to validate this yet.\r\n      return Validator.none;\r\n    case DataType.Time:\r\n      return Validator.duration;\r\n    case DataType.Undefined:\r\n      return Validator.none;\r\n  }\r\n}\r\n\r\nfunction getNextString() {\r\n  return DataType.constants.stringPrefix + getNextNumber().toString();\r\n}\r\n\r\nfunction getNextNumber() {\r\n  let result = DataType.constants.nextNumber;\r\n  DataType.constants.nextNumber += DataType.constants.nextNumberIncrement;\r\n  return result;\r\n}\r\n\r\nfunction getNextGuid() {\r\n  return core.getUuid();\r\n}\r\n\r\nfunction getNextDateTime() {\r\n  return new Date();\r\n}\r\n\r\nfunction getConcurrencyDateTime(val: any) {\r\n  // use the current datetime but insure that it is different from previous call.\r\n  let dt = new Date();\r\n  let dt2 = new Date();\r\n  while (dt.getTime() === dt2.getTime()) {\r\n    dt2 = new Date();\r\n  }\r\n  return dt2;\r\n}\r\n\r\nfunction coerceToString(source: any, sourceTypeName?: string) {\r\n  return (source == null) ? source : source.toString();\r\n}\r\n\r\nfunction coerceToGuid(source: any, sourceTypeName: string) {\r\n  if (sourceTypeName === \"string\") {\r\n    return source.trim().toLowerCase();\r\n  }\r\n  return source;\r\n}\r\n\r\nfunction coerceToInt(source: any, sourceTypeName: string) {\r\n  if (sourceTypeName === \"string\") {\r\n    let src = source.trim();\r\n    if (src === \"\") return null;\r\n    let val = parseInt(src, 10);\r\n    return isNaN(val) ? source : val;\r\n  } else if (sourceTypeName === \"number\") {\r\n    return Math.round(source);\r\n  }\r\n  // do we want to coerce floats -> ints\r\n  return source;\r\n}\r\n\r\nfunction coerceToFloat(source: any, sourceTypeName: string) {\r\n  if (sourceTypeName === \"string\") {\r\n    let src = source.trim();\r\n    if (src === \"\") return null;\r\n    let val = parseFloat(src);\r\n    return isNaN(val) ? source : val;\r\n  }\r\n  return source;\r\n}\r\n\r\nfunction coerceToDate(source: any, sourceTypeName: string) {\r\n  let val: any;\r\n  if (sourceTypeName === \"string\") {\r\n    let src = source.trim();\r\n    if (src === \"\") return null;\r\n    val = new Date(Date.parse(src));\r\n    return core.isDate(val) ? val : source;\r\n  } else if (sourceTypeName === \"number\") {\r\n    val = new Date(source);\r\n    return core.isDate(val) ? val : source;\r\n  }\r\n  return source;\r\n}\r\n\r\nfunction coerceToBool(source: any, sourceTypeName: string) {\r\n  if (sourceTypeName === \"string\") {\r\n    let src = source.trim().toLowerCase();\r\n    if (src === \"false\" || src === \"\") {\r\n      return false;\r\n    } else if (src === \"true\") {\r\n      return true;\r\n    } else {\r\n      return source;\r\n    }\r\n  }\r\n  return source;\r\n}\r\n\r\nfunction fmtString(val: any) {\r\n  return val == null ? null : \"'\" + val.replace(/'/g, \"''\") + \"'\";\r\n}\r\n\r\nfunction fmtInt(val: any) {\r\n  return val == null ? null : ((typeof val === \"string\") ? parseInt(val, 10) : val);\r\n}\r\n\r\nfunction makeFloatFmt(fmtSuffix: string) {\r\n  return function (val: any) {\r\n    if (val == null) return null;\r\n    if (typeof val === \"string\") {\r\n      val = parseFloat(val);\r\n    }\r\n    return val + fmtSuffix;\r\n  };\r\n}\r\n\r\nfunction fmtDateTime(val: Date) {\r\n  if (val == null) return null;\r\n  try {\r\n    return \"datetime'\" + val.toISOString() + \"'\";\r\n  } catch (e) {\r\n    throwError(\"'%1' is not a valid dateTime\", val);\r\n  }\r\n}\r\n\r\nfunction fmtDateTimeOffset(val: Date) {\r\n  if (val == null) return null;\r\n  try {\r\n    return \"datetimeoffset'\" + val.toISOString() + \"'\";\r\n  } catch (e) {\r\n    throwError(\"'%1' is not a valid dateTime\", val);\r\n  }\r\n}\r\n\r\nfunction fmtTime(val: any) {\r\n  if (val == null) return null;\r\n  if (!core.isDuration(val)) {\r\n    throwError(\"'%1' is not a valid ISO 8601 duration\", val);\r\n  }\r\n  return \"time'\" + val + \"'\";\r\n}\r\n\r\nfunction fmtGuid(val: any) {\r\n  if (val == null) return null;\r\n  if (!core.isGuid(val)) {\r\n    throwError(\"'%1' is not a valid guid\", val);\r\n  }\r\n  return \"guid'\" + val + \"'\";\r\n}\r\n\r\nfunction fmtBoolean(val: any) {\r\n  if (val == null) return null;\r\n  if (typeof val === \"string\") {\r\n    return val.trim().toLowerCase() === \"true\";\r\n  } else {\r\n    return !!val;\r\n  }\r\n}\r\n\r\nfunction fmtBinary(val: any) {\r\n  if (val == null) return val;\r\n  return \"binary'\" + val + \"'\";\r\n}\r\n\r\n// TODO: use __identity instead;\r\nfunction fmtUndefined(val: any) {\r\n  return val;\r\n}\r\n\r\nfunction throwError(msg: string, val: any) {\r\n  msg = core.formatString(msg, val);\r\n  throw new Error(msg);\r\n}\r\n\r\nfunction parseRawDate(val: any) {\r\n  if (!core.isDate(val)) {\r\n    val = DataType.parseDateFromServer(val);\r\n  }\r\n  return val;\r\n}\r\n\r\nfunction parseRawBinary(val: any) {\r\n  if (val && val.$value !== undefined) {\r\n    val = val.$value; // this will be a byte[] encoded as a string\r\n  }\r\n  return val;\r\n}\r\n\r\n//function hasTimeZone(source) {\r\n//  var ix = source.indexOf(\"T\");\r\n//  var timePart = source.substring(ix+1);\r\n//  return  timePart.indexOf(\"-\") >= 0 || timePart.indexOf(\"+\") >= 0 || timePart.indexOf(\"Z\");\r\n//}\r\n\r\n\r\n","import { BreezeEnum } from './enum';\r\n\r\n/**\r\nEntityState is an 'Enum' containing all of the valid states for an 'Entity'.\r\n**/\r\nexport class EntityState extends BreezeEnum {\r\n\r\n  /** The 'Unchanged' state. **/\r\n  static Unchanged = new EntityState();\r\n  /**  The 'Added' state.  **/\r\n  static Added = new EntityState();\r\n  /**  The 'Modified' state.   **/\r\n  static Modified = new EntityState();\r\n  /**  The 'Deleted' state.  **/\r\n  static Deleted = new EntityState();\r\n  /**  The 'Detached' state.  **/\r\n  static Detached = new EntityState();\r\n\r\n  /**\r\n  Returns whether an entityState instance is EntityState.Unchanged.\r\n  >     var es = anEntity.entityAspect.entityState;\r\n  >     return es.isUnchanged();\r\n\r\n  is the same as\r\n  >     return es === EntityState.Unchanged;\r\n  **/\r\n  isUnchanged() {\r\n    return this === EntityState.Unchanged;\r\n  }\r\n\r\n  /**\r\n  Return whether an entityState instance is EntityState.Added.\r\n  \r\n  >     var es = anEntity.entityAspect.entityState;\r\n  >     return es.isAdded();\r\n\r\n  is the same as\r\n  >     return es === EntityState.Added;\r\n  **/\r\n  isAdded() {\r\n    return this === EntityState.Added;\r\n  }\r\n\r\n  /**\r\n  Returns whether an entityState instance is EntityState.Modified.\r\n  >     var es = anEntity.entityAspect.entityState;\r\n  >     return es.isModified();\r\n\r\n  is the same as\r\n  >     return es === EntityState.Modified;\r\n  **/\r\n  isModified() {\r\n    return this === EntityState.Modified;\r\n  }\r\n\r\n  /**\r\n  Returns whether an entityState instance is EntityState.Deleted.\r\n  >     var es = anEntity.entityAspect.entityState;\r\n  >     return es.isDeleted();\r\n\r\n  is the same as\r\n  \r\n  >     return es === EntityState.Deleted;\r\n  **/\r\n  isDeleted() {\r\n    return this === EntityState.Deleted;\r\n  }\r\n\r\n  /**\r\n  Returns whether an entityState instance is EntityState.Detached.\r\n  >     var es = anEntity.entityAspect.entityState;\r\n  >     return es.isDetached();\r\n\r\n  is the same as\r\n  >     return es === EntityState.Detached;\r\n  **/\r\n  isDetached() {\r\n    return this === EntityState.Detached;\r\n  }\r\n\r\n  /**\r\n  Returns whether an entityState instance is EntityState.Unchanged or EntityState.Modified.\r\n  >     var es = anEntity.entityAspect.entityState;\r\n  >     return es.isUnchangedOrModified();\r\n\r\n  is the same as\r\n  >     return es === EntityState.Unchanged || es === EntityState.Modified\r\n  **/\r\n  isUnchangedOrModified() {\r\n    return this === EntityState.Unchanged || this === EntityState.Modified;\r\n  }\r\n\r\n  /** Returns whether an entityState instance is EntityState.Added or EntityState.Modified or EntityState.Deleted.\r\n  >     var es = anEntity.entityAspect.entityState;\r\n  >     return es.isAddedModifiedOrDeleted();\r\n\r\n  is the same as\r\n  >     return es === EntityState.Added || es === EntityState.Modified || es === EntityState.Deleted\r\n  **/\r\n  isAddedModifiedOrDeleted() {\r\n    return this === EntityState.Added ||\r\n      this === EntityState.Modified ||\r\n      this === EntityState.Deleted;\r\n  }\r\n\r\n}\r\nEntityState.prototype._$typeName = \"EntityState\";\r\nError['x'] = EntityState.resolveSymbols();\r\n","import { BreezeEnum} from './enum';\r\n\r\n/** EntityAction is an 'Enum' containing all of the valid actions that can occur to an 'Entity'. \r\n \r\n*/\r\n\r\nexport class EntityAction extends BreezeEnum {\r\n\r\n  /** Entity was attached via an AttachEntity call. */\r\n  static Attach = new EntityAction( { _isAttach: true });\r\n  /**  Entity was attached as a result of a query. */\r\n  static AttachOnQuery = new EntityAction({ _isAttach: true});\r\n  /**  Entity was attached as a result of an import. */\r\n  static AttachOnImport = new EntityAction({ _isAttach: true});\r\n\r\n  /** Entity was detached */\r\n  static Detach = new EntityAction( { _isDetach: true });\r\n\r\n  /** Properties on the entity were merged as a result of a query. */\r\n  static MergeOnQuery = new EntityAction({ _isModification: true });\r\n  /** Properties on the entity were merged as a result of an import. */\r\n  static MergeOnImport = new EntityAction({ _isModification: true });\r\n  /** Properties on the entity were merged as a result of a save */\r\n  static MergeOnSave = new EntityAction({ _isModification: true });\r\n\r\n  /** A property on the entity was changed. */\r\n  static PropertyChange = new EntityAction({ _isModification: true});\r\n\r\n  /** The EntityState of the entity was changed. */\r\n  static EntityStateChange = new EntityAction();\r\n\r\n  /** AcceptChanges was called on the entity, or its entityState was set to Unmodified. */\r\n  static AcceptChanges = new EntityAction();\r\n  /** RejectChanges was called on the entity. */\r\n  static RejectChanges = new EntityAction({ _isModification: true});\r\n\r\n  /** The EntityManager was cleared.  All entities detached. */\r\n  static Clear = new EntityAction({ _isDetach: true});\r\n\r\n  /** @hidden @internal */\r\n  _isAttach?: boolean;\r\n  /** @hidden @internal */\r\n  _isDetach?: boolean;\r\n  /** @hidden @internal */\r\n  _isModification: boolean;\r\n  /** Is this an 'attach' operation? ( Attach, AttachOnQuery or AttachOnImport) */\r\n  isAttach() {\r\n    return !!this._isAttach;\r\n  }\r\n  /** Is this a 'detach' operation? ( Detach, Clear) */\r\n  isDetach() {\r\n    return !!this._isDetach;\r\n  }\r\n  /** Is this a 'modification' operation? ( PropertyChange, MergeOnQuery, MergeOnSave, MergeOnImport, RejectChanges) */\r\n  isModification() {\r\n    return !!this._isModification;\r\n  }\r\n}\r\nEntityAction.prototype._$typeName = \"EntityAction\";\r\nError['x'] = EntityAction.resolveSymbols();\r\n\r\n\r\n\r\n","import { core } from './core';\r\nimport { assertParam } from './assert-param';\r\nimport { EntityType, MetadataStore } from './entity-metadata';\r\nimport { DataType } from './data-type';\r\n\r\n/**\r\nAn EntityKey is an object that represents the unique identity of an entity.  EntityKey's are immutable.\r\n\r\n\r\n**/\r\nexport class EntityKey {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // actually placed on prototype\r\n  /** @hidden @internal */\r\n  static ENTITY_KEY_DELIMITER = \":::\";\r\n  /**  The 'EntityType' that this is a key for. __Read Only__ */\r\n  entityType: EntityType;\r\n  /**  An array of the values for this key. This will usually only have a single element, \r\n  unless the entity type has a multipart key. __Read Only__ */\r\n  values: any[];\r\n  /** @hidden @internal */\r\n  _keyInGroup: string;\r\n  /** @hidden @internal */\r\n  _subtypes: EntityType[];\r\n\r\n  /**\r\n  Constructs a new EntityKey.  Each entity within an EntityManager will have a unique EntityKey.\r\n  >     // assume em1 is an EntityManager containing a number of existing entities.\r\n  >     var empType = em1.metadataStore.getEntityType(\"Employee\");\r\n  >     var entityKey = new EntityKey(empType, 1);\r\n\r\n  EntityKey's may also be found by calling EntityAspect.getKey()\r\n  >     // assume employee1 is an existing Employee entity\r\n  >     var empKey = employee1.entityAspect.getKey();\r\n\r\n  Multipart keys are created by passing an array as the 'keyValues' parameter\r\n  >     var empTerrType = em1.metadataStore.getEntityType(\"EmployeeTerritory\");\r\n  >     var empTerrKey = new EntityKey(empTerrType, [ 1, 77]);\r\n  >     // The order of the properties in the 'keyValues' array must be the same as that\r\n  >     // returned by empTerrType.keyProperties\r\n  @param entityType - The [[EntityType]] of the entity.\r\n  @param keyValues - A single value or an array of values. \r\n  */\r\n  constructor(entityType: EntityType, keyValues: any) {\r\n    assertParam(entityType, \"entityType\").isInstanceOf(EntityType).check();\r\n    let subtypes = entityType.getSelfAndSubtypes();\r\n    if (subtypes.length > 1) {\r\n      this._subtypes = subtypes.filter(function (st) {\r\n        return st.isAbstract === false;\r\n      });\r\n    }\r\n\r\n    if (!Array.isArray(keyValues)) {\r\n      keyValues = [keyValues];\r\n    }\r\n\r\n    this.entityType = entityType;\r\n    entityType.keyProperties.forEach(function (kp, i) {\r\n      // insure that guid keys are comparable.\r\n      if (kp.dataType === DataType.Guid) {\r\n        keyValues[i] = keyValues[i] && keyValues[i].toLowerCase ? keyValues[i].toLowerCase() : keyValues[i];\r\n      }\r\n    });\r\n\r\n    this.values = keyValues;\r\n    this._keyInGroup = EntityKey.createKeyString(keyValues);\r\n\r\n  }\r\n\r\n\r\n  toJSON() {\r\n    return {\r\n      entityType: this.entityType.name,\r\n      values: this.values\r\n    };\r\n  }\r\n\r\n  static fromJSON(json: any, metadataStore: MetadataStore) {\r\n    let et = metadataStore._getStructuralType(json.entityType, true) as EntityType;\r\n    return new EntityKey(et, json.values);\r\n  }\r\n\r\n  /**\r\n  Used to compare EntityKeys are determine if they refer to the same Entity.\r\n  There is also an static version of 'equals' with the same functionality.\r\n  \r\n  >      // assume em1 is an EntityManager containing a number of existing entities.\r\n  >      var empType = em1.metadataStore.getEntityType(\"Employee\");\r\n  >      var empKey1 = new EntityKey(empType, 1);\r\n  >      // assume employee1 is an existing Employee entity\r\n  >      var empKey2 = employee1.entityAspect.getKey();\r\n  >      if (empKey1.equals(empKey2)) {\r\n  >          // do something  ...\r\n  >      }\r\n  **/\r\n  equals(entityKey: EntityKey): boolean {\r\n    if (!(entityKey instanceof EntityKey)) return false;\r\n    return (this.entityType === entityKey.entityType) &&\r\n      core.arrayEquals(this.values, entityKey.values);\r\n  }\r\n\r\n  /*\r\n  Returns a human readable representation of this EntityKey.\r\n  */\r\n  toString(altEntityType?: EntityType) {\r\n    return (altEntityType || this.entityType).name + '-' + this._keyInGroup;\r\n  }\r\n\r\n  /**\r\n  Used to compare EntityKeys are determine if they refer to the same Entity.\r\n  There is also an instance version of 'equals' with the same functionality.\r\n  >      // assume em1 is an EntityManager containing a number of existing entities.\r\n  >      var empType = em1.metadataStore.getEntityType(\"Employee\");\r\n  >      var empKey1 = new EntityKey(empType, 1);\r\n  >      // assume employee1 is an existing Employee entity\r\n  >      var empKey2 = employee1.entityAspect.getKey();\r\n  >      if (EntityKey.equals(empKey1, empKey2)) {\r\n  >          // do something  ...\r\n  >      }\r\n  **/\r\n  static equals(k1: EntityKey, k2: EntityKey) {\r\n    if (!(k1 instanceof EntityKey)) return false;\r\n    return k1.equals(k2);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  // TODO: we may want to compare to default values later.\r\n  _isEmpty() {\r\n    return this.values.join(\"\").length === 0;\r\n  }\r\n\r\n  /** hidden */\r\n  // TODO: think about giving _ prefix or documenting.\r\n  static createKeyString(keyValues: any[]) {\r\n    return keyValues.join(EntityKey.ENTITY_KEY_DELIMITER);\r\n  }\r\n\r\n}\r\nEntityKey.prototype._$typeName = \"EntityKey\";\r\n\r\n\r\n","import { core } from './core';\r\nimport { BreezeEnum } from './enum';\r\nimport { assertConfig } from './assert-param';\r\n\r\n/**\r\nMergeStrategy is an 'Enum' that determines how entities are merged into an EntityManager.\r\n\r\n@class MergeStrategy\r\n@static\r\n**/\r\nexport class MergeStrategy extends BreezeEnum {\r\n\r\n  /**\r\n  MergeStrategy.PreserveChanges updates the cached entity with the incoming values unless the cached entity is in a changed\r\n  state (added, modified, deleted) in which case the incoming values are ignored. The updated cached entityâs EntityState will\r\n  remain [[EntityState.Unchanged]] unless youâre importing entities in which case the new EntityState will\r\n  be that of the imported entities.\r\n  **/\r\n  static PreserveChanges = new MergeStrategy();\r\n  /**\r\n  MergeStrategy.OverwriteChanges always updates the cached entity with incoming values even if the entity is in\r\n  a changed state (added, modified, deleted). After the merge, the pending changes are lost.\r\n  The new EntityState will be  [[EntityState/Unchanged]] unless youâre importing entities\r\n  in which case the new EntityState will be that of the imported entities.\r\n  **/\r\n  static OverwriteChanges = new MergeStrategy();\r\n\r\n  /**\r\n  SkipMerge is used to ignore incoming values. Adds the incoming entity to the cache only if there is no cached entity with the same key.\r\n  This is the fastest merge strategy but your existing cached data will remain âstaleâ.\r\n  **/\r\n  static SkipMerge = new MergeStrategy();\r\n\r\n  /**\r\n  Disallowed is used to throw an exception if there is an incoming entity with the same key as an entity already in the cache.\r\n  Use this strategy when you want to be sure that the incoming entity is not already in cache.\r\n  This is the default strategy for EntityManager.attachEntity.\r\n  **/\r\n  static Disallowed = new MergeStrategy();\r\n\r\n\r\n}\r\nMergeStrategy.prototype._$typeName = \"MergeStrategy\";\r\nError['x'] = MergeStrategy.resolveSymbols();\r\n\r\n/**\r\nFetchStrategy is an 'Enum' that determines how and where entities are retrieved from as a result of a query.\r\n**/\r\nexport class FetchStrategy extends BreezeEnum {\r\n\r\n  /**\r\n  FromServer is used to tell the query to execute the query against a remote data source on the server.\r\n  **/\r\n  static FromServer = new FetchStrategy();\r\n  /**\r\n  FromLocalCache is used to tell the query to execute the query against a local EntityManager instead of going to a remote server.\r\n  **/\r\n  static FromLocalCache = new FetchStrategy();\r\n\r\n}\r\nFetchStrategy.prototype._$typeName = \"FetchStrategy\";\r\nError['x'] = FetchStrategy.resolveSymbols();\r\n\r\n/** Configuration info to be passed to the [[QueryOptions]] constructor. */\r\nexport interface QueryOptionsConfig {\r\n  /** The [[FetchStrategy]] to use with any queries.*/\r\n  fetchStrategy?: FetchStrategy;\r\n  /** The [[MergeStrategy]] to use with any queries.*/\r\n  mergeStrategy?: MergeStrategy;\r\n  /** Whether to include cached deleted entities in a query result (false by default). __Read Only__ */\r\n  includeDeleted?: boolean;\r\n}\r\n\r\n/**\r\nA QueryOptions instance is used to specify the 'options' under which a query will occur.\r\n**/\r\nexport class QueryOptions {\r\n  /** @hidden @internal */\r\n  _$typeName: string;\r\n  /** The [[FetchStrategy]] to use with any queries. __Read Only__ */\r\n  fetchStrategy: FetchStrategy;\r\n  /** The [[MergeStrategy]] to use with any queries. __Read Only__ */\r\n  mergeStrategy: MergeStrategy;\r\n  /** Whether to include cached deleted entities in a query result (false by default). __Read Only__ */\r\n  includeDeleted: boolean;\r\n\r\n  /**\r\n  The default instance for use whenever QueryOptions are not specified.\r\n  **/\r\n  static defaultInstance = new QueryOptions({\r\n    fetchStrategy: FetchStrategy.FromServer,\r\n    mergeStrategy: MergeStrategy.PreserveChanges,\r\n    includeDeleted: false\r\n  });\r\n\r\n  /**\r\n  QueryOptions constructor\r\n  >     var newQo = new QueryOptions( { mergeStrategy: MergeStrategy.OverwriteChanges });\r\n  >     // assume em1 is a preexisting EntityManager\r\n  >     em1.setProperties( { queryOptions: newQo });\r\n  Any QueryOptions property that is not defined will be defaulted from any QueryOptions defined at a higher level in the breeze hierarchy, i.e.\r\n  -  from query.queryOptions\r\n  -  to   entityManager.queryOptions\r\n  -  to   QueryOptions.defaultInstance;\r\n\r\n  @param config - A configuration object.\r\n  **/\r\n  constructor(config?: QueryOptionsConfig) {\r\n    QueryOptions._updateWithConfig(this, config);\r\n  }\r\n\r\n  static resolve(queryOptionsArray: any[]) {\r\n    return new QueryOptions(core.resolveProperties(queryOptionsArray, [\"fetchStrategy\", \"mergeStrategy\", \"includeDeleted\"]));\r\n  }\r\n\r\n  /**\r\n  Returns a copy of this QueryOptions with the specified [[MergeStrategy]],\r\n  [[FetchStrategy]], or 'includeDeleted' option applied.\r\n  >     // Given an EntityManager instance, em\r\n  >     var queryOptions = em.queryOptions.using(MergeStrategy.PreserveChanges);\r\n\r\n  or\r\n  >     var queryOptions = em.queryOptions.using(FetchStrategy.FromLocalCache);\r\n\r\n  or\r\n  >     var queryOptions = em.queryOptions.using({ mergeStrategy: MergeStrategy.OverwriteChanges });\r\n\r\n  or\r\n  >     var queryOptions = em.queryOptions.using({\r\n  >        includeDeleted: true,\r\n  >        fetchStrategy:  FetchStrategy.FromLocalCache \r\n  >     });\r\n  @param config - A configuration object or a standalone [[MergeStrategy]] or [[FetchStrategy]] \r\n  @return A new QueryOptions instance.\r\n  **/\r\n  using(qoConfig: QueryOptionsConfig | MergeStrategy | FetchStrategy) {\r\n    if (!qoConfig) return this;\r\n    let result = new QueryOptions(this);\r\n    if ( qoConfig instanceof MergeStrategy) {\r\n      qoConfig = { mergeStrategy: qoConfig };\r\n    } else if ( qoConfig instanceof FetchStrategy) {\r\n      qoConfig = { fetchStrategy: qoConfig };\r\n    }\r\n    return QueryOptions._updateWithConfig(result, qoConfig);\r\n  }\r\n\r\n  /**\r\n  Sets the 'defaultInstance' by creating a copy of the current 'defaultInstance' and then applying all of the properties of the current instance.\r\n  The current instance is returned unchanged.\r\n  >     var newQo = new QueryOptions( { mergeStrategy: MergeStrategy.OverwriteChanges });\r\n  >     newQo.setAsDefault();\r\n  **/\r\n  setAsDefault() {\r\n    return core.setAsDefault(this, QueryOptions);\r\n  }\r\n\r\n  toJSON() {\r\n    return core.toJson(this, {\r\n      fetchStrategy: null,\r\n      mergeStrategy: null,\r\n      includeDeleted: false\r\n    });\r\n  }\r\n\r\n  static fromJSON(json: any) {\r\n    return new QueryOptions({\r\n      fetchStrategy: FetchStrategy.fromName(json.fetchStrategy),\r\n      mergeStrategy: MergeStrategy.fromName(json.mergeStrategy),\r\n      includeDeleted: json.includeDeleted === true\r\n    });\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  private static _updateWithConfig(obj: QueryOptions, config?: QueryOptionsConfig) {\r\n    if (config) {\r\n      assertConfig(config)\r\n        .whereParam(\"fetchStrategy\").isEnumOf(FetchStrategy).isOptional()\r\n        .whereParam(\"mergeStrategy\").isEnumOf(MergeStrategy).isOptional()\r\n        .whereParam(\"includeDeleted\").isBoolean().isOptional()\r\n        .applyAll(obj);\r\n    }\r\n    return obj;\r\n  }\r\n\r\n}\r\nQueryOptions.prototype._$typeName = \"QueryOptions\";\r\n","import { core } from './core';\r\nimport { EntityType, StructuralType, DataProperty  } from './entity-metadata';\r\nimport { QueryOp } from './entity-query';\r\nimport { DataType  } from './data-type';\r\nimport { EntityAspect, Entity } from './entity-aspect';\r\nimport { LocalQueryComparisonOptions } from './local-query-comparison-options';\r\n\r\nexport interface Op {\r\n  key: string;\r\n  aliases?: string[];\r\n  isFunction?: boolean;\r\n}\r\n\r\n/** @hidden @internal */\r\nexport interface OpMap {\r\n  [key: string]: Op;\r\n}\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden \r\n*/\r\nexport interface Visitor {\r\n\r\n}\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden \r\n*/\r\nexport interface VisitContext {\r\n  entityType?: EntityType;\r\n  // usesNameOnServer?: boolean;\r\n  toNameOnServer?: boolean;\r\n  useExplicitDataType?: boolean;\r\n  visitor?: Visitor;\r\n}\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden \r\n*/\r\nexport interface ExpressionContext {\r\n  entityType?: EntityType;\r\n  usesNameOnServer?: boolean;\r\n  dataType?: DataType | string;\r\n  isRHS?: boolean;\r\n  isFnArg?: boolean;\r\n}\r\n\r\n/**\r\nUsed to define a 'where' predicate for an [[EntityQuery]].  Predicates are immutable, which means that any\r\nmethod that would modify a Predicate actually returns a new Predicate.\r\n**/\r\nexport class Predicate {\r\n  op: Op;\r\n  /** @hidden @internal */\r\n  _entityType?: EntityType;\r\n  /** @hidden @internal */\r\n  aliasMap: OpMap;\r\n  visitorMethodName: string;\r\n\r\n\r\n  /**\r\n  Predicate constructor\r\n  >     let p1 = new Predicate(\"CompanyName\", \"StartsWith\", \"B\");\r\n  >     let query = new EntityQuery(\"Customers\").where(p1);\r\n\r\n  or\r\n  >     let p2 = new Predicate(\"Region\", FilterQueryOp.Equals, null);\r\n  >     let query = new EntityQuery(\"Customers\").where(p2);\r\n  @param property - A property name, a nested property name or an expression involving a property name.\r\n  @param operator - \r\n  @param value - This will be treated as either a property expression or a literal depending on context.  In general,\r\n  if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal.\r\n  In most cases this works well, but you can also force the interpretation by making the value argument itself an object with a 'value'\r\n  property and an 'isLiteral' property set to either true or false.  Breeze also tries to infer the dataType of any\r\n  literal based on context, if this fails you can force this inference by making the value argument an object with a\r\n  'value' property and a 'dataType' property set to one of the breeze.DataType enumeration instances.\r\n  **/\r\n  constructor(...args: any[]) {\r\n    if (args.length === 0) return;\r\n    if (!(this instanceof Predicate)) {\r\n      return new Predicate(...<any>args);\r\n    }\r\n    return Predicate.create(...<any>args);\r\n  }\r\n\r\n  /**\r\n  Same as using the ctor.\r\n  >      // so \r\n  >      let p = Predicate.create(a, b, c);\r\n  >      // is the same as \r\n  >      let p = new Predicate(a, b, c); \r\n  @param property -  A property name, a nested property name or an expression involving a property name.\r\n  @param operator - the filter query operator.\r\n  @param value - This will be treated as either a property expression or a literal depending on context.  In general,\r\n  if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal.\r\n  In most cases this works well, but you can also force the interpretation by making the value argument itself an object with a 'value'\r\n  property and an 'isLiteral' property set to either true or false.  Breeze also tries to infer the dataType of any\r\n  literal based on context, if this fails you can force this inference by making the value argument an object with a\r\n  'value' property and a 'dataType' property set to one of the breeze.DataType enumeration instances.\r\n  **/\r\n  static create(...args: any[]) {\r\n    // can be called from std javascript without new ( legacy )\r\n\r\n    // empty ctor is used by all subclasses.\r\n    if (args.length === 0) return new Predicate();\r\n    if (args.length === 1) {\r\n      // possibilities:\r\n      //      Predicate([ aPredicate ]) or  Predicate([\"freight\", \">\", 100]) - an array\r\n      //      Predicate(aPredicate) - a predicate\r\n      //      Predicate( \"freight gt 100\" }  // passthru ( i.e. maybe an odata string) - a string\r\n      //      Predicate( { freight: { \">\": 100 } }) - an object\r\n      let arg = arguments[0];\r\n      if (Array.isArray(arg)) {\r\n        if (arg.length === 1) {\r\n          // recurse\r\n          return new Predicate(arg[0]);\r\n        } else {\r\n          return createPredicateFromArray(arg);\r\n        }\r\n      } else if (arg instanceof Predicate) {\r\n        return arg;\r\n      } else if (typeof arg === 'string') {\r\n        return new PassthruPredicate(arg);\r\n      } else {\r\n        return createPredicateFromObject(arg);\r\n      }\r\n    } else {\r\n      // 2 possibilities\r\n      //      Predicate(\"freight\", \">\", 100\");\r\n      //      Predicate(\"orders\", \"any\", \"freight\",  \">\", 950);\r\n      return createPredicateFromArray(args);\r\n    }\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _validate(entityType: EntityType | undefined, usesNameOnServer?: boolean) {\r\n    // noop here;\r\n  }\r\n\r\n  /**\r\n  Creates a 'composite' Predicate by 'and'ing a set of specified Predicates together.\r\n  >      let dt = new Date(88, 9, 12);\r\n  >      let p1 = Predicate.create(\"OrderDate\", \"ne\", dt);\r\n  >      let p2 = Predicate.create(\"ShipCity\", \"startsWith\", \"C\");\r\n  >      let p3 = Predicate.create(\"Freight\", \">\", 100);\r\n  >      let newPred = Predicate.and(p1, p2, p3);\r\n\r\n  or\r\n  >      let preds = [p1, p2, p3];\r\n  >      let newPred = Predicate.and(preds);\r\n  @param predicates - multiple Predicates or an array of Predicate. \r\n  Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.\r\n  **/\r\n  static and(...args: any[]) {\r\n    let pred = new AndOrPredicate(\"and\", args);\r\n    // TODO removed below\r\n    // return undefined if empty\r\n    // return pred.op && pred;\r\n    return pred;\r\n  }\r\n\r\n  /**\r\n  Creates a 'composite' Predicate by 'or'ing a set of specified Predicates together.\r\n  >      let dt = new Date(88, 9, 12);\r\n  >      let p1 = Predicate.create(\"OrderDate\", \"ne\", dt);\r\n  >      let p2 = Predicate.create(\"ShipCity\", \"startsWith\", \"C\");\r\n  >      let p3 = Predicate.create(\"Freight\", \">\", 100);\r\n  >      let newPred = Predicate.or(p1, p2, p3);\r\n\r\n  or\r\n  >      let preds = [p1, p2, p3];\r\n  >      let newPred = Predicate.or(preds);\r\n  @param predicates - multiple Predicates or an array of Predicate.\r\n  Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.\r\n  **/\r\n  static or(...args: any[]) {\r\n    let pred = new AndOrPredicate(\"or\", args);\r\n    // return pred.op && pred;\r\n    return pred;\r\n  }\r\n\r\n  /**\r\n  Creates a 'composite' Predicate by 'negating' a specified predicate.\r\n  >      let p1 = Predicate.create(\"Freight\", \"gt\", 100);\r\n  >      let not_p1 = Predicate.not(p1);\r\n\r\n  This can also be accomplished using the 'instance' version of the 'not' method\r\n  >      let not_p1 = p1.not();\r\n\r\n  Both of which would be the same as\r\n  >      let not_p1 = Predicate.create(\"Freight\", \"le\", 100);\r\n  **/\r\n  static not(pred: Predicate) {\r\n    return pred.not();\r\n  }\r\n\r\n  // TODO: determine if/where this is used.\r\n  // static extendBinaryPredicateFn(opMap: IOpMap, visitorFn: any) {\r\n  //   let baseVisitorFn = toFunctionVisitor.binaryPredicate;\r\n  //   for (let op in (opMap || {})) {\r\n  //     let config = opMap[op];\r\n  //     config.visitorFn = visitorFn;\r\n  //     updateAliasMap(BinaryPredicate.prototype.aliasMap, op, opMap[op]);\r\n  //   }\r\n  //   if (!toFunctionVisitor.isExtended) {\r\n  //     toFunctionVisitor.binaryPredicate = function (context, expr1Val, expr2Val) {\r\n  //       let visitorFn = this.aliasMap[this.op.key].visitorFn;\r\n  //       if (visitorFn) {\r\n  //         return visitorFn(context, expr1Val, expr2Val);\r\n  //       } else {\r\n  //         return baseVisitorFn(context, expr1Val, expr2Val);\r\n  //       }\r\n  //     };\r\n  //     toFunctionVisitor.isExtended = true;\r\n  //   }\r\n  // };\r\n\r\n\r\n  /**\r\n  'And's this Predicate with one or more other Predicates and returns a new 'composite' Predicate\r\n  >      let dt = new Date(88, 9, 12);\r\n  >      let p1 = Predicate.create(\"OrderDate\", \"ne\", dt);\r\n  >      let p2 = Predicate.create(\"ShipCity\", \"startsWith\", \"C\");\r\n  >      let p3 = Predicate.create(\"Freight\", \">\", 100);\r\n  >      let newPred = p1.and(p2, p3);\r\n\r\n  or\r\n  >      let preds = [p2, p3];\r\n  >      let newPred = p1.and(preds);\r\n\r\n  The 'and' method is also used to write \"fluent\" expressions\r\n  >      let p4 = Predicate.create(\"ShipCity\", \"startswith\", \"F\")\r\n  >        .and(\"Size\", \"gt\", 2000);\r\n  @param predicates - multiple Predicates or an array of Predicates. \r\n  Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.\r\n  **/\r\n  and(...args: any[]) {\r\n    return new AndOrPredicate(\"and\", argsForAndOrPredicates(this, args));\r\n  }\r\n\r\n  /**\r\n  'Or's this Predicate with one or more other Predicates and returns a new 'composite' Predicate\r\n  >      let dt = new Date(88, 9, 12);\r\n  >      let p1 = Predicate.create(\"OrderDate\", \"ne\", dt);\r\n  >      let p2 = Predicate.create(\"ShipCity\", \"startsWith\", \"C\");\r\n  >      let p3 = Predicate.create(\"Freight\", \">\", 100);\r\n  >      let newPred = p1.or(p2, p3);\r\n\r\n  or\r\n  >      let preds = [p2, p3];\r\n  >      let newPred = p1.or(preds);\r\n\r\n  The 'or' method is also used to write \"fluent\" expressions\r\n  >      let p4 = Predicate.create(\"ShipCity\", \"startswith\", \"F\")\r\n  >        .or(\"Size\", \"gt\", 2000);\r\n  @param predicates - multiple Predicates or an array of Predicates. \r\n  Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.\r\n  **/\r\n  or(...args: any[]) {\r\n    return new AndOrPredicate(\"or\", argsForAndOrPredicates(this, args));\r\n  }\r\n\r\n  /**\r\n  Returns the 'negated' version of this Predicate\r\n  >      let p1 = Predicate.create(\"Freight\", \"gt\", 100);\r\n  >      let not_p1 = p1.not();\r\n\r\n  This can also be accomplished using the 'static' version of the 'not' method\r\n  >      let p1 = Predicate.create(\"Freight\", \"gt\", 100);\r\n  >      let not_p1 = Predicate.not(p1);\r\n\r\n  which would be the same as\r\n  >      let not_p1 = Predicate.create(\"Freight\", \"le\", 100);\r\n  **/\r\n  not() {\r\n    return new UnaryPredicate(\"not\", this);\r\n  }\r\n\r\n  //\r\n  toJSON() {\r\n    // toJSON ( part of js standard - takes a single parameter\r\n    // that is either \"\" or the name of the property being serialized.\r\n    return this.toJSONExt({ entityType: this._entityType });\r\n  }\r\n\r\n  /** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n  @adapter (see [[IUriBuilderAdapter]])    \r\n  @hidden @internal \r\n  */\r\n  toJSONExt(context: VisitContext) {\r\n    return this.visit(context, toJSONVisitor);\r\n  }\r\n\r\n  /** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n  @adapter (see [[IUriBuilderAdapter]])    \r\n  @hidden @internal \r\n  */\r\n  toFunction(context: VisitContext) {\r\n    return this.visit(context, toFunctionVisitor);\r\n  }\r\n\r\n  toString() {\r\n    return JSON.stringify(this);\r\n  }\r\n\r\n  /** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n  @adapter (see [[IUriBuilderAdapter]])    \r\n  @hidden @internal \r\n  */\r\n  visit(context: VisitContext, visitor?: Visitor) {\r\n    if (core.isEmpty(context)) {\r\n      context = { entityType: undefined };\r\n    } else if (context instanceof EntityType) {\r\n      context = { entityType: context };\r\n    } else if (!core.hasOwnProperty(context, \"entityType\")) {\r\n      throw new Error(\"All visitor methods must be called with a context object containing at least an 'entityType' property\");\r\n    }\r\n\r\n    if (visitor) {\r\n      context.visitor = visitor;\r\n    }\r\n    let tVisitor = visitor || context.visitor!;\r\n    let fn = tVisitor[this.visitorMethodName];\r\n    if (fn == null) {\r\n      throw new Error(\"Unable to locate method: \" + this.visitorMethodName + \" on visitor\");\r\n    }\r\n\r\n    let entityType = context.entityType;\r\n    // don't bother validating if already done so ( or if no _validate method\r\n    if (this._validate && (entityType == null || this._entityType !== entityType)) {\r\n      // don't need to capture return value because validation fn doesn't have one.\r\n      // TODO: this was old code\r\n      // this._validate(entityType, context.usesNameOnServer);\r\n      this._validate(entityType, context.toNameOnServer);\r\n      this._entityType = entityType;\r\n    }\r\n\r\n    return fn.call(this, context);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _initialize(visitorMethodName: string, opMap: { [key: string]: { aliases?: string[], isFunction?: boolean }} = {}) {\r\n    this.visitorMethodName = visitorMethodName;\r\n    let aliasMap = this.aliasMap = {};\r\n    for (let op in opMap ) {\r\n      updateAliasMap(aliasMap, op, opMap[op] as Op);\r\n    }\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _resolveOp(op: string | QueryOp, okIfNotFound?: boolean) {\r\n    let opStr = (typeof op === \"string\") ? op : op.operator;\r\n    let result = this.aliasMap[opStr.toLowerCase()];\r\n    if (!result && !okIfNotFound) {\r\n      throw new Error(\"Unable to resolve operator: \" + opStr);\r\n    }\r\n    return result;\r\n  }\r\n\r\n}\r\n\r\nfunction createPredicateFromArray(arr: any[]) {\r\n  // TODO: assert that length of the array should be > 3\r\n  // Needs to handle:\r\n  //      [ \"freight\", \">\", 100\"];\r\n  //      [ \"orders\", \"any\", \"freight\",  \">\", 950 ]\r\n  //      [ \"orders\", \"and\", anotherPred ]\r\n  //      [ \"orders\", \"and\", [ \"freight, \">\", 950 ]]\r\n  let json = {};\r\n  let value = {};\r\n  json[arr[0]] = value;\r\n  let op = arr[1];\r\n  op = op.operator || op;  // incoming op will be either a string or a FilterQueryOp\r\n  if (arr.length === 3) {\r\n    value[op] = arr[2];\r\n  } else {\r\n    value[op] = createPredicateFromArray(arr.splice(2));\r\n  }\r\n  return createPredicateFromObject(json);\r\n}\r\n\r\nfunction createPredicateFromObject(obj: Object) {\r\n  if (obj instanceof Predicate) return obj;\r\n\r\n  if (typeof obj !== 'object') {\r\n    throw new Error(\"Unable to convert to a Predicate: \" + obj);\r\n  }\r\n  let keys = Object.keys(obj);\r\n  let preds = keys.map(function (key) {\r\n    return createPredicateFromKeyValue(key, obj[key]);\r\n  });\r\n  return (preds.length === 1) ? preds[0] : new AndOrPredicate(\"and\", preds);\r\n}\r\n\r\nfunction createPredicateFromKeyValue(key: string, value: any): Predicate {\r\n  // { and: [a,b] } key='and', value = [a,b]\r\n  if (AndOrPredicate.prototype._resolveOp(key, true)) {\r\n    return new AndOrPredicate(key, value);\r\n  }\r\n\r\n  // { not: a }  key= 'not', value = a\r\n  if (UnaryPredicate.prototype._resolveOp(key, true)) {\r\n    return new UnaryPredicate(key, value);\r\n  }\r\n\r\n  if ((typeof value !== 'object') || value == null || core.isDate(value)) {\r\n    // { foo: bar } key='foo', value = bar ( where bar is a literal i.e. a string, a number, a boolean or a date.\r\n    return new BinaryPredicate(\"eq\", key, value);\r\n  } else if (core.hasOwnProperty(value, 'value')) {\r\n    // { foo: { value: bar, dataType: xxx} } key='foo', value = bar ( where bar is an object representing a literal\r\n    return new BinaryPredicate(\"eq\", key, value);\r\n  }\r\n\r\n  if (Array.isArray(value)) {\r\n    throw new Error(\"Unable to resolve predicate after the phrase: \" + key);\r\n  }\r\n\r\n  let expr = key;\r\n  let keys = Object.keys(value);\r\n  let preds = keys.map(function (op) {\r\n\r\n    // { a: { any: b } op = 'any', expr=a, value[op] = b\r\n    if (AnyAllPredicate.prototype._resolveOp(op, true)) {\r\n      return new AnyAllPredicate(op, expr, value[op]);\r\n    }\r\n\r\n    if (BinaryPredicate.prototype._resolveOp(op, true)) {\r\n      // { a: { \">\": b }} op = \">\", expr=a, value[op] = b\r\n      return new BinaryPredicate(op, expr, value[op]);\r\n    } else if (core.hasOwnProperty(value[op], 'value')) {\r\n      // { a: { \">\": { value: b, dataType: 'Int32' }} expr = a value[op] = { value: b, dataType: 'Int32' }\r\n      return new BinaryPredicate(\"eq\", expr, value[op]);\r\n    }\r\n\r\n    let msg = core.formatString(\"Unable to resolve predicate after the phrase: '%1' for operator: '%2'  and value: '%3'\", expr, op, value[op]);\r\n    throw new Error(msg);\r\n\r\n  });\r\n\r\n  return (preds.length === 1) ? preds[0] : new AndOrPredicate(\"and\", preds);\r\n}\r\n\r\nfunction argsForAndOrPredicates(obj: {}, args: any[]) {\r\n  let preds = args[0];\r\n  if (preds instanceof Predicate) {\r\n    preds = core.arraySlice(args);\r\n  } else if (!Array.isArray(preds)) {\r\n    preds = [new Predicate(core.arraySlice(args))];\r\n  }\r\n  return [obj].concat(preds);\r\n}\r\n\r\nfunction updateAliasMap(aliasMap: OpMap, opStr: string, op: Op) {\r\n  let key = opStr.toLowerCase();\r\n  op.key = key;\r\n  aliasMap[key] = op;\r\n\r\n  op.aliases && op.aliases.forEach((alias: any) => {\r\n    aliasMap[alias.toLowerCase()] = op;\r\n  });\r\n}\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden @internal \r\n*/\r\nclass PassthruPredicate extends Predicate {\r\n  value: any;\r\n  constructor(value: any) {\r\n    super();\r\n    this.value = value;\r\n  }\r\n\r\n  // _validate = core.noop;\r\n}\r\nError['x'] = PassthruPredicate.prototype._initialize('passthruPredicate');\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden \r\n*/\r\nexport class UnaryPredicate extends Predicate {\r\n  op: Op;\r\n  pred: Predicate;\r\n  constructor(op: string | QueryOp, ...args: any[]) {\r\n    super();\r\n    this.op = this._resolveOp(op);\r\n    this.pred = new Predicate(args);\r\n  }\r\n\r\n  _validate(entityType: EntityType, usesNameOnServer?: boolean) {\r\n    this.pred._validate(entityType, usesNameOnServer);\r\n  }\r\n}\r\n\r\nError['x'] = UnaryPredicate.prototype._initialize('unaryPredicate', {\r\n  'not': { aliases: ['!', '~'] },\r\n});\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden \r\n*/\r\nexport class BinaryPredicate extends Predicate {\r\n  op: Op;\r\n  expr1Source: any;\r\n  expr2Source: any;\r\n  expr1?: PredicateExpression;\r\n  expr2?: PredicateExpression;\r\n  constructor(op: string | QueryOp, expr1: any, expr2: any) {\r\n    super();\r\n    // 5 public props op, expr1Source, expr2Source, expr1, expr2\r\n    this.op = this._resolveOp(op);\r\n    this.expr1Source = expr1;\r\n    this.expr2Source = expr2;\r\n    // this.expr1 and this.expr2 won't be\r\n    // determined until validate is run\r\n  }\r\n\r\n\r\n  _validate(entityType: EntityType, usesNameOnServer?: boolean) {\r\n    let expr1Context = { entityType: entityType, usesNameOnServer: usesNameOnServer };\r\n    this.expr1 = createExpr(this.expr1Source, expr1Context);\r\n    if (this.expr1 == null) {\r\n      throw new Error(\"Unable to validate 1st expression: \" + this.expr1Source);\r\n    }\r\n    if (this.expr1 instanceof LitExpr) {\r\n      // lhs must be either a property or a function.\r\n      throw new Error(\"The left hand side of a binary predicate cannot be a literal expression, it must be a valid property or functional predicate expression: \" + this.expr1Source);\r\n    }\r\n\r\n    if (this.op.key === 'in' && !Array.isArray(this.expr2Source)) {\r\n      throw new Error(\"The 'in' operator requires that its right hand argument be an array\");\r\n    }\r\n    let expr2Context = core.extend(expr1Context, { isRHS: true, dataType: this.expr1.dataType });\r\n    this.expr2 = createExpr(this.expr2Source, expr2Context);\r\n    if (this.expr2 == null) {\r\n      throw new Error(\"Unable to validate 2nd expression: \" + this.expr2Source);\r\n    }\r\n\r\n    if (this.expr1.dataType == null) {\r\n      this.expr1.dataType = this.expr2.dataType;\r\n    }\r\n  }\r\n\r\n\r\n}\r\n\r\nError['x'] = BinaryPredicate.prototype._initialize('binaryPredicate', {\r\n  'eq': {\r\n    aliases: [\"==\", \"equals\"]\r\n  },\r\n  'ne': {\r\n    aliases: [\"!=\", \"~=\", \"notequals\"]\r\n  },\r\n  'lt': {\r\n    aliases: [\"<\", \"lessthan\"]\r\n  },\r\n  'le': {\r\n    aliases: [\"<=\", \"lessthanorequal\"]\r\n  },\r\n  'gt': {\r\n    aliases: [\">\", \"greaterthan\"]\r\n  },\r\n  'ge': {\r\n    aliases: [\">=\", \"greaterthanorequal\"]\r\n  },\r\n  'startswith': {\r\n    isFunction: true\r\n  },\r\n  'endswith': {\r\n    isFunction: true\r\n  },\r\n  'contains': {\r\n    aliases: [\"substringof\"],\r\n    isFunction: true\r\n  },\r\n  'in': {\r\n\r\n  }\r\n});\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden\r\n*/\r\nexport class AndOrPredicate extends Predicate {\r\n  op: Op;\r\n  preds: Predicate[];\r\n  constructor(op: string | QueryOp, preds: any[]) {\r\n    super();\r\n    this.op = this._resolveOp(op);\r\n    if (preds.length === 1 && Array.isArray(preds[0])) {\r\n      preds = preds[0];\r\n    }\r\n    this.preds = preds.filter(function (pred) {\r\n      return pred != null;\r\n    }).map(function (pred) {\r\n      return new Predicate(pred);\r\n    });\r\n    // TODO: this was removed - test if really needed.\r\n    // if (this.preds.length === 0) {\r\n    //   // marker for an empty predicate\r\n    //   this.op = null;\r\n    // }\r\n    if (this.preds.length === 1) {\r\n      return this.preds[0] as AndOrPredicate; // HACK: this.preds[0] is actually NOT a AndOrPredicate but some other kind of pred.\r\n    }\r\n  }\r\n\r\n  _validate(entityType: EntityType, usesNameOnServer?: boolean) {\r\n    this.preds.forEach((pred) => {\r\n      pred._validate(entityType, usesNameOnServer);\r\n    });\r\n  }\r\n}\r\n\r\nError['x'] = AndOrPredicate.prototype._initialize(\"andOrPredicate\", {\r\n  'and': { aliases: ['&&'] },\r\n  'or': { aliases: ['||'] }\r\n} );\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden \r\n*/\r\nexport class AnyAllPredicate extends Predicate {\r\n  op: Op;\r\n  /** @internal */\r\n  expr: PredicateExpression;\r\n  exprSource: string;\r\n  pred: Predicate;\r\n  // 4 public props: op, exprSource, expr, pred\r\n  constructor(op: string | QueryOp, expr: string, pred: any) {\r\n    super();\r\n    this.op = this._resolveOp(op);\r\n    this.exprSource = expr;\r\n    // this.expr will not be resolved until validate is called\r\n    this.pred = new Predicate(pred);\r\n  }\r\n\r\n  _validate(entityType: EntityType, usesNameOnServer: boolean) {\r\n    this.expr = createExpr(this.exprSource, { entityType: entityType, usesNameOnServer: usesNameOnServer } as ExpressionContext);\r\n    // can't really know the predicateEntityType unless the original entity type was known.\r\n    if (entityType == null || entityType.isAnonymous) {\r\n      this.expr.dataType = undefined;\r\n    }\r\n    this.pred._validate(this.expr.dataType as EntityType | undefined, usesNameOnServer);\r\n  }\r\n\r\n}\r\n\r\nError['x'] = AnyAllPredicate.prototype._initialize(\"anyAllPredicate\", {\r\n  'any': { aliases: ['some'] },\r\n  'all': { aliases: [\"every\"] }\r\n});\r\n\r\n/** @hidden */\r\nexport class PredicateExpression {\r\n  visitorMethodName: string;\r\n  visit: Function; // TODO\r\n  dataType?: DataType | StructuralType;\r\n  constructor(visitorMethodName: string) {\r\n    this.visitorMethodName = visitorMethodName;\r\n    // give expressions the Predicate prototype method\r\n    this.visit = Predicate.prototype.visit;\r\n  }\r\n\r\n  // default impls - may/will be overridden be subclass expressions\r\n  _validate(entityType: EntityType | undefined, usesNameOnServer?: boolean) {\r\n    // noop;\r\n  }\r\n}\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden \r\n*/\r\nexport class LitExpr extends PredicateExpression {\r\n  value: any;\r\n  dataType: DataType;\r\n  hasExplicitDataType: boolean;\r\n  // 2 public props: value, dataType\r\n  constructor(value: any, dataType: string | DataType | undefined, hasExplicitDataType?: boolean) {\r\n    super(\"litExpr\");\r\n    // dataType may come is an a string\r\n    let dt1 = resolveDataType(dataType);\r\n    // if the DataType comes in as Undefined this means\r\n    // that we should NOT attempt to parse it but just leave it alone\r\n    // for now - this is usually because it is part of a Func expr.\r\n    // TODO: cast as DataType seems to be needed by early version of TypeDoc - may be able to remove later\r\n    let dt2 = (dt1 || DataType.fromValue(value)) as DataType;\r\n\r\n    if (dt2.parse) {\r\n      if (Array.isArray(value)) {\r\n        this.value = value.map((v) => { return dt2.parse!(v, typeof v); });\r\n      } else {\r\n        this.value = dt2.parse(value, typeof value);\r\n      }\r\n    } else {\r\n      this.value = value;\r\n    }\r\n    this.dataType = dt2;\r\n    this.hasExplicitDataType = !!hasExplicitDataType;\r\n  }\r\n\r\n  toString() {\r\n    return \" LitExpr - value: \" + this.value.toString() + \" dataType: \" + this.dataType.toString();\r\n  }\r\n\r\n}\r\n\r\nfunction resolveDataType(dataType?: DataType | string) {\r\n  if (dataType == null) return dataType;\r\n  // if (DataType.contains(dataType)) {\r\n  if (dataType instanceof DataType) {\r\n    return dataType;\r\n  }\r\n  if (typeof dataType === 'string') {\r\n    let dt = DataType.fromName(dataType) as DataType;\r\n    if (dt) return dt;\r\n    throw new Error(\"Unable to resolve a dataType named: \" + dataType);\r\n  }\r\n\r\n  throw new Error(\"The dataType parameter passed into this literal expression is not a 'DataType'\" + dataType);\r\n}\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden \r\n*/\r\nexport class PropExpr extends PredicateExpression {\r\n  propertyPath: string;\r\n  dataType: DataType | StructuralType;\r\n  // two public props: propertyPath, dateType\r\n  constructor(propertyPath: string) {\r\n    super('propExpr');\r\n    this.propertyPath = propertyPath;\r\n    //this.dataType = DataType.Undefined;\r\n    // this.dataType resolved after validate ( if not on an anon type }\r\n  }\r\n\r\n  toString() {\r\n    return \" PropExpr - \" + this.propertyPath;\r\n  }\r\n\r\n  _validate(entityType: EntityType | undefined, usesNameOnServer?: boolean) {\r\n\r\n    if (entityType == null || entityType.isAnonymous) return;\r\n    let props = entityType.getPropertiesOnPath(this.propertyPath, null, false);\r\n\r\n    if (!props) {\r\n      let msg = core.formatString(\"Unable to resolve propertyPath.  EntityType: '%1'   PropertyPath: '%2'\", entityType.name, this.propertyPath);\r\n      throw new Error(msg);\r\n    }\r\n    // get the last property\r\n    let prop = props[props.length - 1];\r\n    if (prop instanceof DataProperty) {\r\n      this.dataType = prop.dataType;\r\n    } else {\r\n      this.dataType = prop.entityType;\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation. \r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden @dynamic\r\n*/\r\nexport class FnExpr extends PredicateExpression {\r\n  fnName: string;\r\n  exprs: PredicateExpression[];\r\n  localFn: any; // TODO:\r\n  dataType: DataType;\r\n  constructor(fnName: string, exprs: PredicateExpression[]) {\r\n    super('fnExpr');\r\n    // 4 public props: fnName, exprs, localFn, dataType\r\n    this.fnName = fnName;\r\n    this.exprs = exprs;\r\n    let qf = FnExpr._funcMap[fnName];\r\n    if (qf == null) {\r\n      throw new Error(\"Unknown function: \" + fnName);\r\n    }\r\n    this.localFn = qf.fn;\r\n    this.dataType = qf.dataType;\r\n  }\r\n\r\n  toString() {\r\n    let exprStr = this.exprs.map(function (expr) {\r\n      expr.toString();\r\n    }).toString();\r\n    return \"FnExpr - \" + this.fnName + \"(\" + exprStr + \")\";\r\n  }\r\n\r\n  _validate(entityType: EntityType | undefined, usesNameOnServer?: boolean) {\r\n    this.exprs.forEach(function (expr) {\r\n      expr._validate(entityType, usesNameOnServer);\r\n    });\r\n  }\r\n\r\n  static _funcMap = {\r\n    toupper: {\r\n      fn: function (source: string) {\r\n        return source.toUpperCase();\r\n      }, dataType: DataType.String\r\n    },\r\n    tolower: {\r\n      fn: function (source: string) {\r\n        return source.toLowerCase();\r\n      }, dataType: DataType.String\r\n    },\r\n    substring: {\r\n      fn: function (source: string, pos: number, length: number) {\r\n        return source.substring(pos, length);\r\n      }, dataType: DataType.String\r\n    },\r\n    substringof: {\r\n      fn: function (find: string, source: string) {\r\n        return source.indexOf(find) >= 0;\r\n      }, dataType: DataType.Boolean\r\n    },\r\n    length: {\r\n      fn: function (source: any) {\r\n        return source.length;\r\n      }, dataType: DataType.Int32\r\n    },\r\n    trim: {\r\n      fn: function (source: string) {\r\n        return source.trim();\r\n      }, dataType: DataType.String\r\n    },\r\n    concat: {\r\n      fn: function (s1: string, s2: string) {\r\n        return s1.concat(s2);\r\n      }, dataType: DataType.String\r\n    },\r\n    replace: {\r\n      fn: function (source: string, find: string, replace: string) {\r\n        return source.replace(find, replace);\r\n      }, dataType: DataType.String\r\n    },\r\n    startswith: {\r\n      fn: function (source: string, find: string) {\r\n        return core.stringStartsWith(source, find);\r\n      }, dataType: DataType.Boolean\r\n    },\r\n    endswith: {\r\n      fn: function (source: string, find: string) {\r\n        return core.stringEndsWith(source, find);\r\n      }, dataType: DataType.Boolean\r\n    },\r\n    indexof: {\r\n      fn: function (source: any, find: any) {\r\n        return source.indexOf(find);\r\n      }, dataType: DataType.Int32\r\n    },\r\n    round: {\r\n      fn: function (source: number) {\r\n        return Math.round(source);\r\n      }, dataType: DataType.Int32\r\n    },\r\n    ceiling: {\r\n      fn: function (source: number) {\r\n        return Math.ceil(source);\r\n      }, dataType: DataType.Int32\r\n    },\r\n    floor: {\r\n      fn: function (source: number) {\r\n        return Math.floor(source);\r\n      }, dataType: DataType.Int32\r\n    },\r\n    second: {\r\n      fn: function (source: Date) {\r\n        return source.getSeconds();\r\n      }, dataType: DataType.Int32\r\n    },\r\n    minute: {\r\n      fn: function (source: Date) {\r\n        return source.getMinutes();\r\n      }, dataType: DataType.Int32\r\n    },\r\n    day: {\r\n      fn: function (source: Date) {\r\n        return source.getDate();\r\n      }, dataType: DataType.Int32\r\n    },\r\n    month: {\r\n      fn: function (source: Date) {\r\n        return source.getMonth() + 1;\r\n      }, dataType: DataType.Int32\r\n    },\r\n    year: {\r\n      fn: function (source: Date) {\r\n        return source.getFullYear();\r\n      }, dataType: DataType.Int32\r\n    }\r\n  };\r\n\r\n}\r\n\r\n// TODO: add dataTypes for the args next - will help to infer other dataTypes.\r\n\r\n\r\nlet RX_IDENTIFIER = /^[a-z_][\\w.$]*$/i;\r\n// comma delimited expressions ignoring commas inside of both single and double quotes.\r\nlet RX_COMMA_DELIM1 = /('[^']*'|[^,]+)/g;\r\nlet RX_COMMA_DELIM2 = /(\"[^\"]*\"|[^,]+)/g;\r\nlet DELIM = String.fromCharCode(191);\r\n\r\nfunction createExpr(source: any, exprContext: ExpressionContext) {\r\n  let entityType = exprContext.entityType;\r\n\r\n  // the right hand side of an 'in' clause\r\n  if (Array.isArray(source)) {\r\n    if (!exprContext.isRHS) {\r\n      throw new Error(\"Array expressions are only permitted on the right hand side of a BinaryPredicate\");\r\n    }\r\n    return new LitExpr(source, exprContext.dataType!);\r\n  }\r\n\r\n  if (!(typeof source === 'string')) {\r\n    if (source != null && typeof source === 'object' && !source.toISOString) {\r\n      // source is an object but not a Date-like thing such as a JS or MomentJS Date\r\n      if (source.value === undefined) {\r\n        throw new Error(\"Unable to resolve an expression for: \" + source + \" on entityType: \" + (entityType ? entityType.name : 'null'));\r\n      }\r\n      if (source.isProperty) {\r\n        return new PropExpr(source.value);\r\n      } else {\r\n        // we want to insure that any LitExpr created this way is tagged with 'hasExplicitDataType: true'\r\n        // because we want to insure that if we roundtrip thru toJSON that we don't\r\n        // accidentally reinterpret this node as a PropExpr.\r\n        // return new LitExpr(source.value, source.dataType || context.dataType, !!source.dataType);\r\n        return new LitExpr(source.value, source.dataType || exprContext.dataType, true);\r\n      }\r\n    } else {\r\n      return new LitExpr(source, exprContext.dataType);\r\n    }\r\n  }\r\n\r\n  if (exprContext.isRHS) {\r\n    if (entityType == null || entityType.isAnonymous) {\r\n      // if entityType is unknown then assume that the rhs is a literal\r\n      return new LitExpr(source, exprContext.dataType);\r\n    } else {\r\n      return parseLitOrPropExpr(source, exprContext);\r\n    }\r\n  } else {\r\n    let regex = /\\([^()]*\\)/;\r\n    let m: RegExpExecArray | null;\r\n    let tokens: string[] = [];\r\n    let i = 0;\r\n    while (m = regex.exec(source)) {\r\n      let token = m[0];\r\n      tokens.push(token);\r\n      let repl = DELIM + i++;\r\n      source = source.replace(token, repl);\r\n    }\r\n\r\n    let expr = parseExpr(source, tokens, exprContext);\r\n    expr._validate(entityType, exprContext.usesNameOnServer);\r\n    return expr;\r\n  }\r\n}\r\n\r\nfunction parseExpr(source: string, tokens: string[], exprContext: ExpressionContext): PredicateExpression {\r\n  let parts = source.split(DELIM);\r\n  if (parts.length === 1) {\r\n    return parseLitOrPropExpr(parts[0], exprContext);\r\n  } else {\r\n    return parseFnExpr(source, parts, tokens, exprContext);\r\n  }\r\n}\r\n\r\nfunction parseLitOrPropExpr(value: string, exprContext: ExpressionContext): PredicateExpression {\r\n  value = value.trim();\r\n  // value is either a string, a quoted string, a number, a bool value, or a date\r\n  // if a string ( not a quoted string) then this represents a property name ( 1st ) or a lit string ( 2nd)\r\n  let firstChar = value.substr(0, 1);\r\n  let isQuoted = (firstChar === \"'\" || firstChar === '\"') && value.length > 1 && value.substr(value.length - 1) === firstChar;\r\n  if (isQuoted) {\r\n    let unquotedValue = value.substr(1, value.length - 2);\r\n    return new LitExpr(unquotedValue, exprContext.dataType || DataType.String);\r\n  } else {\r\n    let entityType = exprContext.entityType;\r\n    // TODO: get rid of isAnonymous below when we get the chance.\r\n    if (entityType == null || entityType.isAnonymous) {\r\n      // this fork will only be reached on the LHS of an BinaryPredicate -\r\n      // a RHS expr cannot get here with an anon type\r\n      return new PropExpr(value);\r\n    } else {\r\n      let mayBeIdentifier = RX_IDENTIFIER.test(value);\r\n      if (mayBeIdentifier) {\r\n        // if (entityType.getProperty(value, false) != null) {\r\n        if (entityType.getPropertiesOnPath(value, null, false) != null) {\r\n          return new PropExpr(value);\r\n        }\r\n      }\r\n    }\r\n    // we don't really know the datatype here because even though it comes in as a string\r\n    // its usually a string BUT it might be a number  i.e. the \"1\" or the \"2\" from an expr\r\n    // like \"toUpper(substring(companyName, 1, 2))\"\r\n    return new LitExpr(value, exprContext.dataType);\r\n  }\r\n}\r\n\r\nfunction parseFnExpr(source: string, parts: string[], tokens: string[], exprContext: ExpressionContext) {\r\n  try {\r\n    let fnName = parts[0].trim().toLowerCase();\r\n\r\n    let argSource = tokens[parts[1]].trim() as string;\r\n    if (argSource.substr(0, 1) === \"(\") {\r\n      argSource = argSource.substr(1, argSource.length - 2);\r\n    }\r\n    let commaMatchStr = source.indexOf(\"'\") >= 0 ? RX_COMMA_DELIM1 : RX_COMMA_DELIM2;\r\n    let args = argSource.match(commaMatchStr);\r\n    let newContext = core.extend({}, exprContext) as ExpressionContext;\r\n    // a dataType of Undefined on a context basically means not to try parsing\r\n    // the value if the expr is a literal\r\n    newContext.dataType = DataType.Undefined;\r\n    newContext.isFnArg = true;\r\n    let exprs = args!.map(function (a) {\r\n      return parseExpr(a, tokens, newContext);\r\n    });\r\n    return new FnExpr(fnName, exprs);\r\n  } catch (e) {\r\n    // TODO: removed old code here\r\n    // return null;\r\n    // and replaced with \r\n    throw e;\r\n  }\r\n}\r\n\r\n// toFunctionVisitor\r\n\r\nlet toFunctionVisitor = {\r\n\r\n  isExtended: false,\r\n\r\n  passthruPredicate: function (this: PassthruPredicate) {\r\n    throw new Error(\"Cannot execute an PassthruPredicate expression against the local cache: \" + this.value);\r\n  },\r\n\r\n  unaryPredicate: function (this: UnaryPredicate, context: VisitContext) {\r\n    let predFn = this.pred.visit(context);\r\n    switch (this.op.key) {\r\n      case \"not\":\r\n        return function (entity: any) {\r\n          return !predFn(entity);\r\n        };\r\n      default:\r\n        throw new Error(\"Invalid unary operator:\" + this.op.key);\r\n    }\r\n  },\r\n\r\n  binaryPredicate: function (this: BinaryPredicate, context: VisitContext) {\r\n    let expr1Fn = this.expr1!.visit(context);\r\n    let expr2Fn = this.expr2!.visit(context);\r\n    let dataType = this.expr1!.dataType || this.expr2!.dataType;\r\n    let lqco = context.entityType!.metadataStore.localQueryComparisonOptions;\r\n    let predFn = getBinaryPredicateFn(this, dataType as DataType, lqco);\r\n    if (predFn == null) {\r\n      throw new Error(\"Invalid binaryPredicate operator:\" + this.op.key);\r\n    }\r\n    return function (entity: Entity) {\r\n      return predFn!(expr1Fn(entity), expr2Fn(entity));\r\n    };\r\n  },\r\n\r\n  andOrPredicate: function (this: AndOrPredicate, context: VisitContext) {\r\n    let predFns = this.preds.map((pred) => {\r\n      return pred.visit(context);\r\n    });\r\n    switch (this.op!.key) {\r\n      case \"and\":\r\n        return function (entity: any) {\r\n          let result = predFns.reduce(function (prev, cur) {\r\n            return prev && cur(entity);\r\n          }, true);\r\n          return result;\r\n        };\r\n      case \"or\":\r\n        return function (entity: any) {\r\n          let result = predFns.reduce(function (prev, cur) {\r\n            return prev || cur(entity);\r\n          }, false);\r\n          return result;\r\n        };\r\n      default:\r\n        throw new Error(\"Invalid boolean operator:\" + this.op!.key);\r\n    }\r\n  },\r\n\r\n  anyAllPredicate: function (this: AnyAllPredicate, context: VisitContext) {\r\n    let exprFn = this.expr.visit(context);\r\n    let newContext = core.extend({}, context) as VisitContext;\r\n    newContext.entityType = this.expr.dataType as EntityType;\r\n    let predFn = this.pred.visit(newContext);\r\n    let anyAllPredFn = getAnyAllPredicateFn(this.op);\r\n    return function (entity: any) {\r\n      return anyAllPredFn(exprFn(entity), predFn);\r\n    };\r\n  },\r\n\r\n  litExpr: function (this: LitExpr) {\r\n    let value = this.value;\r\n    return function (entity: any) {\r\n      return value;\r\n    };\r\n  },\r\n\r\n  propExpr: function (this: PropExpr) {\r\n    let propertyPath = this.propertyPath;\r\n    let properties = propertyPath.split('.');\r\n    if (properties.length === 1) {\r\n      return function (entity: any) {\r\n        return entity.getProperty(propertyPath);\r\n      };\r\n    } else {\r\n      return function (entity: Entity) {\r\n        return EntityAspect.getPropertyPathValue(entity, properties);\r\n      };\r\n    }\r\n  },\r\n\r\n  fnExpr: function (this: FnExpr, context: ExpressionContext) {\r\n    let exprFns = this.exprs.map(function (expr) {\r\n      return expr.visit(context);\r\n    });\r\n    let that = this;\r\n    return function (entity: any) {\r\n      let values = exprFns.map(function (exprFn) {\r\n        let value = exprFn(entity);\r\n        return value;\r\n      });\r\n      let result = that.localFn.apply(null, values);\r\n      return result;\r\n    };\r\n  }\r\n\r\n};\r\n\r\nfunction getAnyAllPredicateFn(op: Op): (v1: any[], v2: any) => boolean {\r\n  switch (op.key) {\r\n    case \"any\":\r\n      return function (v1, v2) {\r\n        return v1.some(function (v) {\r\n          return v2(v);\r\n        });\r\n      };\r\n    case \"all\":\r\n      return function (v1, v2) {\r\n        return v1.every(function (v) {\r\n          return v2(v);\r\n        });\r\n      };\r\n    default:\r\n      throw new Error(\"Unknown operator: \" + op.key);\r\n  }\r\n}\r\n\r\nfunction getBinaryPredicateFn(binaryPredicate: BinaryPredicate, dataType: DataType, lqco: LocalQueryComparisonOptions) {\r\n  let op = binaryPredicate.op;\r\n  let mc = DataType.getComparableFn(dataType);\r\n  let predFn: (v1: any, v2: any) => boolean;\r\n  switch (op.key) {\r\n    case 'eq':\r\n      predFn = function (v1, v2) {\r\n        if (v1 && typeof v1 === 'string') {\r\n          return stringEquals(v1, v2, lqco);\r\n        } else {\r\n          return mc(v1) === mc(v2);\r\n        }\r\n      };\r\n      break;\r\n    case 'ne':\r\n      predFn = function (v1, v2) {\r\n        if (v1 && typeof v1 === 'string') {\r\n          return !stringEquals(v1, v2, lqco);\r\n        } else {\r\n          return mc(v1) !== mc(v2);\r\n        }\r\n      };\r\n      break;\r\n    case 'gt':\r\n      predFn = function (v1, v2) {\r\n        return mc(v1) > mc(v2);\r\n      };\r\n      break;\r\n    case 'ge':\r\n      predFn = function (v1, v2) {\r\n        return mc(v1) >= mc(v2);\r\n      };\r\n      break;\r\n    case 'lt':\r\n      predFn = function (v1, v2) {\r\n        return mc(v1) < mc(v2);\r\n      };\r\n      break;\r\n    case 'le':\r\n      predFn = function (v1, v2) {\r\n        return mc(v1) <= mc(v2);\r\n      };\r\n      break;\r\n    case 'startswith':\r\n      predFn = function (v1, v2) {\r\n        return stringStartsWith(v1, v2, lqco);\r\n      };\r\n      break;\r\n    case 'endswith':\r\n      predFn = function (v1, v2) {\r\n        return stringEndsWith(v1, v2, lqco);\r\n      };\r\n      break;\r\n    case 'contains':\r\n      predFn = function (v1, v2) {\r\n        return stringContains(v1, v2, lqco);\r\n      };\r\n      break;\r\n    case 'in':\r\n      predFn = function (v1: any, v2: any[]) {\r\n        v1 = mc(v1);\r\n        v2 = v2.map(function (v) { return mc(v); });\r\n        return v2.indexOf(v1) >= 0;\r\n      };\r\n      break;\r\n    default:\r\n      return null;\r\n  }\r\n  return predFn;\r\n}\r\n\r\nfunction stringEquals(a: any, b: any, lqco: LocalQueryComparisonOptions) {\r\n  if (b == null) return false;\r\n  if (typeof b !== 'string') {\r\n    b = b.toString();\r\n  }\r\n  if (lqco.usesSql92CompliantStringComparison) {\r\n    a = (a || \"\").trim();\r\n    b = (b || \"\").trim();\r\n  }\r\n  if (!lqco.isCaseSensitive) {\r\n    a = (a || \"\").toLowerCase();\r\n    b = (b || \"\").toLowerCase();\r\n  }\r\n  return a === b;\r\n}\r\n\r\nfunction stringStartsWith(a: any, b: any, lqco: LocalQueryComparisonOptions) {\r\n  if (!lqco.isCaseSensitive) {\r\n    a = (a || \"\").toLowerCase();\r\n    b = (b || \"\").toLowerCase();\r\n  }\r\n  return core.stringStartsWith(a, b);\r\n}\r\n\r\nfunction stringEndsWith(a: any, b: any, lqco: LocalQueryComparisonOptions) {\r\n  if (!lqco.isCaseSensitive) {\r\n    a = (a || \"\").toLowerCase();\r\n    b = (b || \"\").toLowerCase();\r\n  }\r\n  return core.stringEndsWith(a, b);\r\n}\r\n\r\nfunction stringContains(a: any, b: any, lqco: LocalQueryComparisonOptions) {\r\n  if (!lqco.isCaseSensitive) {\r\n    a = (a || \"\").toLowerCase();\r\n    b = (b || \"\").toLowerCase();\r\n  }\r\n  return a.indexOf(b) >= 0;\r\n}\r\n\r\n// toJSONVisitor\r\n\r\nlet toJSONVisitor = {\r\n\r\n  passthruPredicate: function (this: PassthruPredicate) {\r\n    return this.value;\r\n  },\r\n\r\n  unaryPredicate: function (this: UnaryPredicate, context: VisitContext) {\r\n    let predVal = this.pred.visit(context);\r\n    let json = {};\r\n    json[this.op.key] = predVal;\r\n    return json;\r\n  },\r\n\r\n  binaryPredicate: function (this: BinaryPredicate, context: VisitContext) {\r\n    let expr1Val = this.expr1!.visit(context);\r\n    let expr2Val = this.expr2!.visit(context);\r\n    let json = {};\r\n    if (this.expr2 instanceof PropExpr) {\r\n      expr2Val = { value: expr2Val, isProperty: true };\r\n    }\r\n    if (this.op.key === \"eq\") {\r\n      json[expr1Val] = expr2Val;\r\n    } else {\r\n      let value = {};\r\n      json[expr1Val] = value;\r\n      value[this.op.key] = expr2Val;\r\n    }\r\n    return json;\r\n  },\r\n\r\n  andOrPredicate: function (this: AndOrPredicate, context: VisitContext) {\r\n    let predVals = this.preds.map(function (pred) {\r\n      return pred.visit(context);\r\n    });\r\n    if (!predVals || !predVals.length) {\r\n      return {};\r\n    }\r\n    let json: Object | undefined;\r\n    // normalizeAnd clauses if possible.\r\n    // passthru predicate will appear as string and their 'ands' can't be 'normalized'\r\n    if (this.op!.key === 'and' && predVals.length === 2 && !predVals.some((v) => typeof(v) === 'string')) {\r\n      // normalize 'and' clauses - will return null if can't be combined.\r\n      json = predVals.reduce(combine);\r\n    }\r\n    if (json == null) {\r\n      json = {};\r\n      json[this.op!.key!] = predVals;\r\n    }\r\n    return json;\r\n  },\r\n\r\n  anyAllPredicate: function (this: AnyAllPredicate, context: VisitContext) {\r\n    let exprVal = this.expr.visit(context);\r\n    let newContext = core.extend({}, context) as VisitContext;\r\n    newContext.entityType = this.expr.dataType as EntityType;\r\n    let predVal = this.pred.visit(newContext);\r\n    let json = {};\r\n    let value = {};\r\n    value[this.op.key] = predVal;\r\n    json[exprVal] = value;\r\n    return json;\r\n  },\r\n\r\n  litExpr: function (this: LitExpr, context: VisitContext) {\r\n    if (this.hasExplicitDataType || context.useExplicitDataType) {\r\n      return { value: this.value, dataType: this.dataType.name };\r\n    } else {\r\n      return this.value;\r\n    }\r\n  },\r\n\r\n  propExpr: function (this: PropExpr, context: VisitContext) {\r\n    if (context.toNameOnServer) {\r\n      return context.entityType!.clientPropertyPathToServer(this.propertyPath);\r\n    } else {\r\n      return this.propertyPath;\r\n    }\r\n  },\r\n\r\n  fnExpr: function (this: FnExpr, context: VisitContext) {\r\n    let exprVals = this.exprs.map(function (expr) {\r\n      return expr.visit(context);\r\n    });\r\n    return this.fnName + \"(\" + exprVals.join(\",\") + \")\";\r\n  }\r\n\r\n};\r\n\r\nfunction combine(j1: Object, j2: Object) {\r\n  let ok = Object.keys(j2).every(function (key) {\r\n    if (j1.hasOwnProperty(key)) {\r\n      if (typeof (j2[key]) !== 'object') {\r\n        // exit and indicate that we can't combine\r\n        return false;\r\n      }\r\n      if (combine(j1[key], j2[key]) == null) {\r\n        return false;\r\n      }\r\n    } else {\r\n      j1[key] = j2[key];\r\n    }\r\n    return true;\r\n  });\r\n  return ok ? j1 : null;\r\n}\r\n\r\n\r\n\r\n\r\n","import { core, Callback, ErrorCallback } from './core';\r\nimport { assertParam } from './assert-param';\r\nimport { DataType } from './data-type';\r\nimport { EntityAspect, Entity } from './entity-aspect';\r\nimport { EntityKey } from './entity-key';\r\nimport { BreezeEnum } from './enum';\r\nimport { DataService, JsonResultsAdapter } from './data-service';\r\nimport { EntityManager, QueryResult } from './entity-manager';\r\nimport { MetadataStore, EntityType, NavigationProperty, EntityProperty } from './entity-metadata';\r\nimport { QueryOptions, MergeStrategy, FetchStrategy } from './query-options';\r\nimport { Predicate } from './predicate';\r\n\r\nexport interface RecursiveArray<T> {\r\n  [i: number]: T | RecursiveArray<T>;\r\n}\r\n\r\nexport interface EntityQueryJsonContext {\r\n  entityType?: EntityType;\r\n  propertyPathFn?: Function; // TODO\r\n  toNameOnServer?: boolean;\r\n}\r\n/**\r\nAn EntityQuery instance is used to query entities either from a remote datasource or from a local [[EntityManager]].\r\n\r\nEntityQueries are immutable - this means that all EntityQuery methods that return an EntityQuery actually create a new EntityQuery.  This means that\r\nEntityQueries can be 'modified' without affecting any current instances.\r\n@dynamic\r\n**/\r\nexport class EntityQuery {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // actually placed on prototype\r\n  // top = this.take; // TODO: consider\r\n  /** The resource name used by this query. __Read Only__ */\r\n  resourceName?: string;\r\n  /** The [[EntityType]] that is associated with the 'from' clause ( resourceName) of the query.  This is only guaranteed to be be set AFTER the query\r\n  has been executed because it depends on the [[MetadataStore]] associated with the [[EntityManager]] that the query was executed against.\r\n  This value may be null if the entityType cannot be associated with a resourceName. __Read Only__ */\r\n  fromEntityType?: EntityType;\r\n  /** The 'where' [[Predicate]] used by this query. __Read Only__ */\r\n  wherePredicate: Predicate; // TODO\r\n  /** The [[OrderByClause]] used by this query. __Read Only__ */\r\n  orderByClause?: OrderByClause;\r\n  /** The [[ExpandClause]] used by this query. __Read Only__ */\r\n  expandClause?: ExpandClause;\r\n  /** The [[SelectClause]] used by this query. __Read Only__ */\r\n  selectClause?: SelectClause;\r\n  /** The number of entities to 'skip' for this query. __Read Only__ */\r\n  skipCount?: number;\r\n  /** The number of entities to 'take' for this query. __Read Only__ */\r\n  takeCount?: number;\r\n  /** Any additional parameters that were added to the query via the 'withParameters' method. __Read Only__ */\r\n  parameters: Object;\r\n  /** Whether an inline count is returned for this query. __Read Only__ */\r\n  inlineCountEnabled: boolean;\r\n  /** Whether entity tracking has been disabled for this query. __Read Only__ */\r\n  noTrackingEnabled: boolean;\r\n  /** The [[QueryOptions]] for this query. __Read Only__  **/\r\n  // default is to get queryOptions and dataService from the entityManager.\r\n  queryOptions?: QueryOptions;\r\n  /** The [[DataService]] for this query. __Read Only__  **/\r\n  dataService?: DataService;\r\n  /** The [[EntityManager]] for this query. This may be null and can be set via the 'using' method.  **/\r\n  entityManager?: EntityManager;\r\n  /**  The entityType that will be returned by this query. \r\n  This property will only be set if the 'toType' method was called. __Read Only__ */\r\n  resultEntityType: EntityType | string;\r\n  usesNameOnServer?: boolean;\r\n\r\n  /** Constructor\r\n  >    let query = new EntityQuery(\"Customers\")\r\n\r\n  Usually this constructor will be followed by calls to filtering, ordering or selection methods\r\n  >      let query = new EntityQuery(\"Customers\")\r\n  >        .where(\"CompanyName\", \"startsWith\", \"C\")\r\n  >        .orderBy(\"Region\");\r\n  @param resourceName - either a resource name or a serialized EntityQuery ( created by [[EntityQuery.toJSON]])\r\n  **/\r\n  constructor(resourceName?: string | Object) {\r\n    if (resourceName != null && (typeof resourceName !== 'string')) {\r\n      return fromJSON(this, resourceName);\r\n    }\r\n    // TODO: cast as string below needed for early versions of TypeDoc - but not for regular compile - check later\r\n    this.resourceName = resourceName as string;\r\n    this.fromEntityType = undefined;\r\n    this.wherePredicate = undefined;\r\n    this.orderByClause = undefined;\r\n    this.selectClause = undefined;\r\n    this.skipCount = undefined;\r\n    this.takeCount = undefined;\r\n    this.expandClause = undefined;\r\n    this.parameters = {};\r\n    this.inlineCountEnabled = false;\r\n    this.noTrackingEnabled = false;\r\n    // default is to get queryOptions and dataService from the entityManager.\r\n    // this.queryOptions = new QueryOptions();\r\n    // this.dataService = new DataService();\r\n    this.entityManager = undefined;\r\n\r\n  }\r\n\r\n\r\n  /**\r\n  Specifies the resource to query for this EntityQuery.\r\n  >      let query = new EntityQuery()\r\n  >        .from(\"Customers\");\r\n\r\n  is the same as\r\n  >      let query = new EntityQuery(\"Customers\");\r\n  @param resourceName - The resource to query.\r\n  **/\r\n  from(resourceName: string) {\r\n    // TODO: think about allowing entityType as well\r\n    assertParam(resourceName, \"resourceName\").isString().check();\r\n    return clone(this, \"resourceName\", resourceName);\r\n  }\r\n\r\n  /**\r\n  This is a static version of the \"from\" method and it creates a 'base' entityQuery for the specified resource name.\r\n  >      let query = EntityQuery.from(\"Customers\");\r\n\r\n  is the same as\r\n  >      let query = new EntityQuery(\"Customers\");\r\n  @param resourceName - The resource to query.\r\n  **/\r\n  static from(resourceName: string) {\r\n    assertParam(resourceName, \"resourceName\").isString().check();\r\n    return new EntityQuery(resourceName);\r\n  }\r\n\r\n  /**\r\n  Specifies the top level EntityType that this query will return.  Only needed when a query returns a json result that does not include type information.\r\n  >      let query = new EntityQuery()\r\n  >        .from(\"MyCustomMethod\")\r\n  >        .toType(\"Customer\")\r\n  @param entityType - The top level EntityType that this query will return.  This method is only needed when a query returns a json result that\r\n  does not include type information.  If the json result consists of more than a simple entity or array of entities, consider using a [[JsonResultsAdapter]] instead.\r\n  **/\r\n  toType(entityType: string | EntityType) {\r\n    assertParam(entityType, \"entityType\").isString().or().isInstanceOf(EntityType).check();\r\n    return clone(this, \"resultEntityType\", entityType);\r\n  }\r\n\r\n\r\n  where(predicate?: Predicate): EntityQuery;\r\n  where(predicate: Object): EntityQuery;\r\n  where(property: string, operator: string, value: any): EntityQuery;\r\n  where(property: string, operator: FilterQueryOp, value: any): EntityQuery;\r\n  where(property: string, filterop: FilterQueryOp, property2: string, filterop2: FilterQueryOp, value: any): EntityQuery;  // for any/all clauses\r\n  where(property: string, filterop: string, property2: string, filterop2: string, value: any): EntityQuery;  // for any/all clauses\r\n  where(property: string, filterop: string, property2: string, filterop2: string, property3: string, filterop3: string, value: any): EntityQuery;  // for any/all clauses\r\n  where(anArray: RecursiveArray<string | number | FilterQueryOp | Predicate>): EntityQuery;\r\n  /**\r\n  Returns a new query with an added filter criteria; Can be called multiple times which means to 'and' with any existing\r\n  Predicate or can be called with null to clear all predicates.\r\n  >      let query = new EntityQuery(\"Customers\")\r\n  >          .where(\"CompanyName\", \"startsWith\", \"C\");\r\n\r\n  This can also be expressed using an explicit [[FilterQueryOp]] as\r\n  >      let query = new EntityQuery(\"Customers\")\r\n  >          .where(\"CompanyName\", FilterQueryOp.StartsWith, \"C\");\r\n\r\n  or a preconstructed [[Predicate]] may be used\r\n  >      let pred = new Predicate(\"CompanyName\", FilterQueryOp.StartsWith, \"C\");\r\n  >      let query = new EntityQuery(\"Customers\").where(pred);\r\n\r\n  Predicates are often useful when you want to combine multiple conditions in a single filter, such as\r\n  >      let pred = Predicate.create(\"CompanyName\", \"startswith\", \"C\").and(\"Region\", FilterQueryOp.Equals, null);\r\n  >      let query = new EntityQuery(\"Customers\")\r\n  >          .where(pred);\r\n\r\n  More complicated queries can make use of nested property paths\r\n  >      let query = new EntityQuery(\"Products\")\r\n  >          .where(\"Category.CategoryName\", \"startswith\", \"S\");\r\n\r\n  or OData functions - A list of valid OData functions can be found within the [[Predicate]] documentation.\r\n  \r\n  >      let query = new EntityQuery(\"Customers\")\r\n  >          .where(\"toLower(CompanyName)\", \"startsWith\", \"c\");\r\n\r\n  or to be even more baroque\r\n  >      let query = new EntityQuery(\"Customers\")\r\n  >          .where(\"toUpper(substring(CompanyName, 1, 2))\", FilterQueryOp.Equals, \"OM\");\r\n  @param predicate -  Can be either\r\n    - a single [[Predicate]]\r\n\r\n    - the parameters to create a 'simple' Predicate\r\n    - -  a property name, a property path with '.' as path seperators or a property expression {String}\r\n    - -  an operator - [[FilterQueryOp]] or it's string representation. Case is ignored\r\n    when if a string is provided and any string that matches one of the FilterQueryOp aliases will be accepted.\r\n    - -  a value {Object} - This will be treated as either a property expression or a literal depending on context.  \r\n    In general, if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal.\r\n    In most cases this works well, but you can also force the interpretation by making the value argument itself an object \r\n    with a 'value' property and an 'isLiteral' property set to either true or false.\r\n    Breeze also tries to infer the dataType of any literal based on context, if this fails you can force this inference by making the value argument \r\n    an object with a 'value' property and a 'dataType'property set to one of the DataType enumeration instances.\r\n\r\n    - a null or undefined ( this causes any existing where clause to be removed)\r\n  **/\r\n  where(...args: any[]) {\r\n    let wherePredicate: Predicate | undefined;\r\n    if (args.length > 0 && args[0] != null) {\r\n      wherePredicate = Predicate.create(...<any>args);\r\n      if (this.fromEntityType) wherePredicate._validate(this.fromEntityType);\r\n      if (this.wherePredicate) {\r\n        wherePredicate = this.wherePredicate.and(wherePredicate);\r\n      }\r\n    }\r\n    return clone(this, \"wherePredicate\", wherePredicate);\r\n  }\r\n\r\n\r\n  orderBy(propertyPaths?: string, isDescending?: boolean): EntityQuery;\r\n  orderBy(propertyPaths: string[], isDescending?: boolean): EntityQuery;\r\n  /**\r\n  Returns a new query that orders the results of the query by property name.  By default sorting occurs is ascending order, but sorting in descending order is supported as well.\r\n  OrderBy clauses may be chained.\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .orderBy(\"CompanyName\");\r\n\r\n  or to sort across multiple properties\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .orderBy(\"Region, CompanyName\");\r\n\r\n  Nested property paths are also supported\r\n  >     let query = new EntityQuery(\"Products\")\r\n  >        .orderBy(\"Category.CategoryName\");\r\n\r\n  Sorting in descending order is supported via the addition of ' desc' to the end of any property path.\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .orderBy(\"CompanyName desc\");\r\n\r\n  or\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .orderBy(\"Region desc, CompanyName desc\");\r\n  @param propertyPaths - A comma-separated (',') string of property paths or an array of property paths.\r\n  Each property path can optionally end with \" desc\" to force a descending sort order. If 'propertyPaths' is either null or omitted then all ordering is removed.\r\n  @param isDescending - If specified, overrides all of the embedded 'desc' tags in the previously specified property paths.\r\n  **/\r\n  orderBy(propertyPaths: string | string[], isDescending?: boolean) {\r\n    // propertyPaths: can pass in create(\"A.X,B\") or create(\"A.X desc, B\") or create(\"A.X desc,B\", true])\r\n    // isDesc parameter trumps isDesc in propertyName.\r\n    let orderByClause = propertyPaths == null ? null : new OrderByClause(normalizePropertyPaths(propertyPaths), isDescending);\r\n    if (this.orderByClause && orderByClause) {\r\n      orderByClause = new OrderByClause([this.orderByClause, orderByClause]);\r\n    }\r\n    return clone(this, \"orderByClause\", orderByClause);\r\n  }\r\n\r\n\r\n  orderByDesc(propertyPaths: string): EntityQuery;\r\n  orderByDesc(propertyPaths: string[]): EntityQuery;\r\n  /**\r\n  Returns a new query that orders the results of the query by property name in descending order.\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .orderByDesc(\"CompanyName\");\r\n\r\n  or to sort across multiple properties\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .orderByDesc(\"Region, CompanyName\");\r\n\r\n  Nested property paths are also supported\r\n  >     let query = new EntityQuery(\"Products\")\r\n  >        .orderByDesc(\"Category.CategoryName\");\r\n  @param propertyPaths - A comma-separated (',') string of property paths or an array of property paths.\r\n  If 'propertyPaths' is either null or omitted then all ordering is removed.\r\n  **/\r\n  orderByDesc(propertyPaths: string | string[]) {\r\n    return this.orderBy(propertyPaths as any, true);\r\n  }\r\n\r\n  /**\r\n  Returns a new query that selects a list of properties from the results of the original query and returns the values of just these properties. This\r\n  will be referred to as a projection.\r\n  If the result of this selection \"projection\" contains entities, these entities will automatically be added to EntityManager's cache and will\r\n  be made 'observable'.\r\n  Any simple properties, i.e. strings, numbers or dates within a projection will not be cached are will NOT be made 'observable'.\r\n  \r\n  Simple data properties can be projected\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >         .where(\"CompanyName\", \"startsWith\", \"C\")\r\n  >         .select(\"CompanyName\");\r\n\r\n  This will return an array of objects each with a single \"CompanyName\" property of type string.\r\n  A similar query could return a navigation property instead\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .where(\"CompanyName\", \"startsWith\", \"C\")\r\n  >        .select(\"Orders\");\r\n\r\n  where the result would be an array of objects each with a single \"Orders\" property that would itself be an array of \"Order\" entities.\r\n  Composite projections are also possible:\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .where(\"CompanyName\", \"startsWith\", \"C\")\r\n  >        .select(\"CompanyName, Orders\");\r\n\r\n  As well as projections involving nested property paths\r\n  >     let query = EntityQuery(\"Orders\")\r\n  >        .where(\"Customer.CompanyName\", \"startsWith\", \"C\")\r\n  >        .select(\"Customer.CompanyName, Customer, OrderDate\");\r\n  @param propertyPaths - A comma-separated (',') string of property paths or an array of property paths.\r\n  If 'propertyPaths' is either null or omitted then any existing projection on the query is removed.\r\n  **/\r\n  select(propertyPaths?: string | string[]) {\r\n    let selectClause = propertyPaths == null ? null : new SelectClause(normalizePropertyPaths(propertyPaths));\r\n    return clone(this, \"selectClause\", selectClause);\r\n  }\r\n\r\n  /**\r\n  Returns a new query that skips the specified number of entities when returning results.\r\n  Any existing 'skip' can be cleared by calling 'skip' with no arguments.\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >       .where(\"CompanyName\", \"startsWith\", \"C\")\r\n  >       .skip(5);\r\n  @param count - The number of entities to skip over. If omitted or null any existing skip count on the query is removed.\r\n  **/\r\n  skip(count?: number) {\r\n    assertParam(count, \"count\").isOptional().isNumber().check();\r\n    return clone(this, \"skipCount\", (count == null) ? null : count);\r\n  }\r\n\r\n  /**\r\n  Returns a new query that returns only the specified number of entities when returning results. - Same as 'take'.\r\n  Any existing 'top' can be cleared by calling 'top' with no arguments.\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .top(5);\r\n  @param count - The number of entities to return.\r\n  If 'count' is either null or omitted then any existing 'top' count on the query is removed.\r\n  **/\r\n  top(count?: number) {\r\n    return this.take(count);\r\n  }\r\n\r\n  /**\r\n  Returns a new query that returns only the specified number of entities when returning results - Same as 'top'.\r\n  Any existing take can be cleared by calling take with no arguments.\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .take(5);\r\n  @param count - The number of entities to return.\r\n  If 'count' is either null or omitted then any existing 'take' count on the query is removed.\r\n  **/\r\n  take(count?: number) {\r\n    assertParam(count, \"count\").isOptional().isNumber().check();\r\n    return clone(this, \"takeCount\", (count == null) ? null : count);\r\n  }\r\n\r\n  /**\r\n  Returns a new query that will return related entities nested within its results. The expand method allows you to identify related entities, via navigation property\r\n  names such that a graph of entities may be retrieved with a single request. Any filtering occurs before the results are 'expanded'.\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .where(\"CompanyName\", \"startsWith\", \"C\")\r\n  >        .expand(\"Orders\");\r\n\r\n  will return the filtered customers each with its \"Orders\" properties fully resolved.\r\n  Multiple paths may be specified by separating the paths by a ','\r\n  >     let query = new EntityQuery(\"Orders\")\r\n  >        .expand(\"Customer, Employee\")\r\n\r\n  and nested property paths my be specified as well\r\n  >     let query = new EntityQuery(\"Orders\")\r\n  >        .expand(\"Customer, OrderDetails, OrderDetails.Product\")\r\n  @param propertyPaths - A comma-separated list of navigation property names or an array of navigation property names. Each Navigation Property name can be followed\r\n  by a '.' and another navigation property name to enable identifying a multi-level relationship.\r\n  If 'propertyPaths' is either null or omitted then any existing 'expand' clause on the query is removed.\r\n  **/\r\n  expand(propertyPaths?: string | string[]) {\r\n    let expandClause = propertyPaths == null ? null : new ExpandClause(normalizePropertyPaths(propertyPaths));\r\n    return clone(this, \"expandClause\", expandClause);\r\n  }\r\n\r\n  /**\r\n  Returns a new query that includes a collection of parameters to pass to the server.\r\n  >     let query = EntityQuery.from(\"EmployeesFilteredByCountryAndBirthdate\")\r\n  >        .withParameters({ BirthDate: \"1/1/1960\", Country: \"USA\" });\r\n   \r\n  will call the 'EmployeesFilteredByCountryAndBirthdate' method on the server and pass in 2 parameters. This\r\n  query will be uri encoded as\r\n  >      {serviceApi}/EmployeesFilteredByCountryAndBirthdate?birthDate=1%2F1%2F1960&country=USA\r\n\r\n  Parameters may also be mixed in with other query criteria.\r\n  >     let query = EntityQuery.from(\"EmployeesFilteredByCountryAndBirthdate\")\r\n  >        .withParameters({ BirthDate: \"1/1/1960\", Country: \"USA\" })\r\n  >        .where(\"LastName\", \"startsWith\", \"S\")\r\n  >        .orderBy(\"BirthDate\");\r\n  @param parameters - A parameters object where the keys are the parameter names and the values are the parameter values.\r\n  **/\r\n  withParameters(parameters: Object) {\r\n    assertParam(parameters, \"parameters\").isObject().check();\r\n    return clone(this, \"parameters\", parameters);\r\n  }\r\n\r\n  /**\r\n  Returns a query with the 'inlineCount' capability either enabled or disabled.  With 'inlineCount' enabled, an additional 'inlineCount' property\r\n  will be returned with the query results that will contain the number of entities that would have been returned by this\r\n  query with only the 'where'/'filter' clauses applied, i.e. without any 'skip'/'take' operators applied. For local queries this clause is ignored.\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >        .take(20)\r\n  >        .orderBy(\"CompanyName\")\r\n  >        .inlineCount(true);\r\n\r\n  will return the first 20 customers as well as a count of all of the customers in the remote store.\r\n  @param enabled - (default = true) Whether or not inlineCount capability should be enabled. If this parameter is omitted, true is assumed.\r\n  **/\r\n  inlineCount(enabled?: boolean) {\r\n    assertParam(enabled, \"enabled\").isBoolean().isOptional().check();\r\n    enabled = (enabled === undefined) ? true : !!enabled;\r\n    return clone(this, \"inlineCountEnabled\", enabled);\r\n  }\r\n\r\n  useNameOnServer(usesNameOnServer?: boolean) {\r\n    assertParam(usesNameOnServer, \"usesNameOnServer\").isBoolean().isOptional().check();\r\n    usesNameOnServer = (usesNameOnServer === undefined) ? true : !!usesNameOnServer;\r\n    return clone(this, \"usesNameOnServer\", usesNameOnServer);\r\n  }\r\n\r\n  /**\r\n  Returns a query with the 'noTracking' capability either enabled or disabled.  With 'noTracking' enabled, the results of this query\r\n  will not be coerced into entities but will instead look like raw javascript projections. i.e. simple javascript objects.\r\n  >     let query = new EntityQuery(\"Customers\")\r\n  >         .take(20)\r\n  >         .orderBy(\"CompanyName\")\r\n  >         .noTracking(true);\r\n  @param enabled - (default = true) Whether or not the noTracking capability should be enabled. If this parameter is omitted, true is assumed.\r\n  **/\r\n  noTracking(enabled?: boolean) {\r\n    assertParam(enabled, \"enabled\").isBoolean().isOptional().check();\r\n    enabled = (enabled === undefined) ? true : !!enabled;\r\n    return clone(this, \"noTrackingEnabled\", enabled);\r\n  }\r\n\r\n  using(obj: EntityManager): EntityQuery;\r\n  using(obj: DataService): EntityQuery;\r\n  using(obj: JsonResultsAdapter): EntityQuery;\r\n  using(obj: QueryOptions): EntityQuery;\r\n  using(obj: MergeStrategy): EntityQuery;\r\n  using(obj: FetchStrategy): EntityQuery;\r\n  /**\r\n  Returns a copy of this EntityQuery with the specified [[EntityManager]], [[DataService]],\r\n  [[JsonResultsAdapter]], [[MergeStrategy]] or [[FetchStrategy]] applied.\r\n  >      // 'using' can be used to return a new query with a specified EntityManager.\r\n  >      let em = new EntityManager(serviceName);\r\n  >      let query = new EntityQuery(\"Orders\")\r\n  >        .using(em);\r\n\r\n  or with a specified [[MergeStrategy]]\r\n  >      let em = new EntityManager(serviceName);\r\n  >      let query = new EntityQuery(\"Orders\")\r\n  >        .using(MergeStrategy.PreserveChanges);\r\n\r\n  or with a specified [[FetchStrategy]]\r\n  >      let em = new EntityManager(serviceName);\r\n  >      let query = new EntityQuery(\"Orders\")\r\n  >        .using(FetchStrategy.FromLocalCache);\r\n  @param obj - The object to update in creating a new EntityQuery from an existing one.\r\n  **/\r\n  using(obj: any) {\r\n    if (!obj) return this;\r\n    let eq = clone(this);\r\n    processUsing(eq, {\r\n      \"entityManager\": null,\r\n      \"dataService\": null,\r\n      \"queryOptions\": null,\r\n      \"fetchStrategy\": (eq: EntityQuery, val: any) => {\r\n        eq.queryOptions = (eq.queryOptions || new QueryOptions()).using(val);\r\n      },\r\n      \"mergeStrategy\": (eq: EntityQuery, val: any) => {\r\n        eq.queryOptions = (eq.queryOptions || new QueryOptions()).using(val);\r\n      },\r\n      \"jsonResultsAdapter\": (eq: EntityQuery, val: any) => {\r\n        eq.dataService = (eq.dataService || new DataService()).using({ jsonResultsAdapter: val });\r\n      }\r\n    }, obj);\r\n    return eq;\r\n  }\r\n\r\n  /**\r\n  Executes this query.  This method requires that an EntityManager has been previously specified via the \"using\" method.\r\n  \r\n  This method can be called using a 'promises' syntax ( recommended)\r\n  >      let em = new EntityManager(serviceName);\r\n  >      let query = new EntityQuery(\"Orders\").using(em);\r\n  >      query.execute().then( function(data) {\r\n  >          ... query results processed here\r\n  >      }).catch( function(err) {\r\n  >          ... query failure processed here\r\n  >      });\r\n\r\n  or with callbacks\r\n  >      let em = new EntityManager(serviceName);\r\n  >      let query = new EntityQuery(\"Orders\").using(em);\r\n  >      query.execute(\r\n  >        function(data) {\r\n  >                    let orders = data.results;\r\n  >                    ... query results processed here\r\n  >                },\r\n  >        function(err) {\r\n  >                    ... query failure processed here\r\n  >                });\r\n\r\n  Either way this method is the same as calling the EntityManager 'execute' method.\r\n  >      let em = new EntityManager(serviceName);\r\n  >      let query = new EntityQuery(\"Orders\");\r\n  >      em.executeQuery(query).then( function(data) {\r\n  >         let orders = data.results;\r\n  >          ... query results processed here\r\n  >      }).catch( function(err) {\r\n  >         ... query failure processed here\r\n  >      });\r\n\r\n  @param callback -  Function called on success.\r\n  @param errorCallback - Function called on failure.\r\n  @return Promise\r\n  **/\r\n  execute(callback?: Callback, errorCallback?: ErrorCallback): Promise<QueryResult> {\r\n    if (!this.entityManager) {\r\n      throw new Error(\"An EntityQuery must have its EntityManager property set before calling 'execute'\");\r\n    }\r\n    return this.entityManager.executeQuery(this, callback, errorCallback);\r\n  }\r\n\r\n  /**\r\n  Executes this query against the local cache.  This method requires that an EntityManager have been previously specified via the \"using\" method.\r\n  >      // assume em is an entityManager already filled with order entities;\r\n  >      let query = new EntityQuery(\"Orders\").using(em);\r\n  >      let orders = query.executeLocally();\r\n\r\n  Note that calling this method is the same as calling [[EntityManager.executeQueryLocally]].\r\n  **/\r\n  executeLocally() {\r\n    if (!this.entityManager) {\r\n      throw new Error(\"An EntityQuery must have its EntityManager property set before calling 'executeLocally'\");\r\n    }\r\n    return this.entityManager.executeQueryLocally(this);\r\n  }\r\n\r\n  toJSON() {\r\n    return this.toJSONExt();\r\n  }\r\n\r\n  /** Typically only for use when building UriBuilderAdapters.  \r\n  @hidden @internal  \r\n  */\r\n  toJSONExt(context?: EntityQueryJsonContext) {\r\n    context = context || {};\r\n    context.entityType = context.entityType || this.fromEntityType;\r\n    context.propertyPathFn = context.toNameOnServer ? context.entityType!.clientPropertyPathToServer.bind(context.entityType) : core.identity;\r\n\r\n    let toJSONExtFn = function (v: any) {\r\n      return v ? v.toJSONExt(context) : undefined;\r\n    };\r\n    return core.toJson(this, {\r\n      \"from,resourceName\": null,\r\n      \"toType,resultEntityType\": function (v: any) {\r\n        // resultEntityType can be either a string or an entityType\r\n        return v ? (typeof v === 'string' ? v : v.name) : undefined;\r\n      },\r\n      \"where,wherePredicate\": toJSONExtFn,\r\n      \"orderBy,orderByClause\": toJSONExtFn,\r\n      \"select,selectClause\": toJSONExtFn,\r\n      \"expand,expandClause\": toJSONExtFn,\r\n      \"skip,skipCount\": null,\r\n      \"take,takeCount\": null,\r\n      parameters: function (v: any) {\r\n        return core.isEmpty(v) ? undefined : v;\r\n      },\r\n      \"inlineCount,inlineCountEnabled\": false,\r\n      \"noTracking,noTrackingEnabled\": false,\r\n      queryOptions: null\r\n    });\r\n\r\n  }\r\n\r\n  static fromEntities(entity: Entity): EntityQuery;\r\n  static fromEntities(entities: Entity[]): EntityQuery;\r\n  /**\r\n  Static method that creates an EntityQuery that will allow 'requerying' an entity or a collection of entities by primary key. This can be useful\r\n  to force a requery of selected entities, or to restrict an existing collection of entities according to some filter.\r\n\r\n  Works for a single entity or an array of entities of the SAME type.\r\n  Does not work for an array of entities of different types.\r\n  >      // assuming 'customers' is an array of 'Customer' entities retrieved earlier.\r\n  >      let customersQuery = EntityQuery.fromEntities(customers);\r\n\r\n  The resulting query can, of course, be extended\r\n  >      // assuming 'customers' is an array of 'Customer' entities retrieved earlier.\r\n  >      let customersQuery = EntityQuery.fromEntities(customers)\r\n  >        .where(\"Region\", FilterQueryOp.NotEquals, null);\r\n\r\n  Single entities can requeried as well.\r\n  >      // assuming 'customer' is a 'Customer' entity retrieved earlier.\r\n  >      let customerQuery = EntityQuery.fromEntities(customer);\r\n\r\n  will create a query that will return an array containing a single customer entity.\r\n  @param entities - The entities for which we want to create an EntityQuery.\r\n  **/\r\n  static fromEntities(entities: Entity | Entity[]) {\r\n    assertParam(entities, \"entities\").isEntity().or().isNonEmptyArray().isEntity().check();\r\n    let ents = (Array.isArray(entities)) ? entities : [entities];\r\n\r\n    let firstEntity = ents[0];\r\n    let type = firstEntity.entityType;\r\n    if (ents.some(function (e) {\r\n      return e.entityType !== type;\r\n    })) {\r\n      throw new Error(\"All 'fromEntities' must be the same type; at least one is not of type \" +\r\n        type.name);\r\n    }\r\n    let q = new EntityQuery(type.defaultResourceName);\r\n    let preds = ents.map(function (entity) {\r\n      return buildPredicate(entity);\r\n    });\r\n    let pred = Predicate.or(preds);\r\n    q = q.where(pred);\r\n    let em = firstEntity.entityAspect.entityManager;\r\n    if (em) {\r\n      q = q.using(em);\r\n    }\r\n    return q;\r\n  }\r\n\r\n  /**\r\n  Creates an EntityQuery for the specified [[EntityKey]].\r\n  >      let empType = metadataStore.getEntityType(\"Employee\");\r\n  >      let entityKey = new EntityKey(empType, 1);\r\n  >      let query = EntityQuery.fromEntityKey(entityKey);\r\n\r\n  or\r\n  >      // 'employee' is a previously queried employee\r\n  >      let entityKey = employee.entityAspect.getKey();\r\n  >      let query = EntityQuery.fromEntityKey(entityKey);\r\n  @param entityKey - The [[EntityKey]] for which a query will be created.\r\n  **/\r\n  static fromEntityKey(entityKey: EntityKey) {\r\n    assertParam(entityKey, \"entityKey\").isInstanceOf(EntityKey).check();\r\n    let q = new EntityQuery(entityKey.entityType.defaultResourceName);\r\n    let pred = buildKeyPredicate(entityKey);\r\n    q = q.where(pred).toType(entityKey.entityType);\r\n    return q;\r\n  }\r\n\r\n  /**\r\n  Creates an EntityQuery for the specified entity and [[NavigationProperty]].\r\n  >      // 'employee' is a previously queried employee\r\n  >      let ordersNavProp = employee.entityType.getProperty(\"Orders\");\r\n  >      let query = EntityQuery.fromEntityNavigation(employee, ordersNavProp);\r\n\r\n  will return a query for the \"Orders\" of the specified 'employee'.\r\n  @param entity - The Entity whose navigation property will be queried.\r\n  @param navigationProperty - The [[NavigationProperty]] or name of the NavigationProperty to be queried.\r\n  **/\r\n  static fromEntityNavigation = function (entity: Entity, navigationProperty: NavigationProperty | string) {\r\n    assertParam(entity, \"entity\").isEntity().check();\r\n    let navProperty = entity.entityType._checkNavProperty(navigationProperty);\r\n    let q = new EntityQuery(navProperty.entityType.defaultResourceName);\r\n    let pred = buildNavigationPredicate(entity, navProperty);\r\n    if (pred == null) {\r\n      throw new Error(\"Unable to create a NavigationQuery for navigationProperty: \" + navProperty.name );\r\n    }\r\n    q = q.where(pred);\r\n    let em = entity.entityAspect.entityManager;\r\n    return em ? q.using(em) : q;\r\n  };\r\n\r\n  // protected methods\r\n  /** @hidden @internal */\r\n  _getFromEntityType(metadataStore: MetadataStore, throwErrorIfNotFound?: boolean) {\r\n    // Uncomment next two lines if we make this method public.\r\n    // assertParam(metadataStore, \"metadataStore\").isInstanceOf(MetadataStore).check();\r\n    // assertParam(throwErrorIfNotFound, \"throwErrorIfNotFound\").isBoolean().isOptional().check();\r\n    let entityType = this.fromEntityType;\r\n    if (entityType) return entityType;\r\n\r\n    let resourceName = this.resourceName;\r\n    if (!resourceName) {\r\n      throw new Error(\"There is no resourceName for this query\");\r\n    }\r\n\r\n    if (metadataStore.isEmpty()) {\r\n      if (throwErrorIfNotFound) {\r\n        throw new Error(\"There is no metadata available for this query. \" +\r\n          \"Are you querying the local cache before you've fetched metadata?\");\r\n      } else {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    let entityTypeName = metadataStore.getEntityTypeNameForResourceName(resourceName);\r\n    if (entityTypeName) {\r\n      entityType = metadataStore._getStructuralType(entityTypeName) as EntityType;\r\n    } else {\r\n      entityType = this._getToEntityType(metadataStore, true);\r\n    }\r\n\r\n    if (!entityType) {\r\n      if (throwErrorIfNotFound) {\r\n        throw new Error(core.formatString(\"Cannot find an entityType for resourceName: '%1'. \"\r\n          + \" Consider adding an 'EntityQuery.toType' call to your query or \"\r\n          + \"calling the MetadataStore.setEntityTypeForResourceName method to register an entityType for this resourceName.\", resourceName));\r\n      } else {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    this.fromEntityType = entityType;\r\n    return entityType;\r\n\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _getToEntityType(metadataStore: MetadataStore, skipFromCheck?: boolean): EntityType | undefined {\r\n    // skipFromCheck is to avoid recursion if called from _getFromEntityType;\r\n    if (this.resultEntityType instanceof EntityType) {\r\n      return this.resultEntityType;\r\n    } else if (this.resultEntityType) {\r\n      // resultEntityType is a string\r\n      this.resultEntityType = metadataStore._getStructuralType(this.resultEntityType, false) as EntityType;\r\n      return this.resultEntityType;\r\n    } else {\r\n      // resolve it, if possible, via the resourceName\r\n      // do not cache this value in this case\r\n      // cannot determine the resultEntityType if a selectClause is present.\r\n      // return skipFromCheck ? null : (!this.selectClause) && this._getFromEntityType(metadataStore, false);\r\n      if (skipFromCheck || this.selectClause) {\r\n        return undefined;\r\n      } else {\r\n        this._getFromEntityType(metadataStore, false);\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  // for testing\r\n  _toUri(em: EntityManager) {\r\n    let ds = DataService.resolve([em.dataService]);\r\n    return ds!.uriBuilder!.buildUri(this, em.metadataStore);\r\n  }\r\n\r\n}\r\nEntityQuery.prototype._$typeName = \"EntityQuery\";\r\n\r\n// private functions\r\n\r\nfunction fromJSON(eq: EntityQuery, json: Object) {\r\n  core.toJson(json, {\r\n    \"resourceName,from\": null,\r\n    // just the name comes back and will be resolved later\r\n    \"resultEntityType,toType\": null,\r\n    \"wherePredicate,where\": function (v: any) {\r\n      return v ? new Predicate(v) : undefined;\r\n    },\r\n    \"orderByClause,orderBy\": function (v: any) {\r\n      return v ? new OrderByClause(v) : undefined;\r\n    },\r\n    \"selectClause,select\": function (v: any) {\r\n      return v ? new SelectClause(v) : undefined;\r\n    },\r\n    \"expandClause,expand\": function (v: any) {\r\n      return v ? new ExpandClause(v) : undefined;\r\n    },\r\n    \"skipCount,skip\": null,\r\n    \"takeCount,take\": null,\r\n    parameters: function (v: any) {\r\n      return core.isEmpty(v) ? undefined : v;\r\n    },\r\n    \"inlineCountEnabled,inlineCount\": false,\r\n    \"noTrackingEnabled,noTracking\": false,\r\n    queryOptions: function (v: any) {\r\n      return v ? QueryOptions.fromJSON(v) : undefined;\r\n    }\r\n  }, eq);\r\n  return eq;\r\n}\r\n\r\nfunction clone(eq: EntityQuery, propName?: string, value?: any) {\r\n  // immutable queries mean that we don't need to clone if no change in value.\r\n  if (propName) {\r\n    if (eq[propName] === value) return eq;\r\n  }\r\n  // copying QueryOptions is safe because they are are immutable;\r\n  let copy = core.extend(new EntityQuery(), eq, [\r\n    \"resourceName\",\r\n    \"fromEntityType\",\r\n    \"wherePredicate\",\r\n    \"orderByClause\",\r\n    \"selectClause\",\r\n    \"skipCount\",\r\n    \"takeCount\",\r\n    \"expandClause\",\r\n    \"inlineCountEnabled\",\r\n    \"noTrackingEnabled\",\r\n    \"usesNameOnServer\",\r\n    \"queryOptions\",\r\n    \"entityManager\",\r\n    \"dataService\",\r\n    \"resultEntityType\"\r\n  ]) as EntityQuery;\r\n  copy.parameters = core.extend({}, eq.parameters);\r\n  if (propName) {\r\n    copy[propName] = value;\r\n  }\r\n  return copy;\r\n}\r\n\r\nfunction processUsing(eq: EntityQuery, map: Object, value: any, propertyName?: string) {\r\n  let typeName = value._$typeName || ((value instanceof BreezeEnum) && (value.constructor as any).name);\r\n  let key = typeName && typeName.substr(0, 1).toLowerCase() + typeName.substr(1);\r\n  if (propertyName && key !== propertyName) {\r\n    throw new Error(\"Invalid value for property: \" + propertyName);\r\n  }\r\n  if (key) {\r\n    let fn = map[key];\r\n    if (fn === undefined) {\r\n      throw new Error(\"Invalid config property: \" + key);\r\n    } else if (fn === null) {\r\n      eq[key] = value;\r\n    } else {\r\n      fn(eq, value);\r\n    }\r\n  } else {\r\n    core.objectForEach(value, (propName, val) => {\r\n      processUsing(eq, map, val, propName);\r\n    });\r\n  }\r\n}\r\n\r\nfunction normalizePropertyPaths(propertyPaths: string | string[]) {\r\n  assertParam(propertyPaths, \"propertyPaths\").isOptional().isString().or().isArray().isString().check();\r\n  if (typeof propertyPaths === 'string') {\r\n    propertyPaths = propertyPaths.split(\",\");\r\n  }\r\n\r\n  propertyPaths = propertyPaths.map(function (pp) {\r\n    return pp.trim();\r\n  });\r\n  return propertyPaths;\r\n}\r\n\r\nfunction buildPredicate(entity: Entity) {\r\n  let entityType = entity.entityType;\r\n  let predParts = entityType.keyProperties.map(function (kp) {\r\n    return Predicate.create(kp.name, FilterQueryOp.Equals, entity.getProperty(kp.name));\r\n  });\r\n  let pred = Predicate.and(predParts);\r\n  return pred;\r\n}\r\n\r\nfunction buildKeyPredicate(entityKey: EntityKey) {\r\n  let keyProps = entityKey.entityType.keyProperties;\r\n  let preds = core.arrayZip(keyProps, entityKey.values, function (kp, v) {\r\n    return Predicate.create(kp.name, FilterQueryOp.Equals, v);\r\n  });\r\n  let pred = Predicate.and(preds);\r\n  return pred;\r\n}\r\n\r\nfunction buildNavigationPredicate(entity: Entity, navigationProperty: NavigationProperty) {\r\n  if (navigationProperty.isScalar) {\r\n    if (navigationProperty.foreignKeyNames.length === 0) return null;\r\n    let relatedKeyValues = navigationProperty.foreignKeyNames.map((fkName) => {\r\n      return entity.getProperty(fkName);\r\n    });\r\n    let entityKey = new EntityKey(navigationProperty.entityType, relatedKeyValues);\r\n    return buildKeyPredicate(entityKey);\r\n  } else {\r\n    let inverseNp = navigationProperty.inverse;\r\n    let foreignKeyNames = inverseNp ? inverseNp.foreignKeyNames : navigationProperty.invForeignKeyNames;\r\n    if (foreignKeyNames.length === 0) return null;\r\n    let keyValues = entity.entityAspect.getKey().values;\r\n    let predParts = core.arrayZip(foreignKeyNames, keyValues, (fkName, kv) => {\r\n      return Predicate.create(fkName, FilterQueryOp.Equals, kv);\r\n    });\r\n    return Predicate.and(predParts);\r\n  }\r\n}\r\n\r\n/** Base class for BooleanQueryOp and FilterQueryOp */\r\nexport interface QueryOp {\r\n  /** The operator for this enum. */\r\n  operator: string;\r\n}\r\n\r\n\r\n\r\n/**\r\nFilterQueryOp is an 'Enum' containing all of the valid  [[Predicate]]\r\nfilter operators for an [[EntityQuery]].\r\n**/\r\nexport class FilterQueryOp extends BreezeEnum implements QueryOp {\r\n  /** The operator for this enum. */\r\n  operator: string;\r\n\r\n  /** Aliases: \"eq\", \"==\" **/\r\n  static Equals = new FilterQueryOp({ operator: \"eq\" });\r\n  /**  Aliases: \"ne\", \"!=\"  **/\r\n  static NotEquals = new FilterQueryOp({ operator: \"ne\" });\r\n  /** Aliases: \"gt\", \">\"   **/\r\n  static GreaterThan = new FilterQueryOp({ operator: \"gt\" });\r\n  /** Aliases: \"lt\", \"<\"  **/\r\n  static LessThan = new FilterQueryOp({ operator: \"lt\" });\r\n  /**  Aliases: \"ge\", \">=\"  **/\r\n  static GreaterThanOrEqual = new FilterQueryOp({ operator: \"ge\" });\r\n  /**  Aliases: \"le\", \"<=\"  **/\r\n  static LessThanOrEqual = new FilterQueryOp({ operator: \"le\" });\r\n  /**  String operation: Is a string a substring of another string.  Aliases: \"substringof\"   **/\r\n  static Contains = new FilterQueryOp({ operator: \"contains\" });\r\n  /** No aliases */\r\n  static StartsWith = new FilterQueryOp({ operator: \"startswith\" });\r\n  /** No aliases */\r\n  static EndsWith = new FilterQueryOp({ operator: \"endswith\" });\r\n  /**  Aliases: \"some\"  **/\r\n  static Any = new FilterQueryOp({ operator: \"any\" });\r\n  /**  Aliases: \"every\"  **/\r\n  static All = new FilterQueryOp({ operator: \"all\" });\r\n  /** No aliases */\r\n  static In = new FilterQueryOp({ operator: \"in\" });\r\n  /** No aliases */\r\n  static IsTypeOf = new FilterQueryOp({ operator: \"isof\" });\r\n}\r\nFilterQueryOp.prototype._$typeName = \"FilterQueryOp\";\r\nError['x'] = FilterQueryOp.resolveSymbols();\r\n\r\n\r\n/**\r\n BooleanQueryOp is an 'Enum' containing all of the valid  boolean\r\noperators for an [[EntityQuery]].\r\n**/\r\nexport class BooleanQueryOp extends BreezeEnum implements QueryOp {\r\n  /** The operator for this enum. */\r\n  operator: string;\r\n\r\n  static And = new BooleanQueryOp({ operator: \"and\" });\r\n  static Or = new BooleanQueryOp({ operator: \"or\" });\r\n  static Not = new BooleanQueryOp({ operator: \"not\" });\r\n\r\n}\r\nBooleanQueryOp.prototype._$typeName = \"BooleanQueryOp\";\r\nError['x'] = BooleanQueryOp.resolveSymbols();\r\n\r\n\r\n/** For use by breeze plugin authors only.  The class is used in most [[IUriBuilderAdapter]] implementations\r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden\r\n\r\nAn OrderByClause is a description of the properties and direction that the result\r\nof a query should be sorted in.  OrderByClauses are immutable, which means that any\r\nmethod that would modify an OrderByClause actually returns a new OrderByClause.\r\n\r\nFor example for an Employee object with properties of 'Company' and 'LastName' the following would be valid expressions:\r\n>     let obc = new OrderByClause(\"Company.CompanyName, LastName\")\r\n\r\nor\r\n>     let obc = new OrderByClause(\"Company.CompanyName desc, LastName\")\r\n\r\nor\r\n>     let obc = new OrderByClause(\"Company.CompanyName, LastName\", true);\r\n*/\r\nexport class OrderByClause {\r\n  /** @hidden @internal */\r\n  items: OrderByItem[];\r\n\r\n  constructor(propertyPaths: string[] | OrderByClause[], isDesc?: boolean) {\r\n    if (propertyPaths.length === 0) {\r\n      throw new Error(\"OrderByClause cannot be empty\");\r\n    }\r\n\r\n    // you can also pass in an array of orderByClauses\r\n    if (propertyPaths[0] instanceof OrderByClause) {\r\n      let clauses = propertyPaths as OrderByClause[];\r\n      this.items = core.arrayFlatMap(clauses, c => c.items);\r\n      // this.items = Array.prototype.concat.apply(clauses[0].items, clauses.slice(1).map(core.pluck(\"items\")));\r\n      // this.items = Array.prototype.concat.apply([], clauses.map(core.pluck(\"items\")));\r\n    } else {\r\n      this.items = (propertyPaths as string[]).map(function (pp) {\r\n        return new OrderByItem(pp, isDesc);\r\n      });\r\n    }\r\n\r\n  }\r\n\r\n  validate(entityType: EntityType) {\r\n    if (entityType == null || entityType.isAnonymous) return;\r\n    this.items.forEach((item) => {\r\n      item.validate(entityType);\r\n    });\r\n  }\r\n\r\n  getComparer(entityType: EntityType) {\r\n    let orderByFuncs = this.items.map(function (obc) {\r\n      return obc.getComparer(entityType);\r\n    });\r\n    return function (entity1: any, entity2: any) {\r\n      for (let i = 0; i < orderByFuncs.length; i++) {\r\n        let result = orderByFuncs[i](entity1, entity2);\r\n        if (result !== 0) {\r\n          return result;\r\n        }\r\n      }\r\n      return 0;\r\n    };\r\n  }\r\n\r\n  toJSONExt(context: EntityQueryJsonContext) {\r\n    return this.items.map(function (item) {\r\n      return context.propertyPathFn!(item.propertyPath) + (item.isDesc ? \" desc\" : \"\");\r\n    });\r\n  }\r\n\r\n}\r\n\r\n/** @hidden @internal */\r\nexport class OrderByItem {\r\n  propertyPath: string;\r\n  isDesc: boolean;\r\n  lastProperty: EntityProperty;\r\n\r\n  constructor(propertyPath: string, isDesc?: boolean) {\r\n    if (!(typeof propertyPath === 'string')) {\r\n      throw new Error(\"propertyPath is not a string\");\r\n    }\r\n    propertyPath = propertyPath.trim();\r\n\r\n    let parts = propertyPath.split(' ');\r\n    // parts[0] is the propertyPath; [1] would be whether descending or not.\r\n    // if (parts.length > 1 && isDesc !== true && isDesc !== false) {\r\n    if (parts.length > 1 && isDesc == null) {\r\n      isDesc = core.stringStartsWith(parts[1].toLowerCase(), \"desc\");\r\n      if (!isDesc) {\r\n        // isDesc is false but check to make sure its intended.\r\n        let isAsc = core.stringStartsWith(parts[1].toLowerCase(), \"asc\");\r\n        if (!isAsc) {\r\n          throw new Error(\"the second word in the propertyPath must begin with 'desc' or 'asc'\");\r\n        }\r\n\r\n      }\r\n    }\r\n    this.propertyPath = parts[0];\r\n    this.isDesc = isDesc || false;\r\n  }\r\n\r\n  validate(entityType: EntityType): EntityProperty | undefined {\r\n    if (entityType == null || entityType.isAnonymous) return;\r\n    // will throw an exception on bad propertyPath\r\n    this.lastProperty = entityType.getProperty(this.propertyPath, true) as EntityProperty;\r\n    return this.lastProperty;\r\n  }\r\n\r\n  getComparer(entityType: EntityType) {\r\n    let propDataType: DataType;\r\n    let isCaseSensitive: boolean;\r\n    if (!this.lastProperty) this.validate(entityType);\r\n    if (this.lastProperty) {\r\n      propDataType = (this.lastProperty as any).dataType;\r\n      isCaseSensitive = this.lastProperty.parentType.metadataStore.localQueryComparisonOptions.isCaseSensitive;\r\n    }\r\n\r\n    let propertyPath = this.propertyPath;\r\n    let isDesc = this.isDesc;\r\n\r\n    return function (entity1: any, entity2: any) {\r\n      let value1 = EntityAspect.getPropertyPathValue(entity1, propertyPath);\r\n      let value2 = EntityAspect.getPropertyPathValue(entity2, propertyPath);\r\n      let dataType = propDataType || (value1 && DataType.fromValue(value1)) || DataType.fromValue(value2);\r\n      if (dataType === DataType.String) {\r\n        if (isCaseSensitive) {\r\n          value1 = value1 || \"\";\r\n          value2 = value2 || \"\";\r\n        } else {\r\n          value1 = (value1 || \"\").toLowerCase();\r\n          value2 = (value2 || \"\").toLowerCase();\r\n        }\r\n      } else {\r\n        let normalize = DataType.getComparableFn(dataType);\r\n        value1 = normalize(value1);\r\n        value2 = normalize(value2);\r\n      }\r\n      if (value1 === value2) {\r\n        return 0;\r\n      } else if (value1 > value2 || value2 === undefined) {\r\n        return isDesc ? -1 : 1;\r\n      } else {\r\n        return isDesc ? 1 : -1;\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n/** For use by breeze plugin authors only.  The class is used in most [[IUriBuilderAdapter]] implementations\r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden \r\n**/\r\nexport class SelectClause {\r\n  propertyPaths: string[];\r\n  /** @hidden @internal */\r\n  _pathNames: string[];\r\n\r\n  constructor(propertyPaths: string[]) {\r\n    this.propertyPaths = propertyPaths;\r\n    this._pathNames = propertyPaths.map(function (pp) {\r\n      return pp.replace(\".\", \"_\");\r\n    });\r\n  }\r\n\r\n  validate(entityType: EntityType) {\r\n    if (entityType == null || entityType.isAnonymous) return; // can't validate yet\r\n    // will throw an exception on bad propertyPath\r\n    this.propertyPaths.forEach(function (path) {\r\n      entityType.getProperty(path, true);\r\n    });\r\n  }\r\n\r\n  toFunction(/* config */) {\r\n    let that = this;\r\n    return function (entity: Entity) {\r\n      let result = {};\r\n      that.propertyPaths.forEach(function (path, i) {\r\n        result[that._pathNames[i]] = EntityAspect.getPropertyPathValue(entity, path);\r\n      });\r\n      return result;\r\n    };\r\n  }\r\n\r\n  toJSONExt(context: EntityQueryJsonContext) {\r\n    return this.propertyPaths.map(function (pp) {\r\n      return context.propertyPathFn!(pp);\r\n    });\r\n  }\r\n}\r\n\r\n/** For use by breeze plugin authors only.  The class is used in most [[IUriBuilderAdapter]] implementations\r\n@adapter (see [[IUriBuilderAdapter]])    \r\n@hidden \r\n**/\r\nexport class ExpandClause {\r\n  propertyPaths: string[];\r\n\r\n  constructor(propertyPaths: string[]) {\r\n    this.propertyPaths = propertyPaths;\r\n  }\r\n\r\n  toJSONExt(context: EntityQueryJsonContext) {\r\n    return this.propertyPaths.map(function (pp) {\r\n      return context.propertyPathFn!(pp);\r\n    });\r\n  }\r\n\r\n}\r\n\r\n\r\n","import { core } from './core';\r\nimport { config } from './config';\r\nimport { BreezeEvent } from './event';\r\nimport { assertParam } from './assert-param';\r\nimport { EntityState  } from './entity-state';\r\nimport { EntityAction } from './entity-action';\r\nimport { EntityType, ComplexType, DataProperty, NavigationProperty, EntityProperty } from './entity-metadata';\r\nimport { EntityKey } from './entity-key';\r\nimport { EntityGroup } from './entity-group';\r\nimport { EntityManager, QueryResult, QueryErrorCallback, QuerySuccessCallback } from './entity-manager';\r\nimport { Validator, ValidationError } from './validate';\r\nimport { EntityQuery } from './entity-query';\r\n\r\nexport interface Entity {\r\n  entityAspect: EntityAspect;\r\n  entityType: EntityType;\r\n  /** @internal */\r\n  getProperty?(prop: string): any;\r\n  /** @internal */\r\n  setProperty?(prop: any, value: any): void;\r\n  /** @hidden @internal */\r\n  prototype?: { _$typeName: string };\r\n  /** @hidden @internal */\r\n  _$entityType?: EntityType;\r\n}\r\n\r\nexport interface ComplexObject {\r\n  complexAspect: ComplexAspect;\r\n  complexType: ComplexType;\r\n  getProperty(prop: string): any;\r\n  setProperty(prop: any, value: any): void;\r\n  /** @hidden @internal */\r\n  prototype?: { _$typeName: string };\r\n}\r\n\r\nexport type StructuralObject = Entity | ComplexObject;\r\n\r\nexport interface PropertyChangedEventArgs {\r\n  entity: Entity;\r\n  propertyName: string | null;\r\n  parent?: StructuralObject;\r\n  property?: EntityProperty;\r\n  oldValue?: any;\r\n  newValue?: any;\r\n}\r\n\r\nexport interface ValidationErrorsChangedEventArgs {\r\n  entity: Entity;\r\n  added: ValidationError[];\r\n  removed: ValidationError[];\r\n}\r\n\r\n/**\r\nAn EntityAspect instance is associated with every attached entity and is accessed via the entity's 'entityAspect' property.\r\n\r\nThe EntityAspect itself provides properties to determine and modify the EntityState of the entity and has methods\r\nthat provide a variety of services including validation and change tracking.\r\n\r\nAn EntityAspect will almost never need to be constructed directly. You will usually get an EntityAspect by accessing\r\nan entities 'entityAspect' property.  This property will be automatically attached when an entity is created via either\r\na query, import or [[EntityManager.createEntity]] call.\r\n>      // assume order is an order entity attached to an EntityManager.\r\n>      var aspect = order.entityAspect;\r\n>      var currentState = aspect.entityState;\r\n\r\n**/\r\nexport class EntityAspect {\r\n  /** The Entity that this aspect is associated with. __Read Only__  **/\r\n  entity?: Entity;\r\n  /** The [[EntityManager]] that contains this entity. __Read Only__ **/\r\n  entityManager?: EntityManager;\r\n  /**  @hidden @internal */\r\n  entityGroup?: EntityGroup;\r\n  /** The [[EntityState]] of this entity. __Read Only__ **/\r\n  entityState: EntityState;\r\n  /**   Whether this entity is in the process of being saved. __Read Only__ */\r\n  isBeingSaved: boolean;\r\n  /** The 'original values' of this entity where they are different from the 'current values'.\r\n  This is a map where the key is a property name and the value is the 'original value' of the property. */\r\n  originalValues: {};\r\n  /**  Whether this entity has any validation errors. __Read Only__ */\r\n  hasValidationErrors: boolean;\r\n  /** Whether this entity has a temporary [[EntityKey]]. */\r\n  hasTempKey: boolean;\r\n  /** Whether this entity was created by being loaded from the database */\r\n  wasLoaded?: boolean;\r\n  /** Extra metadata about this entity such as the entity's etag.\r\n  You may extend this object with your own metadata information.\r\n  Breeze (de)serializes this object when importing/exporting the entity. **/\r\n  extraMetadata?: any;\r\n  /**\r\n  A [[BreezeEvent]] that fires whenever any of the validation errors on this entity change.\r\n  Note that this might be the removal of an error when some data on the entity is fixed.\r\n  @eventArgs - \r\n    - entity - The entity on which the validation errors are being added or removed.\r\n    - added - An array containing any newly added [[ValidationError]]s\r\n    - removed - An array containing any newly removed [[ValidationError]]s. This is those\r\n      errors that have been 'fixed'.\r\n\r\n>      // assume order is an order entity attached to an EntityManager.\r\n>      order.entityAspect.validationErrorsChanged.subscribe(\r\n>      function (validationChangeArgs) {\r\n>          // this code will be executed anytime a property value changes on the 'order' entity.\r\n>          var entity == validationChangeArgs.entity; // Note: entity === order\r\n>          var errorsAdded = validationChangeArgs.added;\r\n>          var errorsCleared = validationChangeArgs.removed;\r\n>      });\r\n  @event\r\n  **/\r\n  validationErrorsChanged: BreezeEvent<ValidationErrorsChangedEventArgs>;\r\n  /**\r\n  A [[BreezeEvent]] that fires whenever a value of one of this entity's properties change.\r\n  @eventArgs -\r\n    - entity - The entity whose property has changed.\r\n    - property - The [[DataProperty]] that changed.\r\n    - propertyName - The name of the property that changed. This value will be 'null' for operations that replace the entire entity.  This includes\r\n      queries, imports and saves that require a merge. The remaining parameters will not exist in this case either. This will actually be a \"property path\"\r\n      for any properties of a complex type.\r\n    - oldValue - The old value of this property before the change.\r\n    - newValue - The new value of this property after the change.\r\n    - parent - The immediate parent object for the changed property.  This will be a ComplexType instance as opposed to an Entity \r\n      for any complex type or nested complex type properties.\r\n\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      order.entityAspect.propertyChanged.subscribe(\r\n  >      function (propertyChangedArgs) {\r\n  >          // this code will be executed anytime a property value changes on the 'order' entity.\r\n  >          var entity = propertyChangedArgs.entity; // Note: entity === order\r\n  >          var propertyNameChanged = propertyChangedArgs.propertyName;\r\n  >          var oldValue = propertyChangedArgs.oldValue;\r\n  >          var newValue = propertyChangedArgs.newValue;\r\n  >      });\r\n  @event\r\n  **/\r\n  propertyChanged: BreezeEvent<PropertyChangedEventArgs>;\r\n\r\n  /** @hidden @internal */\r\n  _validationErrors: { [index: string]: ValidationError };\r\n  /** @hidden @internal */\r\n  _pendingValidationResult: any;\r\n  /** @hidden @internal */\r\n  _entityKey: EntityKey;\r\n  /** @hidden @internal */\r\n  _loadedNps: any[];\r\n  /** @hidden @internal */\r\n  _initialized?: boolean;\r\n  /** @hidden @internal */\r\n  _inProcess: any[]; // used in defaultPropertyInterceptor for temp storage.\r\n  /** @hidden @internal */\r\n  _inProcessEntity?: Entity; // used in EntityManager\r\n  /** @hidden @internal */\r\n  static _nullInstance = new EntityAspect(); // TODO: determine if this works\r\n  /** @hidden @internal */\r\n  constructor(entity?: Entity) {\r\n\r\n    // if called without new\r\n    // if (!(this instanceof EntityAspect)) {\r\n    //   return new EntityAspect(entity);\r\n    // }\r\n\r\n    this.entity = entity;\r\n    // TODO: keep public or not?\r\n    this.entityGroup = undefined;\r\n    this.entityManager = undefined;\r\n    this.entityState = EntityState.Detached;\r\n    this.isBeingSaved = false;\r\n    this.originalValues = {};\r\n    this.hasValidationErrors = false;\r\n    this._validationErrors = {};\r\n\r\n    // Uncomment when we implement entityAspect.isNavigationPropertyLoaded method\r\n    // this._loadedNavPropMap = {};\r\n\r\n    this.validationErrorsChanged = new BreezeEvent(\"validationErrorsChanged\", this);\r\n    this.propertyChanged = new BreezeEvent(\"propertyChanged\", this);\r\n    // in case this is the NULL entityAspect. - used with ComplexAspects that have no parent.\r\n\r\n    if (entity != null) {\r\n      // remove properties that should be on prototype but placed on class by Babel\r\n      if (!entity.entityType) { delete(entity.entityType); }\r\n      if (!entity.entityAspect) { delete(entity.entityAspect); }\r\n      entity.entityAspect = this;\r\n\r\n      // entityType should already be on the entity from 'watch'\r\n      let entityType = entity.entityType || entity._$entityType;\r\n      if (!entityType) {\r\n        let typeName = entity.prototype._$typeName;\r\n        if (!typeName) {\r\n          throw new Error(\"This entity is not registered as a valid EntityType\");\r\n        } else {\r\n          throw new Error(\"Metadata for this entityType has not yet been resolved: \" + typeName);\r\n        }\r\n      }\r\n      let entityCtor = entityType.getEntityCtor();\r\n      config.interfaceRegistry.modelLibrary.getDefaultInstance().startTracking(entity, entityCtor.prototype);\r\n    }\r\n  }\r\n\r\n  /** @hidden */\r\n  // type-guard\r\n  static isEntity(obj: StructuralObject): obj is Entity {\r\n    return (obj as any).entityAspect != null;\r\n  }\r\n\r\n  // No longer used\r\n  // static createFrom(entity: Entity): EntityAspect {\r\n  //   if (entity == null) {\r\n  //     return EntityAspect._nullInstance;\r\n  //   } else if (entity.entityAspect) {\r\n  //     return entity.entityAspect;\r\n  //   }\r\n  //   return new EntityAspect(entity);\r\n  // }\r\n\r\n  // TODO: refactor this and the instance getPropertyValue method.\r\n  /**\r\n  Returns the value of a specified 'property path' for a specified entity.\r\n\r\n  The propertyPath can be either a string delimited with '.' or a string array.  \r\n  **/\r\n  // used by EntityQuery and Predicate\r\n  static getPropertyPathValue(obj: Entity, propertyPath: string | string[]) {\r\n    let properties = Array.isArray(propertyPath) ? propertyPath : propertyPath.split(\".\");\r\n    if (properties.length === 1) {\r\n      return obj.getProperty(propertyPath as string);\r\n    } else {\r\n      let nextValue = obj;\r\n      // hack use of some to perform mapFirst operation.\r\n      properties.some((prop) => {\r\n        nextValue = nextValue.getProperty(prop);\r\n        return nextValue == null;\r\n      });\r\n      return nextValue;\r\n    }\r\n  }\r\n\r\n  /**\r\n  Returns the [[EntityKey]] for this Entity.\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      var entityKey = order.entityAspect.getKey();\r\n  @param forceRefresh - (boolean=false) Forces the recalculation of the key.  This should normally be unnecessary.\r\n  @return The [[EntityKey]] associated with this Entity.\r\n  **/\r\n  getKey(forceRefresh: boolean = false) {\r\n    forceRefresh = assertParam(forceRefresh, \"forceRefresh\").isBoolean().isOptional().check(false);\r\n    if (forceRefresh || !this._entityKey) {\r\n      let entityType = this.entity!.entityType;\r\n      let keyProps = entityType.keyProperties;\r\n      let values = keyProps.map(function (p) {\r\n        return this.entity.getProperty(p.name);\r\n      }, this);\r\n      this._entityKey = new EntityKey(entityType, values);\r\n    }\r\n    return this._entityKey;\r\n  }\r\n\r\n  /**\r\n  Returns the entity to an [[EntityState]] of 'Unchanged' by committing all changes made since the entity was last queried\r\n  had 'acceptChanges' called on it.\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      order.entityAspect.acceptChanges();\r\n  >      // The 'order' entity will now be in an 'Unchanged' state with any changes committed.\r\n  **/\r\n  acceptChanges() {\r\n    if (!this.entity) return;\r\n    this._checkOperation(\"acceptChanges\");\r\n    let em = this.entityManager!;\r\n    if (this.entityState.isDeleted()) {\r\n      em.detachEntity(this.entity);\r\n    } else {\r\n      this.setUnchanged();\r\n    }\r\n    em.entityChanged.publish({ entityAction: EntityAction.AcceptChanges, entity: this.entity });\r\n  }\r\n\r\n  /**\r\n  Returns the entity to an [[EntityState]] of 'Unchanged' by rejecting all changes made to it since the entity was last queried\r\n  had 'rejectChanges' called on it.\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      order.entityAspect.rejectChanges();\r\n  >      // The 'order' entity will now be in an 'Unchanged' state with any changes rejected.\r\n  **/\r\n  rejectChanges() {\r\n    this._checkOperation(\"rejectChanges\");\r\n    let entity = this.entity!;\r\n    let entityManager = this.entityManager!;\r\n    // we do not want PropertyChange or EntityChange events to occur here\r\n    core.using(entityManager, \"isRejectingChanges\", true, function () {\r\n      rejectChangesCore(entity);\r\n    });\r\n    if (this.entityState.isAdded()) {\r\n      // next line is needed because the following line will cause this.entityManager -> null;\r\n      entityManager.detachEntity(entity);\r\n      // need to tell em that an entity that needed to be saved no longer does.\r\n      entityManager._notifyStateChange(entity, false);\r\n    } else {\r\n      if (this.entityState.isDeleted()) {\r\n        entityManager._linkRelatedEntities(entity);\r\n      }\r\n      this.setUnchanged();\r\n      // propertyChanged propertyName is not specified because more than one property may have changed.\r\n      this.propertyChanged.publish({ entity: entity, propertyName: null });\r\n      entityManager.entityChanged.publish({ entityAction: EntityAction.RejectChanges, entity: entity });\r\n    }\r\n  }\r\n\r\n  /**  @hidden @internal */\r\n  // TODO: rename - and use '_'; used on both EntityAspect and ComplexAspect for polymorphic reasons.\r\n  getPropertyPath(propName: string) {\r\n    return propName;\r\n  }\r\n\r\n  /**\r\n  Sets the entity to an EntityState of 'Added'.  This is NOT the equivalent of calling [[EntityManager.addEntity]]\r\n  because no key generation will occur for autogenerated keys as a result of this operation. As a result this operation can be problematic\r\n  unless you are certain that the entity being marked 'Added' does not already exist in the database and does not have an autogenerated key.\r\n  The same operation can be performed by calling [[EntityAspect.setEntityState]].\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      order.entityAspect.setAdded();\r\n  >      // The 'order' entity will now be in an 'Added' state.\r\n  **/\r\n  setAdded() {\r\n    return this.setEntityState(EntityState.Added);\r\n  }\r\n\r\n  /**\r\n  Sets the entity to an EntityState of 'Unchanged'.  This is also the equivalent of calling [[EntityAspect.acceptChanges]].\r\n  The same operation can be performed by calling [[EntityAspect.setEntityState]].\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      order.entityAspect.setUnchanged();\r\n  >      // The 'order' entity will now be in an 'Unchanged' state with any changes committed.\r\n  **/\r\n  setUnchanged = function () {\r\n    return this.setEntityState(EntityState.Unchanged);\r\n  };\r\n\r\n\r\n  /**\r\n  Sets the entity to an EntityState of 'Modified'.  This can also be achieved by changing the value of any property on an 'Unchanged' entity.\r\n  The same operation can be performed by calling [[EntityAspect.setEntityState]].\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      order.entityAspect.setModified();\r\n  >      // The 'order' entity will now be in a 'Modified' state.\r\n  **/\r\n  setModified = function () {\r\n    return this.setEntityState(EntityState.Modified);\r\n  };\r\n\r\n  /**\r\n  Sets the entity to an EntityState of 'Deleted'.  This both marks the entity as being scheduled for deletion during the next 'Save' call\r\n  but also removes the entity from all of its related entities.\r\n  The same operation can be performed by calling [[EntityAspect.setEntityState]].\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      order.entityAspect.setDeleted();\r\n  >      // The 'order' entity will now be in a 'Deleted' state and it will no longer have any 'related' entities.\r\n  **/\r\n  setDeleted = function () {\r\n    return this.setEntityState(EntityState.Deleted);\r\n  };\r\n\r\n  /**\r\n  Sets the entity to an EntityState of 'Detached'.  This removes the entity from all of its related entities, but does NOT change the EntityState of any existing entities.\r\n  The same operation can be performed by calling [[EntityAspect.setEntityState]].\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      order.entityAspect.setDetached();\r\n  >      // The 'order' entity will now be in a 'Detached' state and it will no longer have any 'related' entities.\r\n  **/\r\n  setDetached = function () {\r\n    return this.setEntityState(EntityState.Detached);\r\n  };\r\n\r\n  /**\r\n  Sets the entity to the specified EntityState. See also 'setUnchanged', 'setModified', 'setDetached', etc.\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      order.entityAspect.setEntityState(EntityState.Unchanged);\r\n  >      // The 'order' entity will now be in a 'Unchanged' state.\r\n  **/\r\n  setEntityState(entityState: EntityState) {\r\n    if (this.entityState === entityState) return false;\r\n    this._checkOperation(\"setEntityState\");\r\n    if (this.entityState.isDetached()) {\r\n      throw new Error(\"You cannot set the 'entityState' of an entity when it is detached - except by first attaching it to an EntityManager\");\r\n    }\r\n    let entity = this.entity!;\r\n    let em = this.entityManager!;\r\n    let needsSave = true;\r\n    if (entityState === EntityState.Unchanged) {\r\n      clearOriginalValues(entity);\r\n      delete this.hasTempKey;\r\n      needsSave = false;\r\n    } else if (entityState === EntityState.Added) {\r\n      clearOriginalValues(entity);\r\n      // TODO: more to do here... like regenerating key ???\r\n    } else if (entityState === EntityState.Deleted) {\r\n      if (this.entityState.isAdded()) {\r\n        // turn it into a detach and exit early\r\n        this.setEntityState(EntityState.Detached);\r\n        return true;\r\n      } else {\r\n        // TODO: think about cascade deletes\r\n        // entityState needs to be set it early in this one case to insure that fk's are not cleared.\r\n        this.entityState = EntityState.Deleted;\r\n        removeFromRelations(entity, EntityState.Deleted);\r\n      }\r\n    } else if (entityState === EntityState.Modified) {\r\n      // nothing extra needed\r\n    } else if (entityState === EntityState.Detached) {\r\n      let group = this.entityGroup;\r\n      // no group === already detached.\r\n      if (!group) return false;\r\n      group.detachEntity(entity);\r\n      // needs to occur early here - so this IS deliberately redundent with the same code later in this method.\r\n      this.entityState = entityState;\r\n      removeFromRelations(entity, EntityState.Detached);\r\n      this._detach();\r\n      em.entityChanged.publish({ entityAction: EntityAction.Detach, entity: entity });\r\n      needsSave = false;\r\n    }\r\n    this.entityState = entityState;\r\n    em._notifyStateChange(entity, needsSave);\r\n    return true;\r\n  }\r\n\r\n  loadNavigationProperty(navigationProperty: string, callback?: QuerySuccessCallback, errorCallback?: QueryErrorCallback): Promise<QueryResult>;\r\n  loadNavigationProperty(navigationProperty: NavigationProperty, callback?: QuerySuccessCallback, errorCallback?: QueryErrorCallback): Promise<QueryResult>;\r\n  /**\r\n  Performs a query for the value of a specified [[NavigationProperty]]. __Async__\r\n  >      emp.entityAspect.loadNavigationProperty(\"Orders\").then(function (data) {\r\n  >          var orders = data.results;\r\n  >      }).catch(function (exception) {\r\n  >          // handle exception here;\r\n  >      });\r\n  @param navigationProperty - The NavigationProperty or the name of the NavigationProperty to 'load'.\r\n  @param callback - Function to call on success.\r\n  @param errorCallback - Function to call on failure.\r\n  @return Promise with shape\r\n    - results {Array of Entity}\r\n    - query {EntityQuery} The original query\r\n    - httpResponse {httpResponse} The HttpResponse returned from the server.\r\n  **/\r\n  loadNavigationProperty(navigationProperty: NavigationProperty | string, callback: QuerySuccessCallback, errorCallback: QueryErrorCallback) {\r\n    let entity = this.entity!;\r\n    let navProperty = entity.entityType._checkNavProperty(navigationProperty);\r\n    let query = EntityQuery.fromEntityNavigation(entity, navProperty);\r\n    // return entity.entityAspect.entityManager.executeQuery(query, callback, errorCallback);\r\n    let promise = entity.entityAspect.entityManager!.executeQuery(query);\r\n\r\n    return promise.then((data) => {\r\n      this._markAsLoaded(navProperty.name);\r\n      if (callback) callback(data);\r\n      return Promise.resolve(data);\r\n    }, (error) => {\r\n      if (errorCallback) errorCallback(error);\r\n      return Promise.reject(error);\r\n    });\r\n\r\n  }\r\n\r\n  /**\r\n  Marks this navigationProperty on this entity as already having been loaded.\r\n  >      emp.entityAspect.markNavigationPropertyAsLoaded(\"Orders\");\r\n  @param navigationProperty - The NavigationProperty or name of NavigationProperty to 'load'.\r\n  **/\r\n  markNavigationPropertyAsLoaded(navigationProperty: NavigationProperty | string) {\r\n    if (!this.entity) return;\r\n    let navProperty = this.entity.entityType._checkNavProperty(navigationProperty);\r\n    this._markAsLoaded(navProperty.name);\r\n  }\r\n\r\n  isNavigationPropertyLoaded(navigationProperty: string): boolean;\r\n  isNavigationPropertyLoaded(navigationProperty: NavigationProperty): boolean;\r\n  /**\r\n  Determines whether a navigationProperty on this entity has already been loaded.\r\n\r\n  A navigation property is considered loaded when any of the following three conditions applies:\r\n\r\n    1. It was fetched from the backend server.\r\n        <br/>   This can be the result of an expand query or a call to the [[EntityAspect.loadNavigationProperty]] method.\r\n        <br/>   Note that even if the fetch returns nothing the property is still marked as loaded in this case.\r\n    1. The property is scalar and has been set to a nonnull value.\r\n    1. The [[EntityAspect.markNavigationPropertyAsLoaded]] was called.\r\n  \r\n  >     var wasLoaded = emp.entityAspect.isNavigationPropertyLoaded(\"Orders\");\r\n  @param navigationProperty - The NavigationProperty or name of NavigationProperty to 'load'.\r\n  **/\r\n  isNavigationPropertyLoaded(navigationProperty: NavigationProperty | string) {\r\n    if (!this.entity) return;\r\n    let navProperty = this.entity.entityType._checkNavProperty(navigationProperty);\r\n    if (navProperty.isScalar && this.entity.getProperty(navProperty.name) != null) {\r\n      return true;\r\n    }\r\n    return this._loadedNps && this._loadedNps.indexOf(navProperty.name) >= 0;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _markAsLoaded(navPropName: string) {\r\n    this._loadedNps = this._loadedNps || [];\r\n    core.arrayAddItemUnique(this._loadedNps, navPropName);\r\n  }\r\n\r\n\r\n  /**\r\n  Performs validation on the entity, any errors encountered during the validation are available via the\r\n  [[EntityAspect.getValidationErrors]] method. Validating an entity means executing\r\n  all of the validators on both the entity itself as well as those on each of its properties.\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      var isOk = order.entityAspect.validateEntity();\r\n  >      // isOk will be 'true' if there are no errors on the entity.\r\n  >      if (!isOk) {\r\n  >          var errors = order.entityAspect.getValidationErrors();\r\n  >      }\r\n  @return Whether the entity passed validation.\r\n  **/\r\n  validateEntity() {\r\n    let ok = true;\r\n    this._processValidationOpAndPublish(function (that: any) {\r\n      ok = validateTarget(that.entity);\r\n    });\r\n    return ok;\r\n  }\r\n\r\n  validateProperty(property: string, context?: any): boolean;\r\n  validateProperty(property: DataProperty, context?: any): boolean;\r\n  validateProperty(property: NavigationProperty, context?: any): boolean;\r\n  /**\r\n  Performs validation on a specific property of this entity, any errors encountered during the validation are available via the\r\n  [[EntityAspect.getValidationErrors]] method. Validating a property means executing\r\n  all of the validators on the specified property.  This call is also made automatically anytime a property\r\n  of an entity is changed.\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      var isOk = order.entityAspect.validateProperty(\"Order\");\r\n\r\n  or\r\n  >      var orderDateProperty = order.entityType.getProperty(\"OrderDate\");\r\n  >      var isOk = order.entityAspect.validateProperty(OrderDateProperty);\r\n  @param property - The [[DataProperty]] or [[NavigationProperty]] to validate or a string \r\n  with the name of the property or a property path with the path to a property of a complex object.\r\n  @param context -  A context object used to pass additional information to each [[Validator]].\r\n  @return Whether the entity passed validation.\r\n  **/\r\n  validateProperty(property: EntityProperty | string, context: any) {\r\n    let value = this.getPropertyValue(property); // performs validations\r\n    if (value && value.complexAspect) {\r\n      return validateTarget(value);\r\n    }\r\n    context = context || {};\r\n    context.entity = this.entity;\r\n    if (typeof property === \"string\") {\r\n      context.property = this.entity!.entityType.getProperty(property, true);\r\n      context.propertyName = property;\r\n    } else {\r\n      context.property = property;\r\n      context.propertyName = property.name;\r\n    }\r\n\r\n    return this._validateProperty(value, context);\r\n  }\r\n\r\n  getValidationErrors(): ValidationError[];\r\n  getValidationErrors(property: string): ValidationError[];\r\n  getValidationErrors(property: EntityProperty): ValidationError[];\r\n  /**\r\n  Returns the validation errors associated with either the entire entity or any specified property.\r\n  \r\n  This method can return all of the errors for an Entity\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      var valErrors = order.entityAspect.getValidationErrors();\r\n\r\n  as well as those for just a specific property.\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      var orderDateErrors = order.entityAspect.getValidationErrors(\"OrderDate\");\r\n\r\n  which can also be expressed as\r\n  >      // assume order is an order entity attached to an EntityManager.\r\n  >      var orderDateProperty = order.entityType.getProperty(\"OrderDate\");\r\n  >      var orderDateErrors = order.entityAspect.getValidationErrors(orderDateProperty);\r\n  @param property - The property for which validation errors should be retrieved.\r\n  If omitted, all of the validation errors for this entity will be returned.\r\n  @return A array of validation errors.\r\n  **/\r\n  getValidationErrors(property?: DataProperty | NavigationProperty | string) {\r\n    assertParam(property, \"property\").isOptional().isEntityProperty().or().isString().check();\r\n    let result = core.getOwnPropertyValues(this._validationErrors);\r\n    if (property) {\r\n      let propertyName = typeof (property) === 'string' ? property : property.name;\r\n      result = result.filter(function (ve: ValidationError) {\r\n        return ve.property && (ve.property.name === propertyName || (propertyName.indexOf(\".\") !== -1 && ve.propertyName === propertyName));\r\n      });\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n  Adds a validation error.\r\n  **/\r\n  addValidationError(validationError: ValidationError) {\r\n    assertParam(validationError, \"validationError\").isInstanceOf(ValidationError).check();\r\n    this._processValidationOpAndPublish(function (that: any) {\r\n      that._addValidationError(validationError);\r\n    });\r\n  }\r\n\r\n  removeValidationError(validationError: ValidationError): void;\r\n  removeValidationError(validationKey: string): void;\r\n  /**\r\n  Removes a validation error.\r\n  @param validationErrorOrKey - Either a ValidationError or a ValidationError 'key' value\r\n  **/\r\n  removeValidationError(validationErrorOrKey: ValidationError | string) {\r\n    assertParam(validationErrorOrKey, \"validationErrorOrKey\").isString().or().isInstanceOf(ValidationError).or().isInstanceOf(Validator).check();\r\n\r\n    let key = (typeof (validationErrorOrKey) === \"string\") ? validationErrorOrKey : validationErrorOrKey.key;\r\n    this._processValidationOpAndPublish(function (that: any) {\r\n      that._removeValidationError(key);\r\n    });\r\n  }\r\n\r\n  /**\r\n  Removes all of the validation errors for a specified entity\r\n  **/\r\n  clearValidationErrors() {\r\n    this._processValidationOpAndPublish(function (that: any) {\r\n      core.objectForEach(that._validationErrors, function (key: string, valError: ValidationError) {\r\n        if (valError) {\r\n          delete that._validationErrors[key];\r\n          that._pendingValidationResult.removed.push(valError);\r\n        }\r\n      });\r\n      that.hasValidationErrors = !core.isEmpty(that._validationErrors);\r\n    });\r\n  }\r\n\r\n  /**\r\n  Returns an [[EntityKey]] for the entity pointed to by the specified scalar NavigationProperty.\r\n  This only returns an EntityKey if the current entity is a 'child' entity along the specified NavigationProperty. \r\n  i.e. has a single parent.\r\n\r\n  @param navigationProperty - The [[NavigationProperty]] ( pointing to a parent). \r\n  @returns Either a parent EntityKey if this is a 'child' entity or null;  \r\n  */\r\n  getParentKey(navigationProperty: NavigationProperty) {\r\n    if (!this.entity) return null;\r\n    // TODO: review this - not sure about the comment.\r\n    // NavigationProperty doesn't yet exist\r\n    // assertParam(navigationProperty, \"navigationProperty\").isInstanceOf(NavigationProperty).check();\r\n    let fkNames = navigationProperty.foreignKeyNames;\r\n    if (fkNames.length === 0) return null;\r\n    let that = this;\r\n    let fkValues = fkNames.map(function (fkn) {\r\n      return that.entity!.getProperty(fkn);\r\n    });\r\n    return new EntityKey(navigationProperty.entityType, fkValues);\r\n  }\r\n\r\n  // TODO: refactor this and the static getPropertyPathValue.\r\n  /**\r\n  Returns the value of a specified DataProperty or NavigationProperty or 'property path'.  \r\n  **/\r\n  getPropertyValue(property: string | DataProperty | NavigationProperty) {\r\n    assertParam(property, \"property\").isString().or().isEntityProperty().check();\r\n    let value: any;\r\n    if (typeof (property) === 'string') {\r\n      let propNames = property.trim().split(\".\");\r\n      let propName = propNames.shift();\r\n      value = this.entity;\r\n      value = value.getProperty(propName);\r\n      while (propNames.length > 0) {\r\n        propName = propNames.shift();\r\n        value = value.getProperty(propName);\r\n      }\r\n    } else {\r\n      if (!(property.parentType instanceof EntityType)) {\r\n        throw new Error(\"The validateProperty method does not accept a 'property' parameter whose parentType is a ComplexType; \" +\r\n          \"Pass a 'property path' string as the 'property' parameter instead \");\r\n      }\r\n      value = this.entity!.getProperty(property.name);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  // internal methods\r\n  /** @hidden @internal */\r\n  _checkOperation(operationName: string) {\r\n    if (this.isBeingSaved) {\r\n      throw new Error(\"Cannot perform a '\" + operationName + \"' on an entity that is in the process of being saved\");\r\n    }\r\n    // allows chaining\r\n    return this;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _detach() {\r\n    this.entityGroup = undefined;\r\n    this.entityManager = undefined;\r\n    this.entityState = EntityState.Detached;\r\n    this.originalValues = {};\r\n    this._validationErrors = {};\r\n    this.hasValidationErrors = false;\r\n    this.validationErrorsChanged.clear();\r\n    this.propertyChanged.clear();\r\n\r\n  }\r\n\r\n\r\n  // called from defaultInterceptor.\r\n  /** @hidden @internal */\r\n  _validateProperty(value: any, context: any) {\r\n    let ok = true;\r\n    this._processValidationOpAndPublish(function (that: any) {\r\n      context.property.getAllValidators().forEach(function (validator: Validator) {\r\n        ok = validate(that, validator, value, context) && ok;\r\n      });\r\n    });\r\n    return ok;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _processValidationOpAndPublish(validationFn: any) {\r\n    if (this._pendingValidationResult) {\r\n      // only top level processValidations call publishes\r\n      validationFn(this);\r\n    } else {\r\n      try {\r\n        this._pendingValidationResult = { entity: this.entity, added: [], removed: [] };\r\n        validationFn(this);\r\n        if (this._pendingValidationResult.added.length > 0 || this._pendingValidationResult.removed.length > 0) {\r\n          this.validationErrorsChanged.publish(this._pendingValidationResult);\r\n          // this might be a detached entity hence the guard below.\r\n          this.entityManager && this.entityManager.validationErrorsChanged.publish(this._pendingValidationResult);\r\n\r\n        }\r\n      } finally {\r\n        this._pendingValidationResult = undefined;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  // TODO: add/use a ValidationError type\r\n  _addValidationError(validationError: any) {\r\n    this._validationErrors[validationError.key] = validationError;\r\n    this.hasValidationErrors = true;\r\n    this._pendingValidationResult.added.push(validationError);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _removeValidationError(key: string) {\r\n    let valError = this._validationErrors[key];\r\n    if (valError) {\r\n      delete this._validationErrors[key];\r\n      this.hasValidationErrors = !core.isEmpty(this._validationErrors);\r\n      this._pendingValidationResult.removed.push(valError);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nBreezeEvent.bubbleEvent(EntityAspect.prototype, function () {\r\n  return this.entityManager;\r\n});\r\n\r\nfunction rejectChangesCore(target: any) {\r\n  let aspect = target.entityAspect || target.complexAspect;\r\n  let stype = target.entityType || target.complexType;\r\n  let originalValues = aspect.originalValues;\r\n  for (let propName in originalValues) {\r\n    target.setProperty(propName, originalValues[propName]);\r\n  }\r\n  stype.complexProperties.forEach(function (cp: any) {\r\n    let cos = target.getProperty(cp.name);\r\n    if (cp.isScalar) {\r\n      rejectChangesCore(cos);\r\n    } else {\r\n      cos._rejectChanges();\r\n      cos.forEach(rejectChangesCore);\r\n    }\r\n  });\r\n}\r\n\r\nfunction removeFromRelations(entity: Entity, entityState: EntityState) {\r\n  // remove this entity from any collections.\r\n  // mark the entity deleted or detached\r\n\r\n  let isDeleted = entityState.isDeleted();\r\n  if (isDeleted) {\r\n    removeFromRelationsCore(entity);\r\n  } else {\r\n    core.using(entity.entityAspect.entityManager!, \"isLoading\", true, function () {\r\n      removeFromRelationsCore(entity);\r\n    });\r\n  }\r\n}\r\n\r\nfunction removeFromRelationsCore(entity: Entity) {\r\n  entity.entityType.navigationProperties.forEach(function (np) {\r\n    let inverseNp = np.inverse;\r\n    let npValue = entity.getProperty(np.name);\r\n    if (np.isScalar) {\r\n      if (npValue) {\r\n        if (inverseNp) {\r\n          if (inverseNp.isScalar) {\r\n            npValue.setProperty(inverseNp.name, null);\r\n          } else {\r\n            let collection = npValue.getProperty(inverseNp.name);\r\n            if (collection.length) {\r\n              core.arrayRemoveItem(collection, entity);\r\n            }\r\n          }\r\n        }\r\n        entity.setProperty(np.name, null);\r\n      }\r\n    } else {\r\n      if (inverseNp != null) {\r\n        // npValue is a live list so we need to copy it first.\r\n        npValue.slice(0).forEach((v: any) => {\r\n          if (inverseNp!.isScalar) {\r\n            v.setProperty(inverseNp!.name, null);\r\n          } else {\r\n            // TODO: many to many - not yet handled.\r\n          }\r\n        });\r\n      }\r\n      // now clear it.\r\n      npValue.length = 0;\r\n    }\r\n  });\r\n\r\n}\r\n\r\n// note entityAspect only - ( no complex aspect allowed on the call).\r\nfunction validate(entityAspect: EntityAspect, validator: Validator, value: any, context?: any) {\r\n  let ve = validator.validate(value, context);\r\n  if (ve) {\r\n    entityAspect._addValidationError(ve);\r\n    return false;\r\n  } else {\r\n    let key = ValidationError.getKey(validator, context ? context.propertyName : null);\r\n    entityAspect._removeValidationError(key);\r\n    return true;\r\n  }\r\n}\r\n\r\n// coIndex is only used where target is a complex object that is part of an array of complex objects\r\n// in which case ctIndex is the index of the target within the array.\r\nfunction validateTarget(target: any, coIndex?: number) {\r\n  let ok = true;\r\n  let stype = target.entityType || target.complexType;\r\n  let aspect = target.entityAspect || target.complexAspect;\r\n  let entityAspect = target.entityAspect || target.complexAspect.getEntityAspect();\r\n  let context = <any>{ entity: entityAspect.entity };\r\n  if (coIndex !== undefined) {\r\n    context.index = coIndex;\r\n  }\r\n\r\n  stype.getProperties().forEach(function (p: any) {\r\n    let value = target.getProperty(p.name);\r\n    let validators = p.getAllValidators();\r\n    if (validators.length > 0) {\r\n      context.property = p;\r\n      context.propertyName = aspect.getPropertyPath(p.name);\r\n      ok = entityAspect._validateProperty(value, context) && ok;\r\n    }\r\n    if (p.isComplexProperty) {\r\n      if (p.isScalar) {\r\n        ok = validateTarget(value) && ok;\r\n      } else {\r\n        ok = value.reduce(function (pv: any, cv: any, ix: number) {\r\n          return validateTarget(cv, ix) && pv;\r\n        }, ok);\r\n      }\r\n    }\r\n  });\r\n\r\n\r\n  // then target level\r\n  stype.getAllValidators().forEach(function (validator: Validator) {\r\n    ok = validate(entityAspect, validator, target) && ok;\r\n  });\r\n  return ok;\r\n}\r\n\r\n/**\r\nAn ComplexAspect instance is associated with every complex object instance and is accessed via the complex object's 'complexAspect' property.\r\n\r\nThe ComplexAspect itself provides properties to determine the parent object, parent property and original values for the complex object.\r\n\r\nA ComplexAspect will almost never need to be constructed directly. You will usually get an ComplexAspect by accessing\r\nan entities 'complexAspect' property.  This property will be automatically attached when an complex object is created as part of an\r\nentity via either a query, import or EntityManager.createEntity call.\r\n>      // assume address is a complex property on the 'Customer' type\r\n>      var aspect = aCustomer.address.complexAspect;\r\n>      // aCustomer === aspect.parent;\r\n**/\r\nexport class ComplexAspect {\r\n\r\n  /** The complex object that this aspect is associated with. __Read Only__ */\r\n  complexObject: ComplexObject;\r\n  /** The 'original values' of this complex object where they are different from the 'current values'.\r\n  This is a map where the key is a property name and the value is the 'original value' of the property.\r\n  __Read Only__ */\r\n  originalValues: {};\r\n  /** The parent object that to which this aspect belongs; this will either be an entity or another complex object. __Read Only__ */\r\n  parent?: StructuralObject;\r\n  /** The [[DataProperty]] on the 'parent' that contains this complex object. __Read Only__ */\r\n  parentProperty?: DataProperty;\r\n  extraMetadata?: any;\r\n\r\n  /** You will rarely, if ever, create a ComplexAspect directly. */\r\n  constructor(complexObject: ComplexObject, parent: StructuralObject, parentProperty: DataProperty) {\r\n    if (!complexObject) {\r\n      throw new Error(\"The  ComplexAspect ctor requires an entity as its only argument.\");\r\n    }\r\n    if (complexObject.complexAspect) {\r\n      return complexObject.complexAspect;\r\n    }\r\n    // if called without new\r\n    if (!(this instanceof ComplexAspect)) {\r\n      return new ComplexAspect(complexObject, parent, parentProperty);\r\n    }\r\n\r\n    // entityType should already be on the entity from 'watch'\r\n    this.complexObject = complexObject;\r\n    complexObject.complexAspect = this;\r\n\r\n    // TODO: keep public or not?\r\n    this.originalValues = {};\r\n\r\n    // if a standalone complexObject\r\n    if (parent != null) {\r\n      this.parent = parent;\r\n      this.parentProperty = parentProperty;\r\n    }\r\n\r\n    let complexType = complexObject.complexType;\r\n    if (!complexType) {\r\n      let typeName = complexObject.prototype._$typeName;\r\n      if (!typeName) {\r\n        throw new Error(\"This entity is not registered as a valid ComplexType\");\r\n      } else {\r\n        throw new Error(\"Metadata for this complexType has not yet been resolved: \" + typeName);\r\n      }\r\n    }\r\n    let complexCtor = complexType.getCtor();\r\n    config.interfaceRegistry.modelLibrary.getDefaultInstance().startTracking(complexObject, complexCtor.prototype);\r\n\r\n  }\r\n\r\n\r\n  /**\r\n  Returns the EntityAspect for the top level entity that contains this complex object.\r\n  **/\r\n  getEntityAspect() {\r\n    let parent = <any>this.parent;\r\n    if (!parent) return new EntityAspect();\r\n    let entityAspect = parent.entityAspect;\r\n    while (parent && !entityAspect) {\r\n      parent = parent.complexAspect && parent.complexAspect.parent;\r\n      entityAspect = parent && parent.entityAspect;\r\n    }\r\n    return entityAspect || new EntityAspect();\r\n  }\r\n\r\n  /**  @hidden @internal */\r\n  // TODO: rename - and use '_'; used on both EntityAspect and ComplexAspect for polymorphic reasons.\r\n  getPropertyPath(propName: string) {\r\n    let parent = <any>this.parent;\r\n    if (!parent) return null;\r\n    let aspect = parent.complexAspect || parent.entityAspect;\r\n    return aspect.getPropertyPath(this.parentProperty!.name + \".\" + propName);\r\n  }\r\n\r\n}\r\n\r\nfunction clearOriginalValues(target: any) {\r\n  let aspect = target.entityAspect || target.complexAspect;\r\n  aspect.originalValues = {};\r\n  let stype = target.entityType || target.complexType;\r\n  stype.complexProperties.forEach(function (cp: any) {\r\n    let cos = target.getProperty(cp.name);\r\n    if (cp.isScalar) {\r\n      clearOriginalValues(cos);\r\n    } else {\r\n      cos._acceptChanges();\r\n      cos.forEach(clearOriginalValues);\r\n    }\r\n  });\r\n}\r\n\r\n\r\n","import { assertConfig } from './assert-param';\r\nimport { core } from './core';\r\nimport { config } from './config';\r\n\r\n// TODO: strongly type context object passed to naming convention converter fns.\r\n\r\n/** Configuration info to be passed to the [[NamingConvention]] constructor */\r\nexport interface NamingConventionConfig {\r\n  /** The name of this NamingConvention */\r\n  name?: string;\r\n  /** Function that takes a server property name add converts it into a client side property name.  */\r\n  serverPropertyNameToClient?: (nm: string, context?: any) => string;\r\n  /** Function that takes a client property name add converts it into a server side property name. */\r\n  clientPropertyNameToServer?: (nm: string, context?: any) => string;\r\n}\r\n\r\n/**\r\nA NamingConvention instance is used to specify the naming conventions under which a MetadataStore\r\nwill translate property names between the server and the javascript client.\r\n\r\nThe default NamingConvention does not perform any translation, it simply passes property names thru unchanged.\r\n@dynamic\r\n**/\r\nexport class NamingConvention {\r\n  /** @hidden @internal */\r\n  _$typeName: string;\r\n  /** The name of this NamingConvention. __Read Only__ */\r\n  name: string;\r\n  /** Function that takes a server property name add converts it into a client side property name.  __Read Only__ */\r\n  serverPropertyNameToClient: (nm: string, context?: any) => string;\r\n  /** Function that takes a client property name add converts it into a server side property name. __Read Only__ */\r\n  clientPropertyNameToServer: (nm: string, context?: any) => string;\r\n\r\n  /**\r\n  NamingConvention constructor\r\n  >      // A naming convention that converts the first character of every property name to uppercase on the server\r\n  >      // and lowercase on the client.\r\n  >      var namingConv = new NamingConvention({\r\n  >          serverPropertyNameToClient: function(serverPropertyName) {\r\n  >              return serverPropertyName.substr(0, 1).toLowerCase() + serverPropertyName.substr(1);\r\n  >          },\r\n  >          clientPropertyNameToServer: function(clientPropertyName) {\r\n  >              return clientPropertyName.substr(0, 1).toUpperCase() + clientPropertyName.substr(1);\r\n  >          }            \r\n  >      });\r\n  >      var ms = new MetadataStore({ namingConvention: namingConv });\r\n  >      var em = new EntityManager( { metadataStore: ms });\r\n  **/\r\n  constructor(ncConfig: NamingConventionConfig ) {\r\n    assertConfig(ncConfig || {})\r\n        .whereParam(\"name\").isOptional().isString()\r\n        .whereParam(\"serverPropertyNameToClient\").isFunction()\r\n        .whereParam(\"clientPropertyNameToServer\").isFunction()\r\n        .applyAll(this);\r\n    if (!this.name) {\r\n      this.name = core.getUuid();\r\n    }\r\n    config._storeObject(this, \"NamingConvention\", this.name);\r\n  }\r\n\r\n  /**\r\n\r\n\r\n  /**\r\n  A noop naming convention - This is the default unless another is specified.\r\n  **/\r\n  static none = new NamingConvention({\r\n    name: \"noChange\",\r\n    serverPropertyNameToClient: (serverPropertyName) => {\r\n      return serverPropertyName;\r\n    },\r\n    clientPropertyNameToServer: (clientPropertyName) => {\r\n      return clientPropertyName;\r\n    }\r\n  });\r\n\r\n  /**\r\n  The \"camelCase\" naming convention - This implementation only lowercases the first character of the server property name\r\n  but leaves the rest of the property name intact.  If a more complicated version is needed then one should be created via the ctor.\r\n  **/\r\n  static camelCase = new NamingConvention({\r\n    name: \"camelCase\",\r\n    serverPropertyNameToClient: (serverPropertyName) => {\r\n      return serverPropertyName.substr(0, 1).toLowerCase() + serverPropertyName.substr(1);\r\n    },\r\n    clientPropertyNameToServer: (clientPropertyName) => {\r\n      return clientPropertyName.substr(0, 1).toUpperCase() + clientPropertyName.substr(1);\r\n    }\r\n  });\r\n\r\n  /**\r\n  The default value whenever NamingConventions are not specified.\r\n  **/\r\n  static defaultInstance = new NamingConvention(NamingConvention.none);\r\n\r\n  /**\r\n  Sets the 'defaultInstance' by creating a copy of the current 'defaultInstance' and then applying all of the properties of the current instance.\r\n  The current instance is returned unchanged.\r\n  >      var namingConv = new NamingConvention({\r\n  >          serverPropertyNameToClient: function(serverPropertyName) {\r\n  >              return serverPropertyName.substr(0, 1).toLowerCase() + serverPropertyName.substr(1);\r\n  >          },\r\n  >          clientPropertyNameToServer: function(clientPropertyName) {\r\n  >              return clientPropertyName.substr(0, 1).toUpperCase() + clientPropertyName.substr(1);\r\n  >          }            \r\n  >      });\r\n  >      namingConv.setAsDefault();\r\n  **/\r\n  setAsDefault() {\r\n    return core.setAsDefault(this, NamingConvention);\r\n  }\r\n\r\n}\r\n\r\nNamingConvention.prototype._$typeName = \"NamingConvention\";\r\n\r\n\r\n\r\n\r\n","import { core } from './core';\r\nimport { MetadataStore, EntityType, ComplexType, DataProperty, NavigationProperty, AutoGeneratedKeyType } from './entity-metadata';\r\nimport { DataType  } from './data-type';\r\nimport { Validator } from './validate';\r\n\r\ninterface IAssociation {\r\n  name: string;\r\n  end: IEnd[];\r\n  referentialConstraint: any;\r\n}\r\n\r\ninterface IEnd {\r\n  multiplicity: string;\r\n  type: string;\r\n  role: string;\r\n}\r\n\r\nfunction parse(metadataStore: MetadataStore, schemas: any, altMetadata: any) {\r\n\r\n  metadataStore._entityTypeResourceMap = {};\r\n  schemas = core.toArray(schemas);\r\n  schemas.forEach(function (schema: any) {\r\n    if (schema.cSpaceOSpaceMapping) {\r\n      // Web api only - not avail in OData.\r\n      // TODO throw informative error if already parsed and converted to map on a previous pass\r\n      let mappings = JSON.parse(schema.cSpaceOSpaceMapping);\r\n      let newMap = {};\r\n      mappings.forEach(function (mapping: any) {\r\n        newMap[mapping[0]] = mapping[1];\r\n      });\r\n      schema.cSpaceOSpaceMapping = newMap;\r\n    }\r\n\r\n    if (schema.entityContainer) {\r\n      core.toArray(schema.entityContainer).forEach(function (container) {\r\n        core.toArray(container.entitySet).forEach(function (entitySet) {\r\n          let entityTypeName = parseTypeNameWithSchema(entitySet.entityType, schema).typeName;\r\n          metadataStore.setEntityTypeForResourceName(entitySet.name, entityTypeName);\r\n          metadataStore._entityTypeResourceMap[entityTypeName] = entitySet.name;\r\n        });\r\n      });\r\n    }\r\n\r\n    // process complextypes before entity types.\r\n    if (schema.complexType) {\r\n      core.toArray(schema.complexType).forEach(function (ct) {\r\n        parseCsdlComplexType(ct, schema, metadataStore);\r\n      });\r\n    }\r\n    if (schema.entityType) {\r\n      core.toArray(schema.entityType).forEach(function (et) {\r\n        parseCsdlEntityType(et, schema, schemas, metadataStore);\r\n\r\n      });\r\n    }\r\n\r\n  });\r\n  let badNavProps = metadataStore.getIncompleteNavigationProperties();\r\n  if (badNavProps.length > 0) {\r\n    let msg = badNavProps.map(function (npa) {\r\n      if (Array.isArray(npa)) {\r\n        return npa.map(function (np) {\r\n          return np.parentType.name + \":\" + np.name;\r\n        }).join(', ');\r\n      }\r\n      return npa.parentType.name + \":\" + npa.name;\r\n    }).join(', ');\r\n    throw new Error(\"Incomplete navigation properties: \" + msg);\r\n  }\r\n  if (altMetadata) {\r\n    metadataStore.importMetadata(altMetadata, true);\r\n  }\r\n  return metadataStore;\r\n}\r\n\r\nfunction parseCsdlEntityType(csdlEntityType: any, schema: any, schemas: any, metadataStore: MetadataStore) {\r\n  let shortName = csdlEntityType.name;\r\n  let ns = getNamespaceFor(shortName, schema);\r\n  let entityType = new EntityType({\r\n    shortName: shortName,\r\n    namespace: ns,\r\n    isAbstract: csdlEntityType.abstract && csdlEntityType.abstract === 'true'\r\n  });\r\n  if (csdlEntityType.baseType) {\r\n    let baseTypeName = parseTypeNameWithSchema(csdlEntityType.baseType, schema).typeName;\r\n    entityType.baseTypeName = baseTypeName;\r\n    let baseEntityType = metadataStore._getStructuralType(baseTypeName, true);\r\n    if (baseEntityType) {\r\n      completeParseCsdlEntityType(entityType, csdlEntityType, schema, schemas, metadataStore);\r\n    } else {\r\n      let deferrals = metadataStore._deferredTypes[baseTypeName];\r\n      if (!deferrals) {\r\n        deferrals = [];\r\n        metadataStore._deferredTypes[baseTypeName] = deferrals;\r\n      }\r\n      deferrals.push({ entityType: entityType, csdlEntityType: csdlEntityType });\r\n    }\r\n  } else {\r\n    completeParseCsdlEntityType(entityType, csdlEntityType, schema, schemas, metadataStore);\r\n  }\r\n  // entityType may or may not have been added to the metadataStore at this point.\r\n  return entityType;\r\n\r\n}\r\n\r\nfunction completeParseCsdlEntityType(entityType: EntityType, csdlEntityType: any, schema: any, schemas: any, metadataStore: MetadataStore) {\r\n  let keyNamesOnServer = csdlEntityType.key ? core.toArray(csdlEntityType.key.propertyRef).map(core.pluck(\"name\")) : [];\r\n\r\n  core.toArray(csdlEntityType.property).forEach(function (prop) {\r\n    parseCsdlDataProperty(entityType, prop, schema, keyNamesOnServer);\r\n  });\r\n\r\n  core.toArray(csdlEntityType.navigationProperty).forEach(function (prop) {\r\n    parseCsdlNavProperty(entityType, prop, schema, schemas);\r\n  });\r\n\r\n  metadataStore.addEntityType(entityType);\r\n  entityType.defaultResourceName = metadataStore._entityTypeResourceMap[entityType.name];\r\n\r\n  let deferredTypes = metadataStore._deferredTypes;\r\n  let deferrals = deferredTypes[entityType.name];\r\n  if (deferrals) {\r\n    deferrals.forEach(function (d: any) {\r\n      completeParseCsdlEntityType(d.entityType, d.csdlEntityType, schema, schemas, metadataStore);\r\n    });\r\n    delete deferredTypes[entityType.name];\r\n  }\r\n\r\n}\r\n\r\nfunction parseCsdlComplexType(csdlComplexType: any, schema: any, metadataStore: MetadataStore) {\r\n  let shortName = csdlComplexType.name;\r\n  let ns = getNamespaceFor(shortName, schema);\r\n  let complexType = new ComplexType({\r\n    shortName: shortName,\r\n    namespace: ns\r\n  });\r\n\r\n  core.toArray(csdlComplexType.property).forEach(function (prop) {\r\n    parseCsdlDataProperty(complexType, prop, schema);\r\n  });\r\n\r\n  metadataStore.addEntityType(complexType);\r\n  return complexType;\r\n}\r\n\r\nfunction parseCsdlDataProperty(parentType: EntityType | ComplexType, csdlProperty: any, schema: any, keyNamesOnServer?: string[]) {\r\n  let dp: DataProperty | undefined;\r\n  let typeParts = csdlProperty.type.split(\".\");\r\n  // Both tests on typeParts are necessary because of differing metadata conventions for OData and Edmx feeds.\r\n  if (typeParts[0] === \"Edm\" && typeParts.length === 2) {\r\n    dp = parseCsdlSimpleProperty(parentType, csdlProperty, keyNamesOnServer);\r\n  } else {\r\n    if (isEnumType(csdlProperty, schema)) {\r\n      dp = parseCsdlSimpleProperty(parentType, csdlProperty, keyNamesOnServer);\r\n      if (dp) {\r\n        dp.enumType = csdlProperty.type;\r\n      }\r\n    } else {\r\n      dp = parseCsdlComplexProperty(parentType, csdlProperty, schema);\r\n    }\r\n  }\r\n  if (dp) {\r\n    parentType._addPropertyCore(dp);\r\n    addValidators(dp);\r\n  }\r\n  return dp;\r\n}\r\n\r\nfunction parseCsdlSimpleProperty(parentType: EntityType | ComplexType, csdlProperty: any, keyNamesOnServer?: string[]) {\r\n  let dataType = DataType.fromEdmDataType(csdlProperty.type);\r\n  if (dataType == null) {\r\n    parentType.warnings.push(\"Unable to recognize DataType for property: \" + csdlProperty.name + \" DateType: \" + csdlProperty.type);\r\n    return undefined;\r\n  }\r\n  let isNullable = csdlProperty.nullable === 'true' || csdlProperty.nullable == null;\r\n  // let fixedLength = csdlProperty.fixedLength ? csdlProperty.fixedLength === true : undefined;\r\n  let isPartOfKey = keyNamesOnServer != null && keyNamesOnServer.indexOf(csdlProperty.name) >= 0;\r\n  if (isPartOfKey && parentType instanceof EntityType && parentType.autoGeneratedKeyType === AutoGeneratedKeyType.None) {\r\n    if (isIdentityProperty(csdlProperty)) {\r\n      parentType.autoGeneratedKeyType = AutoGeneratedKeyType.Identity;\r\n    }\r\n  }\r\n  // TODO: nit - don't set maxLength if null;\r\n  let maxLength = csdlProperty.maxLength;\r\n  maxLength = (maxLength == null || maxLength === \"Max\") ? null : parseInt(maxLength, 10);\r\n  // can't set the name until we go thru namingConventions and these need the dp.\r\n\r\n  let dp = new DataProperty({\r\n    nameOnServer: csdlProperty.name,\r\n    dataType: dataType,\r\n    isNullable: isNullable,\r\n    isPartOfKey: isPartOfKey,\r\n    maxLength: maxLength,\r\n    defaultValue: csdlProperty.defaultValue,\r\n    // fixedLength: fixedLength,\r\n    concurrencyMode: csdlProperty.concurrencyMode\r\n  });\r\n\r\n  if (dataType === DataType.Undefined) {\r\n    dp.rawTypeName = csdlProperty.type;\r\n  }\r\n  return dp;\r\n}\r\n\r\nfunction parseCsdlComplexProperty(parentType: EntityType | ComplexType, csdlProperty: any, schema: any) {\r\n\r\n  // Complex properties are never nullable ( per EF specs)\r\n  // let isNullable = csdlProperty.nullable === 'true' || csdlProperty.nullable == null;\r\n  // let complexTypeName = csdlProperty.type.split(\"Edm.\")[1];\r\n  let complexTypeName = parseTypeNameWithSchema(csdlProperty.type, schema).typeName;\r\n  // can't set the name until we go thru namingConventions and these need the dp.\r\n  let dp = new DataProperty({\r\n    nameOnServer: csdlProperty.name,\r\n    complexTypeName: complexTypeName,\r\n    isNullable: false\r\n  });\r\n\r\n  return dp;\r\n}\r\n\r\nfunction parseCsdlNavProperty(entityType: EntityType, csdlProperty: any, schema: any, schemas: any[]) {\r\n  let association = getAssociation(csdlProperty, schema, schemas);\r\n  if (!association) {\r\n    throw new Error(\"Unable to resolve Foreign Key Association: \" + csdlProperty.relationship);\r\n  }\r\n  let toEnd = core.arrayFirst(association.end, (assocEnd) => {\r\n    return assocEnd.role === csdlProperty.toRole;\r\n  });\r\n\r\n  let isScalar = toEnd!.multiplicity !== \"*\";\r\n  let dataType = parseTypeNameWithSchema(toEnd!.type, schema).typeName;\r\n\r\n  let constraint = association.referentialConstraint;\r\n  if (!constraint) {\r\n    // TODO: Revisit this later - right now we just ignore many-many and assocs with missing constraints.\r\n\r\n    // Think about adding this back later.\r\n    if (association.end[0].multiplicity === \"*\" && association.end[1].multiplicity === \"*\") {\r\n      // ignore many to many relations for now\r\n      return;\r\n    } else {\r\n      // For now assume it will be set later directly on the client.\r\n      // other alternative is to throw an error:\r\n      // throw new Error(\"Foreign Key Associations must be turned on for this model\");\r\n    }\r\n  }\r\n\r\n\r\n\r\n  let cfg = {\r\n    nameOnServer: csdlProperty.name,\r\n    entityTypeName: dataType,\r\n    isScalar: isScalar,\r\n    associationName: association.name,\r\n  };\r\n\r\n  if (constraint) {\r\n    let principal = constraint.principal;\r\n    let dependent = constraint.dependent;\r\n\r\n    let propRefs = core.toArray(dependent.propertyRef);\r\n    let fkNames = propRefs.map(core.pluck(\"name\"));\r\n    if (csdlProperty.fromRole === principal.role) {\r\n      (cfg as any).invForeignKeyNamesOnServer = fkNames;\r\n    } else {\r\n      // will be used later by np._update\r\n      (cfg as any).foreignKeyNamesOnServer = fkNames;\r\n    }\r\n  }\r\n\r\n  let np = new NavigationProperty(cfg);\r\n  entityType._addPropertyCore(np);\r\n  return np;\r\n}\r\n\r\n\r\nfunction isEnumType(csdlProperty: any, schema: any) {\r\n  if (schema.enumType) return isEdmxEnumType(csdlProperty, schema);\r\n  else if (schema.extensions) return isODataEnumType(csdlProperty, schema);\r\n  else return false;\r\n}\r\n\r\nfunction isEdmxEnumType(csdlProperty: any, schema: any) {\r\n  let enumTypes = core.toArray(schema.enumType);\r\n  let typeParts = csdlProperty.type.split(\".\");\r\n  let baseTypeName = typeParts[typeParts.length - 1];\r\n  return enumTypes.some(function (enumType) {\r\n    return enumType.name === baseTypeName;\r\n  });\r\n}\r\n\r\nfunction isODataEnumType(csdlProperty: any, schema: any) {\r\n  let enumTypes = schema.extensions.filter((ext: any) => {\r\n    return ext.name === \"EnumType\";\r\n  });\r\n  let typeParts = csdlProperty.type.split(\".\");\r\n  let baseTypeName = typeParts[typeParts.length - 1];\r\n  return enumTypes.some((enumType: any) => {\r\n    return enumType.attributes.some((attr: any) => {\r\n      return attr.name === \"Name\" && attr.value === baseTypeName;\r\n    });\r\n  });\r\n}\r\n\r\nfunction addValidators(dataProperty: DataProperty) {\r\n  let typeValidator: Validator;\r\n  if (!dataProperty.isNullable) {\r\n    dataProperty.validators.push(Validator.required());\r\n  }\r\n\r\n  if (dataProperty.isComplexProperty) return;\r\n\r\n  if (dataProperty.dataType === DataType.String) {\r\n    if (dataProperty.maxLength) {\r\n      let validatorArgs = { maxLength: dataProperty.maxLength };\r\n      typeValidator = Validator.maxLength(validatorArgs);\r\n    } else {\r\n      typeValidator = Validator.string();\r\n    }\r\n  } else {\r\n      let validatorCtor = (dataProperty.dataType as any).validatorCtor;\r\n      if (!validatorCtor) return;\r\n      typeValidator = validatorCtor();\r\n  }\r\n\r\n  dataProperty.validators.push(typeValidator);\r\n\r\n}\r\n\r\nfunction isIdentityProperty(csdlProperty: any) {\r\n  // see if web api feed\r\n  let propName = core.arrayFirst(Object.keys(csdlProperty), (pn) => {\r\n    return pn.indexOf(\"StoreGeneratedPattern\") >= 0;\r\n  });\r\n  if (propName) {\r\n    return (csdlProperty[propName] === \"Identity\");\r\n  } else {\r\n    // see if Odata feed\r\n    let extensions = csdlProperty.extensions;\r\n    if (!extensions) {\r\n      return false;\r\n    }\r\n    let identityExtn = core.arrayFirst(extensions, (extension) => {\r\n      return extension.name === \"StoreGeneratedPattern\" && extension.value === \"Identity\";\r\n    });\r\n    return !!identityExtn;\r\n  }\r\n}\r\n\r\n// Fast version\r\n// np: schema.entityType[].navigationProperty.relationship -> schema.association\r\n//   match( shortName(np.relationship) == schema.association[].name\r\n//      --> association__\r\n\r\n// Correct version\r\n// np: schema.entityType[].navigationProperty.relationship -> schema.association\r\n//   match( np.relationship == schema.entityContainer[0].associationSet[].association )\r\n//      -> associationSet.name\r\n//   match ( associationSet.name == schema.association[].name )\r\n//      -> association\r\n\r\nfunction getAssociation(csdlNavProperty: any, containingSchema: any, schemas: any[]) {\r\n  let assocFullName = parseTypeNameWithSchema(csdlNavProperty.relationship, containingSchema);\r\n  let assocNamespace = assocFullName.namespace;\r\n  let assocSchema = core.arrayFirst(schemas, (schema) => {\r\n    return schema.namespace === assocNamespace;\r\n  });\r\n  if (!assocSchema) return null;\r\n\r\n  let assocName = assocFullName.shortTypeName;\r\n  let assocs = assocSchema.association;\r\n  if (!assocs) return null;\r\n  if (!Array.isArray(assocs)) {\r\n    assocs = [assocs];\r\n  }\r\n  let association = core.arrayFirst(assocs, (assoc) => {\r\n    return assoc.name === assocName;\r\n  });\r\n  return association as IAssociation;\r\n}\r\n\r\n// schema is only needed for navProperty type name\r\nfunction parseTypeNameWithSchema(entityTypeName: string, schema: any) {\r\n  let result = MetadataStore.parseTypeName(entityTypeName);\r\n  if (schema && schema.cSpaceOSpaceMapping) {\r\n    let ns = getNamespaceFor(result!.shortTypeName, schema);\r\n    if (ns) {\r\n      result = MetadataStore.makeTypeHash(result!.shortTypeName, ns);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction getNamespaceFor(shortName: string, schema: any) {\r\n  let ns: string;\r\n  let mapping = schema.cSpaceOSpaceMapping;\r\n  if (mapping) {\r\n    let fullName = mapping[schema.namespace + \".\" + shortName];\r\n    ns = fullName && fullName.substr(0, fullName.length - (shortName.length + 1));\r\n    if (ns) return ns;\r\n  }\r\n  // if schema does not also have an entityType node then\r\n  // this is an WebApi2 OData schema which is usually equal to 'Default'; which is useless.\r\n  if (schema.entityType || schema.namespace !== 'Default') {\r\n    return schema.namespace;\r\n  }\r\n  return null;\r\n}\r\n\r\n/** @hidden @internal */\r\nexport const CsdlMetadataParser = {\r\n  parse: parse\r\n};\r\n","import { core } from './core';\r\nimport { assertConfig } from './assert-param';\r\nimport { config } from './config';\r\n\r\n\r\n/** Configuration info to be passed to the [[LocalQueryComparisonOptions]] constructor. */\r\nexport interface LocalQueryComparisonOptionsConfig {\r\n  /** The name of this collection of configuration settings. */\r\n  name?: string;\r\n  /** Whether predicates that involve strings will be interpreted in a \"caseSensitive\" manner. Default is 'false'. */\r\n  isCaseSensitive?: boolean;\r\n  /* Whether or not to enforce the ANSI SQL standard\r\n  of padding strings of unequal lengths before comparison with spaces. Note that per the standard, padding only occurs with equality and\r\n  inequality predicates, and not with operations like 'startsWith', 'endsWith' or 'contains'.  Default is true. */\r\n  usesSql92CompliantStringComparison?: boolean;\r\n}\r\n\r\n/**\r\nA LocalQueryComparisonOptions instance is used to specify the \"comparison rules\" used when performing \"local queries\" in order\r\nto match the semantics of these same queries when executed against a remote service.  These options should be set based on the\r\nmanner in which your remote service interprets certain comparison operations.\r\n\r\nThe default LocalQueryComparisonOptions stipulates 'caseInsensitive\" queries with ANSI SQL rules regarding comparisons of unequal\r\nlength strings.\r\n**/\r\nexport class LocalQueryComparisonOptions {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // on prototype\r\n  /** The name for this instance. */\r\n  name: string;\r\n  /** Whether predicates that involve strings will be interpreted in a \"caseSensitive\" manner. (default = false).  */\r\n  isCaseSensitive: boolean;\r\n  /* Whether or not to enforce the ANSI SQL standard\r\n  of padding strings of unequal lengths before comparison with spaces. Note that per the standard, padding only occurs with equality and\r\n  inequality predicates, and not with operations like 'startsWith', 'endsWith' or 'contains'.  Default is true. */\r\n  usesSql92CompliantStringComparison: boolean;\r\n\r\n  /**\r\n  LocalQueryComparisonOptions constructor\r\n  >      // create a 'caseSensitive - non SQL' instance.\r\n  >      var lqco = new LocalQueryComparisonOptions({\r\n  >              name: \"caseSensitive-nonSQL\"\r\n  >              isCaseSensitive: true;\r\n  >              usesSql92CompliantStringComparison: false;\r\n  >          });\r\n  >      // either apply it globally\r\n  >      lqco.setAsDefault();\r\n  >      // or to a specific MetadataStore\r\n  >      var ms = new MetadataStore({ localQueryComparisonOptions: lqco });\r\n  >      var em = new EntityManager( { metadataStore: ms });\r\n  @param config - A configuration object.\r\n  **/\r\n  constructor(lqcoConfig: LocalQueryComparisonOptionsConfig) {\r\n    assertConfig(lqcoConfig || {})\r\n        .whereParam(\"name\").isOptional().isString()\r\n        .whereParam(\"isCaseSensitive\").isOptional().isBoolean()\r\n        .whereParam(\"usesSql92CompliantStringComparison\").isBoolean()\r\n        .applyAll(this);\r\n    if (!this.name) {\r\n      this.name = core.getUuid();\r\n    }\r\n    config._storeObject(this, \"LocalQueryComparisonOptions\", this.name);\r\n  }\r\n\r\n  /**\r\n  Case insensitive SQL compliant options - this is also the default unless otherwise changed.\r\n  **/\r\n  static caseInsensitiveSQL = new LocalQueryComparisonOptions({\r\n    name: \"caseInsensitiveSQL\",\r\n    isCaseSensitive: false,\r\n    usesSql92CompliantStringComparison: true\r\n  });\r\n\r\n  /**\r\n  The default value whenever LocalQueryComparisonOptions are not specified. By default this is 'caseInsensitiveSQL'.\r\n  **/\r\n  static defaultInstance = new LocalQueryComparisonOptions(LocalQueryComparisonOptions.caseInsensitiveSQL);\r\n\r\n  /**\r\n  Sets the 'defaultInstance' by creating a copy of the current 'defaultInstance' and then applying all of the properties of the current instance.\r\n  The current instance is returned unchanged.\r\n  >     var lqco = new LocalQueryComparisonOptions({\r\n  >        isCaseSensitive: false;\r\n  >        usesSql92CompliantStringComparison: true;\r\n  >     });\r\n  >     lqco.setAsDefault();\r\n  **/\r\n  setAsDefault() {\r\n    return core.setAsDefault(this, LocalQueryComparisonOptions);\r\n  }\r\n\r\n}\r\nLocalQueryComparisonOptions.prototype._$typeName = \"LocalQueryComparisonOptions\";\r\n","import { core } from './core';\r\nimport { ComplexType, DataProperty, NavigationProperty, EntityProperty } from './entity-metadata';\r\nimport { EntityKey } from './entity-key';\r\nimport { EntityAspect, ComplexAspect, Entity, StructuralObject } from './entity-aspect';\r\nimport { EntityState } from './entity-state';\r\nimport { EntityAction } from './entity-action';\r\n\r\n/** @hidden @internal */\r\nexport function defaultPropertyInterceptor(this: StructuralObject, property: EntityProperty, newValue: any, rawAccessorFn: Function) {\r\n  // 'this' is the entity itself in this context.\r\n\r\n  if (newValue === undefined) newValue = null; // remove? to allow assignment to undefined in Babel constructors?\r\n  let oldValue = rawAccessorFn();\r\n\r\n  let dataType = (property as any).dataType;\r\n  if (dataType && dataType.parse) {\r\n    // attempts to coerce a value to the correct type - if this fails return the value unchanged\r\n    if (Array.isArray(newValue) && !property.isScalar) {\r\n      newValue = newValue.map(function (nv) {\r\n        return dataType.parse(nv, typeof nv);\r\n      });\r\n    } else {\r\n      newValue = dataType.parse(newValue, typeof newValue);\r\n    }\r\n  }\r\n\r\n  // exit if no change - extra cruft is because dateTimes don't compare cleanly.\r\n  if (newValue === oldValue || (dataType && dataType.normalize && newValue && oldValue && dataType.normalize(newValue) === dataType.normalize(oldValue))) {\r\n    return;\r\n  }\r\n\r\n  // CANNOT DO NEXT LINE because it has the possibility of creating a new property\r\n  // 'entityAspect' on 'this'.  - Not permitted by IE inside of a defined property on a prototype.\r\n  // let entityAspect = new EntityAspect(this);\r\n\r\n  let propertyName: string;\r\n  let entityAspect = (this as any).entityAspect as EntityAspect;\r\n  if (entityAspect) {\r\n    propertyName = property.name;\r\n  } else {\r\n    let localAspect = (this as any).complexAspect as ComplexAspect;\r\n    if (localAspect) {\r\n      entityAspect = localAspect.getEntityAspect();\r\n      propertyName = localAspect.getPropertyPath(property.name);\r\n    } else {\r\n      // does not yet have an EntityAspect so just set the prop\r\n      rawAccessorFn(newValue);\r\n      return;\r\n    }\r\n  }\r\n\r\n  // Note that we need to handle multiple properties in process, not just one in order to avoid recursion.\r\n  // ( except in the case of null propagation with fks where null -> 0 in some cases.)\r\n  // (this may not be needed because of the newValue === oldValue test above)\r\n  let inProcess = entityAspect._inProcess = entityAspect._inProcess || [];\r\n  // check for recursion\r\n  if (inProcess.indexOf(property) >= 0) return;\r\n  inProcess.push(property);\r\n\r\n  try {\r\n\r\n    let context: IContext = {\r\n      parent: this,\r\n      property: property,\r\n      newValue: newValue,\r\n      oldValue: oldValue,\r\n      propertyName: propertyName,\r\n      entityAspect: entityAspect\r\n    };\r\n\r\n    if ((property as any).isComplexProperty) {\r\n      setDpValueComplex(context, rawAccessorFn);\r\n    } else if (property.isDataProperty) {\r\n      setDpValueSimple(context, rawAccessorFn);\r\n    } else {\r\n      setNpValue(context, rawAccessorFn);\r\n    }\r\n\r\n    postChangeEvents(context);\r\n\r\n  } finally {\r\n    inProcess.pop();\r\n  }\r\n}\r\n\r\ninterface IContext {\r\n  parent: StructuralObject;\r\n  property: EntityProperty;\r\n  propertyName: string;\r\n  entityAspect: EntityAspect;\r\n  oldValue: any;\r\n  newValue: any;\r\n}\r\n\r\nfunction setDpValueSimple(context: IContext, rawAccessorFn: any) {\r\n  let parent = context.parent;\r\n  let property = context.property as DataProperty;\r\n  let entityAspect = context.entityAspect;\r\n  let oldValue = context.oldValue;\r\n  let newValue = context.newValue;\r\n\r\n  let entityManager = entityAspect.entityManager;\r\n\r\n  if (!property.isScalar) {\r\n    throw new Error(\"Nonscalar data properties are readonly - items may be added or removed but the collection may not be changed.\");\r\n  }\r\n\r\n  // store an original value for this property if not already set\r\n  if (entityAspect.entityState.isUnchangedOrModified()) {\r\n    let propName = property.name;\r\n    // localAspect is not the same as entityAspect for complex props\r\n    let localAspect = EntityAspect.isEntity(parent) ? parent.entityAspect : parent.complexAspect;\r\n    if (localAspect.originalValues[propName] === undefined) {\r\n      // otherwise this entry will be skipped during serialization\r\n      localAspect.originalValues[propName] = oldValue !== undefined ? oldValue : property.defaultValue;\r\n    }\r\n  }\r\n\r\n  // if we are changing the key update our internal entityGroup indexes.\r\n  if (property.isPartOfKey && entityManager && !entityManager.isLoading) {\r\n    // 'entityType' on the next line be null for complex properties but it will only be ref'd within this\r\n    // fn when the property is part of the key\r\n    let entityType = (parent as Entity).entityType;\r\n    let keyProps = entityType.keyProperties;\r\n    let values = keyProps.map(function (p) {\r\n      if (p === property) {\r\n        return newValue;\r\n      } else {\r\n        return parent.getProperty(p.name);\r\n      }\r\n    });\r\n    let newKey = new EntityKey(entityType, values);\r\n    if (entityManager.findEntityByKey(newKey)) {\r\n      throw new Error(\"An entity with this key is already in the cache: \" + newKey.toString());\r\n    }\r\n    let oldKey = (parent as Entity).entityAspect.getKey();\r\n    let eg = entityManager._findEntityGroup(entityType);\r\n    eg._replaceKey(oldKey, newKey);\r\n  }\r\n\r\n  // process related updates ( the inverse relationship) first so that collection dups check works properly.\r\n  // update inverse relationship\r\n\r\n  let relatedNavProp = property.relatedNavigationProperty;\r\n  if (relatedNavProp && entityManager) {\r\n    // Example: bidirectional fkDataProperty: 1->n: order -> orderDetails\r\n    // orderDetail.orderId <- newOrderId || null\r\n    //    ==> orderDetail.order = lookupOrder(newOrderId)\r\n    //    ==> (see set navProp above)\r\n    //       and\r\n    // Example: bidirectional fkDataProperty: 1->1: order -> internationalOrder\r\n    // internationalOrder.orderId <- newOrderId || null\r\n    //    ==> internationalOrder.order = lookupOrder(newOrderId)\r\n    //    ==> (see set navProp above)\r\n\r\n    if (newValue != null) {\r\n      let key = new EntityKey(relatedNavProp.entityType, [newValue]);\r\n      let relatedEntity = entityManager.findEntityByKey(key);\r\n\r\n      if (relatedEntity) {\r\n        parent.setProperty(relatedNavProp.name, relatedEntity);\r\n      } else {\r\n        // it may not have been fetched yet in which case we want to add it as an unattachedChild.\r\n        entityManager._unattachedChildrenMap.addChild(key, relatedNavProp, parent as Entity);\r\n        parent.setProperty(relatedNavProp.name, null);\r\n      }\r\n    } else {\r\n      parent.setProperty(relatedNavProp.name, null);\r\n    }\r\n  } else if (property.inverseNavigationProperty && entityManager && !entityManager._inKeyFixup) {\r\n    // Example: unidirectional fkDataProperty: 1->n: region -> territories\r\n    // territory.regionId <- newRegionId\r\n    //    ==> lookupRegion(newRegionId).territories.push(territory)\r\n    //                and\r\n    // Example: unidirectional fkDataProperty: 1->1: order -> internationalOrder\r\n    // internationalOrder.orderId <- newOrderId\r\n    //    ==> lookupOrder(newOrderId).internationalOrder = internationalOrder\r\n    //                and\r\n    // Example: unidirectional fkDataProperty: 1->n: region -> territories\r\n    // territory.regionId <- null\r\n    //    ==> lookupRegion(territory.oldRegionId).territories.remove(oldTerritory);\r\n    //                and\r\n    // Example: unidirectional fkDataProperty: 1->1: order -> internationalOrder\r\n    // internationalOrder.orderId <- null\r\n    //    ==> lookupOrder(internationalOrder.oldOrderId).internationalOrder = null;\r\n\r\n    let invNavProp = property.inverseNavigationProperty;\r\n\r\n    if (oldValue != null) {\r\n      let key = new EntityKey(invNavProp.parentType, [oldValue]);\r\n      let relatedEntity = entityManager.findEntityByKey(key);\r\n      if (relatedEntity) {\r\n        if (invNavProp.isScalar) {\r\n          relatedEntity.setProperty(invNavProp.name, null);\r\n        } else {\r\n          // remove 'this' from old related nav prop\r\n          let relatedArray = relatedEntity.getProperty(invNavProp.name);\r\n          // arr.splice(arr.indexOf(value_to_remove), 1);\r\n          relatedArray.splice(relatedArray.indexOf(parent), 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (newValue != null) {\r\n      let key = new EntityKey(invNavProp.parentType, [newValue]);\r\n      let relatedEntity = entityManager.findEntityByKey(key);\r\n\r\n      if (relatedEntity) {\r\n        if (invNavProp.isScalar) {\r\n          relatedEntity.setProperty(invNavProp.name, parent);\r\n        } else {\r\n          relatedEntity.getProperty(invNavProp.name).push(parent);\r\n        }\r\n      } else {\r\n        // it may not have been fetched yet in which case we want to add it as an unattachedChild.\r\n        entityManager._unattachedChildrenMap.addChild(key, invNavProp, parent as Entity);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  rawAccessorFn(newValue);\r\n\r\n  updateStateAndValidate(context);\r\n\r\n  // if (property.isPartOfKey && (!this.complexAspect)) {\r\n  if (property.isPartOfKey) {\r\n    // propogate pk change to all related entities;\r\n    let entityType = (parent as Entity).entityType;\r\n    let propertyIx = entityType.keyProperties.indexOf(property);\r\n    // this part handles order.orderId => orderDetail.orderId\r\n    // but won't handle product.productId => orderDetail.productId because product\r\n    // doesn't have an orderDetails property.\r\n    entityType.navigationProperties.forEach(function (np) {\r\n      let inverseNp = np.inverse;\r\n      let fkNames = inverseNp ? inverseNp.foreignKeyNames : np.invForeignKeyNames;\r\n\r\n      if (fkNames.length === 0) return;\r\n      let npValue = parent.getProperty(np.name);\r\n      if (!npValue) return;\r\n      let fkName = fkNames[propertyIx];\r\n      if (np.isScalar) {\r\n        npValue.setProperty(fkName, newValue);\r\n      } else {\r\n        npValue.forEach(function (iv: any) {\r\n          iv.setProperty(fkName, newValue);\r\n        });\r\n      }\r\n    });\r\n    // this handles unidirectional problems not covered above.\r\n    if (entityManager) {\r\n      let inverseForeignKeyProperties = entityType.inverseForeignKeyProperties;\r\n      let baseEntityType = entityType.baseEntityType;\r\n      while (baseEntityType) {\r\n        inverseForeignKeyProperties = inverseForeignKeyProperties.concat(baseEntityType.inverseForeignKeyProperties);\r\n        baseEntityType = baseEntityType.baseEntityType;\r\n      }\r\n      inverseForeignKeyProperties.forEach((invFkProp) => {\r\n        if (invFkProp.relatedNavigationProperty!.inverse == null) {\r\n          // this next step may be slow - it iterates over all of the entities in a group;\r\n          // hopefully it doesn't happen often.\r\n          entityManager!._updateFkVal(invFkProp, oldValue, newValue);\r\n        }\r\n        \r\n      });\r\n    }\r\n\r\n    // insure that cached key is updated.\r\n    entityAspect.getKey(true);\r\n  }\r\n}\r\n\r\nfunction setDpValueComplex(context: IContext, rawAccessorFn: Function) {\r\n  let property = context.property as DataProperty;\r\n  let oldValue = context.oldValue;\r\n  let newValue = context.newValue;\r\n\r\n  // To get here it must be a ComplexProperty\r\n  // 'dataType' will be a complexType\r\n  let dataType = property.dataType as ComplexType;\r\n  if (property.isScalar) {\r\n    if (!newValue) {\r\n      throw new Error(core.formatString(\"You cannot set the '%1' property to null because it's datatype is the ComplexType: '%2'\", property.name, property.dataType.name));\r\n    }\r\n\r\n    if (!oldValue) {\r\n      let ctor = dataType.getCtor();\r\n      oldValue = new ctor();\r\n      rawAccessorFn(oldValue);\r\n    }\r\n    dataType.dataProperties.forEach(function (dp) {\r\n      let pn = dp.name;\r\n      let nv = newValue.getProperty(pn);\r\n      oldValue.setProperty(pn, nv);\r\n    });\r\n  } else {\r\n    throw new Error(core.formatString(\"You cannot set the non-scalar complex property: '%1' on the type: '%2'.\" +\r\n            \"Instead get the property and use array functions like 'push' or 'splice' to change its contents.\",\r\n        property.name, property.parentType.name));\r\n  }\r\n}\r\n\r\n\r\nfunction setNpValue(context: IContext, rawAccessorFn: Function) {\r\n\r\n  let parent = context.parent as Entity;\r\n  let property = context.property as NavigationProperty;\r\n  let entityAspect = context.entityAspect;\r\n  let oldValue = context.oldValue;\r\n  let newValue = context.newValue;\r\n\r\n  if (!property.isScalar) {\r\n    throw new Error(\"Nonscalar navigation properties are readonly - entities can be added or removed but the collection may not be changed.\");\r\n  }\r\n\r\n  let entityManager = entityAspect.entityManager;\r\n  let inverseProp = property.inverse;\r\n\r\n  // manage attachment -\r\n  if (newValue != null) {\r\n    let newAspect = newValue.entityAspect;\r\n    if (entityManager) {\r\n      if (newAspect.entityState.isDetached()) {\r\n        if (!entityManager.isLoading) {\r\n          entityManager.attachEntity(newValue, EntityState.Added);\r\n        }\r\n      } else {\r\n        if (newAspect.entityManager !== entityManager) {\r\n          throw new Error(\"An Entity cannot be attached to an entity in another EntityManager. One of the two entities must be detached first.\");\r\n        }\r\n      }\r\n    } else {\r\n      if (newAspect && newAspect.entityManager) {\r\n        entityManager = newAspect.entityManager;\r\n        if (!entityManager!.isLoading) {\r\n          entityManager!.attachEntity(entityAspect.entity!, EntityState.Added);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // process related updates ( the inverse relationship) first so that collection dups check works properly.\r\n  // update inverse relationship\r\n  if (inverseProp) {\r\n    ///\r\n    if (inverseProp.isScalar) {\r\n      // Example: bidirectional navProperty: 1->1: order -> internationalOrder\r\n      // order.internationalOrder <- internationalOrder || null\r\n      //    ==> (oldInternationalOrder.order = null)\r\n      //    ==> internationalOrder.order = order\r\n      if (oldValue != null) {\r\n        // TODO: null -> NullEntity later\r\n        oldValue.setProperty(inverseProp.name, null);\r\n      }\r\n      if (newValue != null) {\r\n        newValue.setProperty(inverseProp.name, parent);\r\n      }\r\n    } else {\r\n      // Example: bidirectional navProperty: 1->n: order -> orderDetails\r\n      // orderDetail.order <- newOrder || null\r\n      //    ==> (oldOrder).orderDetails.remove(orderDetail)\r\n      //    ==> order.orderDetails.push(newOrder)\r\n      if (oldValue != null) {\r\n        let oldSiblings = oldValue.getProperty(inverseProp.name);\r\n        let ix = oldSiblings.indexOf(parent);\r\n        if (ix !== -1) {\r\n          oldSiblings.splice(ix, 1);\r\n        }\r\n      }\r\n      if (newValue != null) {\r\n        let siblings = newValue.getProperty(inverseProp.name);\r\n        // recursion check if already in the collection is performed by the relationArray\r\n        siblings.push(parent);\r\n      }\r\n    }\r\n  } else if (property.invForeignKeyNames && entityManager && !entityManager._inKeyFixup) {\r\n    let invForeignKeyNames = property.invForeignKeyNames;\r\n    if (newValue != null) {\r\n      // Example: unidirectional navProperty: 1->1: order -> internationalOrder\r\n      // order.InternationalOrder <- internationalOrder\r\n      //    ==> internationalOrder.orderId = orderId\r\n      //      and\r\n      // Example: unidirectional navProperty: 1->n: order -> orderDetails\r\n      // orderDetail.order <-xxx newOrder\r\n      //    ==> CAN'T HAPPEN because if unidirectional because orderDetail will not have an order prop\r\n      let pkValues = parent.entityAspect.getKey().values;\r\n      invForeignKeyNames.forEach( (fkName, i) => {\r\n        newValue!.setProperty(fkName, pkValues[i]);\r\n      });\r\n    } else {\r\n      // Example: unidirectional navProperty: 1->1: order -> internationalOrder\r\n      // order.internationalOrder <- null\r\n      //    ==> (old internationalOrder).orderId = null\r\n      //        and\r\n      // Example: unidirectional navProperty: 1->n: order -> orderDetails\r\n      // orderDetail.order <-xxx newOrder\r\n      //    ==> CAN'T HAPPEN because if unidirectional because orderDetail will not have an order prop\r\n      if (oldValue != null) {\r\n        invForeignKeyNames.forEach( (fkName) => {\r\n          let fkProp = oldValue.entityType.getProperty(fkName);\r\n          if (!fkProp.isPartOfKey) {\r\n            // don't update with null if fk is part of the key\r\n            oldValue.setProperty(fkName, null);\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  rawAccessorFn(newValue);\r\n\r\n  updateStateAndValidate(context);\r\n\r\n  // update fk data property - this can only occur if this navProperty has\r\n  // a corresponding fk on this entity.\r\n  if (property.relatedDataProperties) {\r\n    let entityState = entityAspect.entityState;\r\n    // if either side of nav prop is detached don't clear fks. Note: oldValue in next line cannot be null so no check is needed.\r\n    if (newValue == null && (entityState.isDetached() || oldValue.entityAspect.entityState.isDetached())) return;\r\n    if (entityState.isDeleted()) return;\r\n    let inverseKeyProps = property.entityType.keyProperties;\r\n    inverseKeyProps.forEach(function (keyProp, i) {\r\n      let relatedDataProp = property.relatedDataProperties[i];\r\n      // Do not trash related property if it is part of that entity's key\r\n      if (newValue || !relatedDataProp.isPartOfKey) {\r\n        let relatedValue = newValue ? newValue.getProperty(keyProp.name) : relatedDataProp.defaultValue;\r\n        parent.setProperty(relatedDataProp.name, relatedValue);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction postChangeEvents(context: IContext) {\r\n  let entityAspect = context.entityAspect;\r\n\r\n  let entityManager = entityAspect.entityManager;\r\n  let entity = entityAspect.entity;\r\n\r\n  let propChangedArgs = { entity: entity!, parent: context.parent, property: context.property, propertyName: context.propertyName, oldValue: context.oldValue, newValue: context.newValue };\r\n  if (entityManager) {\r\n    // propertyChanged will be fired during loading but we only want to fire it once per entity, not once per property.\r\n    // so propertyChanged is fired in the entityManager mergeEntity method if not fired here.\r\n    if ((!entityManager.isLoading) && (!entityManager.isRejectingChanges)) {\r\n      entityAspect.propertyChanged.publish(propChangedArgs);\r\n      // don't fire entityChanged event if propertyChanged is suppressed.\r\n      entityManager.entityChanged.publish({ entityAction: EntityAction.PropertyChange, entity: entity, args: propChangedArgs });\r\n    }\r\n  } else {\r\n    entityAspect.propertyChanged.publish(propChangedArgs);\r\n  }\r\n}\r\n\r\nfunction updateStateAndValidate(context: IContext) {\r\n  let entityAspect = context.entityAspect;\r\n  let entityManager = entityAspect.entityManager;\r\n  if (entityManager == null || entityManager.isLoading) return;\r\n  let property = context.property;\r\n\r\n  if (entityAspect.entityState.isUnchanged() && !property.isUnmapped) {\r\n    entityAspect.setModified();\r\n  }\r\n\r\n  if (entityManager.validationOptions.validateOnPropertyChange) {\r\n    // entityAspect.entity is NOT the same as parent in the code below. It's use is deliberate.\r\n    entityAspect._validateProperty(context.newValue,\r\n        { entity: entityAspect.entity, property: property, propertyName: context.propertyName, oldValue: context.oldValue });\r\n  }\r\n}\r\n","import { core, ErrorCallback } from './core';\r\nimport { config } from './config';\r\nimport { BreezeEvent } from './event';\r\nimport { assertParam, assertConfig, Param } from './assert-param';\r\nimport { DataType } from './data-type';\r\nimport { EntityAspect, ComplexAspect, Entity, ComplexObject, StructuralObject } from './entity-aspect';\r\nimport { EntityKey } from './entity-key';\r\nimport { Validator } from './validate';\r\nimport { BreezeEnum } from './enum';\r\nimport { DataService } from './data-service';\r\nimport { NamingConvention } from './naming-convention';\r\nimport { CsdlMetadataParser } from './csdl-metadata-parser'; // TODO isolate this later;\r\nimport { LocalQueryComparisonOptions } from './local-query-comparison-options';\r\nimport { defaultPropertyInterceptor } from './default-property-interceptor';\r\n\r\nexport type EntityProperty = DataProperty | NavigationProperty;\r\nexport type StructuralType = EntityType | ComplexType;\r\n\r\n/** @hidden @internal */\r\nexport interface IStructuralTypeMap {\r\n  [index: string]: StructuralType;\r\n}\r\n\r\n// TODO: consider exposing later\r\n/** @hidden @internal */\r\nexport interface IMetadataJson {\r\n  metadataVersion: string;\r\n  name: string;\r\n  namingConvention: string;\r\n  localQueryComparisonOptions: string;\r\n  dataServices: Object[]; // IDataServiceJson[]\r\n  structuralTypes: Object[]; // IStructuralTypeJson[]; \r\n  resourceEntityTypeMap: Object[]; // IResourceEntityTypeJson[]\r\n  incompleteTypeMap: Object[];\r\n}\r\n\r\n/** Configuration info to be passed to the [[MetadataStore]] constructor */\r\nexport interface MetadataStoreConfig {\r\n  /** The  [[NamingConvention]] associated with this MetadataStore. */\r\n  namingConvention?: NamingConvention;\r\n  /** The  [[LocalQueryComparisonOptions]] associated with this MetadataStore. */\r\n  localQueryComparisonOptions?: LocalQueryComparisonOptions;\r\n  serializerFn?: (prop: EntityProperty, val: any) => any;\r\n  name?: string;\r\n}\r\n\r\nexport interface MetadataFetchedEventArgs {\r\n  metadataStore: MetadataStore;\r\n  dataService: DataService | string;\r\n  rawMetadata: any;\r\n}\r\n\r\n/**\r\nAn instance of the MetadataStore contains all of the metadata about a collection of [[EntityType]]'s.\r\nMetadataStores may be shared across [[EntityManager]]'s.  If an EntityManager is created without an\r\nexplicit MetadataStore, the MetadataStore from the MetadataStore.defaultInstance property will be used.\r\n@dynamic\r\n**/\r\nexport class MetadataStore {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // on proto\r\n\r\n  /** @hidden @internal */\r\n  static __id = 0;\r\n  /** @hidden @internal */\r\n  static ANONTYPE_PREFIX = \"_IB_\";\r\n  /** The version of any MetadataStores created by this class */\r\n  static metadataVersion = '1.0.5';\r\n\r\n  name: string;\r\n  dataServices: DataService[];\r\n\r\n  /** The  [[NamingConvention]] associated with this MetadataStore. __Read Only__ */\r\n  namingConvention: NamingConvention;\r\n  /** The  [[LocalQueryComparisonOptions]] associated with this MetadataStore. __Read Only__ */\r\n  localQueryComparisonOptions: LocalQueryComparisonOptions;\r\n  serializerFn?: (prop: EntityProperty, val: any) => any;\r\n  /**\r\n  An [[BreezeEvent]] that fires after a MetadataStore has completed fetching metadata from a remote service.\r\n  \r\n  @eventArgs -\r\n    - metadataStore - The MetadataStore into which the metadata was fetched.\r\n    - dataService - The [[DataService]] that metadata was fetched from.\r\n    - rawMetadata - {Object} The raw metadata returned from the service. (It will have already been processed by this point).\r\n  >      let ms = myEntityManager.metadataStore;\r\n  >      ms.metadataFetched.subscribe(function(args) {\r\n  >          let metadataStore = args.metadataStore;\r\n  >          let dataService = args.dataService;\r\n  >      });\r\n  @event\r\n  **/\r\n  metadataFetched: BreezeEvent<MetadataFetchedEventArgs>;\r\n  /** @hidden @internal */\r\n  _resourceEntityTypeMap: {};\r\n  /** @hidden @internal */\r\n  _entityTypeResourceMap: {};\r\n  /** @hidden @internal */\r\n  _structuralTypeMap: IStructuralTypeMap; // key is qualified structuraltype name - value is structuralType. ( structural = entityType or complexType).\r\n  /** @hidden @internal **/\r\n  _shortNameMap: {}; // key is shortName, value is qualified name - does not need to be serialized.\r\n  /** @hidden @internal **/\r\n  _ctorRegistry: {}; // key is either short or qual type name - value is ctor;\r\n  /** @hidden @internal **/\r\n  _incompleteTypeMap: {}; // key is entityTypeName; value is array of nav props\r\n  /** @hidden @internal **/\r\n  _incompleteComplexTypeMap: {}; //\r\n  /** @hidden @internal **/\r\n  _deferredTypes: {};\r\n  /** @hidden @internal **/\r\n  _id: number;\r\n\r\n  /**\r\n  Constructs a new MetadataStore.\r\n  \r\n  >     let ms = new MetadataStore();\r\n\r\n  The store can then be associated with an EntityManager\r\n  >     let entityManager = new EntityManager( {\r\n  >         serviceName: \"breeze/NorthwindIBModel\", \r\n  >         metadataStore: ms \r\n  >     });\r\n\r\n  or for an existing EntityManager\r\n  >    // Assume em1 is an existing EntityManager\r\n  >    em1.setProperties( { metadataStore: ms });\r\n  \r\n  @param config - Configuration settings .\r\n    - namingConvention - (default=NamingConvention.defaultInstance) NamingConvention to be used in mapping property names\r\n  between client and server. Uses the NamingConvention.defaultInstance if not specified.\r\n    - localQueryComparisonOptions - (default=LocalQueryComparisonOptions.defaultInstance) The LocalQueryComparisonOptions to be\r\n  used when performing \"local queries\" in order to match the semantics of queries against a remote service.\r\n    - serializerFn - A function that is used to mediate the serialization of instances of this type.\r\n  **/\r\n  constructor(config?: MetadataStoreConfig) {\r\n    config = config || {};\r\n    assertConfig(config)\r\n      .whereParam(\"namingConvention\").isOptional().isInstanceOf(NamingConvention).withDefault(NamingConvention.defaultInstance)\r\n      .whereParam(\"localQueryComparisonOptions\").isOptional().isInstanceOf(LocalQueryComparisonOptions).withDefault(LocalQueryComparisonOptions.defaultInstance)\r\n      .whereParam(\"serializerFn\").isOptional().isFunction()\r\n      .applyAll(this);\r\n    this.dataServices = []; // array of dataServices;\r\n    this._resourceEntityTypeMap = {}; // key is resource name - value is qualified entityType name\r\n    this._structuralTypeMap = {}; // key is qualified structuraltype name - value is structuralType. ( structural = entityType or complexType).\r\n    this._shortNameMap = {}; // key is shortName, value is qualified name - does not need to be serialized.\r\n    this._ctorRegistry = {}; // key is either short or qual type name - value is ctor;\r\n\r\n    this._incompleteTypeMap = {}; // key is entityTypeName; value is array of nav props\r\n    this._incompleteComplexTypeMap = {}; // key is complexTypeName; value is array of complexType props\r\n    this._id = MetadataStore.__id++;\r\n    this.metadataFetched = new BreezeEvent(\"metadataFetched\", this);\r\n\r\n  }\r\n\r\n  // needs to be made avail to dataService.xxx files\r\n  static normalizeTypeName = core.memoize(function (rawTypeName: string) {\r\n    return rawTypeName && MetadataStore.parseTypeName(rawTypeName).typeName;\r\n  });\r\n  // for debugging use the line below instead.\r\n  //ctor.normalizeTypeName = function (rawTypeName) { return parseTypeName(rawTypeName).typeName; };\r\n\r\n  /**\r\n  General purpose property set method\r\n  \r\n  >     // assume em1 is an EntityManager containing a number of existing entities.\r\n  >     em1.metadataStore.setProperties( {\r\n  >         version: \"6.1.3\",\r\n  >         serializerFn: function(prop, value) {\r\n  >         return (prop.isUnmapped) ? undefined : value;\r\n  >         }\r\n  >     )};\r\n  @param config -  An object containing the selected properties and values to set.\r\n  **/\r\n  setProperties(config: MetadataStoreConfig) {\r\n    assertConfig(config)\r\n      .whereParam(\"name\").isString().isOptional()\r\n      .whereParam(\"serializerFn\").isFunction().isOptional()\r\n      .applyAll(this);\r\n  }\r\n\r\n  /**\r\n  Adds a DataService to this MetadataStore. If a DataService with the same serviceName is already\r\n  in the MetadataStore an exception will be thrown.\r\n  @param dataService - The [[DataService]] to add\r\n  @param shouldOverwrite - (default=false) Permit overwrite of existing DataService rather than throw exception\r\n  **/\r\n  addDataService(dataService: DataService, shouldOverwrite?: boolean) {\r\n    assertParam(dataService, \"dataService\").isInstanceOf(DataService).check();\r\n    assertParam(shouldOverwrite, \"shouldOverwrite\").isBoolean().isOptional().check();\r\n    let ix = this._getDataServiceIndex(dataService.serviceName);\r\n    if (ix >= 0) {\r\n      if (!!shouldOverwrite) {\r\n        this.dataServices[ix] = dataService;\r\n      } else {\r\n        throw new Error(\"A dataService with this name '\" + dataService.serviceName + \"' already exists in this MetadataStore\");\r\n      }\r\n    } else {\r\n      this.dataServices.push(dataService);\r\n    }\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _getDataServiceIndex(serviceName: string) {\r\n    return core.arrayIndexOf(this.dataServices, function (ds) {\r\n      return ds.serviceName === serviceName;\r\n    });\r\n  }\r\n\r\n  /**\r\n  Adds an EntityType to this MetadataStore.  No additional properties may be added to the EntityType after its has\r\n  been added to the MetadataStore.\r\n  @param structuralType - The EntityType or ComplexType to add\r\n  **/\r\n  addEntityType(stype: StructuralType | EntityTypeConfig | ComplexTypeConfig) {\r\n    let structuralType: StructuralType;\r\n    if (stype instanceof EntityType || stype instanceof ComplexType) {\r\n      structuralType = stype;\r\n    } else {\r\n      structuralType = (stype as any).isComplexType ? new ComplexType(stype) : new EntityType(stype);\r\n    }\r\n\r\n    // if (!structuralType.isComplexType) { // same as below but isn't a 'type guard'\r\n    if (structuralType instanceof EntityType) {\r\n      if (structuralType.baseTypeName && !structuralType.baseEntityType) {\r\n        let baseEntityType = this._getStructuralType(structuralType.baseTypeName, true);\r\n        // safe cast because we know that baseEntityType must be an EntityType if the structuralType is an EntityType\r\n        structuralType._updateFromBase(baseEntityType as EntityType);\r\n      }\r\n      if (structuralType.keyProperties.length === 0 && !structuralType.isAbstract) {\r\n        throw new Error(\"Unable to add \" + structuralType.name +\r\n          \" to this MetadataStore.  An EntityType must have at least one property designated as a key property - See the 'DataProperty.isPartOfKey' property.\");\r\n      }\r\n    }\r\n\r\n    structuralType.metadataStore = this;\r\n    // don't register anon types\r\n    if (!(structuralType as any).isAnonymous) {\r\n      if (this._structuralTypeMap[structuralType.name]) {\r\n        throw new Error(\"Type \" + structuralType.name + \" already exists in this MetadataStore.\");\r\n      }\r\n\r\n      this._structuralTypeMap[structuralType.name] = structuralType;\r\n      this._shortNameMap[structuralType.shortName] = structuralType.name;\r\n    }\r\n\r\n    structuralType.getProperties().forEach(p => {\r\n      structuralType._updateNames(p);\r\n      if (!p.isUnmapped) {\r\n        structuralType._mappedPropertiesCount++;\r\n      }\r\n    });\r\n\r\n    structuralType._updateCps();\r\n\r\n    // 'isEntityType' is a type guard\r\n    if (structuralType instanceof EntityType) {\r\n      structuralType._updateNps();\r\n      // give the type it's base's resource name if it doesn't have its own.\r\n      let defResourceName = structuralType.defaultResourceName || (structuralType.baseEntityType && structuralType.baseEntityType.defaultResourceName);\r\n      if (defResourceName && !this.getEntityTypeNameForResourceName(defResourceName)) {\r\n        this.setEntityTypeForResourceName(defResourceName, structuralType.name);\r\n      }\r\n      structuralType.defaultResourceName = defResourceName;\r\n      // check if this structural type's name, short version or qualified version has a registered ctor.\r\n      structuralType.getEntityCtor();\r\n    }\r\n\r\n  }\r\n\r\n\r\n  /**\r\n  Exports this MetadataStore to a serialized string appropriate for local storage.   This operation is also called\r\n  internally when exporting an EntityManager.\r\n  >      // assume ms is a previously created MetadataStore\r\n  >      let metadataAsString = ms.exportMetadata();\r\n  >      window.localStorage.setItem(\"metadata\", metadataAsString);\r\n  >      // and later, usually in a different session imported\r\n  >      let metadataFromStorage = window.localStorage.getItem(\"metadata\");\r\n  >      let newMetadataStore = new MetadataStore();\r\n  >      newMetadataStore.importMetadata(metadataFromStorage);\r\n  @return A serialized version of this MetadataStore that may be stored locally and later restored.\r\n  **/\r\n  exportMetadata() {\r\n    let result = JSON.stringify({\r\n      \"metadataVersion\": MetadataStore.metadataVersion,\r\n      \"name\": this.name,\r\n      \"namingConvention\": this.namingConvention.name,\r\n      \"localQueryComparisonOptions\": this.localQueryComparisonOptions.name,\r\n      \"dataServices\": this.dataServices,\r\n      \"structuralTypes\": core.objectMap(this._structuralTypeMap),\r\n      \"resourceEntityTypeMap\": this._resourceEntityTypeMap\r\n    }, null, config.stringifyPad);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n  Imports a previously exported serialized MetadataStore into this MetadataStore.\r\n    \r\n  >      // assume ms is a previously created MetadataStore\r\n  >      let metadataAsString = ms.exportMetadata();\r\n  >      window.localStorage.setItem(\"metadata\", metadataAsString);\r\n  >      // and later, usually in a different session\r\n  >      let metadataFromStorage = window.localStorage.getItem(\"metadata\");\r\n  >      let newMetadataStore = new MetadataStore();\r\n  >      newMetadataStore.importMetadata(metadataFromStorage);\r\n  @param exportedMetadata - A previously exported MetadataStore.\r\n  @param allowMerge -  Allows custom metadata to be merged into existing metadata types.\r\n  @return This MetadataStore.\r\n  @chainable\r\n  **/\r\n  importMetadata(exportedMetadata: string | Object, allowMerge: boolean = false) {\r\n    assertParam(allowMerge, \"allowMerge\").isOptional().isBoolean().check();\r\n    this._deferredTypes = {};\r\n    // insure that we don't mutate incoming exportedMetadata ( if its an object)\r\n    let metadataAsString = (typeof (exportedMetadata) === \"string\") ? exportedMetadata : JSON.stringify(exportedMetadata);\r\n    const metadataJson = JSON.parse(metadataAsString);\r\n\r\n    if (metadataJson.schema) {\r\n      return CsdlMetadataParser.parse(this, metadataJson.schema, metadataJson.altMetadata);\r\n    }\r\n\r\n    let json = metadataJson as IMetadataJson;\r\n    if (json.metadataVersion && json.metadataVersion !== MetadataStore.metadataVersion) {\r\n      let msg = core.formatString(\"Cannot import metadata with a different 'metadataVersion' (%1) than the current 'MetadataStore.metadataVersion' (%2) \",\r\n        json.metadataVersion, MetadataStore.metadataVersion);\r\n      throw new Error(msg);\r\n    }\r\n\r\n    let ncName = json.namingConvention;\r\n    let lqcoName = json.localQueryComparisonOptions;\r\n    if (this.isEmpty()) {\r\n      this.namingConvention = config._fetchObject(NamingConvention, ncName) || this.namingConvention;\r\n      this.localQueryComparisonOptions = config._fetchObject(LocalQueryComparisonOptions, lqcoName) || this.localQueryComparisonOptions;\r\n    } else {\r\n      if (ncName && this.namingConvention.name !== ncName) {\r\n        throw new Error(\"Cannot import metadata with a different 'namingConvention' from the current MetadataStore\");\r\n      }\r\n      if (lqcoName && this.localQueryComparisonOptions.name !== lqcoName) {\r\n        throw new Error(\"Cannot import metadata with different 'localQueryComparisonOptions' from the current MetadataStore\");\r\n      }\r\n    }\r\n\r\n    //noinspection JSHint\r\n    json.dataServices && json.dataServices.forEach((ds) => {\r\n      let realDs = DataService.fromJSON(ds);\r\n      this.addDataService(realDs, true);\r\n    });\r\n\r\n    json.structuralTypes && json.structuralTypes.forEach((stype) => {\r\n      structuralTypeFromJson(this, stype, allowMerge);\r\n    });\r\n    core.extend(this._resourceEntityTypeMap, json.resourceEntityTypeMap);\r\n    core.extend(this._incompleteTypeMap, json.incompleteTypeMap);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n  Creates a new MetadataStore from a previously exported serialized MetadataStore\r\n  >      // assume ms is a previously created MetadataStore\r\n  >      let metadataAsString = ms.exportMetadata();\r\n  >      window.localStorage.setItem(\"metadata\", metadataAsString);\r\n  >      // and later, usually in a different session\r\n  >      let metadataFromStorage = window.localStorage.getItem(\"metadata\");\r\n  >      let newMetadataStore = MetadataStore.importMetadata(metadataFromStorage);\r\n  @param exportedString - A previously exported MetadataStore.\r\n  @return A new MetadataStore.\r\n  **/\r\n  static importMetadata(exportedString: string) {\r\n    let ms = new MetadataStore();\r\n    ms.importMetadata(exportedString);\r\n    return ms;\r\n  }\r\n\r\n  /**\r\n  Returns whether Metadata has been retrieved for a specified service name.\r\n  >      // Assume em1 is an existing EntityManager.\r\n  >      if (!em1.metadataStore.hasMetadataFor(\"breeze/NorthwindIBModel\"))) {\r\n  >          // do something interesting\r\n  >      }\r\n  @param serviceName - The service name.\r\n  @return Whether metadata has already been retrieved for the specified service name.\r\n  **/\r\n  hasMetadataFor(serviceName: string) {\r\n    return !!this.getDataService(serviceName);\r\n  }\r\n\r\n  /**\r\n  Returns the DataService for a specified service name\r\n  >      // Assume em1 is an existing EntityManager.\r\n  >      let ds = em1.metadataStore.getDataService(\"breeze/NorthwindIBModel\");\r\n  >      let adapterName = ds.adapterName; // may be null\r\n  @param serviceName - The service name.\r\n  @return The DataService with the specified name.\r\n  **/\r\n  getDataService(serviceName: string) {\r\n    assertParam(serviceName, \"serviceName\").isString().check();\r\n\r\n    serviceName = DataService._normalizeServiceName(serviceName);\r\n    return core.arrayFirst(this.dataServices, function (ds: DataService) {\r\n      return ds.serviceName === serviceName;\r\n    });\r\n  }\r\n\r\n  /**\r\n  Fetches the metadata for a specified 'service'. This method is automatically called\r\n  internally by an EntityManager before its first query against a new service. __Async__\r\n\r\n  Usually you will not actually process the results of a fetchMetadata call directly, but will instead\r\n  ask for the metadata from the EntityManager after the fetchMetadata call returns.\r\n  >      let ms = new MetadataStore();\r\n  >      // or more commonly\r\n  >      // let ms = anEntityManager.metadataStore;\r\n  >      ms.fetchMetadata(\"breeze/NorthwindIBModel\").then(function(rawMetadata) {\r\n  >            // do something with the metadata\r\n  >      }).catch(function(exception) {\r\n  >          // handle exception here\r\n  >      });\r\n  @param dataService -  Either a DataService or just the name of the DataService to fetch metadata for.\r\n  @param callback - Function called on success.\r\n  @param errorCallback - Function called on failure.\r\n  @return Promise\r\n  **/\r\n  fetchMetadata(dataService: string | DataService, callback?: (schema: any) => void, errorCallback?: ErrorCallback) {\r\n    try {\r\n      assertParam(dataService, \"dataService\").isString().or().isInstanceOf(DataService).check();\r\n      assertParam(callback, \"callback\").isFunction().isOptional().check();\r\n      assertParam(errorCallback, \"errorCallback\").isFunction().isOptional().check();\r\n\r\n      if (typeof dataService === \"string\") {\r\n        // use the dataService with a matching name or create a new one.\r\n        dataService = this.getDataService(dataService) || new DataService({ serviceName: dataService });\r\n      }\r\n\r\n      dataService = DataService.resolve([dataService]);\r\n\r\n      if (this.hasMetadataFor(dataService.serviceName)) {\r\n        throw new Error(\"Metadata for a specific serviceName may only be fetched once per MetadataStore. ServiceName: \" + dataService.serviceName);\r\n      }\r\n\r\n      return dataService.adapterInstance!.fetchMetadata(this, dataService).then((rawMetadata: any) => {\r\n        this.metadataFetched.publish({ metadataStore: this, dataService: dataService, rawMetadata: rawMetadata });\r\n        if (callback) callback(rawMetadata);\r\n        return Promise.resolve(rawMetadata);\r\n      }, function (error: any) {\r\n        if (errorCallback) errorCallback(error);\r\n        return Promise.reject(error);\r\n      });\r\n    } catch (e) {\r\n      return Promise.reject(e);\r\n    }\r\n  }\r\n\r\n\r\n  // TODO: strongly type interceptor below.\r\n  /**\r\n  Used to register a constructor for an EntityType that is not known via standard Metadata discovery;\r\n  i.e. an unmapped type.\r\n  @param entityCtor - The constructor function for the 'unmapped' type.\r\n  @param interceptor - An interceptor function\r\n  **/\r\n  trackUnmappedType(entityCtor: any, interceptor: any) {\r\n    assertParam(entityCtor, \"entityCtor\").isFunction().check();\r\n    assertParam(interceptor, \"interceptor\").isFunction().isOptional().check();\r\n    // TODO: think about adding this to the MetadataStore.\r\n    let entityType = new EntityType(this);\r\n    entityType._setCtor(entityCtor, interceptor);\r\n  }\r\n\r\n  /**\r\n  Provides a mechanism to register a 'custom' constructor to be used when creating new instances\r\n  of the specified entity type.  If this call is not made, a default constructor is created for\r\n  the entity as needed.\r\n  This call may be made before or after the corresponding EntityType has been discovered via\r\n  Metadata discovery.\r\n  >      let Customer = function () {\r\n  >              this.miscData = \"asdf\";\r\n  >          };\r\n  >      Customer.prototype.doFoo() {\r\n  >              ...\r\n  >          }\r\n  >      // assume em1 is a preexisting EntityManager;\r\n  >      em1.metadataStore.registerEntityTypeCtor(\"Customer\", Customer);\r\n  >      // any queries or EntityType.create calls from this point on will call the Customer constructor\r\n  >      // registered above.\r\n  @param structuralTypeName - The name of the EntityType or ComplexType.\r\n  @param aCtor - The constructor for this EntityType or ComplexType; may be null if all you want to do is set the next parameter.\r\n  @param initFn - A function or the name of a function on the entity that is to be executed immediately after the entity has been created\r\n  and populated with any initial values. Called with 'initFn(entity)'\r\n  @param noTrackingFn - A function that is executed immediately after a noTracking entity has been created and whose return\r\n  value will be used in place of the noTracking entity.\r\n  **/\r\n  registerEntityTypeCtor(structuralTypeName: string, aCtor?: any, initFn?: Function | string, noTrackingFn?: Function) {\r\n    assertParam(structuralTypeName, \"structuralTypeName\").isString().check();\r\n    assertParam(aCtor, \"aCtor\").isFunction().isOptional().check();\r\n    assertParam(initFn, \"initFn\").isOptional().isFunction().or().isString().check();\r\n    assertParam(noTrackingFn, \"noTrackingFn\").isOptional().isFunction().check();\r\n\r\n    let qualifiedTypeName = getQualifiedTypeName(this, structuralTypeName, false);\r\n    let typeName = qualifiedTypeName || structuralTypeName;\r\n\r\n    if (aCtor) {\r\n      if (aCtor._$typeName && aCtor._$typeName !== typeName) {\r\n        // TODO: wrap this - console and especially console.warn does not exist in all browsers.\r\n        console.warn(\"Registering a constructor for \" + typeName + \" that is already used for \" + aCtor._$typeName + \".\");\r\n      }\r\n      aCtor._$typeName = typeName;\r\n    }\r\n\r\n    this._ctorRegistry[typeName] = { ctor: aCtor, initFn: initFn, noTrackingFn: noTrackingFn };\r\n    if (qualifiedTypeName) {\r\n      let stype = this._structuralTypeMap[qualifiedTypeName];\r\n      stype && stype.getCtor(true); // this will complete the registration if avail now.\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n  Returns whether this MetadataStore contains any metadata yet.\r\n  >      // assume em1 is a preexisting EntityManager;\r\n  >      if (em1.metadataStore.isEmpty()) {\r\n  >          // do something interesting\r\n  >      }\r\n  **/\r\n  isEmpty() {\r\n    return core.isEmpty(this._structuralTypeMap);\r\n  }\r\n\r\n  /**\r\n  Returns an [[EntityType]] or null given its name.\r\n  >      // assume em1 is a preexisting EntityManager\r\n  >      let odType = em1.metadataStore.getAsEntityType(\"OrderDetail\");\r\n\r\n  or to throw an error if the type is not found\r\n  >      let badType = em1.metadataStore.getAsEntityType(\"Foo\", false);\r\n  >      // badType will not get set and an exception will be thrown.\r\n  @param structuralTypeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share\r\n  that same short name an exception will be thrown.\r\n  @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.\r\n  @return The EntityType. ComplexType or 'null' if not not found.\r\n  **/\r\n  getAsEntityType(typeName: string, okIfNotFound: boolean = false) {\r\n    const st = this.getStructuralType(typeName, okIfNotFound);\r\n    if (st instanceof EntityType) {\r\n      return st as EntityType;\r\n    } else if (okIfNotFound) {\r\n      return null;\r\n    } else {\r\n      let msg = core.formatString(\"Unable to locate an 'EntityType' by the name: '%1'. Be sure to execute a query or call fetchMetadata first.\", typeName);\r\n      throw new Error(msg);\r\n    }\r\n  }\r\n\r\n  /**\r\n  Returns an [[EntityType]] or null given its name.\r\n  >      // assume em1 is a preexisting EntityManager\r\n  >      let locType = em1.metadataStore.getAsComplexType(\"Location\");\r\n\r\n  or to throw an error if the type is not found\r\n  >      let badType = em1.metadataStore.getAsComplexType(\"Foo\", false);\r\n  >      // badType will not get set and an exception will be thrown.\r\n  @param structuralTypeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share\r\n  that same short name an exception will be thrown.\r\n  @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.\r\n  @return The EntityType. ComplexType or 'null' if not not found.\r\n  **/\r\n getAsComplexType(typeName: string, okIfNotFound: boolean = false) {\r\n  const st = this.getStructuralType(typeName, okIfNotFound);\r\n  if (st instanceof ComplexType) {\r\n    return st as ComplexType;\r\n  } else if (okIfNotFound) {\r\n    return null;\r\n  } else {\r\n    let msg = core.formatString(\"Unable to locate an 'ComplexType' by the name: '%1'. Be sure to execute a query or call fetchMetadata first.\", typeName);\r\n    throw new Error(msg);\r\n  }\r\n}\r\n\r\n\r\n  /**\r\n  Returns an [[EntityType]] or a [[ComplexType]] given its name.\r\n  @deprecated Replaced by getStructuralType but ... it is probably more usefull to call either getAsEntityType or getAsComplexType instead\r\n  @param typeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share\r\n  that same short name an exception will be thrown.\r\n  @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.\r\n  @return The EntityType. ComplexType or 'null' if not not found.\r\n  **/\r\n  getEntityType(typeName: string, okIfNotFound: boolean = false) {\r\n    return this.getStructuralType(typeName, okIfNotFound);\r\n  }\r\n\r\n  /**\r\n  Returns an [[EntityType]] or a [[ComplexType]] given its name.\r\n  >      // assume em1 is a preexisting EntityManager\r\n  >      let odType = em1.metadataStore.getStructuralType(\"OrderDetail\");\r\n\r\n  or to throw an error if the type is not found\r\n  >      let badType = em1.metadataStore.getStructuralType(\"Foo\", false);\r\n  >      // badType will not get set and an exception will be thrown.\r\n  @deprecated Preferably use either getAsEntityType or getAsComplexType.  Get\r\n  @param typeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share\r\n  that same short name an exception will be thrown.\r\n  @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.\r\n  @return The EntityType. ComplexType or 'null' if not not found.\r\n  **/\r\n  getStructuralType(typeName: string, okIfNotFound: boolean = false) {\r\n    assertParam(typeName, \"typeName\").isString().check();\r\n    assertParam(okIfNotFound, \"okIfNotFound\").isBoolean().isOptional().check(false);\r\n    return this._getStructuralType(typeName, okIfNotFound);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _getStructuralType(typeName: string, okIfNotFound: boolean = false) {\r\n    let qualTypeName = getQualifiedTypeName(this, typeName, false);\r\n    let type = this._structuralTypeMap[qualTypeName];\r\n    if (!type) {\r\n      if (okIfNotFound) return null;\r\n      let msg = core.formatString(\"Unable to locate a 'Type' by the name: '%1'. Be sure to execute a query or call fetchMetadata first.\", typeName);\r\n      throw new Error(msg);\r\n    }\r\n    return type;\r\n  }\r\n\r\n  /**\r\n  Returns an array containing all of the [[EntityType]]s or [[ComplexType]]s in this MetadataStore.\r\n  >      // assume em1 is a preexisting EntityManager\r\n  >      let allTypes = em1.metadataStore.getEntityTypes();\r\n  **/\r\n  getEntityTypes() {\r\n    return getTypesFromMap(this._structuralTypeMap);\r\n  }\r\n\r\n  getIncompleteNavigationProperties() {\r\n    return core.objectMap(this._incompleteTypeMap, function (key, value) {\r\n      return value;\r\n    });\r\n  }\r\n\r\n  /**\r\n  Returns a fully qualified entityTypeName for a specified resource name.  The reverse of this operation\r\n  can be obtained via the  [[EntityType.defaultResourceName]] property\r\n  **/\r\n  getEntityTypeNameForResourceName(resourceName: string) {\r\n    assertParam(resourceName, \"resourceName\").isString().check();\r\n    return this._resourceEntityTypeMap[resourceName];\r\n  }\r\n\r\n  /**\r\n  Associates a resourceName with an entityType.\r\n\r\n  This method is only needed in those cases where multiple resources return the same\r\n  entityType.  In this case Metadata discovery will only determine a single resource name for\r\n  each entityType.\r\n  @param resourceName - The resource name\r\n  @param entityTypeOrName - If passing a string either the fully qualified name or a short name may be used. If a short name is specified and multiple types share\r\n  that same short name an exception will be thrown. If the entityType has not yet been discovered then a fully qualified name must be used.\r\n  **/\r\n  setEntityTypeForResourceName(resourceName: string, entityTypeOrName: EntityType | string) {\r\n    assertParam(resourceName, \"resourceName\").isString().check();\r\n    assertParam(entityTypeOrName, \"entityTypeOrName\").isInstanceOf(EntityType).or().isString().check();\r\n\r\n    let entityTypeName: string;\r\n    if (entityTypeOrName instanceof EntityType) {\r\n      entityTypeName = entityTypeOrName.name;\r\n    } else {\r\n      entityTypeName = getQualifiedTypeName(this, entityTypeOrName, true);\r\n    }\r\n\r\n    this._resourceEntityTypeMap[resourceName] = entityTypeName;\r\n    let entityType = this._getStructuralType(entityTypeName, true);\r\n    if (entityType && entityType instanceof EntityType && !entityType.defaultResourceName) {\r\n      entityType.defaultResourceName = resourceName;\r\n    }\r\n  }\r\n\r\n  /** __Dev Only__ - for use when creating a new MetadataParserAdapter  */\r\n  static parseTypeName(entityTypeName: string) {\r\n    // TODO: removed \r\n    // if (!entityTypeName) {\r\n    //   return null;\r\n    // }\r\n\r\n    let typeParts = entityTypeName.split(\":#\");\r\n    if (typeParts.length > 1) {\r\n      return MetadataStore.makeTypeHash(typeParts[0], typeParts[1]);\r\n    }\r\n\r\n    if (core.stringStartsWith(entityTypeName, MetadataStore.ANONTYPE_PREFIX)) {\r\n      let typeHash = MetadataStore.makeTypeHash(entityTypeName);\r\n      (typeHash as any).isAnonymous = true;\r\n      return typeHash;\r\n    }\r\n    let entityTypeNameNoAssembly = entityTypeName.split(\",\")[0];\r\n    typeParts = entityTypeNameNoAssembly.split(\".\");\r\n    if (typeParts.length > 1) {\r\n      let shortName = typeParts[typeParts.length - 1];\r\n      let namespaceParts = typeParts.slice(0, typeParts.length - 1);\r\n      let ns = namespaceParts.join(\".\");\r\n      return MetadataStore.makeTypeHash(shortName, ns);\r\n    } else {\r\n      return MetadataStore.makeTypeHash(entityTypeName);\r\n    }\r\n  }\r\n\r\n  /** __Dev Only__ - for use when creating a new MetadataParserAdapter  */\r\n  static makeTypeHash(shortName: string, ns?: string) {\r\n    return {\r\n      shortTypeName: shortName,\r\n      namespace: ns,\r\n      typeName: qualifyTypeName(shortName, ns)\r\n    };\r\n  }\r\n\r\n  // protected methods\r\n  /** @hidden @internal */\r\n  _checkEntityType(entity: Entity) {\r\n    if (entity.entityType) return;\r\n    let typeName = entity.prototype._$typeName;\r\n    if (!typeName) {\r\n      throw new Error(\"This entity has not been registered. See the MetadataStore.registerEntityTypeCtor method\");\r\n    }\r\n    // we know that it is an EntityType ( as opposed to a ComplexType)\r\n    let entityType = this._getStructuralType(typeName) as EntityType;\r\n    if (entityType) {\r\n      entity.entityType = entityType;\r\n    }\r\n  }\r\n\r\n\r\n}\r\nMetadataStore.prototype._$typeName = \"MetadataStore\";\r\n\r\nBreezeEvent.bubbleEvent(MetadataStore.prototype);\r\n\r\nfunction getTypesFromMap(typeMap: IStructuralTypeMap) {\r\n  let types: (StructuralType)[] = [];\r\n  for (let key in typeMap) {\r\n    let value = typeMap[key];\r\n    // skip 'shortName' entries\r\n    if (key === value.name) {\r\n      types.push(typeMap[key]);\r\n    }\r\n  }\r\n  return types;\r\n}\r\n\r\nfunction structuralTypeFromJson(metadataStore: MetadataStore, json: any, allowMerge: boolean) {\r\n  let typeName = qualifyTypeName(json.shortName, json.namespace);\r\n  let stype = metadataStore._getStructuralType(typeName, true);\r\n  if (stype) {\r\n    if (allowMerge) {\r\n      return mergeStructuralType(stype, json);\r\n    } else {\r\n      // allow it but don't replace anything.\r\n      return stype;\r\n    }\r\n  }\r\n  let config = {\r\n    shortName: json.shortName,\r\n    namespace: json.namespace,\r\n    isAbstract: json.isAbstract,\r\n    autoGeneratedKeyType: AutoGeneratedKeyType.fromName(json.autoGeneratedKeyType),\r\n    defaultResourceName: json.defaultResourceName,\r\n    custom: json.custom\r\n  };\r\n\r\n  stype = json.isComplexType ? new ComplexType(config) : new EntityType(config);\r\n\r\n  // baseType may not have been imported yet so we need to defer handling this type until later.\r\n  if (json.baseTypeName && stype instanceof EntityType) {\r\n    stype.baseTypeName = json.baseTypeName;\r\n    let baseEntityType = metadataStore._getStructuralType(json.baseTypeName, true);\r\n    if (baseEntityType) {\r\n      completeStructuralTypeFromJson(metadataStore, json, stype);\r\n    } else {\r\n      core.getArray(metadataStore._deferredTypes, json.baseTypeName).push({ json: json, stype: stype });\r\n\r\n    }\r\n  } else {\r\n    completeStructuralTypeFromJson(metadataStore, json, stype);\r\n  }\r\n\r\n  // stype may or may not have been added to the metadataStore at this point.\r\n  return stype;\r\n}\r\n\r\nfunction mergeStructuralType(stype: StructuralType, json: any) {\r\n  if (json.custom) {\r\n    stype.custom = json.custom;\r\n  }\r\n\r\n  mergeProps(stype, json.dataProperties);\r\n  mergeProps(stype, json.navigationProperties);\r\n  return stype;\r\n}\r\n\r\nfunction mergeProps(stype: StructuralType, jsonProps: any[]) {\r\n  if (!jsonProps) return;\r\n  jsonProps.forEach((jsonProp) => {\r\n    let propName = jsonProp.name;\r\n    if (!propName) {\r\n      if (jsonProp.nameOnServer) {\r\n        propName = stype.metadataStore.namingConvention.serverPropertyNameToClient(jsonProp.nameOnServer, {});\r\n      } else {\r\n        // backslash-quote works around compiler bug\r\n        const msg = \"Unable to complete \\'importMetadata\\' - cannot locate a \\'name\\' or \\'nameOnServer\\' for one of the imported property nodes\";\r\n        throw new Error(msg);\r\n      }\r\n    }\r\n    if (jsonProp.custom) {\r\n      let prop = stype.getProperty(propName, true);\r\n      prop!.custom = jsonProp.custom;\r\n    }\r\n  });\r\n}\r\n\r\nfunction completeStructuralTypeFromJson(metadataStore: MetadataStore, json: any, stype: any) {\r\n\r\n  // validators from baseType work because validation walks thru base types\r\n  // so no need to copy down.\r\n  if (json.validators) {\r\n    stype.validators = json.validators.map(Validator.fromJSON);\r\n  }\r\n\r\n  json.dataProperties.forEach(function (dp: Object) {\r\n    stype._addPropertyCore(DataProperty.fromJSON(dp));\r\n  });\r\n\r\n\r\n  let isEntityType = !json.isComplexType;\r\n  if (isEntityType) {\r\n    //noinspection JSHint\r\n    json.navigationProperties && json.navigationProperties.forEach(function (np: Object) {\r\n      stype._addPropertyCore(NavigationProperty.fromJSON(np));\r\n    });\r\n  }\r\n\r\n  metadataStore.addEntityType(stype);\r\n\r\n  let deferredTypes = metadataStore._deferredTypes;\r\n  let deferrals = deferredTypes[stype.name];\r\n  if (deferrals) {\r\n    deferrals.forEach(function (d: any) {\r\n      completeStructuralTypeFromJson(metadataStore, d.json, d.stype);\r\n    });\r\n    delete deferredTypes[stype.name];\r\n  }\r\n}\r\n\r\nfunction getQualifiedTypeName(metadataStore: MetadataStore, structTypeName: string, throwIfNotFound?: boolean) {\r\n  if (isQualifiedTypeName(structTypeName)) return structTypeName;\r\n  let result = metadataStore._shortNameMap[structTypeName];\r\n  if (!result && throwIfNotFound) {\r\n    throw new Error(\"Unable to locate 'entityTypeName' of: \" + structTypeName);\r\n  }\r\n  return result;\r\n}\r\n\r\n/** Configuration info to be passed to the [[EntityType]] constructor */\r\nexport interface EntityTypeConfig {\r\n  shortName?: string;\r\n  namespace?: string;\r\n  baseTypeName?: string;\r\n  isAbstract?: boolean;\r\n  autoGeneratedKeyType?: AutoGeneratedKeyType;\r\n  defaultResourceName?: string;\r\n  dataProperties?: DataProperty[] | Object[] | Object;  // TODO: see if we can't qualify Object[] a little better.\r\n  navigationProperties?: NavigationProperty[] | Object[] | Object;\r\n  serializerFn?: (prop: EntityProperty, val: any) => any;\r\n  custom?: Object;\r\n}\r\n\r\n/** Configuration info to be passed to the [[EntityType.setProperties]] method */\r\nexport interface EntityTypeSetConfig {\r\n  autoGeneratedKeyType?: AutoGeneratedKeyType;\r\n  defaultResourceName?: string;\r\n  serializerFn?: (prop: EntityProperty, val: any) => any;\r\n  custom?: Object;\r\n}\r\n\r\n/** Container for all of the metadata about a specific type of Entity.\r\n**/\r\nexport class EntityType {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // on proto\r\n  /** @hidden @internal */\r\n  static __nextAnonIx = 0;\r\n  /** Always false for an EntityType. **/\r\n  isComplexType = false;\r\n  /** The [[MetadataStore]] that contains this EntityType. __Read Only__ **/\r\n  metadataStore: MetadataStore;\r\n  /** The DataProperties (see [[DataProperty]] associated with this EntityType. __Read Only__  **/\r\n  dataProperties: DataProperty[];\r\n  /**  The NavigationProperties (see [[NavigationProperty]] associated with this EntityType. __Read Only__  **/\r\n  navigationProperties: NavigationProperty[];\r\n  /**\r\n  The DataProperties associated with this EntityType that make up it's [[EntityKey]]. __Read Only__ **/\r\n  keyProperties: DataProperty[];\r\n  /** The DataProperties associated with this EntityType that are foreign key properties. __Read Only__ **/\r\n  foreignKeyProperties: DataProperty[];\r\n  inverseForeignKeyProperties: DataProperty[];\r\n  /**  The DataProperties associated with this EntityType that are concurrency properties. __Read Only__ **/\r\n  concurrencyProperties: DataProperty[];\r\n  /** The DataProperties for this EntityType that contain instances of a [[ComplexType]]. __Read Only__   **/\r\n  complexProperties: DataProperty[];\r\n  /** The DataProperties associated with this EntityType that are not mapped to any backend datastore. These are effectively free standing\r\n  properties. __Read Only__ **/\r\n  unmappedProperties: DataProperty[];\r\n\r\n  /** The fully qualified name of this EntityType. __Read Only__  **/\r\n  name: string;\r\n  /** The short, unqualified, name for this EntityType. __Read Only__  **/\r\n  shortName: string;\r\n  /** The namespace for this EntityType. __Read Only__  **/\r\n  namespace: string;\r\n  /** The name of this EntityType's base EntityType  (if any) */\r\n  baseTypeName?: string;\r\n  /** The base EntityType (if any) for this EntityType. __Read Only__   **/\r\n  baseEntityType: EntityType;\r\n  subtypes: EntityType[];\r\n\r\n  /**  Whether this EntityType is abstract. __Read Only__ **/\r\n  isAbstract: boolean;\r\n  /**  Whether this EntityType is anonymous. Anonymous types will never be communicated to or from the server. They are purely for\r\n  client side use and are given an automatically generated name.  __Read Only__ **/\r\n  isAnonymous: boolean;\r\n  /** Whether this EntityType has been 'frozen'.  EntityTypes become frozen after the first instance \r\n  of that type has been created and attached to an EntityManager. */\r\n  isFrozen: boolean;\r\n\r\n  /** The [[AutoGeneratedKeyType]] for this EntityType. __Read Only__ **/\r\n  autoGeneratedKeyType: AutoGeneratedKeyType;\r\n  /**   The default resource name associated with this EntityType.  An EntityType may be queried via a variety of 'resource names' but this one\r\n  is used as the default when no resource name is provided.  This will occur when calling [[EntityAspect.loadNavigationProperty]]\r\n  or when executing any [[EntityQuery]] that was created via an [[EntityKey]]. __Read Only__ **/\r\n  defaultResourceName: string;\r\n  /** A function that is used to customize the serialization of any EntityProperties of this type. */\r\n  serializerFn?: (prop: EntityProperty, val: any) => any;\r\n  /**  A free form object that can be used to define any custom metadata for this EntityType. __Read Only__  **/\r\n  custom?: Object;\r\n  /** The entity level validators associated with this EntityType. Validators can be added and\r\n  removed from this collection. __Read Only__.   **/\r\n  validators: Validator[];\r\n\r\n  warnings: any[];\r\n  initFn: Function | string;\r\n  noTrackingFn: Function;\r\n\r\n  /** @hidden @internal */\r\n  _extra: any;\r\n  /** @hidden @internal */\r\n  _ctor: { new (): StructuralObject };\r\n  /** @hidden @internal */\r\n  _mappedPropertiesCount: number;\r\n\r\n  /** \r\n  @deprecated Use [[getCtor]] instead.   \r\n  */\r\n  getEntityCtor = this.getCtor;\r\n\r\n  /** @hidden @internal */\r\n  static qualifyTypeName = qualifyTypeName;\r\n\r\n\r\n  /** EntityType constructor  \r\n  >      let entityType = new EntityType( {\r\n  >          shortName: \"person\",\r\n  >          namespace: \"myAppNamespace\"\r\n  >      });\r\n  @param config - Configuration settings or a MetadataStore.  If this parameter is just a MetadataStore\r\n  then what will be created is an 'anonymous' type that will never be communicated to or from the server. It is purely for\r\n  client side use and will be given an automatically generated name. Normally, however, you will use a configuration object.\r\n  **/\r\n  constructor(config: MetadataStore | EntityTypeConfig) {\r\n    if (arguments.length > 1) {\r\n      throw new Error(\"The EntityType ctor has a single argument that is either a 'MetadataStore' or a configuration object.\");\r\n    }\r\n    // let etConfig =  <EntityTypeConfig> <any> undefined;\r\n    let etConfig: EntityTypeConfig | undefined = undefined;\r\n\r\n    if ((config as any)._$typeName === \"MetadataStore\") {\r\n      this.metadataStore = config as MetadataStore;\r\n      this.shortName = \"Anon_\" + (++EntityType.__nextAnonIx);\r\n      this.namespace = \"\";\r\n      this.isAnonymous = true;\r\n      // etConfig = undefined;\r\n    } else {\r\n      etConfig = config as EntityTypeConfig;\r\n      assertConfig(config)\r\n        .whereParam(\"shortName\").isNonEmptyString()\r\n        .whereParam(\"namespace\").isString().isOptional().withDefault(\"\")\r\n        .whereParam(\"baseTypeName\").isString().isOptional()\r\n        .whereParam(\"isAbstract\").isBoolean().isOptional().withDefault(false)\r\n        .whereParam(\"autoGeneratedKeyType\").isEnumOf(AutoGeneratedKeyType).isOptional().withDefault(AutoGeneratedKeyType.None)\r\n        .whereParam(\"defaultResourceName\").isNonEmptyString().isOptional().withDefault(null)\r\n        .whereParam(\"dataProperties\").isOptional()\r\n        .whereParam(\"navigationProperties\").isOptional()\r\n        .whereParam(\"serializerFn\").isOptional().isFunction()\r\n        .whereParam(\"custom\").isOptional()\r\n        .applyAll(this);\r\n    }\r\n\r\n    this.name = qualifyTypeName(this.shortName, this.namespace);\r\n\r\n    // the defaultResourceName may also be set up either via metadata lookup or first query or via the 'setProperties' method\r\n    this.dataProperties = [];\r\n    this.navigationProperties = [];\r\n    this.complexProperties = [];\r\n    this.keyProperties = [];\r\n    this.foreignKeyProperties = [];\r\n    this.inverseForeignKeyProperties = [];\r\n    this.concurrencyProperties = [];\r\n    this.unmappedProperties = []; // will be updated later.\r\n    this.validators = [];\r\n    this.warnings = [];\r\n    this._mappedPropertiesCount = 0;\r\n    this.subtypes = [];\r\n    // now process any data/nav props\r\n    if (etConfig && etConfig.dataProperties) {\r\n      addProperties(this, etConfig.dataProperties, DataProperty);\r\n    }\r\n    if (etConfig && etConfig.navigationProperties) {\r\n      addProperties(this, etConfig.navigationProperties, NavigationProperty);\r\n    }\r\n  }\r\n\r\n  /**\r\n  General purpose property set method\r\n  >      // assume em1 is an EntityManager containing a number of existing entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      custType.setProperties( {\r\n  >          autoGeneratedKeyType: AutoGeneratedKeyType.Identity;\r\n  >          defaultResourceName: \"CustomersAndIncludedOrders\"\r\n  >      )};\r\n  @param config - a configuration object\r\n  **/\r\n  setProperties(config: EntityTypeSetConfig) {\r\n    assertConfig(config)\r\n      .whereParam(\"autoGeneratedKeyType\").isEnumOf(AutoGeneratedKeyType).isOptional()\r\n      .whereParam(\"defaultResourceName\").isString().isOptional()\r\n      .whereParam(\"serializerFn\").isFunction().isOptional()\r\n      .whereParam(\"custom\").isOptional()\r\n      .applyAll(this);\r\n    if (config.defaultResourceName) {\r\n      this.defaultResourceName = config.defaultResourceName;\r\n    }\r\n  }\r\n\r\n  /**\r\n  Returns whether this type is a subtype of a specified type.\r\n  **/\r\n  isSubtypeOf(entityType: EntityType) {\r\n    assertParam(entityType, \"entityType\").isInstanceOf(EntityType).check();\r\n    let baseType: EntityType = this;\r\n    do {\r\n      if (baseType === entityType) return true;\r\n      baseType = baseType.baseEntityType;\r\n    } while (baseType);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n  Returns an array containing this type and any/all subtypes of this type down thru the hierarchy.\r\n  **/\r\n  getSelfAndSubtypes() {\r\n    let result = [this];\r\n    this.subtypes.forEach(function (st) {\r\n      let subtypes = st.getSelfAndSubtypes();\r\n      result.push.apply(result, subtypes);\r\n    });\r\n    return result;\r\n  }\r\n\r\n  getAllValidators() {\r\n    let result = this.validators.slice(0);\r\n    let bt = this.baseEntityType;\r\n    while (bt) {\r\n      result.push.apply(result, bt.validators);\r\n      bt = bt.baseEntityType;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n  Adds a  [[DataProperty]] or a [[NavigationProperty]] to this EntityType.\r\n  >      // assume myEntityType is a newly constructed EntityType.\r\n  >      myEntityType.addProperty(dataProperty1);\r\n  >      myEntityType.addProperty(dataProperty2);\r\n  >      myEntityType.addProperty(navigationProperty1);\r\n  **/\r\n  addProperty(property: EntityProperty) {\r\n    assertParam(property, \"property\").isInstanceOf(DataProperty).or().isInstanceOf(NavigationProperty).check();\r\n\r\n    // true is 2nd arg to force resolve of any navigation properties.\r\n    let newprop = this._addPropertyCore(property, true);\r\n\r\n    if (this.subtypes && this.subtypes.length) {\r\n      let stype = this;\r\n      stype.getSelfAndSubtypes().forEach(function (st) {\r\n        if (st !== stype) {\r\n          if (property.isNavigationProperty) {\r\n            st._addPropertyCore(new NavigationProperty(property), true);\r\n          } else {\r\n            st._addPropertyCore(new DataProperty(property as DataProperty), true);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return newprop;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _updateFromBase(baseEntityType: EntityType) {\r\n    this.baseEntityType = baseEntityType;\r\n    if (this.autoGeneratedKeyType === AutoGeneratedKeyType.None) {\r\n      this.autoGeneratedKeyType = baseEntityType.autoGeneratedKeyType;\r\n    }\r\n\r\n    baseEntityType.dataProperties.forEach((dp) => {\r\n      let newDp = new DataProperty(dp);\r\n      // don't need to copy validators becaue we will walk the hierarchy to find them\r\n      newDp.validators = [];\r\n      newDp.baseProperty = dp;\r\n      this._addPropertyCore(newDp);\r\n    }, this);\r\n    baseEntityType.navigationProperties.forEach((np) => {\r\n      let newNp = new NavigationProperty(np);\r\n      // don't need to copy validators becaue we will walk the hierarchy to find them\r\n      newNp.validators = [];\r\n      newNp.baseProperty = np;\r\n      this._addPropertyCore(newNp);\r\n    }, this);\r\n    baseEntityType.subtypes.push(this);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _addPropertyCore(property: EntityProperty, shouldResolve: boolean = false) {\r\n    if (this.isFrozen) {\r\n      throw new Error(\"The '\" + this.name + \"' EntityType/ComplexType has been frozen. You can only add properties to an EntityType/ComplexType before any instances of that type have been created and attached to an entityManager.\");\r\n    }\r\n    let parentType = property.parentType;\r\n    if (parentType) {\r\n      if (parentType !== this) {\r\n        throw new Error(\"This property: \" + property.name + \" has already been added to \" + property.parentType.name);\r\n      } else {\r\n        // adding the same property more than once to the same entityType is just ignored.\r\n        return;\r\n      }\r\n    }\r\n    property.parentType = this;\r\n    let ms = this.metadataStore;\r\n    // if (property.isDataProperty) { // modified because doesn't act as a type guard \r\n    if (property instanceof DataProperty) {\r\n      this._addDataProperty(property);\r\n    } else {\r\n      this._addNavigationProperty(property);\r\n      // metadataStore can be undefined if this entityType has not yet been added to a MetadataStore.\r\n      if (shouldResolve && ms) {\r\n        tryResolveNp(property, ms);\r\n      }\r\n    }\r\n    // unmapped properties can be added AFTER entityType has already resolved all property names.\r\n    if (ms && !(property.name && property.nameOnServer)) {\r\n      updateClientServerNames(ms.namingConvention, property, \"name\");\r\n    }\r\n    // props can be added after entity prototype has already been wrapped.\r\n    if (ms && this._extra) {\r\n      if (this._extra.alreadyWrappedProps) {\r\n        let proto = this._ctor.prototype;\r\n        config.interfaceRegistry.modelLibrary.getDefaultInstance().initializeEntityPrototype(proto);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n  Create a new entity of this type.\r\n  >      // assume em1 is an EntityManager containing a number of existing entities.\r\n  >      let custType = em1.metadataStore.getAsEntityType(\"Customer\");\r\n  >      let cust1 = custType.createEntity();\r\n  >      em1.addEntity(cust1);\r\n  @param initialValues- Configuration object of the properties to set immediately after creation.\r\n  @return The new entity.\r\n  **/\r\n  createEntity(initialValues?: any): any {\r\n    // ignore the _$eref once the entity is attached to an entityManager.\r\n    if (initialValues && initialValues._$eref && !initialValues._$eref.entityAspect.entityManager) return initialValues._$eref;\r\n\r\n    let instance = this._createInstanceCore();\r\n\r\n    if (initialValues) {\r\n      // only assign an _eref if the object is fully \"keyed\"\r\n      if (this.keyProperties.every(function (kp) {\r\n        return initialValues[kp.name] != null;\r\n      })) {\r\n        initialValues._$eref = instance;\r\n      }\r\n\r\n      this._updateTargetFromRaw(instance, initialValues, getRawValueFromConfig);\r\n\r\n      this.navigationProperties.forEach(function (np) {\r\n        let relatedEntity: any;\r\n        let val = initialValues[np.name];\r\n        if (val != undefined) {\r\n          let navEntityType = np.entityType;\r\n          if (np.isScalar) {\r\n            relatedEntity = val.entityAspect ? val : navEntityType.createEntity(val);\r\n            instance.setProperty(np.name, relatedEntity);\r\n          } else {\r\n            let relatedEntities = instance.getProperty(np.name);\r\n            val.forEach((v: any) => {\r\n              relatedEntity = v.entityAspect ? v : navEntityType.createEntity(v);\r\n              relatedEntities.push(relatedEntity);\r\n            });\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    this._initializeInstance(instance);\r\n    return instance;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _createInstanceCore() {\r\n    let aCtor = this.getCtor();\r\n    let instance = new aCtor();\r\n    new EntityAspect(instance as Entity);\r\n    return instance;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _initializeInstance(instance: any) {\r\n    if (this.baseEntityType) {\r\n      this.baseEntityType._initializeInstance(instance);\r\n    }\r\n    let initFn = this.initFn;\r\n    if (initFn) {\r\n      let fn = (typeof initFn === \"string\") ? instance[initFn] : initFn;\r\n      fn(instance);\r\n    }\r\n    this.complexProperties && this.complexProperties.forEach(function (cp) {\r\n      let complexType = cp.dataType as ComplexType;\r\n      let ctInstance = instance.getProperty(cp.name);\r\n      if (Array.isArray(ctInstance)) {\r\n        ctInstance.forEach((ctInst) => {\r\n          complexType._initializeInstance(ctInst);\r\n        });\r\n      } else {\r\n        complexType._initializeInstance(ctInstance);\r\n      }\r\n    });\r\n    // not needed for complexObjects\r\n    if (instance.entityAspect) {\r\n      instance.entityAspect._initialized = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n  Returns the constructor for this EntityType.\r\n  @param forceRefresh - Whether to ignore any cached version of this constructor. (default == false)\r\n  @return The constructor for this EntityType.\r\n  **/\r\n  getCtor(forceRefresh: boolean = false): { new (): StructuralObject } {\r\n    if (this._ctor && !forceRefresh) return this._ctor;\r\n\r\n    let ctorRegistry = this.metadataStore._ctorRegistry;\r\n    let r = ctorRegistry[this.name] || ctorRegistry[this.shortName] || {};\r\n    let aCtor = r.ctor || this._ctor;\r\n\r\n    let ctorType = aCtor && aCtor.prototype && (aCtor.prototype.entityType || aCtor.prototype.complexType);\r\n    if (ctorType && ctorType.metadataStore !== this.metadataStore) {\r\n      // We can't risk a mismatch between the ctor and the type info in a specific metadatastore\r\n      // because modelLibraries rely on type info to intercept ctor properties\r\n      throw new Error(\"Cannot register the same constructor for \" + this.name + \" in different metadata stores.  Please define a separate constructor for each metadata store.\");\r\n    }\r\n\r\n\r\n    if (r.ctor && forceRefresh) {\r\n      this._extra = undefined;\r\n    }\r\n\r\n    if (!aCtor) {\r\n      let createCtor = config.interfaceRegistry.modelLibrary.getDefaultInstance().createCtor;\r\n      aCtor = createCtor ? createCtor(this) : createEmptyCtor(this);\r\n    }\r\n\r\n    this.initFn = r.initFn;\r\n    this.noTrackingFn = r.noTrackingFn;\r\n\r\n    aCtor.prototype._$typeName = this.name;\r\n    this._setCtor(aCtor);\r\n    return aCtor;\r\n  }\r\n\r\n\r\n  /** @hidden @internal */\r\n  // May make public later.\r\n  _setCtor(aCtor: { new (): StructuralObject }, interceptor?: any) {\r\n\r\n    let instanceProto = aCtor.prototype;\r\n\r\n    // place for extra breeze related data\r\n    this._extra = this._extra || {};\r\n\r\n    let instance = new aCtor();\r\n    calcUnmappedProperties(this, instance);\r\n\r\n    if (this._$typeName === \"EntityType\") {\r\n      // insure that all of the properties are on the 'template' instance before watching the class.\r\n      instanceProto.entityType = this;\r\n    } else {\r\n      instanceProto.complexType = this;\r\n    }\r\n\r\n    // defaultPropertyInterceptor is a 'global' (but internal to breeze) function;\r\n    (instanceProto as any)._$interceptor = interceptor || defaultPropertyInterceptor;\r\n    config.interfaceRegistry.modelLibrary.getDefaultInstance().initializeEntityPrototype(instanceProto);\r\n    this._ctor = aCtor;\r\n  }\r\n\r\n  /**\r\n  Adds either an entity or property level validator to this EntityType.\r\n  >      // assume em1 is an EntityManager containing a number of existing entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let countryProp = custType.getProperty(\"Country\");\r\n  >      let valFn = function (v) {\r\n  >              if (v == null) return true;\r\n  >              return (core.stringStartsWith(v, \"US\"));\r\n  >          };\r\n  >      let countryValidator = new Validator(\"countryIsUS\", valFn,\r\n  >      { displayName: \"Country\", messageTemplate: \"'%displayName%' must start with 'US'\" });\r\n  >      custType.addValidator(countryValidator, countryProp);\r\n\r\n  This is the same as adding an entity level validator via the 'validators' property of DataProperty or NavigationProperty\r\n  >      countryProp.validators.push(countryValidator);\r\n\r\n  Entity level validators can also be added by omitting the 'property' parameter.\r\n  >      custType.addValidator(someEntityLevelValidator);\r\n\r\n  or\r\n  >      custType.validators.push(someEntityLevelValidator);\r\n  @param validator - Validator to add.\r\n  @param property - Property to add this validator to.  If omitted, the validator is assumed to be an\r\n  entity level validator and is added to the EntityType's 'validators'.\r\n  **/\r\n  addValidator(validator: Validator, property?: EntityProperty | string) {\r\n    assertParam(validator, \"validator\").isInstanceOf(Validator).check();\r\n    assertParam(property, \"property\").isOptional().isString().or().isEntityProperty().check();\r\n    if (property != null) {\r\n      let prop = (typeof property === 'string') ? this.getProperty(property, true) : property;\r\n      prop!.validators.push(validator);\r\n    } else {\r\n      this.validators.push(validator);\r\n    }\r\n  }\r\n\r\n  /**\r\n  Returns all of the properties ( dataProperties and navigationProperties) for this EntityType.\r\n  >      // assume em1 is an EntityManager containing a number of existing entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let arrayOfProps = custType.getProperties();\r\n  @return An array of Data and Navigation properties.\r\n  **/\r\n  getProperties(): EntityProperty[] {\r\n    return (this.dataProperties as EntityProperty[]).concat(this.navigationProperties);\r\n  }\r\n\r\n  /**\r\n  Returns all of the property names ( for both dataProperties and navigationProperties) for this EntityType.\r\n  >      // assume em1 is an EntityManager containing a number of existing entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let arrayOfPropNames = custType.getPropertyNames();\r\n  **/\r\n  getPropertyNames() {\r\n    return this.getProperties().map(core.pluck('name'));\r\n  }\r\n\r\n  /**\r\n  Returns a data property with the specified name or null.\r\n  >      // assume em1 is an EntityManager containing a number of existing entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let customerNameDataProp = custType.getDataProperty(\"CustomerName\");\r\n  @return A DataProperty or null if not found.\r\n  **/\r\n  getDataProperty(propertyName: string) {\r\n    return core.arrayFirst(this.dataProperties, core.propEq('name', propertyName));\r\n  }\r\n\r\n  /**\r\n  Returns a navigation property with the specified name or null.\r\n  >      // assume em1 is an EntityManager containing a number of existing entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let customerOrdersNavProp = custType.getDataProperty(\"Orders\");\r\n  @return A NavigationProperty or null if not found.\r\n  **/\r\n  getNavigationProperty(propertyName: string) {\r\n    return core.arrayFirst(this.navigationProperties, core.propEq('name', propertyName));\r\n  }\r\n\r\n  /**\r\n  Returns either a DataProperty or a NavigationProperty with the specified name or null.\r\n  \r\n  This method also accepts a '.' delimited property path and will return the 'property' at the\r\n  end of the path.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let companyNameProp = custType.getProperty(\"CompanyName\");\r\n\r\n  This method can also walk a property path to return a property\r\n  >      let orderDetailType = em1.metadataStore.getEntityType(\"OrderDetail\");\r\n  >      let companyNameProp2 = orderDetailType.getProperty(\"Order.Customer.CompanyName\");\r\n  >      // companyNameProp === companyNameProp2\r\n  @param [throwIfNotFound=false] {Boolean} Whether to throw an exception if not found.\r\n  @return A DataProperty or NavigationProperty or null if not found.\r\n  **/\r\n  getProperty(propertyPath: string, throwIfNotFound: boolean = false) {\r\n    let props = this.getPropertiesOnPath(propertyPath, false, throwIfNotFound);\r\n    return (props && props.length > 0) ? props[props.length - 1] : null;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  // TODO: have this return empty array instead of null and fix consumers.\r\n  // TODO: think about renaming with '_' prefix.\r\n  getPropertiesOnPath(propertyPath: string, useServerName: boolean | null, throwIfNotFound: boolean = false) {\r\n    let propertyNames: string[] = (Array.isArray(propertyPath)) ? propertyPath : propertyPath.trim().split('.');\r\n\r\n    let ok = true;\r\n    let key = useServerName === true ? \"nameOnServer\" : useServerName === false ? \"name\" : null;\r\n    let parentType = this as StructuralType;\r\n    \r\n    const getProps = (propName: string) => { \r\n      const fn = key === null ? core.propsEq(\"name\", \"nameOnServer\", propName) : core.propEq(key, propName);\r\n      let prop = core.arrayFirst(parentType.getProperties(), fn);\r\n      if (prop) {\r\n        parentType = (prop instanceof NavigationProperty) ? prop.entityType : prop.dataType as ComplexType;\r\n        // parentType = prop.isNavigationProperty ? prop.entityType : prop.dataType;\r\n      } else if (throwIfNotFound) {\r\n        throw new Error(\"unable to locate property: \" + propName + \" on entityType: \" + parentType.name);\r\n      } else {\r\n        ok = false;\r\n      }\r\n      return prop;\r\n    };\r\n\r\n    let props = propertyNames.map(getProps) as EntityProperty[];\r\n    return ok ? props : null;\r\n  }\r\n\r\n  /** For use in pluggable adapters. */\r\n  // TODO: document use\r\n  clientPropertyPathToServer(propertyPath: string, delimiter: string = '.') {\r\n    let propNames: string[];\r\n    if (this.isAnonymous) {\r\n      let fn = this.metadataStore.namingConvention.clientPropertyNameToServer;\r\n      propNames = propertyPath.split(\".\").map(function (propName) {\r\n        return fn(propName);\r\n      });\r\n    } else {\r\n      let props = this.getPropertiesOnPath(propertyPath, false, true);\r\n      propNames = props!.map((prop: EntityProperty) => prop.nameOnServer);\r\n    }\r\n    return propNames.join(delimiter);\r\n  }\r\n\r\n  /** For use in pluggable adapters. */\r\n  // TODO: document use\r\n  getEntityKeyFromRawEntity(rawEntity: any, rawValueFn: Function) {\r\n    let keyValues = this.keyProperties.map((dp) => {\r\n      let val = rawValueFn(rawEntity, dp);\r\n      return DataType.parseRawValue(val, dp.dataType as DataType);\r\n    });\r\n    return new EntityKey(this, keyValues);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _updateTargetFromRaw(target: StructuralObject, raw: any, rawValueFn: Function) {\r\n    // called recursively for complex properties\r\n    this.dataProperties.forEach((dp) => {\r\n      if (!dp.isSettable) return;\r\n      let rawVal = rawValueFn(raw, dp);\r\n      if (rawVal === undefined) return;\r\n      let dataType = dp.dataType; // this will be a complexType when dp is a complexProperty\r\n      let oldVal: any;\r\n      if (dp.isComplexProperty) {\r\n        let complexType = dp.dataType as ComplexType;\r\n        if (rawVal === null) return; // rawVal may be null in nosql dbs where it was never defined for the given row.\r\n        oldVal = target.getProperty(dp.name);\r\n        if (dp.isScalar) {\r\n          complexType._updateTargetFromRaw(oldVal, rawVal, rawValueFn);\r\n        } else {\r\n          if (Array.isArray(rawVal)) {\r\n            let newVal = rawVal.map(function (rawCo) {\r\n              let newCo = complexType._createInstanceCore(target, dp);\r\n              complexType._updateTargetFromRaw(newCo, rawCo, rawValueFn);\r\n              complexType._initializeInstance(newCo);\r\n              return newCo;\r\n            });\r\n            if (!core.arrayEquals(oldVal, newVal, coEquals)) {\r\n              // clear the old array and push new objects into it.\r\n              oldVal.length = 0;\r\n              newVal.forEach(function (nv) {\r\n                oldVal.push(nv);\r\n              });\r\n            }\r\n          } else {\r\n            oldVal.length = 0;\r\n          }\r\n        }\r\n      } else {\r\n        if (dp.isScalar) {\r\n          let newVal = DataType.parseRawValue(rawVal, dataType as DataType);\r\n          target.setProperty(dp.name, newVal);\r\n        } else {\r\n          oldVal = target.getProperty(dp.name);\r\n          if (Array.isArray(rawVal)) {\r\n            // need to compare values\r\n            let newVal = rawVal.map((rv) => {\r\n              return DataType.parseRawValue(rv, dataType as DataType);\r\n            });\r\n            if (!core.arrayEquals(oldVal, newVal)) {\r\n              // clear the old array and push new objects into it.\r\n              oldVal.length = 0;\r\n              newVal.forEach(function (nv) {\r\n                oldVal.push(nv);\r\n              });\r\n            }\r\n          } else {\r\n            oldVal.length = 0;\r\n          }\r\n\r\n        }\r\n      }\r\n    });\r\n\r\n    // if merging from an import then raw will have an entityAspect or a complexAspect\r\n    let rawAspect = raw.entityAspect || raw.complexAspect;\r\n    if (rawAspect) {\r\n\r\n      let targetAspect = EntityAspect.isEntity(target) ? target.entityAspect : target.complexAspect;\r\n      if (rawAspect.originalValuesMap) {\r\n        targetAspect.originalValues = rawAspect.originalValuesMap;\r\n      }\r\n      if (rawAspect.extraMetadata) {\r\n        targetAspect.extraMetadata = rawAspect.extraMetadata;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n\r\n  /**\r\n  Returns a string representation of this EntityType.\r\n  **/\r\n  toString() {\r\n    return this.name;\r\n  }\r\n\r\n  toJSON() {\r\n    return core.toJson(this, {\r\n      shortName: null,\r\n      namespace: null,\r\n      baseTypeName: null,\r\n      isAbstract: false,\r\n      autoGeneratedKeyType: null, // do not suppress default value\r\n      defaultResourceName: null,\r\n      dataProperties: localPropsOnly,\r\n      navigationProperties: localPropsOnly,\r\n      validators: null,\r\n      custom: null\r\n    });\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _updateNames(property: EntityProperty) {\r\n    let nc = this.metadataStore.namingConvention;\r\n    updateClientServerNames(nc, property, \"name\");\r\n\r\n    if (property.isNavigationProperty) {\r\n      updateClientServerNames(nc, property, \"foreignKeyNames\");\r\n      updateClientServerNames(nc, property, \"invForeignKeyNames\");\r\n\r\n      // these will get set later via _updateNps\r\n      // this.inverse\r\n      // this.entityType\r\n      // this.relatedDataProperties\r\n      //    dataProperty.relatedNavigationProperty\r\n      //    dataProperty.inverseNavigationProperty\r\n    }\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _checkNavProperty(navigationProperty: NavigationProperty | string) {\r\n    // if (navigationProperty.isNavigationProperty) {\r\n    if (navigationProperty instanceof NavigationProperty) {\r\n      if (navigationProperty.parentType !== this) {\r\n        throw new Error(core.formatString(\"The navigationProperty '%1' is not a property of entity type '%2'\",\r\n          navigationProperty.name, this.name));\r\n      }\r\n      return navigationProperty;\r\n    }\r\n\r\n    if (typeof (navigationProperty) === 'string') {\r\n      let np = this.getProperty(navigationProperty);\r\n      // if (np && np.isNavigationProperty) return np;\r\n      if (np && np instanceof NavigationProperty) return np;\r\n    }\r\n    throw new Error(\"The 'navigationProperty' parameter must either be a NavigationProperty or the name of a NavigationProperty\");\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _addDataProperty(dp: DataProperty) {\r\n\r\n    this.dataProperties.push(dp);\r\n\r\n    if (dp.isPartOfKey) {\r\n      this.keyProperties.push(dp);\r\n    }\r\n\r\n    if (dp.isComplexProperty) {\r\n      this.complexProperties.push(dp);\r\n    }\r\n\r\n    if (dp.concurrencyMode && dp.concurrencyMode !== \"None\") {\r\n      this.concurrencyProperties.push(dp);\r\n    }\r\n\r\n    if (dp.isUnmapped) {\r\n      this.unmappedProperties.push(dp);\r\n    }\r\n\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _addNavigationProperty(np: NavigationProperty) {\r\n\r\n    this.navigationProperties.push(np);\r\n\r\n    if (!isQualifiedTypeName(np.entityTypeName)) {\r\n      np.entityTypeName = qualifyTypeName(np.entityTypeName, this.namespace);\r\n    }\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _updateCps() {\r\n    let metadataStore = this.metadataStore;\r\n    let incompleteTypeMap = metadataStore._incompleteComplexTypeMap;\r\n    this.complexProperties.forEach(function (cp) {\r\n      if (cp.complexType) return;\r\n      if (!resolveCp(cp, metadataStore)) {\r\n        core.getArray(incompleteTypeMap, cp.complexTypeName).push(cp);\r\n      }\r\n    });\r\n\r\n    if (this.isComplexType) {\r\n      (incompleteTypeMap[this.name] || []).forEach(function (cp: DataProperty) {\r\n        resolveCp(cp, metadataStore);\r\n      });\r\n      delete incompleteTypeMap[this.name];\r\n    }\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _updateNps() {\r\n    let metadataStore = this.metadataStore;\r\n\r\n    // resolve all navProps for this entityType\r\n    this.navigationProperties.forEach(function (np) {\r\n      tryResolveNp(np, metadataStore);\r\n    });\r\n    let incompleteTypeMap = metadataStore._incompleteTypeMap;\r\n    // next resolve all navProp that point to this entityType.\r\n    (incompleteTypeMap[this.name] || []).forEach(function (np: NavigationProperty) {\r\n      tryResolveNp(np, metadataStore);\r\n    });\r\n    // every navProp that pointed to this type should now be resolved\r\n    delete incompleteTypeMap[this.name];\r\n  }\r\n}\r\n\r\nEntityType.prototype._$typeName = \"EntityType\";\r\n\r\nfunction getRawValueFromConfig(rawEntity: any, dp: DataProperty) {\r\n  // 'true' fork can happen if an initializer contains an actaul instance of an already created complex object.\r\n  return (rawEntity.entityAspect || rawEntity.complexAspect) ? rawEntity.getProperty(dp.name) : rawEntity[dp.name];\r\n}\r\n\r\nfunction updateClientServerNames(nc: NamingConvention, parent: any, clientPropName: string) {\r\n  let serverPropName = clientPropName + \"OnServer\";\r\n  let clientName = parent[clientPropName];\r\n  if (clientName && clientName.length) {\r\n    // if (parent.isUnmapped) return;\r\n    let serverNames = core.toArray(clientName).map(function (cName) {\r\n      let sName = nc.clientPropertyNameToServer(cName, parent);\r\n      let testName = nc.serverPropertyNameToClient(sName, parent);\r\n      if (cName !== testName) {\r\n        throw new Error(\"NamingConvention for this client property name does not roundtrip properly:\" + cName + \"-->\" + testName);\r\n      }\r\n      return sName;\r\n    });\r\n    parent[serverPropName] = Array.isArray(clientName) ? serverNames : serverNames[0];\r\n  } else {\r\n    let serverName = parent[serverPropName];\r\n    if ((!serverName) || serverName.length === 0) return;\r\n    let clientNames = core.toArray(serverName).map(function (sName) {\r\n      let cName = nc.serverPropertyNameToClient(sName, parent);\r\n      let testName = nc.clientPropertyNameToServer(cName, parent);\r\n      if (sName !== testName) {\r\n        throw new Error(\"NamingConvention for this server property name does not roundtrip properly:\" + sName + \"-->\" + testName);\r\n      }\r\n      return cName;\r\n    });\r\n    parent[clientPropName] = Array.isArray(serverName) ? clientNames : clientNames[0];\r\n  }\r\n}\r\n\r\nfunction createEmptyCtor(type: any) {\r\n  if (config.noEval) {\r\n    let Entity = function() {};\r\n    return Entity;\r\n  } else {\r\n    let name = type.name.replace(/\\W/g, '_');\r\n    return Function('return function ' + name + '(){}')();\r\n  }\r\n}\r\n\r\nfunction coEquals(co1: ComplexObject, co2: ComplexObject): boolean {\r\n  let complexType = co1.complexAspect!.parentProperty!.dataType as ComplexType;\r\n  let dataProps = complexType.dataProperties;\r\n  let areEqual = dataProps.every(function (dp) {\r\n    if (!dp.isSettable) return true;\r\n    let v1 = co1.getProperty(dp.name);\r\n    let v2 = co2.getProperty(dp.name);\r\n    if (dp.isComplexProperty && dp.isScalar) {\r\n      return coEquals(v1, v2);\r\n    }\r\n    else if (dp.isComplexProperty && !dp.isScalar) {\r\n      return core.arrayEquals(v1, v2, coEquals);\r\n    } else {\r\n      let dataType = <any>dp.dataType; // this will be a complexType when dp is a complexProperty\r\n      return (v1 === v2 || (dataType && dataType.normalize && v1 && v2 && dataType.normalize(v1) === dataType.normalize(v2)));\r\n    }\r\n  });\r\n  return areEqual;\r\n}\r\n\r\nfunction localPropsOnly(props: EntityProperty[]) {\r\n  return props.filter(function (prop) {\r\n    return prop.baseProperty == null;\r\n  });\r\n}\r\n\r\n\r\nfunction resolveCp(cp: DataProperty, metadataStore: MetadataStore) {\r\n  let complexType = metadataStore._getStructuralType(cp.complexTypeName, true);\r\n  if (!complexType) return false;\r\n  if (!(complexType instanceof ComplexType)) {\r\n    throw new Error(\"Unable to resolve ComplexType with the name: \" + cp.complexTypeName + \" for the property: \" + cp.name);\r\n  }\r\n  cp.dataType = complexType;\r\n  cp.defaultValue = null;\r\n  return true;\r\n}\r\n\r\nfunction tryResolveNp(np: NavigationProperty, metadataStore: MetadataStore) {\r\n  if (np.entityType) return true;\r\n\r\n  let entityType = metadataStore._getStructuralType(np.entityTypeName, true) as EntityType;\r\n  if (entityType) {\r\n    np.entityType = entityType;\r\n    np._resolveNp();\r\n    // don't bother removing - _updateNps will do it later.\r\n    // __arrayRemoveItem(incompleteNps, np, false);\r\n  } else {\r\n    let incompleteNps = core.getArray(metadataStore._incompleteTypeMap, np.entityTypeName);\r\n    core.arrayAddItemUnique(incompleteNps, np);\r\n  }\r\n  return !!entityType;\r\n}\r\n\r\nfunction calcUnmappedProperties(stype: StructuralType, instance: any) {\r\n  let metadataPropNames = stype.getPropertyNames();\r\n  let modelLib = config.interfaceRegistry.modelLibrary.getDefaultInstance();\r\n  let trackablePropNames = modelLib.getTrackablePropertyNames(instance);\r\n  trackablePropNames.forEach(function (pn: string) {\r\n    if (metadataPropNames.indexOf(pn) === -1) {\r\n      let val = instance[pn];\r\n      try {\r\n        if (typeof val === \"function\") val = val();\r\n      } catch (e) {\r\n      }\r\n      let dt = DataType.fromValue(val);\r\n      let newProp = new DataProperty({\r\n        name: pn,\r\n        dataType: dt,\r\n        isNullable: true,\r\n        isUnmapped: true\r\n      });\r\n      newProp.isSettable = core.isSettable(instance, pn);\r\n      if (stype instanceof EntityType && stype.subtypes != null && stype.subtypes.length) {\r\n        stype.getSelfAndSubtypes().forEach((st) => {\r\n          st._addPropertyCore(new DataProperty(newProp));\r\n        });\r\n      } else {\r\n        stype._addPropertyCore(newProp);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nexport interface ComplexTypeConfig {\r\n  shortName?: string;\r\n  namespace?: string;\r\n  dataProperties?: DataProperty[] | Object[] | Object;\r\n  isComplexType?: boolean;  // needed because this ctor can get called from the addEntityType method which needs the isComplexType prop\r\n  custom?: Object;\r\n}\r\n\r\n/**  Container for all of the metadata about a specific type of Complex object.\r\n>     let complexType = new ComplexType( {\r\n>         shortName: \"address\",\r\n>         namespace: \"myAppNamespace\"\r\n>     });\r\n@param config - Configuration settings\r\n**/\r\nexport class ComplexType {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // on proto\r\n  /** For polymorphic purpose only - always true here */\r\n  isComplexType = true;\r\n\r\n  /** The [[MetadataStore]] containing this ComplexType. */\r\n  metadataStore: MetadataStore;\r\n\r\n  /**  The fully qualifed name of this ComplexType. __Read Only__  **/\r\n  name: string;\r\n  /**  The short, unqualified, name for this ComplexType. __Read Only__ **/\r\n  shortName: string;\r\n\r\n  /** The namespace for this ComplexType. __Read Only__ **/\r\n  namespace: string;\r\n  /** The DataProperties (see [[DataProperty]] associated with this ComplexType. __Read Only__ */\r\n  dataProperties: DataProperty[];\r\n  /** The DataProperties for this ComplexType that contain instances of a [[ComplexType]]. __Read Only__ */\r\n  complexProperties: DataProperty[];\r\n\r\n  /**\r\n  The entity level validators associated with this ComplexType. Validators can be added and\r\n  removed from this collection. __Read Only__  **/\r\n  validators: Validator[];\r\n  /** For polymorphic purpose only - always empty here */\r\n  concurrencyProperties: DataProperty[];\r\n  /** The DataProperties associated with this ComplexType that are not mapped to any backend datastore. These are effectively free standing\r\n  properties. __Read Only__   **/\r\n  unmappedProperties: DataProperty[];\r\n\r\n  // keyProperties and navigationProperties are not used on complexTypes - but here to allow sharing of code between EntityType and ComplexType.\r\n  navigationProperties: DataProperty[];\r\n  // and may be used later to enforce uniqueness on arrays of complextypes.\r\n  keyProperties: DataProperty[];\r\n  warnings: any[];\r\n  serializerFn?: (prop: EntityProperty, val: any) => any;\r\n\r\n  /** A free form object that can be used to define any custom metadata for this ComplexType. ***/\r\n  custom?: any;\r\n  /** @hidden @internal */\r\n  _mappedPropertiesCount: number;\r\n  /** @hidden @internal */\r\n  _extra?: any;\r\n\r\n  // copy entityType methods onto complexType\r\n  /** See [[EntityType.getCtor]] */\r\n  getCtor = EntityType.prototype.getCtor;\r\n  // note the name change.\r\n  createInstance = EntityType.prototype.createEntity;\r\n  /** See [EntityType.addValidator] */\r\n  addValidator = EntityType.prototype.addValidator;\r\n  getProperty = EntityType.prototype.getProperty;\r\n  getPropertiesOnPath = EntityType.prototype.getPropertiesOnPath;\r\n  getPropertyNames = EntityType.prototype.getPropertyNames;\r\n  /** @hidden @internal */\r\n  _addPropertyCore = EntityType.prototype._addPropertyCore;\r\n  /** @hidden @internal */\r\n  _addDataProperty = EntityType.prototype._addDataProperty;\r\n  /** @hidden @internal */\r\n  _updateNames = EntityType.prototype._updateNames;\r\n  /** @hidden @internal */\r\n  _updateCps = EntityType.prototype._updateCps;\r\n  /** @hidden @internal */\r\n  _initializeInstance = EntityType.prototype._initializeInstance;\r\n  /** @hidden @internal */\r\n  _updateTargetFromRaw = EntityType.prototype._updateTargetFromRaw;\r\n  /** @hidden @internal */\r\n  _setCtor = EntityType.prototype._setCtor;\r\n\r\n  constructor(config: ComplexTypeConfig) {\r\n    if (arguments.length > 1) {\r\n      throw new Error(\"The ComplexType ctor has a single argument that is a configuration object.\");\r\n    }\r\n\r\n    assertConfig(config)\r\n      .whereParam(\"shortName\").isNonEmptyString()\r\n      .whereParam(\"namespace\").isString().isOptional().withDefault(\"\")\r\n      .whereParam(\"dataProperties\").isOptional()\r\n      .whereParam(\"isComplexType\").isOptional().isBoolean()   // needed because this ctor can get called from the addEntityType method which needs the isComplexType prop\r\n      .whereParam(\"custom\").isOptional()\r\n      .applyAll(this);\r\n\r\n    this.name = qualifyTypeName(this.shortName, this.namespace);\r\n    this.isComplexType = true;\r\n    this.dataProperties = [];\r\n    this.complexProperties = [];\r\n    this.validators = [];\r\n    this.concurrencyProperties = [];\r\n    this.unmappedProperties = [];\r\n    this._mappedPropertiesCount = 0;\r\n    // keyProperties and navigationProperties are not used on complexTypes - but here to allow sharing of code between EntityType and ComplexType.\r\n    this.navigationProperties = [];\r\n    this.keyProperties = []; // may be used later to enforce uniqueness on arrays of complextypes.\r\n    if (config.dataProperties) {\r\n      addProperties(this, config.dataProperties, DataProperty);\r\n    }\r\n  }\r\n\r\n  /**\r\n  General purpose property set method\r\n  >      // assume em1 is an EntityManager\r\n  >      let addresstType = em1.metadataStore.getEntityType(\"Address\");\r\n  >      addressType.setProperties( {\r\n  >          custom: { foo: 7, bar: \"test\" }\r\n  >      });\r\n  @param config - Custom config object\r\n  @param config.custom - {Object}\r\n  **/\r\n  setProperties(config: { custom?: Object }) {\r\n    assertConfig(config)\r\n      .whereParam(\"custom\").isOptional()\r\n      .applyAll(this);\r\n  }\r\n\r\n\r\n  getAllValidators() {\r\n    // ComplexType inheritance is not YET supported.\r\n    return this.validators;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _createInstanceCore(parent: StructuralObject, parentProperty: DataProperty) {\r\n    let aCtor = this.getCtor();\r\n    let instance = new aCtor() as ComplexObject;\r\n    new ComplexAspect(instance, parent, parentProperty);\r\n    // initialization occurs during either attach or in createInstance call.\r\n    return instance;\r\n  }\r\n\r\n\r\n  addProperty(dataProperty: DataProperty) {\r\n    assertParam(dataProperty, \"dataProperty\").isInstanceOf(DataProperty).check();\r\n    return this._addPropertyCore(dataProperty);\r\n  }\r\n\r\n  getProperties(): EntityProperty[] {\r\n    return this.dataProperties;\r\n  }\r\n\r\n  toJSON() {\r\n    return core.toJson(this, {\r\n      shortName: null,\r\n      namespace: null,\r\n      isComplexType: null,\r\n      dataProperties: null,\r\n      validators: null,\r\n      custom: null\r\n    });\r\n  }\r\n\r\n}\r\nComplexType.prototype._$typeName = \"ComplexType\";\r\n/** Creates an instance of this complexType */\r\nComplexType.prototype.createInstance = EntityType.prototype.createEntity;\r\n\r\nexport interface DataPropertyConfig {\r\n  name?: string;\r\n  nameOnServer?: string;\r\n  dataType?: DataType | string | ComplexType;\r\n  complexTypeName?: string;\r\n  isNullable?: boolean;\r\n  isScalar?: boolean; // will be false for some NoSQL databases.\r\n  defaultValue?: any;\r\n  isPartOfKey?: boolean;\r\n  isUnmapped?: boolean;\r\n  isSettable?: boolean;\r\n  concurrencyMode?: string;\r\n  maxLength?: number;\r\n  validators?: Validator[];\r\n  displayName?: string;\r\n  enumType?: any;\r\n  rawTypeName?: string;  // occurs with undefined datatypes\r\n  custom?: Object;\r\n}\r\n\r\n/**\r\nA DataProperty describes the metadata for a single property of an  [[EntityType]] that contains simple data.\r\n\r\nInstances of the DataProperty class are constructed automatically during Metadata retrieval. However it is also possible to construct them\r\ndirectly via the constructor.\r\n**/\r\nexport class DataProperty {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // on proto\r\n  /** Is this a DataProperty? - always true here. Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */\r\n  isDataProperty = true;\r\n  /** Is this a NavigationProperty? - always false here.  Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */\r\n  isNavigationProperty = false;\r\n  /** The name of this property. __Read Only__  **/\r\n  name: string;\r\n  /** The name of this property on the server. __Read Only__ **/\r\n  nameOnServer: string;\r\n  /** The [[DataType]] of this property. __Read Only__ */\r\n  dataType: DataType | ComplexType; // this will be a complexType when dp is a complexProperty\r\n  /** The name of the [[ComplexType]] associated with this property; may be null. __Read Only__ */\r\n  complexTypeName: string;\r\n  /** The [[ComplexType]] associated with this property; may be undefined. __Read Only__ */\r\n  complexType?: ComplexType;\r\n  /**  Whether the contents of this property is an instance of a [[ComplexType]]. __Read Only__ */\r\n  isComplexProperty: boolean;\r\n  /** Whether this property is nullable. __Read Only__ */\r\n  isNullable: boolean;\r\n  /**  Whether this property is scalar (i.e., returns a single value as opposed to an array). __Read Only__ */\r\n  isScalar: boolean; // will be false for some NoSQL databases.\r\n  /** The default value for this property. __Read Only__ */\r\n  defaultValue: any;\r\n  /**  Whether this property is a 'key' property. __Read Only__ */\r\n  isPartOfKey: boolean;\r\n  /** Whether this property is an 'unmapped' property. __Read Only__ */\r\n  isUnmapped: boolean;\r\n  /** Whether this property is 'settable'. __Read Only__ */\r\n  isSettable: boolean;\r\n  // TODO: doc this\r\n  concurrencyMode: string;\r\n  /**  The maximum length for the value of this property. Only meaningful for strings. __Read Only__ */\r\n  maxLength?: number;\r\n  /** The [[Validator]] instances that are associated with this property. Validators can be added and\r\n  removed from this collection. __Read Only__ */\r\n  validators: Validator[];\r\n  /** The display name of this property. __Read Only__ */\r\n  displayName: string;\r\n  // TODO: doc this\r\n  enumType?: any;\r\n  /** The raw type name of this property. will only be defined for properties with a DataType of 'Undefined' */\r\n  rawTypeName?: string;  // occurs with undefined datatypes\r\n  /**  A free form object that can be used to define any custom metadata for this DataProperty. __Read Only__ */\r\n  custom?: Object;\r\n  // TODO: doc this\r\n  inverseNavigationProperty?: NavigationProperty;\r\n  /**\r\n  The navigation property related to this property.  Will only be set if this is a foreign key property. __Read Only__ */\r\n  relatedNavigationProperty?: NavigationProperty;\r\n  /** The parent type that this property belongs to - will be either a [[EntityType]] or a [[ComplexType]]. __Read Only__ */\r\n  parentType: StructuralType;\r\n  /** Property on the base type that this property is inherited from. Will be null if the property is not on the base type. __Read Only__ */\r\n  baseProperty?: DataProperty;\r\n\r\n  /** DataProperty constructor\r\n  >      let lastNameProp = new DataProperty( {\r\n  >          name: \"lastName\",\r\n  >          dataType: DataType.String,\r\n  >          isNullable: true,\r\n  >          maxLength: 20\r\n  >      });\r\n  >      // assuming personEntityType is a newly constructed EntityType\r\n  >      personEntityType.addProperty(lastNameProperty);\r\n  @param config - A configuration Object or a DataProperty\r\n  */\r\n  constructor(config: DataPropertyConfig | DataProperty) {\r\n    assertConfig(config)\r\n      .whereParam(\"name\").isString().isOptional()\r\n      .whereParam(\"nameOnServer\").isString().isOptional()\r\n      .whereParam(\"dataType\").isEnumOf(DataType).isOptional().or().isString().or().isInstanceOf(ComplexType)\r\n      .whereParam(\"complexTypeName\").isOptional()\r\n      .whereParam(\"isNullable\").isBoolean().isOptional().withDefault(true)\r\n      .whereParam(\"isScalar\").isOptional().withDefault(true)// will be false for some NoSQL databases.\r\n      .whereParam(\"defaultValue\").isOptional()\r\n      .whereParam(\"isPartOfKey\").isBoolean().isOptional()\r\n      .whereParam(\"isUnmapped\").isBoolean().isOptional()\r\n      .whereParam(\"isSettable\").isBoolean().isOptional().withDefault(true)\r\n      .whereParam(\"concurrencyMode\").isString().isOptional()\r\n      .whereParam(\"maxLength\").isNumber().isOptional()\r\n      .whereParam(\"validators\").isInstanceOf(Validator).isArray().isOptional().withDefault([])\r\n      .whereParam(\"displayName\").isOptional()\r\n      .whereParam(\"enumType\").isOptional()\r\n      .whereParam(\"rawTypeName\").isOptional() // occurs with undefined datatypes\r\n      .whereParam(\"custom\").isOptional()\r\n      .applyAll(this);\r\n    let hasName = !!(this.name || this.nameOnServer);\r\n    if (!hasName) {\r\n      throw new Error(\"A DataProperty must be instantiated with either a 'name' or a 'nameOnServer' property\");\r\n    }\r\n    // name/nameOnServer is resolved later when a metadataStore is available.\r\n\r\n    if (this.complexTypeName) {\r\n      this.isComplexProperty = true;\r\n      // this.dataType = null; // TODO: would like to remove this line because dataType will be set later.\r\n    } else if (typeof (this.dataType) === \"string\") {\r\n      let dt = DataType.fromName(this.dataType);\r\n      if (!dt) {\r\n        throw new Error(\"Unable to find a DataType enumeration by the name of: \" + this.dataType);\r\n      }\r\n      this.dataType = dt;\r\n    } else if (!this.dataType) {\r\n      this.dataType = DataType.String;\r\n    }\r\n\r\n    // == as opposed to === is deliberate here.\r\n    if (this.defaultValue == null) {\r\n      if (this.isNullable) {\r\n        this.defaultValue = null;\r\n      } else {\r\n        if (this.isComplexProperty) {\r\n          // what to do? - shouldn't happen from EF - but otherwise ???\r\n        } else if (this.dataType === DataType.Binary) {\r\n          this.defaultValue = \"AAAAAAAAJ3U=\"; // hack for all binary fields but value is specifically valid for timestamp fields - arbitrary valid 8 byte base64 value.\r\n        } else {\r\n          this.defaultValue = (this.dataType as any).defaultValue;\r\n          if (this.defaultValue == null) {\r\n            throw new Error(\"A nonnullable DataProperty cannot have a null defaultValue. Name: \" + (this.name || this.nameOnServer));\r\n          }\r\n        }\r\n      }\r\n    } else if ((this.dataType as any).isNumeric) {\r\n      // in case the defaultValue comes in as a string ( which it does in EF6).\r\n      if (typeof (this.defaultValue) === \"string\") {\r\n        this.defaultValue = parseFloat(this.defaultValue);\r\n      }\r\n    }\r\n\r\n    if (this.isComplexProperty) {\r\n      this.isScalar = this.isScalar == null || this.isScalar === true;\r\n    }\r\n\r\n  }\r\n\r\n  static getRawValueFromServer(rawEntity: Object, dp: DataProperty) {\r\n    if (dp.isUnmapped) {\r\n      return rawEntity[dp.nameOnServer || dp.name];\r\n    } else {\r\n      let val = rawEntity[dp.nameOnServer];\r\n      return val !== undefined ? val : dp.defaultValue;\r\n    }\r\n  }\r\n\r\n  static getRawValueFromClient(rawEntity: Object, dp: DataProperty) {\r\n    let val = rawEntity[dp.name];\r\n    return val !== undefined ? val : dp.defaultValue;\r\n  }\r\n\r\n  resolveProperty(propName: string) {\r\n    let result = this[propName];\r\n    let baseProp = this.baseProperty;\r\n    while (result == undefined && baseProp != null) {\r\n      result = baseProp[propName];\r\n      baseProp = baseProp.baseProperty;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  formatName() {\r\n    return this.parentType.name + \"--\" + this.name;\r\n  }\r\n\r\n\r\n  /**\r\n  General purpose property set method\r\n  >      // assume em1 is an EntityManager\r\n  >      let prop = myEntityType.getProperty(\"myProperty\");\r\n  >      prop.setProperties( {\r\n  >          custom: { foo: 7, bar: \"test\" }\r\n  >      });\r\n  @param config - A configuration object.\r\n  **/\r\n  setProperties(config: { displayName?: string, custom?: Object }) {\r\n    assertConfig(config)\r\n      .whereParam(\"displayName\").isOptional()\r\n      .whereParam(\"custom\").isOptional()\r\n      .applyAll(this);\r\n  }\r\n\r\n  getAllValidators() {\r\n    let validators = this.validators.slice(0);\r\n    let baseProp = this.baseProperty;\r\n    while (baseProp) {\r\n      validators.push.apply(validators, baseProp.validators);\r\n      baseProp = baseProp.baseProperty;\r\n    }\r\n    return validators;\r\n  }\r\n\r\n  toJSON() {\r\n    // do not serialize dataTypes that are complexTypes\r\n    return core.toJson(this, {\r\n      name: null,\r\n      dataType: function (v: any) {\r\n        return (v && v instanceof DataType) ? v.name : undefined;\r\n      }, // do not serialize dataTypes that are complexTypes\r\n      complexTypeName: null,\r\n      isNullable: true,\r\n      defaultValue: null,\r\n      isPartOfKey: false,\r\n      isUnmapped: false,\r\n      isSettable: true,\r\n      concurrencyMode: null,\r\n      maxLength: null,\r\n      validators: null,\r\n      displayName: null,\r\n      enumType: null,\r\n      rawTypeName: null,\r\n      isScalar: true,\r\n      custom: null\r\n    });\r\n  }\r\n\r\n  static fromJSON(json: any) {\r\n    json.dataType = DataType.fromName(json.dataType);\r\n    // Parse default value into correct data type. (dateTime instances require extra work to deserialize properly.)\r\n    if (json.defaultValue && json.dataType && json.dataType.parse) {\r\n      json.defaultValue = json.dataType.parse(json.defaultValue, typeof json.defaultValue);\r\n    }\r\n\r\n    if (json.validators) {\r\n      json.validators = json.validators.map(Validator.fromJSON);\r\n    }\r\n\r\n    return new DataProperty(json);\r\n  }\r\n\r\n}\r\nDataProperty.prototype._$typeName = \"DataProperty\";\r\n\r\nexport interface NavigationPropertyConfig {\r\n  name?: string;\r\n  nameOnServer?: string;\r\n  entityTypeName?: string;\r\n  isScalar?: boolean;\r\n  associationName?: string;\r\n  foreignKeyNames?: string[];\r\n  foreignKeyNamesOnServer?: string[];\r\n  invForeignKeyNames?: string[];\r\n  invForeignKeyNamesOnServer?: string[];\r\n  validators?: Validator[];\r\n  displayName?: string;\r\n  custom?: Object;\r\n}\r\n\r\n/**   A NavigationProperty describes the metadata for a single property of an [[EntityType]] that return instances of other EntityTypes.\r\n\r\nInstances of the NavigationProperty class are constructed automatically during Metadata retrieval.   However it is also possible to construct them\r\ndirectly via the constructor.\r\n**/\r\nexport class NavigationProperty {\r\n  /** @hidden @internal */\r\n  _$typeName: string;\r\n  /** Is this a DataProperty? - always false here \r\n  Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */\r\n  isDataProperty = false;\r\n  /** Is this a NavigationProperty? - always true here\r\n  Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */\r\n  isNavigationProperty = true;\r\n\r\n  formatName = DataProperty.prototype.formatName;\r\n  getAllValidators = DataProperty.prototype.getAllValidators;\r\n  resolveProperty = DataProperty.prototype.resolveProperty;\r\n\r\n  /** The [[EntityType]] returned by this property. __Read Only__ */\r\n  entityType: EntityType;\r\n  /** The name of the [[EntityType]] returned by this property. __Read Only__ */\r\n  entityTypeName: string;\r\n  /** The [[EntityType]] that this property belongs to. ( same as entityType). __Read Only__ */\r\n  parentType: EntityType; // ?? same as entityType\r\n  /** The [[EntityType]] that this property belongs to. ( same as entityType). __Read Only__ */\r\n  parentEntityType: EntityType; // ?? same as above\r\n  /** Property on the base type that this property is inherited from. Will be null if the property is not on the base type. __Read Only__ */\r\n  baseProperty?: NavigationProperty;\r\n  /** The inverse of this NavigationProperty.  The NavigationProperty that represents a navigation in the opposite direction\r\n  to this NavigationProperty. May be undefined for a undirectional NavigationProperty. __Read Only__ */\r\n  private _inverse?: NavigationProperty;\r\n  /** The name of this property. __Read Only__ */\r\n  name: string;\r\n  /** The name of this property on the server. __Read Only__ */\r\n  nameOnServer: string;\r\n  /**\r\n  Whether this property returns a single entity as opposed to  an array of entities. __Read Only__ */\r\n  isScalar: boolean;\r\n  /** The name of the association to which that this property belongs.  This associationName will be shared with this\r\n  properties 'inverse'. __Read Only__ */\r\n  associationName: string;\r\n  /** The names of the foreign key DataProperties associated with this NavigationProperty. There will usually only be a single DataProperty associated\r\n  with a Navigation property except in the case of entities with multipart keys. __Read Only__ */\r\n  foreignKeyNames: string[];\r\n  /** The server side names of the foreign key DataProperties associated with this NavigationProperty. There will usually only be a single DataProperty associated\r\n  with a Navigation property except in the case of entities with multipart keys. __Read Only__ */\r\n  foreignKeyNamesOnServer: string[];\r\n  invForeignKeyNames: string[];\r\n  invForeignKeyNamesOnServer: string[];\r\n  /** The 'foreign key' DataProperties associated with this NavigationProperty. There will usually only be a single DataProperty associated\r\n  with a Navigation property except in the case of entities with multipart keys. __Read Only__ */\r\n  relatedDataProperties: DataProperty[];\r\n  /** The [[Validator]] instances that are associated with this property. Validators can be added and\r\n  removed from this collection. __Read Only__ */\r\n  validators: Validator[];\r\n  /** The display name of this property. __Read Only__ */\r\n  displayName: string;\r\n  isUnmapped: boolean;\r\n  /** A free form object that can be used to define any custom metadata for this NavigationProperty.   **/\r\n  custom: Object;\r\n\r\n  /** NavigationProperty constructor\r\n  >      let homeAddressProp = new NavigationProperty( {\r\n  >          name: \"homeAddress\",\r\n  >          entityTypeName: \"Address:#myNamespace\",\r\n  >          isScalar: true,\r\n  >          associationName: \"address_person\",\r\n  >          foreignKeyNames: [\"homeAddressId\"]\r\n  >      });\r\n  >      let homeAddressIdProp = new DataProperty( {\r\n  >          name: \"homeAddressId\"\r\n  >          dataType: DataType.Integer\r\n  >      });\r\n  >      // assuming personEntityType is a newly constructed EntityType\r\n  >      personEntityType.addProperty(homeAddressProp);\r\n  >      personEntityType.addProperty(homeAddressIdProp);\r\n  @param config - A configuration object.\r\n  **/\r\n  constructor(config: NavigationPropertyConfig) {\r\n    assertConfig(config)\r\n      .whereParam(\"name\").isString().isOptional()\r\n      .whereParam(\"nameOnServer\").isString().isOptional()\r\n      .whereParam(\"entityTypeName\").isString()\r\n      .whereParam(\"isScalar\").isBoolean().isOptional().withDefault(true)\r\n      .whereParam(\"associationName\").isString().isOptional()\r\n      .whereParam(\"foreignKeyNames\").isArray().isString().isOptional().withDefault([])\r\n      .whereParam(\"foreignKeyNamesOnServer\").isArray().isString().isOptional().withDefault([])\r\n      .whereParam(\"invForeignKeyNames\").isArray().isString().isOptional().withDefault([])\r\n      .whereParam(\"invForeignKeyNamesOnServer\").isArray().isString().isOptional().withDefault([])\r\n      .whereParam(\"validators\").isInstanceOf(Validator).isArray().isOptional().withDefault([])\r\n      .whereParam(\"displayName\").isOptional()\r\n      .whereParam(\"custom\").isOptional()\r\n      .applyAll(this);\r\n    let hasName = !!(this.name || this.nameOnServer);\r\n\r\n    if (!hasName) {\r\n      throw new Error(\"A Navigation property must be instantiated with either a 'name' or a 'nameOnServer' property\");\r\n    }\r\n  }\r\n\r\n  /**\r\n  General purpose property set method\r\n  >      // assume myEntityType is an EntityType\r\n  >      let prop = myEntityType.getProperty(\"myProperty\");\r\n  >      prop.setProperties( {\r\n  >          custom: { foo: 7, bar: \"test\" }\r\n  >      });\r\n  @param config - A config object\r\n  **/\r\n  // TODO: create an interface for this.\r\n  setProperties(config: {\r\n    displayName?: string,\r\n    foreignKeyNames?: string[],\r\n    invForeignKeyNames?: string[],\r\n    inverse?: NavigationProperty | string,\r\n    custom?: Object\r\n  }) {\r\n    if (!this.parentType) {\r\n      throw new Error(\"Cannot call NavigationProperty.setProperties until the parent EntityType of the NavigationProperty has been set.\");\r\n    }\r\n    let inverse = config.inverse;\r\n    if (inverse) delete config.inverse;\r\n    assertConfig(config)\r\n      .whereParam(\"displayName\").isOptional()\r\n      .whereParam(\"foreignKeyNames\").isArray().isString().isOptional().withDefault([])\r\n      .whereParam(\"invForeignKeyNames\").isArray().isString().isOptional().withDefault([])\r\n      .whereParam(\"custom\").isOptional()\r\n      .applyAll(this);\r\n    this.parentType._updateNames(this);\r\n\r\n    this._resolveNp();\r\n    if (inverse) {\r\n      this.setInverse(inverse);\r\n    }\r\n\r\n  }\r\n\r\n  /** The inverse of this NavigationProperty.  The NavigationProperty that represents a navigation in the opposite direction\r\n  to this NavigationProperty. May be undefined for a undirectional NavigationProperty. __Read Only__ */\r\n  get inverse(): NavigationProperty | undefined {\r\n    return this.getInverse();\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  getInverse(): NavigationProperty | undefined {\r\n    let np: NavigationProperty = this;\r\n    while (!np._inverse && np.baseProperty) {\r\n      np = np.baseProperty;\r\n    }\r\n    return np._inverse;\r\n  }\r\n\r\n  setInverse(inverseNp: NavigationProperty | string) {\r\n    // let invNp: NavigationProperty;\r\n    let invNp = (inverseNp instanceof NavigationProperty) ? inverseNp : this.entityType.getNavigationProperty(inverseNp);\r\n\r\n    if (!invNp) {\r\n      throw throwSetInverseError(this, \"Unable to find inverse property: \" + inverseNp);\r\n    }\r\n\r\n    if (this._inverse || invNp._inverse) {\r\n      throwSetInverseError(this, \"It has already been set on one side or the other.\");\r\n    }\r\n    if (invNp.entityType !== this.parentType) {\r\n      throwSetInverseError(this, invNp.formatName + \" is not a valid inverse property for this.\");\r\n    }\r\n    if (this.associationName) {\r\n      invNp.associationName = this.associationName;\r\n    } else {\r\n      if (!invNp.associationName) {\r\n        invNp.associationName = this.formatName() + \"_\" + invNp.formatName();\r\n      }\r\n      this.associationName = invNp.associationName;\r\n    }\r\n    this._resolveNp();\r\n    invNp._resolveNp();\r\n  }\r\n\r\n  // // In progress - will be used for manual metadata config\r\n  // createInverse(config: any) {\r\n\r\n  //   if (!this.entityType) {\r\n  //     throwCreateInverseError(this, \"has not yet been defined.\");\r\n  //   }\r\n  //   if (this.entityType.isFrozen) {\r\n  //     throwCreateInverseError(this, \"is frozen.\");\r\n  //   }\r\n  //   let metadataStore = this.entityType.metadataStore;\r\n  //   if (metadataStore == null) {\r\n  //     throwCreateInverseError(this, \"has not yet been added to the metadataStore.\");\r\n  //   }\r\n\r\n  //   config.entityTypeName = this.parentEntityType.name;\r\n  //   config.associationName = this.associationName;\r\n  //   let invNp = new NavigationProperty(config);\r\n  //   this.parentEntityType.addNavigationProperty(invNp);\r\n  //   return invNp;\r\n  // };\r\n\r\n\r\n\r\n  toJSON() {\r\n    return core.toJson(this, {\r\n      name: null,\r\n      entityTypeName: null,\r\n      isScalar: null,\r\n      associationName: null,\r\n      validators: null,\r\n      displayName: null,\r\n      foreignKeyNames: null,\r\n      invForeignKeyNames: null,\r\n      custom: null\r\n    });\r\n  }\r\n\r\n  static fromJSON(json: any) {\r\n    if (json.validators) {\r\n      json.validators = json.validators.map(Validator.fromJSON);\r\n    }\r\n    return new NavigationProperty(json);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _resolveNp() {\r\n    let np = this;\r\n    let entityType = np.entityType;\r\n    let invNp = core.arrayFirst(entityType.navigationProperties, (altNp) => {\r\n      // Can't do this because of possibility of comparing a base class np with a subclass altNp.\r\n      // return altNp.associationName === np.associationName\r\n      //    && altNp !== np;\r\n      // So use this instead.\r\n      return altNp.associationName === np.associationName &&\r\n        (altNp.name !== np.name || altNp.entityTypeName !== np.entityTypeName);\r\n    });\r\n    np._inverse = invNp || undefined;\r\n    //if (invNp && invNp.inverse == null) {\r\n    //    invNp._resolveNp();\r\n    //}\r\n    if (!invNp) {\r\n      // unidirectional 1-n relationship\r\n      np.invForeignKeyNames.forEach(function (invFkName) {\r\n        let fkProp = entityType.getDataProperty(invFkName);\r\n        if (fkProp == null) {\r\n          throw new Error(\"EntityType '\" + np.entityTypeName + \"' has no foreign key matching '\" + invFkName + \"'\");\r\n        }\r\n        let invEntityType = np.parentType;\r\n        invNp = core.arrayFirst(invEntityType.navigationProperties, (np2) => {\r\n          return np2.invForeignKeyNames && np2.invForeignKeyNames.indexOf(fkProp!.name) >= 0 && np2.entityType === fkProp!.parentType;\r\n        });\r\n        fkProp.inverseNavigationProperty = invNp || undefined;\r\n        core.arrayAddItemUnique(entityType.foreignKeyProperties, fkProp);\r\n      });\r\n    }\r\n\r\n    resolveRelated(np);\r\n  }\r\n\r\n}\r\nNavigationProperty.prototype._$typeName = \"NavigationProperty\";\r\n\r\nfunction throwSetInverseError(np: NavigationProperty, message: string) {\r\n  throw new Error(\"Cannot set the inverse property for: \" + np.formatName() + \". \" + message);\r\n}\r\n\r\n// Not current used.\r\n// function throwCreateInverseError(np: NavigationProperty, message: string) {\r\n//   throw new Error(\"Cannot create inverse for: \" + np.formatName() + \". The entityType for this navigation property \" + message);\r\n// }\r\n\r\n// sets navigation property: relatedDataProperties and dataProperty: relatedNavigationProperty\r\nfunction resolveRelated(np: NavigationProperty) {\r\n\r\n  let fkNames = np.foreignKeyNames;\r\n  if (fkNames.length === 0) return;\r\n\r\n  let parentEntityType = np.parentType;\r\n  let fkProps = fkNames.map(function (fkName) {\r\n    return parentEntityType.getDataProperty(fkName);\r\n  });\r\n  let fkPropCollection = parentEntityType.foreignKeyProperties;\r\n\r\n  fkProps.forEach((dp: DataProperty) => {\r\n    core.arrayAddItemUnique(fkPropCollection, dp);\r\n    dp.relatedNavigationProperty = np;\r\n    // now update the inverse\r\n    core.arrayAddItemUnique(np.entityType.inverseForeignKeyProperties, dp);\r\n    if (np.relatedDataProperties) {\r\n      core.arrayAddItemUnique(np.relatedDataProperties, dp);\r\n    } else {\r\n      np.relatedDataProperties = [dp];\r\n    }\r\n  });\r\n}\r\n\r\n\r\n/**\r\nAutoGeneratedKeyType is an 'Enum' containing all of the valid states for an automatically generated key.\r\n**/\r\nexport class AutoGeneratedKeyType extends BreezeEnum {\r\n\r\n  /**\r\n  This entity does not have an autogenerated key.\r\n  The client must set the key before adding the entity to the EntityManager\r\n  **/\r\n  static None = new AutoGeneratedKeyType();\r\n  /** \r\n  This entity's key is an Identity column and is set by the backend database.\r\n  Keys for new entities will be temporary until the entities are saved at which point the keys will\r\n  be converted to their 'real' versions.\r\n  **/\r\n  static Identity = new AutoGeneratedKeyType();\r\n  /**\r\n  This entity's key is generated by a KeyGenerator and is set by the backend database.\r\n  Keys for new entities will be temporary until the entities are saved at which point the keys will\r\n  be converted to their 'real' versions.\r\n  **/\r\n  static KeyGenerator = new AutoGeneratedKeyType();\r\n\r\n}\r\nAutoGeneratedKeyType.prototype._$typeName = \"AutoGeneratedKeyType\";\r\nError['x'] = AutoGeneratedKeyType.resolveSymbols();\r\n\r\n\r\n// mixin methods\r\n/** @hidden @internal */\r\ndeclare module \"./assert-param\" {\r\n  interface Param {\r\n    isEntity(): Param;\r\n    isEntityProperty(): Param;\r\n  }\r\n}\r\n\r\nlet proto = Param.prototype;\r\n\r\n// 'this' below is TS annotation \r\nproto.isEntity = function (this: Param) {\r\n  return this._addContext({\r\n    fn: isEntity,\r\n    msg: \" must be an entity\"\r\n  });\r\n};\r\n\r\nfunction isEntity(context: any, v: any) {\r\n  if (v == null) return false;\r\n  return (v.entityType !== undefined);\r\n}\r\n\r\nproto.isEntityProperty = function (this: Param) {\r\n  return this._addContext({\r\n    fn: isEntityProperty,\r\n    msg: \" must be either a DataProperty or a NavigationProperty\"\r\n  });\r\n};\r\n\r\nfunction isEntityProperty(context: any, v: any) {\r\n  if (v == null) return false;\r\n  return (v.isDataProperty || v.isNavigationProperty);\r\n}\r\n\r\n// functions shared between classes related to Metadata\r\n\r\nfunction isQualifiedTypeName(entityTypeName: string) {\r\n  return entityTypeName.indexOf(\":#\") >= 0;\r\n}\r\n\r\nexport function qualifyTypeName(shortName: string, ns?: string) {\r\n  if (ns && ns.length > 0) {\r\n    return shortName + \":#\" + ns;\r\n  } else {\r\n    return shortName;\r\n  }\r\n}\r\n\r\n// Used by both ComplexType and EntityType\r\nfunction addProperties(entityType: StructuralType, propObj: Object | undefined, ctor: any) {\r\n  if (propObj == null) return;\r\n  if (Array.isArray(propObj)) {\r\n    propObj.forEach(entityType._addPropertyCore.bind(entityType));\r\n  } else if (typeof (propObj) === 'object') {\r\n    for (let key in propObj) {\r\n      if (core.hasOwnProperty(propObj, key)) {\r\n        let value = propObj[key];\r\n        value.name = key;\r\n        let prop = new ctor(value);\r\n        entityType._addPropertyCore(prop);\r\n      }\r\n    }\r\n  } else {\r\n    throw new Error(\"The 'dataProperties' or 'navigationProperties' values must be either an array of data/nav properties or an object where each property defines a data/nav property\");\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","import { core } from './core';\r\nimport { config } from './config';\r\nimport { EntityQuery } from './entity-query';\r\nimport { DataServiceAdapter, AjaxAdapter, ChangeRequestInterceptorCtor, ChangeRequestInterceptor } from './interface-registry';\r\nimport { Entity } from './entity-aspect';\r\nimport { MappingContext } from './mapping-context';\r\nimport { DataService, JsonResultsAdapter } from './data-service';\r\nimport { HttpResponse, SaveContext, SaveBundle, ServerError, SaveResult, SaveErrorFromServer, QueryResult } from './entity-manager';\r\nimport { MetadataStore } from './entity-metadata';\r\n\r\n/** For use by breeze plugin authors only.  The class is used as the base class for most [[IDataServiceAdapter]] implementations\r\n@adapter (see [[IDataServiceAdapter]])    \r\n@hidden\r\n*/\r\nexport abstract class AbstractDataServiceAdapter implements DataServiceAdapter {\r\n  /** @hidden @internal */\r\n  _$impl?: any;\r\n  /** The name of this adapter. */\r\n  name: string;\r\n  /** The [[IAjaxAdapter]] used by this [[IDataServiceAdapter]]. */\r\n  ajaxImpl: AjaxAdapter;\r\n\r\n  constructor() {\r\n  }\r\n\r\n\r\n  // TODO use interface\r\n  checkForRecomposition(interfaceInitializedArgs: any) {\r\n    if (interfaceInitializedArgs.interfaceName === \"ajax\" && interfaceInitializedArgs.isDefault) {\r\n      this.initialize();\r\n    }\r\n  }\r\n\r\n  initialize() {\r\n    this.ajaxImpl = config.getAdapterInstance<AjaxAdapter>(\"ajax\") !;\r\n\r\n    // don't cache 'ajax' because then we would need to \".bind\" it, and don't want to because of brower support issues.\r\n    if (this.ajaxImpl && this.ajaxImpl.ajax) {\r\n      return;\r\n    }\r\n    throw new Error(\"Unable to find ajax adapter for dataservice adapter '\" + (this.name || '') + \"'.\");\r\n  }\r\n\r\n  fetchMetadata(metadataStore: MetadataStore, dataService: DataService) {\r\n    let serviceName = dataService.serviceName;\r\n    let url = dataService.qualifyUrl(\"Metadata\");\r\n\r\n    let promise = new Promise((resolve, reject) => {\r\n\r\n      this.ajaxImpl.ajax({\r\n        type: \"GET\",\r\n        url: url,\r\n        dataType: 'json',\r\n        success: (httpResponse: HttpResponse) => {\r\n\r\n          // might have been fetched by another query\r\n          if (metadataStore.hasMetadataFor(serviceName)) {\r\n            return resolve(\"already fetched\");\r\n          }\r\n          let data = httpResponse.data;\r\n          let metadata: any;\r\n          try {\r\n            metadata = typeof (data) === \"string\" ? JSON.parse(data) : data;\r\n            metadataStore.importMetadata(metadata);\r\n          } catch (e) {\r\n            let errMsg = \"Unable to either parse or import metadata: \" + e.message;\r\n            handleHttpError(reject, httpResponse, \"Metadata query failed for: \" + url + \". \" + errMsg);\r\n          }\r\n\r\n          // import may have brought in the service.\r\n          if (!metadataStore.hasMetadataFor(serviceName)) {\r\n            metadataStore.addDataService(dataService);\r\n          }\r\n\r\n          resolve(metadata);\r\n\r\n        },\r\n        error: (httpResponse: HttpResponse) => {\r\n          handleHttpError(reject, httpResponse, \"Metadata query failed for: \" + url);\r\n        }\r\n      });\r\n    });\r\n    return promise;\r\n  }\r\n\r\n  executeQuery(mappingContext: MappingContext) {\r\n    mappingContext.adapter = this;\r\n    let promise = new Promise<QueryResult>((resolve, reject) => {\r\n      let url = mappingContext.getUrl();\r\n\r\n      let params = {\r\n        type: \"GET\",\r\n        url: url,\r\n        params: (mappingContext.query as EntityQuery).parameters,\r\n        dataType: 'json',\r\n        success: function (httpResponse: HttpResponse) {\r\n          let data = httpResponse.data;\r\n          try {\r\n            let rData: QueryResult;\r\n            let results = data && (data.results || data.Results);\r\n            if (results) {\r\n              rData = { results: results, inlineCount: data.inlineCount || data.InlineCount, \r\n                httpResponse: httpResponse, query: mappingContext.query };\r\n            } else {\r\n              rData = { results: data, httpResponse: httpResponse, query: mappingContext.query };\r\n            }\r\n\r\n            resolve(rData);\r\n          } catch (e) {\r\n            if (e instanceof Error) {\r\n              reject(e);\r\n            } else {\r\n              handleHttpError(reject, httpResponse);\r\n            }\r\n          }\r\n\r\n        },\r\n        error: function (httpResponse: HttpResponse) {\r\n          handleHttpError(reject, httpResponse);\r\n        },\r\n        crossDomain: false\r\n      };\r\n      if (mappingContext.dataService.useJsonp) {\r\n        params.dataType = 'jsonp';\r\n        params.crossDomain = true;\r\n      }\r\n      this.ajaxImpl.ajax(params);\r\n    });\r\n    return promise;\r\n  }\r\n\r\n  saveChanges(saveContext: SaveContext, saveBundle: SaveBundle) {\r\n    let adapter = saveContext.adapter = this;\r\n\r\n    let saveBundleSer = adapter._prepareSaveBundle(saveContext, saveBundle);\r\n    let bundle = JSON.stringify(saveBundleSer);\r\n\r\n    let url = saveContext.dataService.qualifyUrl(saveContext.resourceName);\r\n    let promise = new Promise<SaveResult>((resolve, reject) => {\r\n      this.ajaxImpl.ajax({\r\n        type: \"POST\",\r\n        url: url,\r\n        dataType: 'json',\r\n        contentType: \"application/json\",\r\n        data: bundle,\r\n        success: function (httpResponse: HttpResponse) {\r\n          httpResponse.saveContext = saveContext;\r\n          let data = httpResponse.data;\r\n          if (data.Errors || data.errors) {\r\n            handleHttpError(reject, httpResponse);\r\n          } else {\r\n            let saveResult = adapter._prepareSaveResult(saveContext, data);\r\n            saveResult.httpResponse = httpResponse;\r\n            resolve(saveResult);\r\n          }\r\n        },\r\n        error: function (httpResponse: HttpResponse) {\r\n          httpResponse.saveContext = saveContext;\r\n          handleHttpError(reject, httpResponse);\r\n        }\r\n      });\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  /** Abstract method that needs to be overwritten in any concrete DataServiceAdapter subclass. \r\n  The return value from this method should be a serializable object that will be sent to the server after calling JSON.stringify on it.\r\n  */\r\n  _prepareSaveBundle(saveContext: SaveContext, saveBundle: SaveBundle): any {\r\n    // The implementor should call _createChangeRequestInterceptor\r\n    throw new Error(\"Need a concrete implementation of _prepareSaveBundle\");\r\n  }\r\n\r\n  /**\r\n  Returns a constructor function for a \"ChangeRequestInterceptor\"\r\n  that can tweak the saveBundle both as it is built and when it is completed\r\n  by a concrete DataServiceAdapater.\r\n\r\n  Initialized with a default, no-op implementation that developers can replace with a\r\n  substantive implementation that changes the individual entity change requests\r\n  or aspects of the entire 'saveBundle' without having to write their own DataService adapters.\r\n  >     let adapter = breeze.config.getAdapterInstance('dataService');\r\n  >     adapter.changeRequestInterceptor = function (saveContext, saveBundle) {\r\n  >         this.getRequest = function (request, entity, index) {\r\n  >            // alter the request that the adapter prepared for this entity\r\n  >            // based on the entity, saveContext, and saveBundle\r\n  >            // e.g., add a custom header or prune the originalValuesMap\r\n  >            return request;\r\n  >        };\r\n  >        this.done = function (requests) {\r\n  >            // alter the array of requests representing the entire change-set\r\n  >            // based on the saveContext and saveBundle\r\n  >        };\r\n  >     }\r\n\r\n  @param saveContext - The BreezeJS \"context\" for the save operation.\r\n  @param saveBundle - Contains the array of entities-to-be-saved (AKA, the entity change-set).\r\n  @return Constructor for a \"ChangeRequestInterceptor\".\r\n  **/\r\n  changeRequestInterceptor: ChangeRequestInterceptorCtor = DefaultChangeRequestInterceptor;\r\n\r\n  /** @hidden @internal */\r\n  _createChangeRequestInterceptor(saveContext: SaveContext, saveBundle: SaveBundle) {\r\n    let adapter = saveContext.adapter!;\r\n    let cri = adapter.changeRequestInterceptor;\r\n    let isFn = core.isFunction;\r\n\r\n    if (isFn(cri)) {\r\n      let pre = adapter.name + \" DataServiceAdapter's ChangeRequestInterceptor\";\r\n      let post = \" is missing or not a function.\";\r\n      let interceptor = new cri(saveContext, saveBundle);\r\n      if (!isFn(interceptor.getRequest)) {\r\n        throw new Error(pre + '.getRequest' + post);\r\n      }\r\n      if (!isFn(interceptor.done)) {\r\n        throw new Error(pre + '.done' + post);\r\n      }\r\n      return interceptor;\r\n    } else {\r\n      return new DefaultChangeRequestInterceptor(saveContext, saveBundle) as ChangeRequestInterceptor;\r\n    }\r\n  }\r\n\r\n  /** Abstract method that needs to be overwritten in any concrete DataServiceAdapter sublclass. \r\n  This method needs to take the result returned the server and convert it into an ISaveResult. \r\n  */\r\n  _prepareSaveResult(saveContext: SaveContext, data: any): SaveResult {\r\n    throw new Error(\"Need a concrete implementation of _prepareSaveResult\");\r\n  }\r\n\r\n\r\n  /** Utility method that may be used in any concrete DataServiceAdapter sublclass to handle any \r\n  http connection issues. \r\n  */\r\n  // Put this at the bottom of your http error analysis\r\n  static _catchNoConnectionError(err: ServerError) {\r\n    if (err.status === 0 && err.message == null) {\r\n      err.message = \"HTTP response status 0 and no message.  \" +\r\n        \"Likely did not or could not reach server. Is the server running?\";\r\n    }\r\n  }\r\n\r\n  jsonResultsAdapter = new JsonResultsAdapter({\r\n    name: \"noop\",\r\n\r\n    visitNode: function (/* node, mappingContext, nodeContext */) {\r\n      return {};\r\n    }\r\n  });\r\n}\r\n\r\nfunction handleHttpError(reject: (reason?: any) => void, httpResponse: HttpResponse, messagePrefix?: string) {\r\n  let err = createError(httpResponse);\r\n  AbstractDataServiceAdapter._catchNoConnectionError(err);\r\n  if (messagePrefix) {\r\n    err.message = messagePrefix + \"; \" + err.message;\r\n  }\r\n  reject(err);\r\n}\r\n\r\nfunction createError(httpResponse: HttpResponse) {\r\n  let err = new Error() as ServerError;\r\n  err.httpResponse = httpResponse;\r\n  err.status = httpResponse.status;\r\n\r\n  let errObj = httpResponse.data;\r\n\r\n  if (!errObj) {\r\n    err.message = httpResponse.error && httpResponse.error.toString();\r\n    return err;\r\n  }\r\n\r\n  // some ajax providers will convert errant result into an object (angularjs), others will not (jQuery)\r\n  // if not do it here.\r\n  if (typeof errObj === \"string\") {\r\n    try {\r\n      errObj = JSON.parse(errObj);\r\n    } catch (e) {\r\n      // sometimes httpResponse.data is just the error message itself\r\n      err.message = errObj;\r\n      return err;\r\n    }\r\n  }\r\n\r\n  let saveContext = httpResponse.saveContext;\r\n\r\n  // if any of the follow properties exist the source is .NET\r\n  let tmp = errObj.Message || errObj.ExceptionMessage || errObj.EntityErrors || errObj.Errors;\r\n  let isDotNet = !!tmp;\r\n  let message: string, entityErrors: any[];\r\n  if (!isDotNet) {\r\n    message = errObj.message;\r\n    entityErrors = errObj.errors || errObj.entityErrors;\r\n  } else {\r\n    let tmp = errObj;\r\n    do {\r\n      // .NET exceptions can provide both ExceptionMessage and Message but ExceptionMethod if it\r\n      // exists has a more detailed message.\r\n      message = tmp.ExceptionMessage || tmp.Message;\r\n      tmp = tmp.InnerException;\r\n    } while (tmp);\r\n    // .EntityErrors will only occur as a result of an EntityErrorsException being deliberately thrown on the server\r\n    entityErrors = errObj.Errors || errObj.EntityErrors;\r\n    entityErrors = entityErrors && entityErrors.map(function (e) {\r\n      return {\r\n        errorName: e.ErrorName,\r\n        entityTypeName: MetadataStore.normalizeTypeName(e.EntityTypeName),\r\n        keyValues: e.KeyValues,\r\n        propertyName: e.PropertyName,\r\n        errorMessage: e.ErrorMessage\r\n      };\r\n    });\r\n  }\r\n\r\n  if (saveContext && entityErrors) {\r\n\r\n    let propNameFn = saveContext.entityManager.metadataStore.namingConvention.serverPropertyNameToClient;\r\n    entityErrors.forEach(function (e) {\r\n      e.propertyName = e.propertyName && propNameFn(e.propertyName);\r\n    });\r\n    (err as SaveErrorFromServer).entityErrors = entityErrors;\r\n  }\r\n\r\n  err.message = message || \"Server side errors encountered - see the entityErrors collection on this object for more detail\";\r\n  return err;\r\n}\r\n\r\n\r\n/** This is a default, no-op implementation that developers can replace. */\r\nclass DefaultChangeRequestInterceptor {\r\n  constructor(saveContext: SaveContext, saveBundle: SaveBundle) {\r\n\r\n  }\r\n\r\n  getRequest(request: any, entity: Entity, index: number) {\r\n    return request;\r\n  }\r\n\r\n  done(requests: Object[]) {\r\n  }\r\n}\r\n","import { core  } from './core';\r\nimport { assertConfig } from './assert-param';\r\n\r\n/** Configuration info to be passed to the [[ValidationOptions]] constructor */\r\nexport interface ValidationOptionsConfig {\r\n  /** Whether entity and property level validation should occur when entities are attached to the EntityManager \r\n  other than via a query. (default = true) */\r\n  validateOnAttach?: boolean;\r\n  /**  Whether entity and property level validation should occur before entities are saved. \r\n  A failed validation will force the save to fail early. (default = true)  */\r\n  validateOnSave?: boolean;\r\n  /** Whether entity and property level validation should occur after entities are queried from a remote server.\r\n  (default = false)  **/\r\n  validateOnQuery?: boolean;\r\n  /** Whether property level validation should occur after entities are modified.\r\n  (default = true)  **/\r\n  validateOnPropertyChange?: boolean;\r\n}\r\n\r\n/**\r\nA ValidationOptions instance is used to specify the conditions under which validation will be executed.\r\n\r\n*/\r\nexport class ValidationOptions implements ValidationOptionsConfig {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // on proto\r\n  /** Whether entity and property level validation should occur when entities are attached to the EntityManager \r\n  other than via a query. (default = true) __Read Only__ */\r\n  validateOnAttach: boolean;\r\n  /** Whether entity and property level validation should occur before entities are saved. \r\n  A failed validation will force the save to fail early. (default = true) __Read Only__ */\r\n  validateOnSave: boolean;\r\n  /** Whether entity and property level validation should occur after entities are queried from a remote server.\r\n  (default = false) __Read Only__  **/\r\n  validateOnQuery: boolean;\r\n  /** Whether property level validation should occur after entities are modified.\r\n  (default = true) __Read Only__ **/\r\n  validateOnPropertyChange: boolean;\r\n\r\n\r\n\r\n  /** \r\n  ValidationOptions constructor\r\n  >     var newVo = new ValidationOptions( { validateOnSave: false, validateOnAttach: false });\r\n  >     // assume em1 is a preexisting EntityManager\r\n  >     em1.setProperties( { validationOptions: newVo });\r\n  @param config - A configuration object.\r\n  **/\r\n  constructor(config?: ValidationOptionsConfig) {\r\n    updateWithConfig(this, config);\r\n  }\r\n\r\n\r\n  /**\r\n  Returns a copy of this ValidationOptions with changes to the specified config properties.\r\n  >     var validationOptions = new ValidationOptions();\r\n  >     var newOptions = validationOptions.using( { validateOnQuery: true, validateOnSave: false} );\r\n  @param config - A configuration object\r\n  @return A new ValidationOptions instance.\r\n  **/\r\n  using(config: ValidationOptionsConfig) {\r\n    if (!config) return this;\r\n    let result = new ValidationOptions(this);\r\n    updateWithConfig(result, config);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n  Sets the 'defaultInstance' by creating a copy of the current 'defaultInstance' and then applying all of the properties of the current instance.\r\n  The current instance is returned unchanged.\r\n  >     var validationOptions = new ValidationOptions()\r\n  >     var newOptions = validationOptions.using( { validateOnQuery: true, validateOnSave: false} );\r\n  >     var newOptions.setAsDefault();\r\n  **/\r\n  setAsDefault() {\r\n    return core.setAsDefault(this, ValidationOptions);\r\n  }\r\n\r\n  /**\r\n  The default instance for use whenever ValidationOptions are not specified.\r\n  **/\r\n  static defaultInstance = new ValidationOptions({\r\n    validateOnAttach: true,\r\n    validateOnSave: true,\r\n    validateOnQuery: false,\r\n    validateOnPropertyChange: true\r\n  });\r\n}\r\nValidationOptions.prototype._$typeName = \"ValidationOptions\";\r\n\r\nfunction updateWithConfig(options: ValidationOptions, config: ValidationOptionsConfig) {\r\n  if (config) {\r\n    assertConfig(config)\r\n        .whereParam(\"validateOnAttach\").isBoolean().isOptional()\r\n        .whereParam(\"validateOnSave\").isBoolean().isOptional()\r\n        .whereParam(\"validateOnQuery\").isBoolean().isOptional()\r\n        .whereParam(\"validateOnPropertyChange\").isBoolean().isOptional()\r\n        .applyAll(options);\r\n  }\r\n  return options;\r\n}\r\n","import { core } from './core';\r\nimport { assertConfig } from './assert-param';\r\nimport { DataService } from './data-service';\r\n\r\n/** Configuration info to be passed to the [[SaveOptions]] constructor */\r\nexport interface SaveOptionsConfig {\r\n  /** Resource name to be used during the save - this defaults to \"SaveChanges\" */\r\n  resourceName?: string;\r\n  /** The DataService to be used for this save. */\r\n  dataService?: DataService;\r\n  /** Whether multiple saves can be in-flight at the same time. The default is false. */\r\n  allowConcurrentSaves?: boolean;\r\n  /** Free form value that will be sent to the server during the save. */\r\n  tag?: any;\r\n}\r\n\r\n/**\r\nA SaveOptions instance is used to specify the 'options' under which a save will occur.\r\n**/\r\nexport class SaveOptions {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // on proto\r\n  /** Resource name to be used during the save - this defaults to \"SaveChanges\". __Read Only__ */\r\n  resourceName: string;\r\n  /** The DataService to be used for this save. __Read Only__ */\r\n  dataService: DataService;\r\n  /** Whether multiple saves can be in-flight at the same time. The default is false. __Read Only__ */\r\n  allowConcurrentSaves: boolean;\r\n  /** Free form value that will be sent to the server during the save. __Read Only__ */\r\n  tag: any;\r\n\r\n  /** The default value whenever SaveOptions are not specified. */\r\n  static defaultInstance = new SaveOptions({ allowConcurrentSaves: false});\r\n\r\n  constructor(config?: SaveOptionsConfig) {\r\n    SaveOptions._updateWithConfig(this, config);\r\n  }\r\n\r\n\r\n  /**\r\n  Sets the 'defaultInstance' by creating a copy of the current 'defaultInstance' and then applying all of the properties of the current instance.\r\n  The current instance is returned unchanged.\r\n  **/\r\n  setAsDefault() {\r\n    return core.setAsDefault(this, SaveOptions);\r\n  }\r\n\r\n  /**\r\n  Returns a copy of this SaveOptions with the specified config options applied.\r\n  >     var saveOptions = em1.saveOptions.using( {resourceName: \"anotherResource\" });\r\n  **/\r\n  using(config: SaveOptionsConfig) {\r\n    return SaveOptions._updateWithConfig(this, config);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  private static _updateWithConfig(obj: SaveOptions, config: SaveOptionsConfig) {\r\n    if (config) {\r\n      assertConfig(config)\r\n          .whereParam(\"resourceName\").isOptional().isString()\r\n          .whereParam(\"dataService\").isOptional().isInstanceOf(DataService)\r\n          .whereParam(\"allowConcurrentSaves\").isBoolean().isOptional()\r\n          .whereParam(\"tag\").isOptional()\r\n          .applyAll(obj);\r\n    }\r\n    return obj;\r\n  }\r\n\r\n}\r\nSaveOptions.prototype._$typeName = \"SaveOptions\";\r\n\r\n\r\n\r\n","import { EntityType, DataProperty } from './entity-metadata';\r\nimport { EntityKey } from './entity-key';\r\nimport { config } from './config';\r\n\r\ninterface IPropEntry {\r\n  entityType: EntityType;\r\n  propertyName: string;\r\n  keyMap: Object;\r\n}\r\n\r\ninterface ITempIdMap {\r\n  [index: string]: IPropEntry;\r\n}\r\n\r\n/*\r\n  @class KeyGenerator\r\n  */\r\nexport class KeyGenerator {\r\n  /** @hidden @internal */\r\n  private _tempIdMap: ITempIdMap;\r\n\r\n\r\n  constructor() {\r\n    // key is dataProperty.name + || + entityType.name, value is propEntry\r\n    // propEntry = { entityType, propertyName, keyMap }\r\n    // keyMap has key of the actual value ( as a string) and a value of null or the real id.\r\n    this._tempIdMap = {};\r\n  }\r\n\r\n\r\n  /*\r\n  Returns a unique 'temporary' id for the specified [[EntityType]].\r\n  Uniqueness is defined for this purpose as being unique within each instance of a KeyGenerator. This is sufficient\r\n  because each EntityManager will have its own instance of a KeyGenerator and any entities imported into\r\n  the EntityManager with temporary keys will have them regenerated and remapped on import.\r\n\r\n  The return value of this method must be of the correct type as determined by the keyProperties of the\r\n  specified EntityType\r\n  @example\r\n      // Assume em1 is a preexisting EntityManager\r\n      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n      let cust1 = custType.createEntity();\r\n      // next line both sets cust1's 'CustomerId' property but also returns the value\r\n      let cid1 = em1.generateTempKeyValue(cust1);\r\n      em1.saveChanges().then( function( data) {\r\n        let sameCust1 = data.results[0];\r\n        // cust1 === sameCust1;\r\n        // but cust1.getProperty(\"CustomerId\") != cid1\r\n        // because the server will have generated a new id\r\n        // and the client will have been updated with this\r\n        // new id.\r\n      });\r\n  @method generateTempKeyValue\r\n  @param entityType {EntityType}\r\n  */\r\n  generateTempKeyValue(entityType: EntityType, valueIfAvail?: boolean) {\r\n    let keyProps = entityType.keyProperties;\r\n    if (keyProps.length > 1) {\r\n      throw new Error(\"Ids can not be autogenerated for entities with multipart keys\");\r\n    }\r\n    let keyProp = keyProps[0];\r\n    let propEntry = this._getPropEntry(keyProp, true);\r\n    let nextId: any;\r\n    if (valueIfAvail != null) {\r\n      if (!propEntry.keyMap[valueIfAvail.toString()]) {\r\n        nextId = valueIfAvail;\r\n      }\r\n    }\r\n\r\n    if (nextId === undefined) {\r\n      let dataType = keyProp.dataType;\r\n      let getNextFn = (dataType as any).getNext;\r\n      if (getNextFn) {\r\n        nextId = getNextFn(this);\r\n        // need to watch out for collision with previously imported ids that might also get generated.\r\n        while (propEntry.keyMap[nextId.toString()] != null) {\r\n          nextId = getNextFn(this);\r\n        }\r\n      } else {\r\n        throw new Error(\"Cannot use a property with a dataType of: \" + dataType.toString() + \" for id generation\");\r\n      }\r\n    }\r\n\r\n    propEntry.keyMap[nextId.toString()] = true;\r\n    return nextId;\r\n  }\r\n\r\n  getTempKeys() {\r\n    let results: EntityKey[] = [];\r\n    //noinspection JSHint\r\n    for (let key in this._tempIdMap) {\r\n      let propEntry = this._tempIdMap[key];\r\n      let entityType = propEntry.entityType;\r\n      // let propName = propEntry.propertyName;\r\n      //noinspection JSHint\r\n      for (let keyValue in propEntry.keyMap) {\r\n        results.push(new EntityKey(entityType, [keyValue]));\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n\r\n\r\n  // proto methods below are not part of the KeyGenerator interface.\r\n\r\n  isTempKey(entityKey: EntityKey) {\r\n    let keyProps = entityKey.entityType.keyProperties;\r\n    if (keyProps.length > 1) return false;\r\n    let keyProp = keyProps[0];\r\n    let propEntry = this._getPropEntry(keyProp);\r\n    if (!propEntry) {\r\n      return false;\r\n    }\r\n    return (propEntry.keyMap[entityKey.values[0].toString()] !== undefined);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  private _getPropEntry(keyProp: DataProperty, createIfMissing = false) {\r\n    let key = keyProp.name + \"..\" + keyProp.parentType.name;\r\n    let propEntry = this._tempIdMap[key];\r\n    if (!propEntry) {\r\n      if (createIfMissing) {\r\n        propEntry = { entityType: keyProp.parentType as EntityType, propertyName: keyProp.name, keyMap: {} };\r\n        this._tempIdMap[key] = propEntry;\r\n      }\r\n    }\r\n    return propEntry;\r\n  }\r\n\r\n}\r\n\r\nconfig.registerType(KeyGenerator, \"KeyGenerator\");\r\n\r\n","import { Entity } from './entity-aspect';\r\nimport { EntityType, DataProperty  } from './entity-metadata';\r\nimport { EntityKey } from './entity-key';\r\nimport { EntityState } from './entity-state';\r\nimport { EntityManager } from './entity-manager';\r\nimport { MergeStrategy } from './query-options';\r\n\r\n/** @hidden @internal */\r\nexport class EntityGroup {\r\n  entityManager: EntityManager;\r\n  entityType: EntityType;\r\n  _indexMap: { [index: string]: number };\r\n  _entities: (Entity | null)[];\r\n  _emptyIndexes: number[];\r\n\r\n  constructor(entityManager: EntityManager, entityType: EntityType) {\r\n    this.entityManager = entityManager;\r\n    this.entityType = entityType;\r\n    // freeze the entityType after the first instance of this type is either created or queried.\r\n    this.entityType.isFrozen = true;\r\n    this._indexMap = {};\r\n    this._entities = [];\r\n    this._emptyIndexes = [];\r\n  }\r\n\r\n\r\n  attachEntity(entity: Entity, entityState: EntityState, mergeStrategy?: MergeStrategy) {\r\n    // entity should already have an aspect.\r\n    let aspect = entity.entityAspect;\r\n\r\n    if (!aspect._initialized) {\r\n      this.entityType._initializeInstance(entity);\r\n    }\r\n    delete aspect._initialized;\r\n\r\n    let keyInGroup = aspect.getKey()._keyInGroup;\r\n    let ix = this._indexMap[keyInGroup];\r\n    if (ix >= 0) {\r\n      // safecast because key was found not ix will not return a null\r\n      let targetEntity = this._entities[ix] as Entity;\r\n      let targetEntityState = targetEntity.entityAspect.entityState;\r\n      let wasUnchanged = targetEntityState.isUnchanged();\r\n      if (targetEntity === entity) {\r\n        aspect.entityState = entityState;\r\n      } else if (mergeStrategy === MergeStrategy.Disallowed) {\r\n        throw new Error(\"A MergeStrategy of 'Disallowed' does not allow you to attach an entity when an entity with the same key is already attached: \" + aspect.getKey());\r\n      } else if (mergeStrategy === MergeStrategy.OverwriteChanges || (mergeStrategy === MergeStrategy.PreserveChanges && wasUnchanged)) {\r\n        // unwrapInstance returns an entity with server side property names - so we need to use DataProperty.getRawValueFromServer these when we apply\r\n        // the property values back to the target.\r\n        let rawServerEntity = this.entityManager.helper.unwrapInstance(entity);\r\n        this.entityType._updateTargetFromRaw(targetEntity, rawServerEntity, DataProperty.getRawValueFromServer);\r\n        targetEntity.entityAspect.setEntityState(entityState);\r\n      }\r\n      return targetEntity;\r\n    } else {\r\n      if (this._emptyIndexes.length === 0) {\r\n        ix = this._entities.push(entity) - 1;\r\n      } else {\r\n        ix = this._emptyIndexes.pop();\r\n        this._entities[ix] = entity;\r\n      }\r\n      this._indexMap[keyInGroup] = ix;\r\n      aspect.entityState = entityState;\r\n      aspect.entityGroup = this;\r\n      aspect.entityManager = this.entityManager;\r\n      return entity;\r\n    }\r\n  }\r\n\r\n  detachEntity(entity: Entity) {\r\n    // by this point we have already determined that this entity\r\n    // belongs to this group.\r\n    let aspect = entity.entityAspect;\r\n    let keyInGroup = aspect.getKey()._keyInGroup;\r\n    let ix = this._indexMap[keyInGroup];\r\n    if (ix === undefined) {\r\n      // shouldn't happen.\r\n      throw new Error(\"internal error - entity cannot be found in group\");\r\n    }\r\n    delete this._indexMap[keyInGroup];\r\n    this._emptyIndexes.push(ix);\r\n    this._entities[ix] = null;\r\n    return entity;\r\n  }\r\n\r\n\r\n  // returns entity based on an entity key defined either as an array of key values or an EntityKey\r\n  findEntityByKey(entityKey: EntityKey) {\r\n    let keyInGroup: string;\r\n    if (entityKey instanceof EntityKey) {\r\n      keyInGroup = entityKey._keyInGroup;\r\n    } else {\r\n      keyInGroup = EntityKey.createKeyString(entityKey);\r\n    }\r\n    let ix = this._indexMap[keyInGroup];\r\n    // can't use just (ix) below because 0 is valid\r\n    let r = (ix !== undefined) ? this._entities[ix] : undefined;\r\n    // coerce null to undefined\r\n    return r == null ? undefined : r;\r\n  }\r\n\r\n  hasChanges() {\r\n    let entities = this._entities;\r\n    let unchanged = EntityState.Unchanged;\r\n    for (let i = 0, len = entities.length; i < len; i++) {\r\n      let e = entities[i];\r\n      if (e && e.entityAspect.entityState !== unchanged) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  getChanges() {\r\n    let entities = this._entities;\r\n    let unchanged = EntityState.Unchanged;\r\n    let changes: Entity[] = [];\r\n    for (let i = 0, len = entities.length; i < len; i++) {\r\n      let e = entities[i];\r\n      if (e && e.entityAspect.entityState !== unchanged) {\r\n        changes.push(e);\r\n      }\r\n    }\r\n    return changes;\r\n  }\r\n\r\n  getEntities(entityStates: EntityState[]) {\r\n    let filter = getFilter(entityStates);\r\n    return this._entities.filter(filter) as Entity[];\r\n  }\r\n\r\n  _checkOperation(operationName: string) {\r\n    this._entities.forEach(function (entity) {\r\n      entity && entity.entityAspect._checkOperation(operationName);\r\n    });\r\n    // for chaining;\r\n    return this;\r\n  }\r\n\r\n  // do not expose this method. It is doing a special purpose INCOMPLETE fast detach operation\r\n  // just for the entityManager clear method - the entityGroup will be in an inconsistent state\r\n  // after this op, which is ok because it will be thrown away.\r\n  // TODO: rename this to be clear that it is UNSAFE...\r\n  _clear() {\r\n    this._entities.forEach(function (entity) {\r\n      if (entity != null) {\r\n        entity.entityAspect._detach();\r\n      }\r\n    });\r\n    (this as any)._entities = null;\r\n    (this as any)._indexMap = null;\r\n    (this as any)._emptyIndexes = null;\r\n  }\r\n\r\n  _updateFkVal(fkProp: DataProperty, oldValue: any, newValue: any) {\r\n    let fkPropName = fkProp.name;\r\n    this._entities.forEach(function (entity) {\r\n      if (entity != null) {\r\n        if (entity.getProperty(fkPropName) === oldValue) {\r\n          entity.setProperty(fkPropName, newValue);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  _fixupKey(tempValue: any, realValue: any) {\r\n    // single part keys appear directly in map\r\n    let ix = this._indexMap[tempValue];\r\n    if (ix === undefined) {\r\n      throw new Error(\"Internal Error in key fixup - unable to locate entity\");\r\n    }\r\n    let entity = this._entities[ix] as Entity;\r\n    let keyPropName = entity.entityType.keyProperties[0].name;\r\n    // fks on related entities will automatically get updated by this as well\r\n    entity.setProperty(keyPropName, realValue);\r\n    delete entity.entityAspect.hasTempKey;\r\n    delete this._indexMap[tempValue];\r\n    this._indexMap[realValue] = ix;\r\n  }\r\n\r\n  _replaceKey(oldKey: EntityKey, newKey: EntityKey) {\r\n    let ix = this._indexMap[oldKey._keyInGroup];\r\n    delete this._indexMap[oldKey._keyInGroup];\r\n    this._indexMap[newKey._keyInGroup] = ix;\r\n  }\r\n\r\n}\r\n\r\nfunction getFilter(entityStates: EntityState[]) {\r\n  if (entityStates.length === 0) {\r\n    return function (e: Entity) {\r\n      return !!e;\r\n    };\r\n  } else if (entityStates.length === 1) {\r\n    let entityState = entityStates[0];\r\n    return function (e: Entity) {\r\n      return !!e && e.entityAspect.entityState === entityState;\r\n    };\r\n  } else {\r\n    return function (e: Entity) {\r\n      return !!e && -1 !== entityStates.indexOf(e.entityAspect.entityState);\r\n    };\r\n  }\r\n}\r\n\r\n\r\n// do not expose EntityGroup - internal only\r\n\r\n\r\n","import { DataServiceAdapter } from './interface-registry';\r\nimport { core } from './core';\r\nimport { DataType  } from './data-type';\r\nimport { DataService, JsonResultsAdapter, NodeContext, NodeMeta } from './data-service';\r\nimport { EntityState  } from './entity-state';\r\nimport { EntityAction } from './entity-action';\r\nimport { MetadataStore, EntityType, StructuralType, DataProperty, NavigationProperty } from './entity-metadata';\r\nimport { EntityManager } from './entity-manager';\r\nimport { MergeStrategy } from './query-options';\r\nimport { Entity } from './entity-aspect';\r\nimport { EntityQuery } from './entity-query';\r\n\r\n\r\n/**\r\nFor use by breeze plugin authors only. The class is for use in building a [[IDataServiceAdapter]] implementation. \r\n@adapter (see [[IDataServiceAdapter]])    \r\n@hidden \r\n*/\r\nexport interface MergeOptions {\r\n  mergeStrategy: MergeStrategy;\r\n  includeDeleted?: boolean;\r\n  noTracking?: boolean;\r\n}\r\n\r\n/** @hidden */\r\nexport interface MappingContextConfig {\r\n  dataService: DataService;\r\n  query?: EntityQuery | string;\r\n  entityManager: EntityManager;\r\n  mergeOptions: MergeOptions;\r\n}\r\n\r\n/**\r\nFor use by breeze plugin authors only. The class is for use in building a [[IDataServiceAdapter]] implementation. \r\n@adapter (see [[IDataServiceAdapter]])    \r\n@hidden \r\n*/\r\nexport class MappingContext {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // on prototype\r\n\r\n  rawValueFn = DataProperty.getRawValueFromServer; // think about passing this in later.\r\n\r\n  dataService: DataService;\r\n  query: EntityQuery | string;\r\n  entityManager: EntityManager;\r\n  mergeOptions: MergeOptions;\r\n  adapter: DataServiceAdapter;  // assigned in the AbstractDataServiceAdapter.\r\n\r\n  refMap: Object; // TODO\r\n  deferredFns: Function[]; // TODO\r\n  jsonResultsAdapter: JsonResultsAdapter;\r\n  metadataStore: MetadataStore;\r\n\r\n  constructor(config: MappingContextConfig) {\r\n\r\n    core.extend(this, config, [\r\n      \"query\", \"entityManager\", \"dataService\", \"mergeOptions\"\r\n    ]);\r\n\r\n    // calc'd props\r\n    this.refMap = {};\r\n    this.deferredFns = [];\r\n    this.jsonResultsAdapter = this.dataService.jsonResultsAdapter;\r\n    this.metadataStore = this.entityManager.metadataStore;\r\n    this.rawValueFn = DataProperty.getRawValueFromServer; // think about passing this in later.\r\n  }\r\n\r\n  getUrl() {\r\n    let query = this.query;\r\n    if (!query) {\r\n      throw new Error(\"query cannot be empty\");\r\n    }\r\n    let uriString: string;\r\n    if (typeof query === 'string') {\r\n      uriString = query;\r\n    } else if (query instanceof EntityQuery) {\r\n      uriString = this.dataService.uriBuilder!.buildUri(query, this.metadataStore);\r\n    } else {\r\n      throw new Error(\"unable to recognize query parameter as either a string or an EntityQuery\");\r\n    }\r\n    return this.dataService.qualifyUrl(uriString);\r\n  }\r\n\r\n  visitAndMerge(nodes: any[], nodeContext: any) {\r\n    let query = this.query;\r\n    let jra = this.jsonResultsAdapter;\r\n    nodeContext = nodeContext || {};\r\n    let that = this;\r\n    return core.map(nodes, function (node) {\r\n      if (query == null && node.entityAspect) {\r\n        // don't bother merging a result from a save that was not returned from the server.\r\n        if (node.entityAspect.entityState.isDeleted()) {\r\n          that.entityManager.detachEntity(node);\r\n        } else {\r\n          node.entityAspect.acceptChanges();\r\n        }\r\n        return node;\r\n      }\r\n\r\n      let meta = jra.visitNode(node, that, nodeContext) || {};\r\n      node = meta.node || node;\r\n      if (query && nodeContext.nodeType === \"root\" && !meta.entityType) {\r\n        meta.entityType = query instanceof EntityQuery &&  query._getToEntityType && query._getToEntityType(that.metadataStore);\r\n      }\r\n      return processMeta(that, node, meta);\r\n    }, this.mergeOptions.includeDeleted);\r\n  }\r\n\r\n  processDeferred() {\r\n    if (this.deferredFns.length > 0) {\r\n      this.deferredFns.forEach((fn) => {\r\n        fn();\r\n      });\r\n    }\r\n  }\r\n}\r\nMappingContext.prototype._$typeName = \"MappingContext\";\r\n\r\n\r\nfunction processMeta(mc: MappingContext, node: any, meta: NodeMeta, assignFn?: (val: any) => void) {\r\n  // == is deliberate here instead of ===\r\n  if (meta.ignore || node == null) {\r\n    return null;\r\n  } else if (meta.nodeRefId) {\r\n    let refValue = resolveEntityRef(mc, meta.nodeRefId);\r\n    if (typeof refValue === \"function\" && assignFn != null) {\r\n      mc.deferredFns.push(function () {\r\n        assignFn(refValue);\r\n      });\r\n      return undefined; // deferred and will be set later;\r\n    }\r\n    return refValue;\r\n  } else if (meta.entityType) {\r\n    let entityType = meta.entityType;\r\n    if (mc.mergeOptions.noTracking) {\r\n      node = processNoMerge(mc, entityType, node);\r\n      if (entityType.noTrackingFn) {\r\n        node = entityType.noTrackingFn(node, entityType);\r\n      }\r\n      if (meta.nodeId) {\r\n        mc.refMap[meta.nodeId] = node;\r\n      }\r\n      return node;\r\n    } else {\r\n      if (entityType.isComplexType) {\r\n        // because we still need to do serverName to client name processing\r\n        return processNoMerge(mc, entityType, node);\r\n      } else {\r\n        return mergeEntity(mc, node, meta);\r\n      }\r\n    }\r\n  } else {\r\n\r\n    if ((!meta.passThru) && typeof node === 'object' && ! core.isDate(node)) {\r\n      node = processAnonType(mc, node);\r\n    }\r\n\r\n    // updating the refMap for entities is handled by updateEntityRef for entities.\r\n    if (meta.nodeId) {\r\n      mc.refMap[meta.nodeId] = node;\r\n    }\r\n    return node;\r\n  }\r\n}\r\n\r\nfunction processNoMerge(mc: MappingContext, stype: StructuralType, node: any) {\r\n  let result = {};\r\n\r\n  stype.dataProperties.forEach(function (dp) {\r\n    if (dp.isComplexProperty) {\r\n      result[dp.name] = core.map(node[dp.nameOnServer], (v: any) => {\r\n        return processNoMerge(mc, dp.dataType as any, v);\r\n      });\r\n    } else {\r\n      result[dp.name] = DataType.parseRawValue(node[dp.nameOnServer], dp.dataType as DataType);\r\n    }\r\n  });\r\n\r\n  (stype instanceof EntityType) && stype.navigationProperties.forEach( (np) => {\r\n    let nodeContext = { nodeType: \"navProp\", navigationProperty: np };\r\n    visitNode(node[np.nameOnServer], mc, nodeContext, result, np.name);\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nfunction processAnonType(mc: MappingContext, node: any) {\r\n  // node is guaranteed to be an object by this point, i.e. not a scalar\r\n  let keyFn = mc.metadataStore.namingConvention.serverPropertyNameToClient;\r\n  let result = {};\r\n\r\n  core.objectForEach(node, function (key, value) {\r\n    let newKey = keyFn(key);\r\n    let nodeContext = { nodeType: \"anonProp\", propertyName: newKey };\r\n    visitNode(value, mc, nodeContext, result, newKey);\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction visitNode(node: any, mc: MappingContext, nodeContext: NodeContext, result: Object, key: string) {\r\n  let jra = mc.jsonResultsAdapter;\r\n  let meta = jra.visitNode(node, mc, nodeContext) || {};\r\n  // allows visitNode to change the value;\r\n  node = meta.node || node;\r\n\r\n  if (meta.ignore) return;\r\n  if (meta.passThru) return node;\r\n  if (Array.isArray(node)) {\r\n    nodeContext.nodeType = nodeContext.nodeType + \"Item\";\r\n    result[key] = node.map(function (v, ix) {\r\n      meta = jra.visitNode(v, mc, nodeContext) || {};\r\n      v = meta.node || v;\r\n      return processMeta(mc, v, meta, function (refValue) {\r\n        result[key][ix] = refValue();\r\n      });\r\n    });\r\n  } else {\r\n    result[key] = processMeta(mc, node, meta, function (refValue) {\r\n      result[key] = refValue();\r\n    });\r\n  }\r\n}\r\n\r\nfunction resolveEntityRef(mc: MappingContext, nodeRefId: string) {\r\n  let entity = mc.refMap[nodeRefId];\r\n  if (entity === undefined) {\r\n    return function () {\r\n      return mc.refMap[nodeRefId];\r\n    };\r\n  } else {\r\n    return entity;\r\n  }\r\n}\r\n\r\nfunction updateEntityRef(mc: MappingContext, targetEntity: any, node: any) {\r\n  let nodeId = node._$meta.nodeId;\r\n  if (!nodeId && node._$meta.extraMetadata) {\r\n    // odata case.  refMap isn't really used, but is returned as data.retrievedEntities, so we populated it anyway.\r\n    nodeId = node._$meta.extraMetadata.uriKey;\r\n  }\r\n  if (nodeId != null) {\r\n    mc.refMap[nodeId] = targetEntity;\r\n  }\r\n}\r\n\r\n// can return null for a deleted entity if includeDeleted == false\r\nfunction mergeEntity(mc: MappingContext, node: any, meta: NodeMeta) {\r\n  node._$meta = meta;\r\n  let em = mc.entityManager;\r\n\r\n  let entityType = meta.entityType as EntityType;\r\n  if (typeof (entityType) === 'string') {\r\n    entityType = mc.metadataStore._getStructuralType(entityType, false) as EntityType;\r\n  }\r\n  node.entityType = entityType;\r\n\r\n  let mergeStrategy = mc.mergeOptions.mergeStrategy;\r\n  let isSaving = mc.query == null;\r\n\r\n  let entityKey = entityType.getEntityKeyFromRawEntity(node, mc.rawValueFn);\r\n  let targetEntity = em.findEntityByKey(entityKey);\r\n  if (targetEntity) {\r\n    if (isSaving && targetEntity.entityAspect.entityState.isDeleted()) {\r\n      em.detachEntity(targetEntity);\r\n      return targetEntity;\r\n    }\r\n    let targetEntityState = targetEntity.entityAspect.entityState;\r\n    if (mergeStrategy === MergeStrategy.Disallowed) {\r\n      throw new Error(\"A MergeStrategy of 'Disallowed' prevents \" + entityKey.toString() + \" from being merged\");\r\n    } else if (mergeStrategy === MergeStrategy.SkipMerge) {\r\n      updateEntityNoMerge(mc, targetEntity, node);\r\n    } else {\r\n      if (mergeStrategy === MergeStrategy.OverwriteChanges\r\n        || targetEntityState.isUnchanged()) {\r\n        updateEntity(mc, targetEntity, node);\r\n        targetEntity.entityAspect.wasLoaded = true;\r\n        if (meta.extraMetadata) {\r\n          targetEntity.entityAspect.extraMetadata = meta.extraMetadata;\r\n        }\r\n        targetEntity.entityAspect.entityState = EntityState.Unchanged;\r\n        clearOriginalValues(targetEntity);\r\n        // propertyName not specified because multiple props EntityChangedEventArgs\r\n        targetEntity.entityAspect.propertyChanged.publish({ entity: targetEntity, propertyName: null });\r\n        let action = isSaving ? EntityAction.MergeOnSave : EntityAction.MergeOnQuery;\r\n        em.entityChanged.publish({ entityAction: action, entity: targetEntity });\r\n        // this is needed to handle an overwrite of a modified entity with an unchanged entity\r\n        // which might in turn cause _hasChanges to change.\r\n        if (!targetEntityState.isUnchanged()) {\r\n          em._notifyStateChange(targetEntity, false);\r\n        }\r\n      } else {\r\n        if (targetEntityState === EntityState.Deleted && !mc.mergeOptions.includeDeleted) {\r\n          return null;\r\n        }\r\n        updateEntityNoMerge(mc, targetEntity, node);\r\n      }\r\n    }\r\n  } else {\r\n    targetEntity = entityType._createInstanceCore() as Entity;\r\n\r\n    updateEntity(mc, targetEntity, node);\r\n\r\n    if (meta.extraMetadata) {\r\n      targetEntity.entityAspect.extraMetadata = meta.extraMetadata;\r\n    }\r\n    // em._attachEntityCore(targetEntity, EntityState.Unchanged, MergeStrategy.Disallowed);\r\n    em._attachEntityCore(targetEntity, EntityState.Unchanged, mergeStrategy);\r\n    targetEntity.entityAspect.wasLoaded = true;\r\n    em.entityChanged.publish({ entityAction: EntityAction.AttachOnQuery, entity: targetEntity });\r\n  }\r\n  return targetEntity;\r\n}\r\n\r\n// copied from entityAspect\r\nfunction clearOriginalValues(target: any) {\r\n  let aspect = target.entityAspect || target.complexAspect;\r\n  aspect.originalValues = {};\r\n  let stype = target.entityType || target.complexType;\r\n  stype.complexProperties.forEach(function (cp: any) {\r\n    let cos = target.getProperty(cp.name);\r\n    if (cp.isScalar) {\r\n      clearOriginalValues(cos);\r\n    } else {\r\n      cos._acceptChanges();\r\n      cos.forEach(clearOriginalValues);\r\n    }\r\n  });\r\n}\r\n\r\n\r\nfunction updateEntityNoMerge(mc: MappingContext, targetEntity: Entity, node: any) {\r\n  updateEntityRef(mc, targetEntity, node);\r\n  // we still need to merge related entities even if top level entity wasn't modified.\r\n  node.entityType.navigationProperties.forEach(function (np: NavigationProperty) {\r\n    if (np.isScalar) {\r\n      mergeRelatedEntityCore(mc, node, np);\r\n    } else {\r\n      mergeRelatedEntitiesCore(mc, node, np);\r\n    }\r\n  });\r\n}\r\n\r\nfunction updateEntity(mc: MappingContext, targetEntity: Entity, node: any) {\r\n  updateEntityRef(mc, targetEntity, node);\r\n  let entityType = targetEntity.entityType;\r\n  entityType._updateTargetFromRaw(targetEntity, node, mc.rawValueFn);\r\n\r\n  entityType.navigationProperties.forEach(function (np) {\r\n    if (np.isScalar) {\r\n      mergeRelatedEntity(mc, np, targetEntity, node);\r\n    } else {\r\n      mergeRelatedEntities(mc, np, targetEntity, node);\r\n    }\r\n  });\r\n}\r\n\r\nfunction mergeRelatedEntity(mc: MappingContext, navigationProperty: NavigationProperty, targetEntity: Entity, rawEntity: any) {\r\n\r\n  let relatedEntity = mergeRelatedEntityCore(mc, rawEntity, navigationProperty);\r\n  if (relatedEntity == null) return;\r\n  if (typeof relatedEntity === 'function') {\r\n    mc.deferredFns.push(function () {\r\n      relatedEntity = relatedEntity();\r\n      updateRelatedEntity(relatedEntity, targetEntity, navigationProperty);\r\n    });\r\n  } else {\r\n    updateRelatedEntity(relatedEntity, targetEntity, navigationProperty);\r\n  }\r\n}\r\n\r\nfunction mergeRelatedEntities(mc: MappingContext, navigationProperty: NavigationProperty, targetEntity: Entity, rawEntity: any) {\r\n  let relatedEntities = mergeRelatedEntitiesCore(mc, rawEntity, navigationProperty);\r\n  if (relatedEntities == null) return;\r\n\r\n  let inverseProperty = navigationProperty.inverse;\r\n  if (!inverseProperty) return;\r\n\r\n  let originalRelatedEntities = targetEntity.getProperty(navigationProperty.name);\r\n  originalRelatedEntities.wasLoaded = true;\r\n\r\n  relatedEntities.forEach(function (relatedEntity: any) {\r\n    if (typeof relatedEntity === 'function') {\r\n      mc.deferredFns.push(function () {\r\n        relatedEntity = relatedEntity();\r\n        updateRelatedEntityInCollection(mc, relatedEntity, originalRelatedEntities, targetEntity, inverseProperty as NavigationProperty);\r\n      });\r\n    } else {\r\n      updateRelatedEntityInCollection(mc, relatedEntity, originalRelatedEntities, targetEntity, inverseProperty as NavigationProperty);\r\n    }\r\n  });\r\n}\r\n\r\nfunction mergeRelatedEntityCore(mc: MappingContext, rawEntity: any, navigationProperty: NavigationProperty) {\r\n  let relatedRawEntity = rawEntity[navigationProperty.nameOnServer];\r\n  if (!relatedRawEntity) return null;\r\n\r\n  let relatedEntity = mc.visitAndMerge(relatedRawEntity, { nodeType: \"navProp\", navigationProperty: navigationProperty });\r\n  return relatedEntity;\r\n}\r\n\r\nfunction mergeRelatedEntitiesCore(mc: MappingContext, rawEntity: any, navigationProperty: NavigationProperty) {\r\n  let relatedRawEntities = rawEntity[navigationProperty.nameOnServer];\r\n  if (!relatedRawEntities) return null;\r\n\r\n  // needed if what is returned is not an array and we expect one - this happens with __deferred in OData.\r\n  if (!Array.isArray(relatedRawEntities)) {\r\n    // return null;\r\n    relatedRawEntities = relatedRawEntities.results; // OData v3 will look like this with an expand\r\n    if (!relatedRawEntities) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let relatedEntities = mc.visitAndMerge(relatedRawEntities, { nodeType: \"navPropItem\", navigationProperty: navigationProperty });\r\n  return relatedEntities;\r\n}\r\n\r\nfunction updateRelatedEntity(relatedEntity: Entity, targetEntity: Entity, navigationProperty: NavigationProperty) {\r\n  if (!relatedEntity) return;\r\n  let propName = navigationProperty.name;\r\n  let currentRelatedEntity = targetEntity.getProperty(propName);\r\n\r\n  // check if the related entity is already hooked up\r\n  if (currentRelatedEntity !== relatedEntity) {\r\n    // if not hook up both directions.\r\n    targetEntity.setProperty(propName, relatedEntity);\r\n    let inverseProperty = navigationProperty.inverse;\r\n    if (!inverseProperty) return;\r\n    if (inverseProperty.isScalar) {\r\n      relatedEntity.setProperty(inverseProperty.name, targetEntity);\r\n    } else {\r\n      let collection = relatedEntity.getProperty(inverseProperty.name);\r\n      collection.push(targetEntity);\r\n\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateRelatedEntityInCollection(mc: MappingContext, relatedEntity: Entity | undefined,\r\n    relatedEntities: Entity[], targetEntity: Entity, inverseProperty: NavigationProperty) {\r\n  if (!relatedEntity) return;\r\n\r\n  // don't update relatedCollection if preserveChanges & relatedEntity has an fkChange.\r\n  if (relatedEntity.entityAspect.entityState === EntityState.Modified\r\n    && mc.mergeOptions.mergeStrategy === MergeStrategy.PreserveChanges) {\r\n    let origValues = relatedEntity.entityAspect.originalValues;\r\n    let fkWasModified = inverseProperty.relatedDataProperties.some(function (dp) {\r\n      return origValues[dp.name] != undefined;\r\n    });\r\n    if (fkWasModified) return;\r\n  }\r\n  // check if the related entity is already hooked up\r\n  let thisEntity = relatedEntity.getProperty(inverseProperty.name);\r\n\r\n  if (thisEntity !== targetEntity) {\r\n    // if not - hook it up.\r\n    relatedEntities.push(relatedEntity);\r\n    relatedEntity.setProperty(inverseProperty.name, targetEntity);\r\n  }\r\n}\r\n\r\n\r\n","import { core } from './core';\r\nimport { Entity } from './entity-aspect';\r\nimport { NavigationProperty } from './entity-metadata';\r\nimport { EntityKey } from './entity-key';\r\n\r\n/** @hidden @internal */\r\nexport interface INavTuple {\r\n  navigationProperty: NavigationProperty;\r\n  children: Entity[];\r\n}\r\n\r\n/** @hidden @internal */\r\n// Represents entities not yet attached to navigationProperties. \r\nexport class UnattachedChildrenMap {\r\n  // key is EntityKey.toString(), value is array of { navigationProperty, children }\r\n  map: { [index: string]: INavTuple[] } = {};\r\n\r\n\r\n  addChild(parentEntityKey: EntityKey, navigationProperty: NavigationProperty, child: Entity) {\r\n    let tuple = this.getTuple(parentEntityKey, navigationProperty);\r\n    if (!tuple) {\r\n      tuple = { navigationProperty: navigationProperty, children: [] };\r\n      core.getArray(this.map, parentEntityKey.toString()).push(tuple);\r\n    }\r\n    tuple.children.push(child);\r\n  }\r\n\r\n  removeChildren(parentEntityKeyString: string, navigationProperty: NavigationProperty) {\r\n    let tuples = this.map[parentEntityKeyString];\r\n    if (!tuples) return;\r\n    core.arrayRemoveItem(tuples, (t: any) => {\r\n      return t.navigationProperty === navigationProperty;\r\n    });\r\n    if (!tuples.length) {\r\n      delete this.map[parentEntityKeyString];\r\n    }\r\n  }\r\n\r\n  getTuple(parentEntityKey: EntityKey, navigationProperty: NavigationProperty) {\r\n    let tuples = this.getTuples(parentEntityKey);\r\n    if (!tuples) return null;\r\n    let tuple = core.arrayFirst(tuples, function (t) {\r\n      return t.navigationProperty === navigationProperty;\r\n    });\r\n    return tuple;\r\n  }\r\n\r\n  getTuples(parentEntityKey: EntityKey) {\r\n    let allTuples: INavTuple[] = [];\r\n    let tuples = this.map[parentEntityKey.toString()];\r\n    if (tuples) {\r\n      allTuples = allTuples.concat(tuples);\r\n    }\r\n    let entityType = parentEntityKey.entityType;\r\n    while (entityType.baseEntityType) {\r\n      entityType = entityType.baseEntityType;\r\n      let baseKey = parentEntityKey.toString(entityType);\r\n      tuples = this.map[baseKey];\r\n      if (tuples) {\r\n        allTuples = allTuples.concat(tuples);\r\n      }\r\n    }\r\n    return (allTuples.length) ? allTuples : undefined;\r\n  }\r\n\r\n  getTuplesByString(parentEntityKeyString: string) {\r\n    return this.map[parentEntityKeyString];\r\n  }\r\n\r\n}\r\n","import { DataServiceAdapter } from './interface-registry';\r\nimport { core, Callback, ErrorCallback } from './core';\r\nimport { assertParam, assertConfig } from './assert-param';\r\nimport { config } from './config';\r\nimport { BreezeEvent } from './event';\r\nimport { EntityAspect, Entity, ComplexObject, StructuralObject, PropertyChangedEventArgs } from './entity-aspect';\r\nimport { MetadataStore, EntityType, ComplexType, DataProperty, NavigationProperty, AutoGeneratedKeyType } from './entity-metadata';\r\nimport { EntityKey } from './entity-key';\r\nimport { EntityAction  } from './entity-action';\r\nimport { EntityState } from './entity-state';\r\nimport { DataService } from './data-service';\r\nimport { DataType } from './data-type';\r\nimport { ValidationError } from './validate';\r\nimport { ValidationOptions } from './validation-options';\r\nimport { QueryOptions, MergeStrategy, FetchStrategy } from './query-options';\r\nimport { SaveOptions } from './save-options';\r\nimport { KeyGenerator } from './key-generator';\r\nimport { EntityGroup } from './entity-group';\r\nimport { MappingContext } from './mapping-context';\r\nimport { EntityQuery } from './entity-query';\r\nimport { UnattachedChildrenMap } from './unattached-children-map';\r\n\r\nexport interface HttpResponse {\r\n  config: any;\r\n  data: any;\r\n  error?: any;\r\n  saveContext?: any;\r\n  status: number;\r\n  getHeaders(headerName: string): string;\r\n}\r\n\r\nexport interface ImportResult {\r\n  entities: Entity[];\r\n  tempKeyMapping: ITempKeyMap;\r\n}\r\n\r\n// subclasses of Error\r\n\r\n/** Base shape of any errors returned from the server. */\r\nexport interface ServerError extends Error {\r\n  httpResponse: HttpResponse;\r\n  status: number;\r\n  message: string;\r\n  statusText?: string;\r\n  body?: any;\r\n  url?: string;\r\n}\r\n\r\n/** Shape of a save error returned from the server. \r\nFor use by breeze plugin authors only. The class is for use in building a [[IDataServiceAdapter]] implementation. \r\n@adapter (see [[IDataServiceAdapter]])    \r\n@hidden @internal \r\n*/\r\nexport interface SaveErrorFromServer extends ServerError {\r\n  entityErrors: EntityErrorFromServer[];\r\n}\r\n\r\n/** Shape of a save error when returned to the client. */\r\nexport interface SaveError extends ServerError {\r\n  entityErrors: EntityError[];\r\n}\r\n\r\n// not subclasses of Error\r\n/** \r\nFor use by breeze plugin authors only. The class is for use in building a [[IDataServiceAdapter]] implementation. \r\n@adapter (see [[IDataServiceAdapter]])    \r\n@hidden @internal \r\n*/\r\nexport interface EntityErrorFromServer {\r\n  entityTypeName: string;\r\n  keyValues: any[];\r\n\r\n  errorName: string;\r\n  errorMessage: string;\r\n  propertyName: string;\r\n}\r\n\r\n/** Shape of an error on a specific entity.  Part of a [[ISaveError]] */\r\nexport interface EntityError {\r\n  entity: Entity;\r\n  errorName: string;\r\n  errorMessage: string;\r\n  propertyName: string;\r\n  isServerError: boolean;\r\n}\r\n\r\n/** The shape of the Promise returned by an [[EntityManager.executeQuery]] call. */\r\nexport interface QueryResult {\r\n  /** Top level entities returned */\r\n  results: any[];\r\n  /** Query that was executed */\r\n  query: EntityQuery | string;\r\n  /** EntityManager that executed the query */\r\n  entityManager?: EntityManager;\r\n  /** Total number of results available on the server */\r\n  inlineCount?: number;\r\n  /** All entities returned by the query.  Differs from results when an expand is used. */\r\n  retrievedEntities?: Entity[];\r\n    /** Raw response from the server */\r\n  httpResponse?: HttpResponse;\r\n}\r\n\r\nexport interface QuerySuccessCallback {\r\n  (data: QueryResult): void;\r\n}\r\n\r\nexport interface QueryErrorCallback {\r\n  (error: { query: EntityQuery; httpResponse: HttpResponse; entityManager: EntityManager; message?: string; stack?: string }): void;\r\n}\r\n\r\n/** Key mapping information returned as part of an [[ISaveResult]]. */\r\nexport interface KeyMapping {\r\n  entityTypeName: string;\r\n  tempValue: any;\r\n  realValue: any;\r\n}\r\n\r\ninterface ITempKeyMap {\r\n  [index: string]: EntityKey;\r\n}\r\n\r\n/** Configuration info to be passed to the [[EntityManager.importEntities]] method */\r\nexport interface ImportConfig {\r\n  /** If true, merge Added entities (with temp keys) as well.  This can be dangerous. */\r\n  mergeAdds?: boolean;\r\n  mergeStrategy?: MergeStrategy;  \r\n  metadataVersionFn?: (arg: { metadataVersion: any, metadataStoreName: any }) => void;\r\n}\r\n\r\ninterface ImportConfigExt extends ImportConfig {\r\n  tempKeyMap?: ITempKeyMap;\r\n}\r\n\r\n/** The shape of the Promise returned by an [[EntityManager.saveChanges]] call. */\r\nexport interface SaveResult {\r\n  entities: Entity[];\r\n  keyMappings: KeyMapping[];\r\n  deletedKeys?: { entityTypeName: string, keyValues: any[]}[];\r\n  httpResponse?: HttpResponse;\r\n}\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IDataServiceAdapter]] implementation. \r\n@adapter (see [[IDataServiceAdapter]])    \r\n@hidden \r\n*/\r\nexport interface SaveContext {\r\n  entityManager: EntityManager;\r\n  dataService: DataService;\r\n  processSavedEntities: (saveResult: SaveResult) => Entity[];\r\n  resourceName: string;\r\n  adapter?: DataServiceAdapter;\r\n  routePrefix?: string;\r\n}\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IDataServiceAdapter]] implementation. \r\n@adapter (see [[IDataServiceAdapter]])    \r\n@hidden \r\n*/\r\nexport interface SaveBundle {\r\n  entities: Entity[];\r\n  saveOptions: SaveOptions;\r\n}\r\n\r\n/** Configuration info to be passed to the [[EntityManager]] constructor */\r\nexport interface EntityManagerConfig {\r\n  /** The service name associated with this EntityManager.  **/\r\n  serviceName?: string;\r\n  /** The DataService associated with this EntityManager. **/\r\n  dataService?: DataService;\r\n  /** The [[QueryOptions]] associated with this EntityManager.  **/\r\n  queryOptions?: QueryOptions;\r\n  /** The [[SaveOptions]] associated with this EntityManager. **/\r\n  saveOptions?: SaveOptions;\r\n  /** The [[ValidationOptions]] associated with this EntityManager.  **/\r\n  validationOptions?: ValidationOptions;\r\n  /** The [[KeyGenerator]] associated with this EntityManager. **/\r\n  keyGenerator?: KeyGenerator;\r\n  /** The [[KeyGenerator]] constructor associated with this EntityManager. **/\r\n  keyGeneratorCtor?: { new (): KeyGenerator }; // TODO: review this\r\n  /** The [[MetadataStore]] associated with this EntityManager. **/\r\n  metadataStore?: MetadataStore;\r\n}\r\n\r\n/** The shape returned by callbacks registered with [[EntityManager.entityChanged]] event */\r\nexport interface EntityChangedEventArgs {\r\n  entityAction: EntityAction;\r\n  entity?: Entity;\r\n  args?: PropertyChangedEventArgs;\r\n}\r\n\r\nexport interface ValidationErrorsChangedEventArgs {\r\n  entity: Entity; \r\n  added: ValidationError[]; \r\n  removed: ValidationError[];\r\n}\r\n\r\nexport interface HasChangesChangedEventArgs {\r\n  entityManager: EntityManager; \r\n  hasChanges: boolean;\r\n}\r\n\r\n/**\r\nInstances of the EntityManager contain and manage collections of entities, either retrieved from a backend datastore or created on the client.\r\n**/\r\nexport class EntityManager {\r\n  /** @hidden @internal */\r\n  _$typeName: string; // actually defined on prototype\r\n\r\n  /** The service name associated with this EntityManager. __Read Only__ **/\r\n  serviceName: string;\r\n  /** The DataService associated with this EntityManager. __Read Only__ **/\r\n  dataService: DataService;\r\n  /** The [[QueryOptions]] associated with this EntityManager. __Read Only__ **/\r\n  queryOptions: QueryOptions;\r\n  /** The [[SaveOptions]] associated with this EntityManager. __Read Only__ **/\r\n  saveOptions: SaveOptions;\r\n  /** The [[ValidationOptions]] associated with this EntityManager. __Read Only__ **/\r\n  validationOptions: ValidationOptions;\r\n  /** The [[KeyGenerator]] associated with this EntityManager. __Read Only__ **/\r\n  keyGenerator: KeyGenerator;\r\n  /** The [[KeyGenerator]] constructor associated with this EntityManager. __Read Only__ **/\r\n  keyGeneratorCtor: { new (): KeyGenerator }; // TODO: review this\r\n  /** The [[MetadataStore]] associated with this EntityManager. __Read Only__ **/\r\n  metadataStore: MetadataStore;\r\n  isLoading: boolean;\r\n  isRejectingChanges: boolean;\r\n\r\n  // events\r\n  /**\r\n  A [[BreezeEvent]] that fires whenever a change to any entity in this EntityManager occurs. __Read Only__\r\n\r\n  @eventArgs - \r\n  - entityAction - The [[EntityAction]] that occured.\r\n  - entity - The entity that changed.  If this is null, then all entities in the entityManager were affected.\r\n  - args - Additional information about this event. This will differ based on the entityAction.\r\n\r\n  >      let em = new EntityManager( {serviceName: \"breeze/NorthwindIBModel\" });\r\n  >      em.entityChanged.subscribe(function(changeArgs) {\r\n  >          // This code will be executed any time any entity within the entityManager \r\n  >          // is added, modified, deleted or detached for any reason.\r\n  >          let action = changeArgs.entityAction;\r\n  >          let entity = changeArgs.entity;\r\n  >          // .. do something to this entity when it is changed.\r\n  >      });\r\n  >  });\r\n  @event\r\n  **/\r\n  entityChanged: BreezeEvent<EntityChangedEventArgs>;\r\n\r\n  /**\r\n  An [[BreezeEvent]] that fires whenever validationErrors change for any entity in this EntityManager. __Read Only__\r\n  @eventArgs -\r\n    - entity - The entity on which the validation errors have been added or removed.\r\n    - added - An array containing any newly added [[ValidationError]]s\r\n    - removed - An array containing any newly removed [[ValidationError]]s. This is those errors that have been 'fixed'  \r\n\r\n  >      let em = new EntityManager( {serviceName: \"breeze/NorthwindIBModel\" });\r\n  >      em.validationErrorsChanged.subscribe(function(changeArgs) {\r\n  >              // This code will be executed any time any entity within the entityManager experiences a change to its validationErrors collection.\r\n  >              function (validationChangeArgs) {\r\n  >                  let entity == validationChangeArgs.entity;\r\n  >                  let errorsAdded = validationChangeArgs.added;\r\n  >                  let errorsCleared = validationChangeArgs.removed;\r\n  >                  // ... do something interesting with the order.\r\n  >              });\r\n  >          });\r\n  >      });\r\n  @event\r\n  **/\r\n  validationErrorsChanged: BreezeEvent<ValidationErrorsChangedEventArgs>;\r\n\r\n  /**\r\n  A [[BreezeEvent]] that fires whenever an EntityManager transitions to or from having changes. __Read Only__\r\n  @eventArgs -\r\n    - entityManager - The EntityManager whose 'hasChanges' status has changed.\r\n    - hasChanges - Whether or not this EntityManager has changes.\r\n\r\n  >      let em = new EntityManager( {serviceName: \"breeze/NorthwindIBModel\" });\r\n  >      em.hasChangesChanged.subscribe(function(args) {\r\n  >              let hasChangesChanged = args.hasChanges;\r\n  >              let entityManager = args.entityManager;\r\n  >          });\r\n  >      });\r\n  @event \r\n  **/\r\n  hasChangesChanged: BreezeEvent<HasChangesChangedEventArgs>;\r\n\r\n\r\n  /** @hidden @internal */\r\n  _pendingPubs?: any[]; // TODO: refine later\r\n  /** @hidden @internal */\r\n  _hasChangesAction?: (() => boolean); // TODO refine later\r\n  /** @hidden @internal */\r\n  _hasChanges: boolean;\r\n  /** @hidden @internal */\r\n  _entityGroupMap: { [index: string]: EntityGroup };\r\n  /** @hidden @internal */\r\n  _unattachedChildrenMap: UnattachedChildrenMap;\r\n  /** @hidden @internal */\r\n  _inKeyFixup: boolean;\r\n\r\n  helper = {\r\n    unwrapInstance: unwrapInstance,\r\n    unwrapOriginalValues: unwrapOriginalValues,\r\n    unwrapChangedValues: unwrapChangedValues\r\n  };\r\n\r\n  /**\r\n  EntityManager constructor.\r\n\r\n  At its most basic an EntityManager can be constructed with just a service name\r\n  >     let entityManager = new EntityManager( \"breeze/NorthwindIBModel\");\r\n\r\n  This is the same as calling it with the following configuration object\r\n  >     let entityManager = new EntityManager( {serviceName: \"breeze/NorthwindIBModel\" });\r\n\r\n  Usually however, configuration objects will contain more than just the 'serviceName';\r\n  >     let metadataStore = new MetadataStore();\r\n  >     let entityManager = new EntityManager( {\r\n  >       serviceName: \"breeze/NorthwindIBModel\",\r\n  >       metadataStore: metadataStore\r\n  >     });\r\n\r\n  or\r\n  >     return new QueryOptions({\r\n  >         mergeStrategy: obj,\r\n  >         fetchStrategy: this.fetchStrategy\r\n  >     });\r\n  >     let queryOptions = new QueryOptions({\r\n  >         mergeStrategy: MergeStrategy.OverwriteChanges,\r\n  >         fetchStrategy: FetchStrategy.FromServer\r\n  >     });\r\n  >     let validationOptions = new ValidationOptions({\r\n  >         validateOnAttach: true,\r\n  >         validateOnSave: true,\r\n  >         validateOnQuery: false\r\n  >     });\r\n  >     let entityManager = new EntityManager({\r\n  >         serviceName: \"breeze/NorthwindIBModel\",\r\n  >         queryOptions: queryOptions,\r\n  >         validationOptions: validationOptions\r\n  >     });\r\n  @param emConfig - Configuration settings or a service name.  \r\n  **/\r\n  constructor(emConfig?: EntityManagerConfig | string) {\r\n\r\n    if (arguments.length > 1) {\r\n      throw new Error(\"The EntityManager ctor has a single optional argument that is either a 'serviceName' or a configuration object.\");\r\n    }\r\n    let config: EntityManagerConfig;\r\n    if (arguments.length === 0) {\r\n      config = { serviceName: \"\" };\r\n    } else if (typeof emConfig === 'string') {\r\n      config = { serviceName: emConfig };\r\n    } else {\r\n      config = emConfig || {};\r\n    }\r\n\r\n    EntityManager._updateWithConfig(this, config, true);\r\n\r\n    this.entityChanged = new BreezeEvent(\"entityChanged\", this);\r\n    this.validationErrorsChanged = new BreezeEvent(\"validationErrorsChanged\", this);\r\n    this.hasChangesChanged = new BreezeEvent(\"hasChangesChanged\", this);\r\n\r\n    this.clear();\r\n\r\n  }\r\n\r\n  /**\r\n  General purpose property set method.  Any of the properties in the [[EntityManagerConfig]]\r\n  may be set.\r\n  >      // assume em1 is a previously created EntityManager\r\n  >      // where we want to change some of its settings.\r\n  >      em1.setProperties( {\r\n  >          serviceName: \"breeze/foo\"\r\n  >      });\r\n  @param config - An object containing the selected properties and values to set.\r\n  **/\r\n  setProperties(config: EntityManagerConfig) {\r\n    EntityManager._updateWithConfig(this, config, false);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  static _updateWithConfig(em: EntityManager, config: EntityManagerConfig, isCtor: boolean) {\r\n    let defaultQueryOptions = isCtor ? QueryOptions.defaultInstance : em.queryOptions;\r\n    let defaultSaveOptions = isCtor ? SaveOptions.defaultInstance : em.saveOptions;\r\n    let defaultValidationOptions = isCtor ? ValidationOptions.defaultInstance : em.validationOptions;\r\n\r\n    let configParam = assertConfig(config)\r\n      .whereParam(\"serviceName\").isOptional().isString()\r\n      .whereParam(\"dataService\").isOptional().isInstanceOf(DataService)\r\n      .whereParam(\"queryOptions\").isInstanceOf(QueryOptions).isOptional().withDefault(defaultQueryOptions)\r\n      .whereParam(\"saveOptions\").isInstanceOf(SaveOptions).isOptional().withDefault(defaultSaveOptions)\r\n      .whereParam(\"validationOptions\").isInstanceOf(ValidationOptions).isOptional().withDefault(defaultValidationOptions)\r\n      .whereParam(\"keyGeneratorCtor\").isFunction().isOptional();\r\n    if (isCtor) {\r\n      configParam = configParam\r\n        .whereParam(\"metadataStore\").isInstanceOf(MetadataStore).isOptional().withDefault(new MetadataStore());\r\n    }\r\n    configParam.applyAll(em);\r\n\r\n    // insure that entityManager's options versions are completely populated\r\n    core.updateWithDefaults(em.queryOptions, defaultQueryOptions);\r\n    core.updateWithDefaults(em.saveOptions, defaultSaveOptions);\r\n    core.updateWithDefaults(em.validationOptions, defaultValidationOptions);\r\n\r\n    if (config.serviceName) {\r\n      em.dataService = new DataService({\r\n        serviceName: em.serviceName\r\n      });\r\n    }\r\n    em.serviceName = em.dataService && em.dataService.serviceName;\r\n\r\n    em.keyGeneratorCtor = em.keyGeneratorCtor || KeyGenerator;\r\n    if (isCtor || config.keyGeneratorCtor) {\r\n      em.keyGenerator = new em.keyGeneratorCtor();\r\n    }\r\n  }\r\n\r\n  createEntity(typeName: string, initialValues?: Object, entityState?: EntityState, mergeStrategy?: MergeStrategy): Entity;\r\n  createEntity(entityType: EntityType, initialValues?: Object, entityState?: EntityState, mergeStrategy?: MergeStrategy): Entity;\r\n  /**\r\n  Creates a new entity of a specified type and optionally initializes it. By default the new entity is created with an EntityState of Added\r\n  but you can also optionally specify an EntityState.  An EntityState of 'Detached' will insure that the entity is created but not yet added\r\n  to the EntityManager. \r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      // create and add an entity;\r\n  >      let emp1 = em1.createEntity(\"Employee\");\r\n  >      // create and add an initialized entity;\r\n  >      let emp2 = em1.createEntity(\"Employee\", { lastName: \"Smith\", firstName: \"John\" });\r\n  >      // create and attach (not add) an initialized entity\r\n  >      let emp3 = em1.createEntity(\"Employee\", { id: 435, lastName: \"Smith\", firstName: \"John\" }, EntityState.Unchanged);\r\n  >      // create but don't attach an entity;\r\n  >      let emp4 = em1.createEntity(\"Employee\", { id: 435, lastName: \"Smith\", firstName: \"John\" }, EntityState.Detached);\r\n  @param typeName - The name of the EntityType for which an instance should be created.\r\n  @param entityType - The EntityType of the type for which an instance should be created.\r\n  @param initialValues - (default=null) Configuration object of the properties to set immediately after creation.\r\n  @param entityState - (default = [[EntityState.Added]]) The EntityState of the entity after being created and added to this EntityManager.\r\n  @param mergeStrategy - (default = [[MergeStrategy.Disallowed]]) - How to handle conflicts if an entity with the same key already exists within this EntityManager.\r\n  @return {Entity} A new Entity of the specified type. \r\n  */\r\n  createEntity(entityType: EntityType | string, initialValues: Object, entityState: EntityState, mergeStrategy: MergeStrategy) {\r\n    assertParam(entityType, \"entityType\").isString().or().isInstanceOf(EntityType).check();\r\n    assertParam(entityState, \"entityState\").isEnumOf(EntityState).isOptional().check();\r\n    assertParam(mergeStrategy, \"mergeStrategy\").isEnumOf(MergeStrategy).isOptional().check();\r\n\r\n    let et = (typeof entityType === \"string\") ? this.metadataStore._getStructuralType(entityType) as EntityType : entityType;\r\n    entityState = entityState || EntityState.Added;\r\n    let entity = {} as Entity;\r\n    core.using(this, \"isLoading\", true, function () {\r\n      entity = et.createEntity(initialValues);\r\n    });\r\n    if (entityState !== EntityState.Detached) {\r\n      entity = this.attachEntity(entity, entityState, mergeStrategy);\r\n    }\r\n    return entity;\r\n  }\r\n\r\n  static importEntities(exportedString: string, config?: ImportConfig): EntityManager;\r\n  static importEntities(exportedData: Object, config?: ImportConfig): EntityManager;\r\n  /**\r\n  Creates a new EntityManager and imports a previously exported result into it.\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let bundle = em1.exportEntities();\r\n  >      // can be stored via the web storage api\r\n  >      window.localStorage.setItem(\"myEntityManager\", bundle);\r\n  >      // assume the code below occurs in a different session.\r\n  >      let bundleFromStorage = window.localStorage.getItem(\"myEntityManager\");\r\n  >      // and imported\r\n  >      let em2 = EntityManager.importEntities(bundleFromStorage);\r\n  >      // em2 will now have a complete copy of what was in em1\r\n  @param exportedString - The result of a previous 'exportEntities' call as a string\r\n  @param exportedData - The result of a previous 'exportEntities' call as an Object.\r\n  @param config - A configuration object.\r\n  @param config.mergeStrategy - A  [[MergeStrategy]] to use when \r\n  merging into an existing EntityManager.\r\n  @param config.metadataVersionFn - A function that takes two arguments (the current metadataVersion and the imported store's 'name')\r\n  and may be used to perform version checking.\r\n  @return A new EntityManager.  Note that the return value of this method call is different from that\r\n  provided by the same named method on an EntityManager instance. Use that method if you need additional information\r\n  regarding the imported entities.\r\n  **/\r\n  static importEntities(exported: string | Object, config?: ImportConfig) {\r\n    let em = new EntityManager();\r\n    em.importEntities(exported, config);\r\n    return em;\r\n  }\r\n\r\n  // instance methods\r\n\r\n  /**\r\n  Calls [[EntityAspect.acceptChanges]] on every changed entity in this EntityManager.\r\n  **/\r\n  acceptChanges() {\r\n    this.getChanges().map(function (entity) {\r\n      return entity.entityAspect._checkOperation(\"acceptChanges\");\r\n    }).forEach(function (aspect) {\r\n      aspect.acceptChanges();\r\n    });\r\n  }\r\n\r\n  /**\r\n  Exports selected entities, all entities of selected types, or an entire EntityManager cache.\r\n\r\n  This method takes a snapshot of an EntityManager that can be stored offline or held in memory.\r\n  Use the [[EntityManager.importEntities]] method to restore or merge the snapshot\r\n  into another EntityManager at some later time.\r\n  >      // let em1 be an EntityManager containing a number of existing entities.\r\n  >     // export every entity in em1.\r\n  >     let bundle = em1.exportEntities();\r\n  >     // save to the browser's local storage\r\n  >     window.localStorage.setItem(\"myEntityManager\", bundle);\r\n  >     // later retrieve the export\r\n  >     let bundleFromStorage = window.localStorage.getItem(\"myEntityManager\");\r\n  >     // import the retrieved export bundle into another manager\r\n  >     let em2 = em1.createEmptyCopy();\r\n  >     em2.importEntities(bundleFromStorage);\r\n  >     // em2 now has a complete, faithful copy of the entities that were in em1\r\n\r\n  You can also control exactly which entities are exported.\r\n  >     // get em1's unsaved changes (an array) and export them.\r\n  >     let changes = em1.getChanges();\r\n  >     let bundle = em1.exportEntities(changes);\r\n  >     // merge these entities into em2 which may contains some of the same entities.\r\n  >     // do NOT overwrite the entities in em2 if they themselves have unsaved changes.\r\n  >     em2.importEntities(bundle, { mergeStrategy: MergeStrategy.PreserveChanges} );\r\n\r\n  Metadata are included in an export by default. You may want to exclude the metadata\r\n  especially if you're exporting just a few entities for local storage.\r\n  >     let bundle = em1.exportEntities(arrayOfSelectedEntities, {includeMetadata: false});\r\n  >     window.localStorage.setItem(\"goodStuff\", bundle);\r\n\r\n  You may still express this option as a boolean value although this older syntax is deprecated.\r\n  >     // Exclude the metadata (deprecated syntax)\r\n  >     let bundle = em1.exportEntities(arrayOfSelectedEntities, false);\r\n\r\n  You can export all entities of one or more specified EntityTypes.\r\n  >     // Export all Customer and Employee entities (and also exclude metadata)\r\n  >     let bundle = em1.exportEntities(['Customer', 'Employee'], {includeMetadata: false});\r\n\r\n  All of the above examples return an export bundle as a string which is the default format.\r\n  You can export the bundle as JSON if you prefer by setting the `asString` option to false.\r\n  >     // Export all Customer and Employee entities as JSON and exclude the metadata\r\n  >     let bundle = em1.exportEntities(['Customer', 'Employee'],\r\n  >                                     {asString: false, includeMetadata: false});\r\n  >     // store JSON bundle somewhere ... perhaps indexDb ... and later import as we do here.\r\n  >     em2.importEntities(bundle);\r\n  @param entities - The entities to export or the EntityType(s) of the entities to export;\r\n    all entities are exported if this parameter is omitted or null.\r\n  @param exportConfig - Export configuration options or a boolean\r\n    - asString - (boolean) - If true (default), return export bundle as a string.\r\n    - includeMetadata - (boolean) - If true (default), include metadata in the export bundle.\r\n  @return The export bundle either serialized as a string (default) or as a JSON object.\r\n  The bundle contains the metadata (unless excluded) and the entity data grouped by type.\r\n  The entity data include property values, change-state, and temporary key mappings (if any).\r\n\r\n  The export bundle internals are deliberately undocumented.  This Breeze-internal representation of entity data is\r\n  suitable for export, storage, and import. The schema and contents of the bundle may change in future versions of Breeze.\r\n  Manipulate it at your own risk with appropriate caution.\r\n  **/\r\n  exportEntities(entities?: Entity[] | EntityType[] | string[], exportConfig?: { asString?: boolean, includeMetadata?: boolean } | boolean): string | Object {\r\n    assertParam(entities, \"entities\").isArray().isEntity()\r\n      .or().isNonEmptyArray().isInstanceOf(EntityType)\r\n      .or().isNonEmptyArray().isString()\r\n      .or().isOptional().check();\r\n\r\n    // assertParam(exportConfig, \"exportConfig\").isObject()\r\n    //   .or().isBoolean()\r\n    //   .or().isOptional().check();\r\n\r\n    if (exportConfig == null) {\r\n      exportConfig = { includeMetadata: true, asString: true };\r\n    } else if (typeof exportConfig === 'boolean') { // deprecated\r\n      exportConfig = { includeMetadata: exportConfig, asString: true };\r\n    }\r\n\r\n    assertConfig(exportConfig)\r\n      .whereParam(\"asString\").isBoolean().isOptional().withDefault(true)\r\n      .whereParam(\"includeMetadata\").isBoolean().isOptional().withDefault(true)\r\n      .applyAll(exportConfig);\r\n\r\n    let exportBundle = exportEntityGroups(this, entities);\r\n    let json = core.extend({}, exportBundle, [\"tempKeys\", \"entityGroupMap\"]);\r\n\r\n    if (exportConfig.includeMetadata) {\r\n      json = core.extend(json, this, [\"dataService\", \"saveOptions\", \"queryOptions\", \"validationOptions\"]);\r\n      (json as any).metadataStore = this.metadataStore.exportMetadata();\r\n    } else {\r\n      (json as any).metadataVersion = MetadataStore.metadataVersion;\r\n      (json as any).metadataStoreName = this.metadataStore.name;\r\n    }\r\n\r\n    let result = exportConfig.asString ? JSON.stringify(json, null, config.stringifyPad) : json;\r\n    return result;\r\n  }\r\n\r\n  // TODO: type the return value { entities: entitiesToLink, tempKeyMapping: tempKeyMap }\r\n  importEntities(exportedString: string, config?: ImportConfig): ImportResult;\r\n  importEntities(exportedData: Object, config?: ImportConfig): ImportResult;\r\n  /**\r\n  Imports a previously exported result into this EntityManager.\r\n\r\n  This method can be used to make a complete copy of any previously created entityManager, even if created\r\n  in a previous session and stored in localStorage. The static version of this method performs a\r\n  very similar process.\r\n  >     // assume em1 is an EntityManager containing a number of existing entities.\r\n  >     let bundle = em1.exportEntities();\r\n  >     // bundle can be stored in window.localStorage or just held in memory.\r\n  >     let em2 = new EntityManager({\r\n  >         serviceName: em1.serviceName,\r\n  >         metadataStore: em1.metadataStore\r\n  >     });\r\n  >     em2.importEntities(bundle);\r\n  >     // em2 will now have a complete copy of what was in em1\r\n\r\n  It can also be used to merge the contents of a previously created EntityManager with an\r\n  existing EntityManager with control over how the two are merged.\r\n  >     let bundle = em1.exportEntities();\r\n  >     // assume em2 is another entityManager containing some of the same entities possibly with modifications.\r\n  >     em2.importEntities(bundle, { mergeStrategy: MergeStrategy.PreserveChanges} );\r\n  >     // em2 will now contain all of the entities from both em1 and em2.  Any em2 entities with previously\r\n  >     // made modifications will not have been touched, but all other entities from em1 will have been imported.\r\n  @param exportedString - The result of a previous 'export' call.\r\n  @param importConfig - A configuration object.\r\n  @param importConfig.mergeStrategy -  A [[MergeStrategy]] to use when\r\n  merging into an existing EntityManager.\r\n  @param importConfig.metadataVersionFn - A function that takes two arguments (the current metadataVersion and the imported store's 'name')\r\n  and may be used to perform version checking.\r\n  @return result \r\n    - result.entities {Array of Entities} The entities that were imported.\r\n    - result.tempKeyMap {Object} Mapping from original EntityKey in the import bundle to its corresponding EntityKey in this EntityManager.\r\n  **/\r\n  importEntities(exported: string | Object, importConfig?: ImportConfig) {\r\n    importConfig = importConfig || {};\r\n    assertConfig(importConfig)\r\n      .whereParam(\"mergeStrategy\").isEnumOf(MergeStrategy).isOptional().withDefault(this.queryOptions.mergeStrategy)\r\n      .whereParam(\"metadataVersionFn\").isFunction().isOptional()\r\n      .whereParam(\"mergeAdds\").isBoolean().isOptional()\r\n      .applyAll(importConfig);\r\n\r\n    let json = (typeof exported === \"string\") ? JSON.parse(exported) : exported;\r\n    if (json.metadataStore) {\r\n      this.metadataStore.importMetadata(json.metadataStore);\r\n      // the || clause is for backwards compat with an earlier serialization format.\r\n      this.dataService = (json.dataService && DataService.fromJSON(json.dataService)) || new DataService({ serviceName: json.serviceName });\r\n\r\n      this.saveOptions = new SaveOptions(json.saveOptions);\r\n      this.queryOptions = QueryOptions.fromJSON(json.queryOptions);\r\n      this.validationOptions = new ValidationOptions(json.validationOptions);\r\n    } else {\r\n      importConfig.metadataVersionFn && importConfig.metadataVersionFn({\r\n        metadataVersion: json.metadataVersion,\r\n        metadataStoreName: json.metadataStoreName\r\n      });\r\n    }\r\n\r\n    let tempKeyMap: ITempKeyMap = {};\r\n    json.tempKeys.forEach((k: any) => {\r\n      let oldKey = EntityKey.fromJSON(k, this.metadataStore);\r\n      // try to use oldKey if not already used in this keyGenerator.\r\n      tempKeyMap[oldKey.toString()] = new EntityKey(oldKey.entityType, this.keyGenerator.generateTempKeyValue(oldKey.entityType, oldKey.values[0]));\r\n    });\r\n\r\n    let entitiesToLink: Entity[] = [];\r\n    let impConfig = importConfig as ImportConfigExt;\r\n\r\n    impConfig.tempKeyMap = tempKeyMap;\r\n    core.wrapExecution(() => {\r\n      this._pendingPubs = [];\r\n    }, (state) => {\r\n      this._pendingPubs!.forEach((fn) => fn());\r\n      this._pendingPubs = undefined;\r\n      this._hasChangesAction && this._hasChangesAction();\r\n    }, () => {\r\n      core.objectForEach(json.entityGroupMap, (entityTypeName, jsonGroup) => {\r\n        let entityType = this.metadataStore._getStructuralType(entityTypeName, false) as EntityType;\r\n        let targetEntityGroup = findOrCreateEntityGroup(this, entityType);\r\n        let entities = importEntityGroup(targetEntityGroup, jsonGroup, impConfig);\r\n        if (entities && entities.length) {\r\n          entitiesToLink = entitiesToLink.concat(entities);\r\n        }\r\n      });\r\n      entitiesToLink.forEach((entity) => {\r\n        if (!entity.entityAspect.entityState.isDeleted()) {\r\n          this._linkRelatedEntities(entity);\r\n        }\r\n      });\r\n    });\r\n    return {\r\n      entities: entitiesToLink,\r\n      tempKeyMapping: tempKeyMap\r\n    };\r\n  }\r\n\r\n  /**\r\n  Clears this EntityManager's cache but keeps all other settings. Note that this\r\n  method is not as fast as creating a new EntityManager via 'new EntityManager'.\r\n  This is because clear actually detaches all of the entities from the EntityManager.\r\n  >     // assume em1 is an EntityManager containing a number of existing entities.\r\n  >     em1.clear();\r\n  >     // em1 is will now contain no entities, but all other setting will be maintained.\r\n  **/\r\n  clear() {\r\n    core.objectMap(this._entityGroupMap, function (key: string, entityGroup: EntityGroup) {\r\n      return entityGroup._checkOperation('clear');\r\n    }).forEach((entityGroup: EntityGroup) => {\r\n      entityGroup._clear();\r\n    });\r\n\r\n    this._entityGroupMap = {};\r\n    this._unattachedChildrenMap = new UnattachedChildrenMap();\r\n    this.keyGenerator = new this.keyGeneratorCtor();\r\n    this.entityChanged.publish({ entityAction: EntityAction.Clear });\r\n    this._setHasChanges(false);\r\n  }\r\n\r\n  /**\r\n  Creates an empty copy of this EntityManager but with the same DataService, MetadataStore, QueryOptions, SaveOptions, ValidationOptions, etc. \r\n  >     // assume em1 is an EntityManager containing a number of existing entities.\r\n  >     let em2 = em1.createEmptyCopy();\r\n  >     // em2 is a new EntityManager with all of em1's settings\r\n  >     // but no entities.\r\n  @return A new EntityManager.\r\n  **/\r\n  createEmptyCopy() {\r\n    let copy = new EntityManager(core.extend({}, this,\r\n      [\"dataService\", \"metadataStore\", \"queryOptions\", \"saveOptions\", \"validationOptions\", \"keyGeneratorCtor\"]));\r\n    return copy;\r\n  }\r\n\r\n  /**\r\n  Attaches an entity to this EntityManager with an  [[EntityState]] of 'Added'.\r\n  >     // assume em1 is an EntityManager containing a number of existing entities.\r\n  >     let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >     let cust1 = custType.createEntity();\r\n  >     em1.addEntity(cust1);\r\n\r\n  Note that this is the same as using 'attachEntity' with an [[EntityState]] of 'Added'.\r\n\r\n  >     // assume em1 is an EntityManager containing a number of existing entities.\r\n  >     let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >     let cust1 = custType.createEntity();\r\n  >     em1.attachEntity(cust1, EntityState.Added);\r\n  @param entity - The entity to add.\r\n  @return The added entity.\r\n  **/\r\n  addEntity(entity: Entity) {\r\n    return this.attachEntity(entity, EntityState.Added);\r\n  }\r\n\r\n  /**\r\n  Attaches an entity to this EntityManager with a specified [[EntityState]].\r\n  >     // assume em1 is an EntityManager containing a number of existing entities.\r\n  >     let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >     let cust1 = custType.createEntity();\r\n  >     em1.attachEntity(cust1, EntityState.Added);\r\n  @param entity - The entity to add.\r\n  @param entityState - (default=EntityState.Unchanged) The EntityState of the newly attached entity. If omitted this defaults to EntityState.Unchanged.\r\n  @param mergeStrategy - (default = MergeStrategy.Disallowed) How the specified entity should be merged into the EntityManager if this EntityManager already contains an entity with the same key.\r\n  @return The attached entity.\r\n  **/\r\n  attachEntity(entity: Entity, entityState?: EntityState, mergeStrategy?: MergeStrategy) {\r\n    assertParam(entity, \"entity\").isRequired().check();\r\n    this.metadataStore._checkEntityType(entity);\r\n    let esSymbol = assertParam(entityState, \"entityState\").isEnumOf(EntityState).isOptional().check(EntityState.Unchanged) as EntityState;\r\n    let msSymbol = assertParam(mergeStrategy, \"mergeStrategy\").isEnumOf(MergeStrategy).isOptional().check(MergeStrategy.Disallowed) as MergeStrategy;\r\n\r\n    if (entity.entityType.metadataStore !== this.metadataStore) {\r\n      throw new Error(\"Cannot attach this entity because the EntityType (\" + entity.entityType.name +\r\n        \") and MetadataStore associated with this entity does not match this EntityManager's MetadataStore.\");\r\n    }\r\n    let aspect = entity.entityAspect;\r\n    if (aspect) {\r\n      // to avoid reattaching an entity in progress\r\n      if (aspect._inProcessEntity) return aspect._inProcessEntity;\r\n    } else {\r\n      // this occur's when attaching an entity created via new instead of via createEntity.\r\n      aspect = new EntityAspect(entity);\r\n    }\r\n    let manager = aspect.entityManager;\r\n    if (manager) {\r\n      if (manager === this) {\r\n        return entity;\r\n      } else {\r\n        throw new Error(\"This entity already belongs to another EntityManager\");\r\n      }\r\n    }\r\n\r\n    let attachedEntity = {} as Entity;\r\n    core.using(this, \"isLoading\", true, () => {\r\n      if (esSymbol.isAdded()) {\r\n        checkEntityKey(this, entity);\r\n      }\r\n      // attachedEntity === entity EXCEPT in the case of a merge.\r\n      attachedEntity = this._attachEntityCore(entity, esSymbol, msSymbol);\r\n      aspect._inProcessEntity = attachedEntity;\r\n      try {\r\n        // entity ( not attachedEntity) is deliberate here.\r\n        attachRelatedEntities(this, entity, esSymbol, msSymbol);\r\n      } finally {\r\n        // insure that _inProcessEntity is cleared.\r\n        aspect._inProcessEntity = undefined;\r\n      }\r\n    });\r\n    if (this.validationOptions.validateOnAttach) {\r\n      attachedEntity.entityAspect.validateEntity();\r\n    }\r\n    if (!esSymbol.isUnchanged()) {\r\n      this._notifyStateChange(attachedEntity, true);\r\n    }\r\n    this.entityChanged.publish({ entityAction: EntityAction.Attach, entity: attachedEntity });\r\n\r\n    return attachedEntity;\r\n  }\r\n\r\n\r\n  /**\r\n  Detaches an entity from this EntityManager.\r\n  >     // assume em1 is an EntityManager containing a number of existing entities.\r\n  >     // assume cust1 is a customer Entity previously attached to em1\r\n  >     em1.detachEntity(cust1);\r\n  >     // em1 will now no longer contain cust1 and cust1 will have an\r\n  >     // entityAspect.entityState of EntityState.Detached\r\n  @param entity - The entity to detach.\r\n  @return Whether the entity could be detached. This will return false if the entity is already detached or was never attached.\r\n  **/\r\n  detachEntity(entity: Entity) {\r\n    assertParam(entity, \"entity\").isEntity().check();\r\n    let aspect = entity.entityAspect;\r\n    if (!aspect) {\r\n      // no aspect means in couldn't appear in any group\r\n      return false;\r\n    }\r\n\r\n    if (aspect.entityManager !== this) {\r\n      throw new Error(\"This entity does not belong to this EntityManager.\");\r\n    }\r\n    return aspect.setDetached();\r\n  }\r\n\r\n  /**\r\n  Fetches the metadata associated with the EntityManager's current 'serviceName'.  This call\r\n  occurs internally before the first query to any service if the metadata hasn't already been\r\n  loaded. __Async__\r\n\r\n  Usually you will not actually process the results of a fetchMetadata call directly, but will instead\r\n  ask for the metadata from the EntityManager after the fetchMetadata call returns.\r\n  >     let em1 = new EntityManager( \"breeze/NorthwindIBModel\");\r\n  >     em1.fetchMetadata()\r\n  >       .then(function() {\r\n  >           let metadataStore = em1.metadataStore;\r\n  >           // do something with the metadata\r\n  >       }).catch(function(exception) {\r\n  >           // handle exception here\r\n  >       });\r\n  \r\n  @param callback - Function called on success.\r\n  @param errorCallback - Function called on failure.\r\n  @return {Promise}\r\n    - schema {Object} The raw Schema object from metadata provider - Because this schema will differ depending on the metadata provider\r\n        it is usually better to access metadata via the 'metadataStore' property of the EntityManager instead of using this 'raw' data.\r\n  **/\r\n  fetchMetadata(dataService?: DataService, callback?: Callback, errorCallback?: ErrorCallback) {\r\n    if (typeof (dataService) === \"function\") {\r\n      // legacy support for when dataService was not an arg. i.e. first arg was callback\r\n      errorCallback = callback;\r\n      callback = dataService;\r\n      dataService = undefined;\r\n    } else {\r\n      assertParam(dataService, \"dataService\").isInstanceOf(DataService).isOptional().check();\r\n      assertParam(callback, \"callback\").isFunction().isOptional().check();\r\n      assertParam(errorCallback, \"errorCallback\").isFunction().isOptional().check();\r\n    }\r\n\r\n    let promise = this.metadataStore.fetchMetadata(dataService || this.dataService);\r\n    return promiseWithCallbacks(promise, callback, errorCallback);\r\n  }\r\n\r\n\r\n  executeQuery(query: string, callback?: QuerySuccessCallback, errorCallback?: QueryErrorCallback): Promise<QueryResult>;\r\n  executeQuery(query: EntityQuery, callback?: QuerySuccessCallback, errorCallback?: QueryErrorCallback): Promise<QueryResult>;\r\n  /**\r\n  Executes the specified query. __Async__ \r\n  \r\n  >     let em = new EntityManager(serviceName);\r\n  >     let query = new EntityQuery(\"Orders\");\r\n  >     em.executeQuery(query).then( function(data) {\r\n  >         let orders = data.results;\r\n  >         ... query results processed here\r\n  >     }).catch( function(err) {\r\n  >         ... query failure processed here\r\n  >     });\r\n\r\n  or with callbacks\r\n  >     let em = new EntityManager(serviceName);\r\n  >     let query = new EntityQuery(\"Orders\");\r\n  >     em.executeQuery(query,\r\n  >         function(data) {\r\n  >             let orders = data.results;\r\n  >             ... query results processed here\r\n  >         },\r\n  >         function(err) {\r\n  >             ... query failure processed here\r\n  >         });\r\n\r\n  Either way this method is the same as calling the The [[EntityQuery]] 'execute' method.\r\n  >     let em = new EntityManager(serviceName);\r\n  >     let query = new EntityQuery(\"Orders\").using(em);\r\n  >     query.execute().then( function(data) {\r\n  >         let orders = data.results;\r\n  >         ... query results processed here\r\n  >     }).catch( function(err) {\r\n  >         ... query failure processed here\r\n  >     });\r\n  @param query - The [[EntityQuery]] or OData query string to execute.\r\n  @param callback - Function called on success.\r\n  @param errorCallback - {Function} Function called on failure.\r\n  @return Promise of \r\n    - results - An array of entities\r\n    - retrievedEntities - A array of all of the entities returned by the query.  Differs from results (above) when .expand() is used.\r\n    - query - The original [[EntityQuery]] or query string\r\n    - entityManager -  The EntityManager.\r\n    - httpResponse - The [[IHttpResponse]] returned from the server.\r\n    - inlineCount -  Only available if 'inlineCount(true)' was applied to the query.  Returns the count of\r\n    items that would have been returned by the query before applying any skip or take operators, but after any filter/where predicates\r\n    would have been applied.\r\n  **/\r\n  executeQuery(query: EntityQuery | string, callback?: QuerySuccessCallback, errorCallback?: QueryErrorCallback) {\r\n    assertParam(query, \"query\").isInstanceOf(EntityQuery).or().isString().check();\r\n    assertParam(callback, \"callback\").isFunction().isOptional().check();\r\n    assertParam(errorCallback, \"errorCallback\").isFunction().isOptional().check();\r\n    let promise: Promise<any>;\r\n    // 'resolve' methods create a new typed object with all of its properties fully resolved against a list of sources.\r\n    // Thought about creating a 'normalized' query with these 'resolved' objects\r\n    // but decided not to because the 'query' may not be an EntityQuery (it can be a string) and hence might not have a queryOptions or dataServices property on it.\r\n    let queryOptions = QueryOptions.resolve([(query as any).queryOptions, this.queryOptions, QueryOptions.defaultInstance]);\r\n    let dataService = DataService.resolve([(query as any).dataService!, this.dataService]);\r\n\r\n    if ((!dataService.hasServerMetadata) || this.metadataStore.hasMetadataFor(dataService.serviceName)) {\r\n      promise = executeQueryCore(this, query, queryOptions, dataService);\r\n    } else {\r\n      promise = this.fetchMetadata(dataService).then(() => {\r\n        return executeQueryCore(this, query, queryOptions, dataService);\r\n      });\r\n    }\r\n\r\n    return promiseWithCallbacks(promise, callback, errorCallback as ErrorCallback);\r\n  }\r\n\r\n  /**\r\n  Executes the specified query against this EntityManager's local cache.\r\n\r\n  Because this method is executed immediately there is no need for a promise or a callback\r\n  >     let em = new EntityManager(serviceName);\r\n  >     let query = new EntityQuery(\"Orders\");\r\n  >     let orders = em.executeQueryLocally(query);\r\n\r\n  Note that this can also be accomplished using the 'executeQuery' method with\r\n  a FetchStrategy of FromLocalCache and making use of the Promise or callback\r\n  >     let em = new EntityManager(serviceName);\r\n  >     let query = new EntityQuery(\"Orders\").using(FetchStrategy.FromLocalCache);\r\n  >     em.executeQuery(query).then( function(data) {\r\n  >         let orders = data.results;\r\n  >         ... query results processed here\r\n  >     }).catch( function(err) {\r\n  >         ... query failure processed here\r\n  >     });\r\n  @param query - The [[EntityQuery]] to execute.\r\n  @return  {Array of Entity}  Array of entities from cache that satisfy the query\r\n  **/\r\n  executeQueryLocally(query: EntityQuery) {\r\n    return executeQueryLocallyCore(this, query).results;\r\n  }\r\n\r\n  /**\r\n  Saves either a list of specified entities or all changed entities within this EntityManager. If there are no changes to any of the entities\r\n  specified then there will be no server side call made but a valid 'empty' saveResult will still be returned. __Async__\r\n\r\n  Often we will be saving all of the entities within an EntityManager that are either added, modified or deleted\r\n  and we will let the 'saveChanges' call determine which entities these are.\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      // This could include added, modified and deleted entities.\r\n  >      em.saveChanges().then(function(saveResult) {\r\n  >          let savedEntities = saveResult.entities;\r\n  >          let keyMappings = saveResult.keyMappings;\r\n  >      }).catch(function (e) {\r\n  >          // e is any exception that was thrown.\r\n  >      });\r\n\r\n  But we can also control exactly which entities to save and can specify specific SaveOptions\r\n\r\n  >      // assume entitiesToSave is an array of entities to save.\r\n  >      let saveOptions = new SaveOptions({ allowConcurrentSaves: true });\r\n  >      em.saveChanges(entitiesToSave, saveOptions).then(function(saveResult) {\r\n  >          let savedEntities = saveResult.entities;\r\n  >          let keyMappings = saveResult.keyMappings;\r\n  >      }).catch(function (e) {\r\n  >          // e is any exception that was thrown.\r\n  >      });\r\n\r\n  Callback methods can also be used\r\n  >      em.saveChanges(entitiesToSave, null,\r\n  >          function(saveResult) {\r\n  >              let savedEntities = saveResult.entities;\r\n  >              let keyMappings = saveResult.keyMappings;\r\n  >          }, function (e) {\r\n  >              // e is any exception that was thrown.\r\n  >          }\r\n  >      );\r\n\r\n  @param entities - The list of entities to save.\r\n  Every entity in that list will be sent to the server, whether changed or unchanged,\r\n  as long as it is attached to this EntityManager.\r\n  If this parameter is omitted, null or empty (the usual case),\r\n  every entity with pending changes in this EntityManager will be saved.\r\n  @param saveOptions - [[SaveOptions]] for the save - will default to\r\n  [[EntityManager.saveOptions]] if null.\r\n  @param callback -  Function called on success.\r\n  @param errorCallback - Function called on failure.\r\n  @return {Promise} Promise\r\n  **/\r\n  saveChanges(entities?: Entity[] | null, saveOptions?: SaveOptions, callback?: Function, errorCallback?: Function) {\r\n    assertParam(entities, \"entities\").isOptional().isArray().isEntity().check();\r\n    assertParam(saveOptions, \"saveOptions\").isInstanceOf(SaveOptions).isOptional().check();\r\n    assertParam(callback, \"callback\").isFunction().isOptional().check();\r\n    assertParam(errorCallback, \"errorCallback\").isFunction().isOptional().check();\r\n\r\n    saveOptions = saveOptions || this.saveOptions || SaveOptions.defaultInstance;\r\n\r\n    let entitiesToSave = getEntitiesToSave(this, entities ? entities : undefined);\r\n\r\n    if (entitiesToSave.length === 0) {\r\n      let result = { entities: [], keyMappings: [] } as SaveResult;\r\n      if (callback) callback(result);\r\n      return Promise.resolve(result);\r\n    }\r\n\r\n    if (!saveOptions.allowConcurrentSaves) {\r\n      let anyPendingSaves = entitiesToSave.some(function (entity) {\r\n        return entity.entityAspect.isBeingSaved;\r\n      });\r\n      if (anyPendingSaves) {\r\n        let err = new Error(\"Concurrent saves not allowed - SaveOptions.allowConcurrentSaves is false\");\r\n        if (errorCallback) errorCallback(err);\r\n        return Promise.reject(err);\r\n      }\r\n    }\r\n\r\n    clearServerErrors(entitiesToSave);\r\n\r\n    let valError = this.saveChangesValidateOnClient(entitiesToSave);\r\n    if (valError) {\r\n      if (errorCallback) errorCallback(valError);\r\n      return Promise.reject(valError);\r\n    }\r\n\r\n    let dataService = DataService.resolve([saveOptions.dataService, this.dataService]);\r\n    let saveContext: SaveContext = {\r\n      entityManager: this,\r\n      dataService: dataService,\r\n      processSavedEntities: processSavedEntities,\r\n      resourceName: saveOptions.resourceName || this.saveOptions.resourceName || \"SaveChanges\"\r\n    };\r\n\r\n    // TODO: need to check that if we are doing a partial save that all entities whose temp keys\r\n    // are referenced are also in the partial save group\r\n\r\n    let saveBundle = { entities: entitiesToSave, saveOptions: saveOptions };\r\n\r\n\r\n    try { // Guard against exception thrown in dataservice adapter before it goes async\r\n      updateConcurrencyProperties(entitiesToSave);\r\n      return dataService.adapterInstance!.saveChanges(saveContext, saveBundle)\r\n        .then(saveSuccess).then((r) => r, saveFail);\r\n    } catch (err) {\r\n      // undo the marking by updateConcurrencyProperties\r\n      markIsBeingSaved(entitiesToSave, false);\r\n      if (errorCallback) errorCallback(err);\r\n      return Promise.reject(err);\r\n    }\r\n\r\n    function saveSuccess(saveResult: SaveResult) {\r\n      let em = saveContext.entityManager;\r\n      markIsBeingSaved(entitiesToSave, false);\r\n      let savedEntities = saveContext.processSavedEntities(saveResult);\r\n      saveResult.entities = savedEntities;\r\n\r\n      // update _hasChanges after save.\r\n      em._setHasChanges();\r\n\r\n      // can't do this anymore because other changes might have been made while saved entities in flight.\r\n      //      let hasChanges = (isFullSave && haveSameContents(entitiesToSave, savedEntities)) ? false : null;\r\n      //      em._setHasChanges(hasChanges);\r\n\r\n      if (callback) callback(saveResult);\r\n      return Promise.resolve(saveResult);\r\n    }\r\n\r\n    function processSavedEntities(saveResult: SaveResult) {\r\n      let savedEntities = saveResult.entities;\r\n      let deletedKeys = saveResult.deletedKeys || [];\r\n      if (savedEntities.length === 0 && deletedKeys.length === 0) {\r\n        return [];\r\n      }\r\n      let keyMappings = saveResult.keyMappings;\r\n      let em = saveContext.entityManager;\r\n\r\n      // must occur outside of isLoading block\r\n      fixupKeys(em, keyMappings);\r\n\r\n      core.using(em, \"isLoading\", true, () => {\r\n\r\n        let mappingContext = new MappingContext({\r\n          query: undefined, // tells visitAndMerge this is a save instead of a query\r\n          entityManager: em,\r\n          mergeOptions: { mergeStrategy: MergeStrategy.OverwriteChanges },\r\n          dataService: dataService\r\n        });\r\n\r\n        // The visitAndMerge operation has been optimized so that we do not actually perform a merge if the\r\n        // the save operation did not actually return the entity - i.e. during OData and Mongo updates and deletes.\r\n        savedEntities = mappingContext.visitAndMerge(savedEntities, { nodeType: \"root\" });\r\n      });\r\n\r\n      // detach any entities found in the em that appear in the deletedKeys list. \r\n      deletedKeys.forEach(key => {\r\n        let entityType = em.metadataStore._getStructuralType(key.entityTypeName) as EntityType;\r\n        let ekey = new EntityKey(entityType, key.keyValues);\r\n        let entity = em.findEntityByKey(ekey);\r\n        if (entity) {\r\n          entity.entityAspect.setDetached();\r\n        }\r\n      });\r\n\r\n      return savedEntities;\r\n    }\r\n\r\n    function saveFail(serverError: SaveErrorFromServer) {\r\n      markIsBeingSaved(entitiesToSave, false);\r\n      let clientError = processServerErrors(saveContext, serverError);\r\n      if (errorCallback) errorCallback(clientError);\r\n      return Promise.reject(clientError);\r\n    }\r\n  }\r\n\r\n  /**\r\n  Run the \"saveChanges\" pre-save client validation logic.\r\n  \r\n  This is NOT a general purpose validation method.\r\n  It is intended for utilities that must know if saveChanges\r\n  would reject the save due to client validation errors.\r\n  \r\n  It only validates entities if the EntityManager's\r\n  [[ValidationOptions]].validateOnSave is true.\r\n  \r\n  @param entitiesToSave {Array of Entity} The list of entities to save (to validate).\r\n  @return {Error} Validation error or null if no error\r\n  **/\r\n  saveChangesValidateOnClient(entitiesToSave: Entity[]) {\r\n\r\n    if (this.validationOptions.validateOnSave) {\r\n      let failedEntities = entitiesToSave.filter(function (entity) {\r\n        let aspect = entity.entityAspect;\r\n        let isValid = aspect.entityState.isDeleted() || aspect.validateEntity();\r\n        return !isValid;\r\n      });\r\n      if (failedEntities.length > 0) {\r\n        let valError = new Error(\"Client side validation errors encountered - see the entityErrors collection on this object for more detail\");\r\n        (valError as any).entityErrors = createEntityErrors(failedEntities);\r\n        return valError; // TODO: type this.\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _findEntityGroup(entityType: EntityType) {\r\n    return this._entityGroupMap[entityType.name];\r\n  }\r\n\r\n  /**\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let employeeType = em1.metadataStore.getEntityType(\"Employee\");\r\n  >      let employeeKey = new EntityKey(employeeType, 1);\r\n  >      let employee = em1.getEntityByKey(employeeKey);\r\n  >      // employee will either be an entity or null.\r\n  **/\r\n  getEntityByKey(entityKey: EntityKey): Entity | null;\r\n\r\n  /**  \r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let employee = em1.getEntityByKey(\"Employee\", 1);\r\n  >      // employee will either be an entity or null.\r\n  **/\r\n  getEntityByKey(typeName: string, keyValues: any | any[]): Entity | null;\r\n\r\n  /**  \r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let employeeType = em1.metadataStore.getEntityType(\"Employee\");\r\n  >      let employee = em1.getEntityByKey(employeeType, 1);\r\n  >      // employee will either be an entity or null.\r\n  **/\r\n  getEntityByKey(type: EntityType, keyValues: any | any[]): Entity | null;\r\n\r\n  /**  \r\n  Attempts to locate an entity within this EntityManager by its [EntityKey].\r\n  @param entityKey - The [[EntityKey]] of the Entity to be located.\r\n  @param type - The [[EntityType]] for this key.\r\n  @param typeName - The EntityType name for this key.\r\n  @param keyValues - The values for this key - will usually just be a single value; an array is only needed for multipart keys.  \r\n  @return An Entity or null;\r\n  **/\r\n  getEntityByKey(...args: any[]) {\r\n    let entityKey = createEntityKey(this, args).entityKey;\r\n    let entityTypes = entityKey._subtypes || [entityKey.entityType];\r\n    let e: Entity | undefined;\r\n    // hack use of some to simulate mapFirst logic.\r\n    entityTypes.some((et) => {\r\n      let group = this._findEntityGroup(et);\r\n      // group version of findEntityByKey doesn't care about entityType\r\n      e = group && group.findEntityByKey(entityKey);\r\n      return e != null;\r\n    });\r\n    return e || null;\r\n  }\r\n\r\n  fetchEntityByKey(typeName: string, keyValues: any | any[], checkLocalCacheFirst?: boolean): Promise<IEntityByKeyResult>;\r\n  fetchEntityByKey(entityType: EntityType, keyValues: any | any[], checkLocalCacheFirst?: boolean): Promise<IEntityByKeyResult>;\r\n  fetchEntityByKey(entityKey: EntityKey, checkLocalCacheFirst?: boolean): Promise<IEntityByKeyResult>;\r\n  /**\r\n  Attempts to fetch an entity from the server by its [[EntityKey]] with\r\n  an option to check the local cache first. Note the this EntityManager's queryOptions.mergeStrategy\r\n  will be used to merge any server side entity returned by this method.\r\n  >     // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >     let employeeType = em1.metadataStore.getEntityType(\"Employee\");\r\n  >     let employeeKey = new EntityKey(employeeType, 1);\r\n  >     em1.fetchEntityByKey(employeeKey).then(function(result) {\r\n  >       let employee = result.entity;\r\n  >       let entityKey = result.entityKey;\r\n  >       let fromCache = result.fromCache;\r\n  >     });\r\n  @param typeName  - The EntityType name for this key.\r\n  @param entityType  - The EntityType for this key.\r\n  @param keyValues - The values for this key - will usually just be a single value; an array is only needed for multipart keys.\r\n  @param entityKey - The [[EntityKey]] of the Entity to be located.\r\n  @param checkLocalCacheFirst - (default = false) - Whether to check this EntityManager first before going to the server. By default, the query will NOT do this.\r\n  @return {Promise}\r\n    - Properties on the promise success result\r\n      - entity {Object} The entity returned or null\r\n      - entityKey {EntityKey} The entityKey of the entity to fetch.\r\n      - fromCache {Boolean} Whether this entity was fetched from the server or was found in the local cache.\r\n  **/\r\n  fetchEntityByKey(...args: any[]) {\r\n    let dataService = DataService.resolve([this.dataService]);\r\n    if ((!dataService.hasServerMetadata) || this.metadataStore.hasMetadataFor(dataService.serviceName)) {\r\n      return fetchEntityByKeyCore(this, args);\r\n    } else {\r\n      return this.fetchMetadata(dataService).then(() => {\r\n        return fetchEntityByKeyCore(this, args);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n  [Deprecated] - Attempts to locate an entity within this EntityManager by its  [[EntityKey]].\r\n  >     // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >     let employeeType = em1.metadataStore.getEntityType(\"Employee\");\r\n  >     let employeeKey = new EntityKey(employeeType, 1);\r\n  >     let employee = em1.findEntityByKey(employeeKey);\r\n  >     // employee will either be an entity or null.\r\n  @deprecated    Use getEntityByKey instead\r\n  @param entityKey - The  [[EntityKey]] of the Entity to be located.\r\n  @return An Entity or null;\r\n  **/\r\n  findEntityByKey(entityKey: EntityKey) {\r\n    return this.getEntityByKey(entityKey);\r\n  }\r\n\r\n  /**\r\n  Generates a temporary key for the specified entity.  This is used to insure that newly\r\n  created entities have unique keys and to register that these keys are temporary and\r\n  need to be automatically replaced with 'real' key values once these entities are saved.\r\n  \r\n  The [[EntityManager.keyGeneratorCtor]] property is used internally by this method to actually generate\r\n  the keys - See the  KeyGenerator interface interface description to see\r\n  how a custom key generator can be plugged in.\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let customer = custType.createEntity();\r\n  >      let customerId = em.generateTempKeyValue(customer);\r\n  >      // The 'customer' entity 'CustomerID' property is now set to a newly generated unique id value\r\n  >      // This property will change again after a successful save of the 'customer' entity.\r\n  >  \r\n  >      em1.saveChanges().then( function( data) {\r\n  >          let sameCust1 = data.results[0];\r\n  >          // cust1 === sameCust1;\r\n  >          // but cust1.getProperty(\"CustomerId\") != customerId\r\n  >          // because the server will have generated a new id\r\n  >          // and the client will have been updated with this\r\n  >          // new id.\r\n  >      })\r\n  @param entity - The Entity to generate a key for.\r\n  @return The new key value\r\n  **/\r\n  generateTempKeyValue(entity: Entity) {\r\n    // TODO - check if this entity is attached to this EntityManager.\r\n    assertParam(entity, \"entity\").isEntity().check();\r\n    let entityType = entity.entityType;\r\n    let nextKeyValue = this.keyGenerator.generateTempKeyValue(entityType);\r\n    let keyProp = entityType.keyProperties[0];\r\n    entity.setProperty(keyProp.name, nextKeyValue);\r\n    entity.entityAspect.hasTempKey = true;\r\n    return nextKeyValue;\r\n  }\r\n\r\n  hasChanges(): boolean;\r\n  hasChanges(entityTypeNames: string | string[]): boolean;\r\n  hasChanges(entityTypes: EntityType | EntityType[]): boolean;\r\n  /**\r\n  Returns whether there are any changed entities of the specified [[EntityType]]s. A 'changed' Entity has\r\n  has an [[EntityState]] of either Added, Modified or Deleted.\r\n\r\n  This method can be used to determine if an EntityManager has any changes\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      if ( em1.hasChanges() {\r\n  >          // do something interesting\r\n  >      }\r\n\r\n  or if it has any changes on to a specific [[EntityType]].\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      if ( em1.hasChanges(custType) {\r\n  >          // do something interesting\r\n  >      }\r\n\r\n  or to a collection of [[EntityType]]s\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let orderType = em1.metadataStore.getEntityType(\"Order\");\r\n  >      if ( em1.hasChanges( [custType, orderType]) {\r\n  >          // do something interesting\r\n  >      }\r\n  @param entityTypes - The [[EntityType]] or EntityTypes for which 'changed' entities will be found.\r\n  @param entityTypeNames - The [[EntityType]] name or names for which 'changed' entities will be found.\r\n  @return Whether there are any changed entities that match the types specified..\r\n  **/\r\n  hasChanges(entityTypes?: EntityType | EntityType[] | string | string[]) {\r\n    if (!this._hasChanges) return false;\r\n    if (entityTypes === undefined) return this._hasChanges;\r\n    return this._hasChangesCore(entityTypes);\r\n  }\r\n\r\n\r\n  /** @hidden @internal */\r\n  // backdoor to \"really\" check for changes.\r\n  _hasChangesCore(entityTypes?: EntityType | EntityType[] | string | string[]) {\r\n    let ets = checkEntityTypes(this, entityTypes);\r\n    let entityGroups = getEntityGroups(this, ets);\r\n    return entityGroups.some(function (eg) {\r\n      return eg && eg.hasChanges();\r\n    });\r\n  }\r\n\r\n  getChanges(): Entity[];\r\n  getChanges(entityTypeNames: string | string[]): Entity[];\r\n  getChanges(entityTypes: EntityType | EntityType[]): Entity[];\r\n  /**\r\n  Returns a array of all changed entities of the specified [[EntityType]]s. A 'changed' Entity has\r\n  has an [[EntityState]] of either Added, Modified or Deleted.\r\n  \r\n  This method can be used to get all of the changed entities within an EntityManager\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let changedEntities = em1.getChanges();\r\n\r\n  or you can specify that you only want the changes on a specific [[EntityType]]\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let changedCustomers = em1.getChanges(custType);\r\n\r\n  or to a collection of [[EntityType]]s\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let orderType = em1.metadataStore.getEntityType(\"Order\");\r\n  >      let changedCustomersAndOrders = em1.getChanges([custType, orderType]);\r\n  @param entityTypes - The [[EntityType]] or EntityTypes for which 'changed' entities will be found.\r\n  @param entityTypeNames - The [[EntityType]] name or names for which 'changed' entities will be found.\r\n  @return An array of Entities\r\n  **/\r\n  getChanges(entityTypes?: EntityType | EntityType[] | string | string[]) {\r\n    let ets = checkEntityTypes(this, entityTypes);\r\n    return getChangesCore(this, ets);\r\n  }\r\n\r\n  /**\r\n  Rejects (reverses the effects) all of the additions, modifications and deletes from this EntityManager.\r\n  Calls [[EntityAspect.rejectChanges]] on every changed entity in this EntityManager.\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let entities = em1.rejectChanges();\r\n  @return The entities whose changes were rejected. These entities will all have EntityStates of\r\n  either 'Unchanged' or 'Detached'\r\n  **/\r\n  rejectChanges() {\r\n    if (!this._hasChanges) return [];\r\n    let changes = getChangesCore(this);\r\n    // next line stops individual reject changes from each calling _hasChangesCore\r\n    let aspects = changes.map(function (e) {\r\n      return e.entityAspect._checkOperation(\"rejectChanges\");\r\n    });\r\n    this._hasChanges = false;\r\n    aspects.forEach(function (aspect) {\r\n      aspect.rejectChanges();\r\n    });\r\n    this.hasChangesChanged.publish({ entityManager: this, hasChanges: false });\r\n    return changes;\r\n  }\r\n\r\n  getEntities(entityTypeNames?: string | string[], entityStates?: EntityState | EntityState[]): Entity[];\r\n  getEntities(entityTypes?: EntityType | EntityType[], entityStates?: EntityState | EntityState[]): Entity[];\r\n  /**\r\n  Returns a array of all entities of the specified [[EntityType]]s with the specified [[EntityState]]s.\r\n\r\n  This method can be used to get all of the entities within an EntityManager\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let entities = em1.getEntities();\r\n\r\n  or you can specify that you only want the changes on a specific [[EntityType]]\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let customers = em1.getEntities(custType);\r\n\r\n  or to a collection of [[EntityType]]s\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let orderType = em1.metadataStore.getEntityType(\"Order\");\r\n  >      let customersAndOrders = em1.getChanges([custType, orderType]);\r\n\r\n  You can also ask for entities with a particular [[EntityState]] or EntityStates.\r\n  >      // assume em1 is an EntityManager containing a number of preexisting entities.\r\n  >      let custType = em1.metadataStore.getEntityType(\"Customer\");\r\n  >      let orderType = em1.metadataStore.getEntityType(\"Order\");\r\n  >      let addedCustomersAndOrders = em1.getEntities([custType, orderType], EntityState.Added);\r\n \r\n  @param entityTypeName - The [[EntityType]] name or names for which entities will be found.\r\n  If this parameter is omitted, all EntityTypes are searched.  \r\n  @param entityTypes - The [[EntityType]] or EntityTypes for which entities will be found.\r\n  If this parameter is omitted, all EntityTypes are searched. \r\n  @param entityStates - The [[EntityState]]s for which entities will be found.\r\n  If this parameter is omitted, entities of all EntityStates are returned.\r\n  @return An array of Entities\r\n  **/\r\n  getEntities(entityTypes?: EntityType | EntityType[] | string | string[], entityStates?: EntityState | EntityState[]) {\r\n    let entTypes = checkEntityTypes(this, entityTypes);\r\n    assertParam(entityStates, \"entityStates\").isOptional().isEnumOf(EntityState).or().isNonEmptyArray().isEnumOf(EntityState).check();\r\n\r\n    let states = validateEntityStates(this, entityStates);\r\n    return getEntitiesCore(this, entTypes, states);\r\n  }\r\n\r\n\r\n  // protected methods\r\n  /** @hidden @internal */\r\n  _notifyStateChange(entity: Entity, needsSave: boolean) {\r\n    let ecArgs = { entityAction: EntityAction.EntityStateChange, entity: entity };\r\n\r\n    if (needsSave) {\r\n      if (!this._hasChanges) this._setHasChanges(true);\r\n    } else {\r\n      // called when rejecting a change or merging an unchanged record.\r\n      // NOTE: this can be slow with lots of entities in the cache.\r\n      // so defer it during a query/import or save and call it once when complete ( if needed).\r\n      if (this._hasChanges) {\r\n        if (this.isLoading) {\r\n          this._hasChangesAction = this._hasChangesAction || function () {\r\n            this._setHasChanges(null);\r\n            this.entityChanged.publish(ecArgs);\r\n          }.bind(this);\r\n          return;\r\n        } else {\r\n          this._setHasChanges();\r\n        }\r\n      }\r\n    }\r\n    this.entityChanged.publish(ecArgs);\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _setHasChanges(hasChanges?: boolean) {\r\n    if (hasChanges == null) hasChanges = this._hasChangesCore();\r\n    let hadChanges = this._hasChanges;\r\n    this._hasChanges = hasChanges;\r\n    if (hasChanges !== hadChanges) {\r\n      this.hasChangesChanged.publish({ entityManager: this, hasChanges: hasChanges });\r\n    }\r\n    this._hasChangesAction = undefined;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _linkRelatedEntities(entity: Entity) {\r\n    let em = this;\r\n    let entityAspect = entity.entityAspect;\r\n    // we do not want entityState to change as a result of linkage.\r\n    core.using(em, \"isLoading\", true, function () {\r\n\r\n      let unattachedMap = em._unattachedChildrenMap;\r\n      let entityKey = entityAspect.getKey();\r\n      let entityType = entityKey.entityType;\r\n\r\n      while (entityType) {\r\n        let keystring = entityKey.toString(entityType);\r\n\r\n        // attach any unattachedChildren\r\n        let tuples = unattachedMap.getTuplesByString(keystring);\r\n        if (tuples) {\r\n          tuples.slice(0).forEach(function (tpl) {\r\n\r\n            let unattachedChildren = tpl.children.filter(function (e) {\r\n              return e.entityAspect.entityState !== EntityState.Detached;\r\n            });\r\n\r\n            let childToParentNp: NavigationProperty;\r\n            let parentToChildNp: NavigationProperty;\r\n\r\n            // np is usually childToParentNp\r\n            // except with unidirectional 1-n where it is parentToChildNp;\r\n            let np = tpl.navigationProperty;\r\n\r\n            let inverseNp = np.inverse;\r\n            if (inverseNp) {\r\n              // bidirectional\r\n              childToParentNp = np;\r\n              parentToChildNp = inverseNp;\r\n\r\n              if (parentToChildNp.isScalar) {\r\n                let onlyChild = unattachedChildren[0];\r\n                entity.setProperty(parentToChildNp.name, onlyChild);\r\n                onlyChild.setProperty(childToParentNp.name, entity);\r\n              } else {\r\n                let currentChildren = entity.getProperty(parentToChildNp.name);\r\n                unattachedChildren.forEach(function (child) {\r\n                  currentChildren.push(child);\r\n                  child.setProperty(childToParentNp.name, entity);\r\n                });\r\n              }\r\n              unattachedMap.removeChildren(keystring, childToParentNp);\r\n            } else {\r\n              // unidirectional\r\n              // if (np.isScalar || np.parentType !== entity.entityType) {\r\n              if (np.isScalar) {\r\n                // n -> 1  eg: child: OrderDetail parent: Product\r\n                // 1 -> 1 eg child: Employee parent: Employee ( only Manager, no DirectReports property)\r\n                childToParentNp = np;\r\n                unattachedChildren.forEach(function (child) {\r\n                  child.setProperty(childToParentNp.name, entity);\r\n                });\r\n                unattachedMap.removeChildren(keystring, childToParentNp);\r\n              } else {\r\n                // 1 -> n  eg: parent: Region child: Terr\r\n                // TODO: need to remove unattached children from the map after this; only a perf issue.\r\n                parentToChildNp = np;\r\n                let currentChildren = entity.getProperty(parentToChildNp.name);\r\n                unattachedChildren.forEach(function (child) {\r\n                  // we know if can't already be there.\r\n                  currentChildren._push(child);\r\n                });\r\n              }\r\n            }\r\n          });\r\n        }\r\n        entityType = entityType.baseEntityType; // look for relationships up the hierarchy\r\n      }\r\n\r\n\r\n      // now add to unattachedMap if needed.\r\n      entity.entityType.navigationProperties.forEach(function (np) {\r\n        if (np.isScalar) {\r\n          let value = entity.getProperty(np.name);\r\n          // property is already linked up\r\n          if (value) return;\r\n        }\r\n\r\n        // first determine if np contains a parent or child\r\n        // having a parentKey means that this is a child\r\n        // if a parent then no need for more work because children will attach to it.\r\n        let parentKey = entityAspect.getParentKey(np);\r\n        if (parentKey) {\r\n          // check for empty keys - meaning that parent id's are not yet set.\r\n          if (parentKey._isEmpty()) return;\r\n          // if a child - look for parent in the em cache\r\n          let parent = em.findEntityByKey(parentKey);\r\n          if (parent) {\r\n            // if found hook it up\r\n            entity.setProperty(np.name, parent);\r\n          } else {\r\n            // else add parent to unresolvedParentMap;\r\n            unattachedMap.addChild(parentKey, np, entity);\r\n          }\r\n        }\r\n      });\r\n\r\n      // handle unidirectional 1-x where we set x.fk\r\n      entity.entityType.foreignKeyProperties.forEach(function (fkProp) {\r\n        let invNp = fkProp.inverseNavigationProperty;\r\n        if (!invNp) return;\r\n        // unidirectional fk props only\r\n        let fkValue = entity.getProperty(fkProp.name);\r\n        let parentKey = new EntityKey(invNp.parentType, [fkValue]);\r\n        let parent = em.findEntityByKey(parentKey);\r\n\r\n        if (parent) {\r\n          if (invNp.isScalar) {\r\n            parent.setProperty(invNp.name, entity);\r\n          } else {\r\n            if (em.isLoading) {\r\n              parent.getProperty(invNp.name)._push(entity);\r\n            } else {\r\n              parent.getProperty(invNp.name).push(entity);\r\n            }\r\n          }\r\n        } else {\r\n          // else add parent to unresolvedParentMap;\r\n          unattachedMap.addChild(parentKey, invNp, entity);\r\n        }\r\n      });\r\n    });\r\n\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _attachEntityCore(entity: Entity, entityState: EntityState, mergeStrategy: MergeStrategy) {\r\n    let group = findOrCreateEntityGroup(this, entity.entityType);\r\n    let attachedEntity = group.attachEntity(entity, entityState, mergeStrategy);\r\n    this._linkRelatedEntities(attachedEntity);\r\n    return attachedEntity;\r\n  }\r\n\r\n  /** @hidden @internal */\r\n  _updateFkVal(fkProp: DataProperty, oldValue: any, newValue: any) {\r\n    let group = this._entityGroupMap[fkProp.parentType.name];\r\n    if (!group) return;\r\n    group._updateFkVal(fkProp, oldValue, newValue);\r\n  }\r\n}\r\n\r\nEntityManager.prototype._$typeName = \"EntityManager\";\r\n\r\nBreezeEvent.bubbleEvent(EntityManager.prototype);\r\n\r\nfunction clearServerErrors(entities: Entity[]) {\r\n  entities.forEach(function (entity) {\r\n    let serverKeys: string[] = [];\r\n    let aspect = entity.entityAspect;\r\n    core.objectForEach(aspect._validationErrors, function (key, ve) {\r\n      if (ve.isServerError) serverKeys.push(key);\r\n    });\r\n    if (serverKeys.length === 0) return;\r\n    aspect._processValidationOpAndPublish(function () {\r\n      serverKeys.forEach(function (key) {\r\n        aspect._removeValidationError(key);\r\n      });\r\n    });\r\n  });\r\n}\r\n\r\nfunction createEntityErrors(entities: Entity[]) {\r\n  let entityErrors: EntityError[] = [];\r\n  entities.forEach((entity) => {\r\n    core.objectForEach(entity.entityAspect._validationErrors, function (key, ve) {\r\n      let cfg = core.extend({\r\n        entity: entity,\r\n        errorName: ve.validator.name\r\n      }, ve, [\"errorMessage\", \"propertyName\", \"isServerError\"]) as EntityError;\r\n      entityErrors.push(cfg);\r\n    });\r\n  });\r\n  return entityErrors;\r\n}\r\n\r\n\r\nfunction processServerErrors(saveContext: SaveContext, saveError: SaveErrorFromServer) {\r\n  // converting ISaveErrorFromServer -> ISaveError\r\n  let serverErrors = saveError.entityErrors;\r\n  if (!serverErrors) return <SaveError> <any> saveError;\r\n  let entityManager = saveContext.entityManager;\r\n  let metadataStore = entityManager.metadataStore;\r\n  let entityErrors = serverErrors.map((serr) => {\r\n    let entity: Entity | null = null;\r\n    let entityType: EntityType | undefined;\r\n    if (serr.keyValues) {\r\n      entityType = metadataStore._getStructuralType(serr.entityTypeName) as EntityType;\r\n      let ekey = new EntityKey(entityType, serr.keyValues);\r\n      entity = entityManager.findEntityByKey(ekey);\r\n    }\r\n\r\n    if (entityType && entity) {\r\n      let context = serr.propertyName ?\r\n        {\r\n          propertyName: serr.propertyName,\r\n          property: entityType.getProperty(serr.propertyName)\r\n        } : {\r\n        };\r\n      let key = ValidationError.getKey(serr.errorName || serr.errorMessage, serr.propertyName);\r\n\r\n      let ve = new ValidationError(null, context, serr.errorMessage, key);\r\n      ve.isServerError = true;\r\n      entity.entityAspect.addValidationError(ve);\r\n    }\r\n\r\n    let entityError = core.extend({\r\n      entity: entity,\r\n      isServerError: true\r\n    }, serr, [\"errorName\", \"errorMessage\", \"propertyName\"]) as EntityError;\r\n    return entityError;\r\n  });\r\n  // converting ISaveErrorFromServer -> ISaveError \r\n  saveError.entityErrors = entityErrors as any;\r\n  return <SaveError> <any> saveError;\r\n}\r\n\r\nexport interface IEntityByKeyResult {\r\n  entity?: Entity;\r\n  entityKey: EntityKey;\r\n  fromCache: boolean;\r\n}\r\n\r\nfunction fetchEntityByKeyCore(em: EntityManager, args: any[]): Promise<IEntityByKeyResult> {\r\n  let tpl = createEntityKey(em, args);\r\n  let entityKey = tpl.entityKey;\r\n\r\n  let checkLocalCacheFirst = tpl.remainingArgs.length === 0 ? false : !!tpl.remainingArgs[0];\r\n  let entity: Entity | null = null;\r\n  let foundIt = false;\r\n  if (checkLocalCacheFirst) {\r\n    entity = em.getEntityByKey(entityKey);\r\n    foundIt = entity != null;\r\n    if (entity != null &&\r\n      // null the entity if it is deleted and we should exclude deleted entities\r\n      !em.queryOptions.includeDeleted && entity.entityAspect.entityState.isDeleted()) {\r\n      entity = null;\r\n      // but resume looking if we'd overwrite deleted entity with a remote entity\r\n      // note: em.queryOptions is always fully resolved by now\r\n      foundIt = em.queryOptions.mergeStrategy !== MergeStrategy.OverwriteChanges;\r\n    }\r\n  }\r\n  if (foundIt) {\r\n    return Promise.resolve({ entity: entity || undefined, entityKey: entityKey, fromCache: true });\r\n  } else {\r\n    return EntityQuery.fromEntityKey(entityKey).using(em).execute().then(function (data: any) {\r\n      entity = (data.results.length === 0) ? null : data.results[0];\r\n      return Promise.resolve({ entity: entity || undefined, entityKey: entityKey, fromCache: false });\r\n    });\r\n  }\r\n}\r\n\r\n\r\n// private fns\r\n\r\n// takes in entityTypes as either strings or entityTypes or arrays of either\r\n// and returns either an entityType or an array of entityTypes or throws an error\r\nfunction checkEntityTypes(em: EntityManager, entityTypes?: EntityType | EntityType[] | string | string[]) {\r\n  assertParam(entityTypes, \"entityTypes\").isString().isOptional().or().isNonEmptyArray().isString()\r\n    .or().isInstanceOf(EntityType).or().isNonEmptyArray().isInstanceOf(EntityType).check();\r\n  let resultTypes: EntityType | EntityType[] | undefined;\r\n  if (typeof entityTypes === \"string\") {\r\n    resultTypes = em.metadataStore._getStructuralType(entityTypes, false) as (EntityType | EntityType[]);\r\n  } else if (Array.isArray(entityTypes) && typeof entityTypes[0] === \"string\") {\r\n    resultTypes = (entityTypes as string[]).map(function (etName) {\r\n      return em.metadataStore._getStructuralType(etName, false) as EntityType;\r\n    });\r\n  } else {\r\n    resultTypes = entityTypes as (EntityType | EntityType[] | undefined);\r\n  }\r\n\r\n  return resultTypes;\r\n}\r\n\r\nfunction getChangesCore(em: EntityManager, entityTypes?: EntityType | EntityType[]) {\r\n  let entityGroups = getEntityGroups(em, entityTypes);\r\n\r\n  // TODO: think about writing a core.mapMany method if we see more of these.\r\n  let selected: Entity[] = [];\r\n  entityGroups.forEach(function (eg) {\r\n    // eg may be undefined or null\r\n    if (!eg) return;\r\n    let entities = eg.getChanges();\r\n    if (selected && selected.length) {\r\n      selected = selected.concat(entities);\r\n    } else {\r\n      selected = entities;\r\n    }\r\n  });\r\n  return selected;\r\n}\r\n\r\nfunction getEntitiesCore(em: EntityManager, entityTypes: EntityType | EntityType[] | undefined, entityStates: EntityState[]) {\r\n  let entityGroups = getEntityGroups(em, entityTypes);\r\n\r\n  // TODO: think about writing a core.mapMany method if we see more of these.\r\n  let selected: Entity[] = [];\r\n  entityGroups.forEach(function (eg) {\r\n    // eg may be undefined or null\r\n    if (!eg) return;\r\n    let entities = eg.getEntities(entityStates);\r\n    if (selected && selected.length) {\r\n      selected = selected.concat(entities);\r\n    } else {\r\n      selected = entities;\r\n    }\r\n  });\r\n  return selected;\r\n}\r\n\r\n\r\nfunction createEntityKey(em: EntityManager, args: any[]) {\r\n  try {\r\n    if (args[0] instanceof EntityKey) {\r\n      return { entityKey: args[0] as EntityKey, remainingArgs: core.arraySlice(args, 1) };\r\n    } else if (args.length >= 2) {\r\n      let entityType = (typeof args[0] === 'string') ? em.metadataStore._getStructuralType(args[0], false) : args[0];\r\n      return { entityKey: new EntityKey(entityType, args[1]), remainingArgs: core.arraySlice(args, 2) };\r\n    }\r\n  } catch (e) {/* throw below */\r\n    // throw new Error(\"Must supply an EntityKey OR an EntityType name or EntityType followed by a key value or an array of key values.\");\r\n  }\r\n  throw new Error(\"Must supply an EntityKey OR an EntityType name or EntityType followed by a key value or an array of key values.\");\r\n}\r\n\r\nfunction markIsBeingSaved(entities: Entity[], flag: boolean) {\r\n  entities.forEach(function (entity) {\r\n    entity.entityAspect.isBeingSaved = flag;\r\n  });\r\n}\r\n\r\nfunction exportEntityGroups(em: EntityManager, entitiesOrEntityTypes: Entity[] | EntityType[] | string[]) {\r\n  let entityGroupMap: { [index: string]: EntityGroup };\r\n  let first = entitiesOrEntityTypes && entitiesOrEntityTypes[0];\r\n  // check if array\r\n  if (first) {\r\n    // group entities by entityType and\r\n    // create 'groups' that look like entityGroups.\r\n    entityGroupMap = {};\r\n    if ((first as any).entityType) {\r\n      let entities = entitiesOrEntityTypes as Entity[];\r\n      // assume \"entities\" is an array of entities;\r\n      entities.forEach(function (e) {\r\n        if (e.entityAspect.entityState === EntityState.Detached) {\r\n          throw new Error(\"Unable to export an entity with an EntityState of 'Detached'\");\r\n        }\r\n        let group = entityGroupMap[e.entityType.name];\r\n        if (!group) {\r\n          group = {} as EntityGroup;\r\n          group.entityType = e.entityType;\r\n          group._entities = [];\r\n          entityGroupMap[e.entityType.name] = group;\r\n        }\r\n        group._entities.push(e);\r\n      });\r\n    } else {\r\n      // assume \"entities\" is an array of EntityTypes (or names)\r\n      let entityTypes = checkEntityTypes(em, entitiesOrEntityTypes as EntityType[] | string[]) as EntityType[];\r\n      if (entityTypes != null) {\r\n        entityTypes.forEach((et) => {\r\n          let group = em._entityGroupMap[et.name];\r\n          if (group && group._entities.length) {\r\n            entityGroupMap[et.name] = group;\r\n          }\r\n        });\r\n      }\r\n    }\r\n  } else if (entitiesOrEntityTypes && entitiesOrEntityTypes.length === 0) {\r\n    // empty array = export nothing\r\n    entityGroupMap = {};\r\n  } else {\r\n    entityGroupMap = em._entityGroupMap;\r\n  }\r\n\r\n  let tempKeys: ITempKey[] = [];\r\n  let newGroupMap = {};\r\n  core.objectForEach(entityGroupMap, (entityTypeName, entityGroup) => {\r\n    newGroupMap[entityTypeName] = exportEntityGroup(entityGroup, tempKeys);\r\n  });\r\n\r\n  return { entityGroupMap: newGroupMap, tempKeys: tempKeys };\r\n}\r\n\r\nfunction exportEntityGroup(entityGroup: EntityGroup, tempKeys: ITempKey[]) {\r\n  let resultGroup = {} as { entities: any[] };\r\n  let entityType = entityGroup.entityType;\r\n  let dps = entityType.dataProperties;\r\n  let serializerFn = getSerializerFn(entityType);\r\n  let rawEntities: any[] = [];\r\n  entityGroup._entities.forEach((entity) => {\r\n    if (entity) {\r\n      let rawEntity = structuralObjectToJson(entity, dps, serializerFn, tempKeys);\r\n      rawEntities.push(rawEntity);\r\n    }\r\n  });\r\n  resultGroup.entities = rawEntities;\r\n  return resultGroup;\r\n}\r\n\r\nfunction structuralObjectToJson(so: StructuralObject, dps: DataProperty[], serializerFn?: (dp: DataProperty, value: any) => any, tempKeys?: ITempKey[]) {\r\n\r\n  let result = {};\r\n  dps.forEach(function (dp) {\r\n    let dpName = dp.name;\r\n    let value = so.getProperty(dpName);\r\n    if (value == null && dp.defaultValue == null) return;\r\n\r\n    if (value && dp.isComplexProperty) {\r\n      let coDps = (dp.dataType as ComplexType).dataProperties;\r\n      value = core.map(value, function (v: ComplexObject) {\r\n        return structuralObjectToJson(v, coDps, serializerFn);\r\n      });\r\n    } else {\r\n      value = serializerFn ? serializerFn(dp, value) : value;\r\n      if (dp.isUnmapped) {\r\n        value = core.toJSONSafe(value, core.toJSONSafeReplacer);\r\n      }\r\n    }\r\n    if (value === undefined) return;\r\n    result[dpName] = value;\r\n  });\r\n\r\n  // if (so.entityAspect) {\r\n  if (EntityAspect.isEntity(so)) {\r\n    let aspect = so.entityAspect;\r\n    let entityState = aspect.entityState;\r\n    let newAspect = {\r\n      tempNavPropNames: exportTempKeyInfo(aspect, tempKeys || []),\r\n      entityState: entityState.name\r\n    } as any;\r\n    if (aspect.extraMetadata) {\r\n      newAspect.extraMetadata = aspect.extraMetadata;\r\n    }\r\n    if (entityState.isModified() || entityState.isDeleted()) {\r\n      newAspect.originalValuesMap = aspect.originalValues;\r\n    }\r\n    (result as any).entityAspect = newAspect;\r\n  } else {\r\n    let aspect = so.complexAspect;\r\n    let newAspect = {} as any;\r\n    if (aspect.originalValues && !core.isEmpty(aspect.originalValues)) {\r\n      newAspect.originalValuesMap = aspect.originalValues;\r\n    }\r\n\r\n    (result as any).complexAspect = newAspect;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\ninterface ITempKey {\r\n  entityType: string;\r\n  values: any[];\r\n}\r\n\r\nfunction exportTempKeyInfo(entityAspect: EntityAspect, tempKeys: ITempKey[]) {\r\n  let entity = entityAspect.entity as Entity;\r\n  if (entityAspect.hasTempKey) {\r\n    tempKeys.push(entityAspect.getKey().toJSON());\r\n  }\r\n  // create map for this entity with foreignKeys that are 'temporary'\r\n  // map -> key: tempKey, value: fkPropName\r\n  let tempNavPropNames: string[] = [];\r\n  entity.entityType.navigationProperties.forEach(function (np) {\r\n    if (np.relatedDataProperties) {\r\n      let relatedValue = entity.getProperty(np.name);\r\n      if (relatedValue && relatedValue.entityAspect.hasTempKey) {\r\n        tempNavPropNames.push(np.name);\r\n      }\r\n    }\r\n  });\r\n  return tempNavPropNames;\r\n}\r\n\r\nfunction importEntityGroup(entityGroup: EntityGroup, jsonGroup: { entities: any[] }, importConfig: ImportConfigExt) {\r\n\r\n  let tempKeyMap = importConfig.tempKeyMap;\r\n  let mergeAdds = !!importConfig.mergeAdds;\r\n\r\n  let entityType = entityGroup.entityType;\r\n  let mergeStrategy = importConfig.mergeStrategy;\r\n\r\n  let targetEntity: Entity | undefined;\r\n\r\n  let em = entityGroup.entityManager;\r\n  let entityChanged = em.entityChanged;\r\n  let entitiesToLink: Entity[] = [];\r\n  let rawValueFn = DataProperty.getRawValueFromClient;\r\n  jsonGroup.entities.forEach(function (rawEntity: any) {\r\n    let newAspect = rawEntity.entityAspect;\r\n\r\n    let entityKey = entityType.getEntityKeyFromRawEntity(rawEntity, rawValueFn);\r\n    let entityState = EntityState.fromName(newAspect.entityState) as EntityState;\r\n    if (!entityState || entityState === EntityState.Detached) {\r\n      throw new Error(\"Only entities with a non detached entity state may be imported.\");\r\n    }\r\n\r\n    // Merge if raw entity is in cache UNLESS this is a new entity w/ a temp key\r\n    // Cannot safely merge such entities even if could match temp key to an entity in cache.\r\n    // Can enable merge of entities w/temp key using \"mergeAdds\" - use at your own risk!\r\n    let newTempKey = !mergeAdds && entityState.isAdded() && getMappedKey(tempKeyMap!, entityKey);\r\n    targetEntity = newTempKey ? undefined : entityGroup.findEntityByKey(entityKey);\r\n\r\n    if (targetEntity) {\r\n      if (mergeStrategy === MergeStrategy.SkipMerge) {\r\n        // deliberate fall thru\r\n      } else if (mergeStrategy === MergeStrategy.Disallowed) {\r\n        throw new Error(\"A MergeStrategy of 'Disallowed' prevents \" + entityKey.toString() + \" from being merged\");\r\n      } else {\r\n        let targetEntityState = targetEntity.entityAspect.entityState;\r\n        let wasUnchanged = targetEntityState.isUnchanged();\r\n        if (mergeStrategy === MergeStrategy.OverwriteChanges || wasUnchanged) {\r\n          entityType._updateTargetFromRaw(targetEntity, rawEntity, rawValueFn);\r\n          targetEntity.entityAspect.setEntityState(entityState);\r\n          entityChanged.publish({ entityAction: EntityAction.MergeOnImport, entity: targetEntity });\r\n        }\r\n      }\r\n    } else {\r\n      targetEntity = entityType._createInstanceCore() as Entity;\r\n      entityType._updateTargetFromRaw(targetEntity, rawEntity, rawValueFn);\r\n      if (newTempKey) {\r\n        targetEntity.entityAspect.hasTempKey = true;\r\n        // fixup pk\r\n        targetEntity.setProperty(entityType.keyProperties[0].name, newTempKey.values[0]);\r\n\r\n        // fixup foreign keys\r\n        // This is safe because the entity is detached here and therefore originalValues will not be updated.\r\n        if (newAspect.tempNavPropNames) {\r\n          newAspect.tempNavPropNames.forEach(function (npName: string) {\r\n            let np = entityType.getNavigationProperty(npName);\r\n            let fkPropName = np!.relatedDataProperties[0].name;\r\n            let oldFkValue = targetEntity!.getProperty(fkPropName);\r\n            let fk = new EntityKey(np!.entityType, [oldFkValue]);\r\n            let newFk = getMappedKey(tempKeyMap!, fk);\r\n            targetEntity!.setProperty(fkPropName, newFk!.values[0]);\r\n          });\r\n        }\r\n      }\r\n      // Now performed in attachEntity\r\n      targetEntity = entityGroup.attachEntity(targetEntity, entityState);\r\n      entityChanged.publish({ entityAction: EntityAction.AttachOnImport, entity: targetEntity });\r\n      if (!entityState.isUnchanged()) {\r\n        em._notifyStateChange(targetEntity, true);\r\n      }\r\n    }\r\n\r\n    entitiesToLink.push(targetEntity);\r\n  });\r\n  return entitiesToLink;\r\n}\r\n\r\nfunction getMappedKey(tempKeyMap: ITempKeyMap, entityKey: EntityKey) {\r\n  let newKey = tempKeyMap[entityKey.toString()];\r\n  if (newKey) return newKey;\r\n  let subtypes = entityKey._subtypes;\r\n  if (!subtypes) return null;\r\n  for (let i = 0, j = subtypes.length; i < j; i++) {\r\n    newKey = tempKeyMap[entityKey.toString(subtypes[i])];\r\n    if (newKey) return newKey;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction promiseWithCallbacks<T>(promise: Promise<T>, callback?: Callback, errorCallback?: ErrorCallback) {\r\n  promise = promise.then(function (data) {\r\n    if (callback) callback(data);\r\n    return Promise.resolve(data);\r\n  }, function (error) {\r\n    if (errorCallback) errorCallback(error);\r\n    return Promise.reject(error);\r\n  });\r\n  return promise;\r\n}\r\n\r\nfunction getEntitiesToSave(em: EntityManager, entities?: Entity[]) {\r\n  let entitiesToSave: Entity[];\r\n  if (entities) {\r\n    entitiesToSave = entities.filter(function (e) {\r\n      if (e.entityAspect.entityManager !== em) {\r\n        throw new Error(\"Only entities in this entityManager may be saved\");\r\n      }\r\n      return !e.entityAspect.entityState.isDetached();\r\n    });\r\n  } else {\r\n    entitiesToSave = em.getChanges();\r\n  }\r\n  return entitiesToSave;\r\n}\r\n\r\nfunction fixupKeys(em: EntityManager, keyMappings: KeyMapping[]) {\r\n  em._inKeyFixup = true;\r\n  keyMappings.forEach(function (km) {\r\n    let group = em._entityGroupMap[km.entityTypeName];\r\n    if (!group) {\r\n      throw new Error(\"Unable to locate the following fully qualified EntityType name: \" + km.entityTypeName);\r\n    }\r\n    group._fixupKey(km.tempValue, km.realValue);\r\n  });\r\n  em._inKeyFixup = false;\r\n}\r\n\r\nfunction getEntityGroups(em: EntityManager, entityTypes?: EntityType | EntityType[]) {\r\n  let groupMap = em._entityGroupMap;\r\n  if (entityTypes) {\r\n    return core.toArray(entityTypes).map(function (et: EntityType) {\r\n      if (et instanceof EntityType) {\r\n        return groupMap[et.name];\r\n      } else {\r\n        throw new Error(\"The EntityManager.getChanges() 'entityTypes' parameter must be either an entityType or an array of entityTypes or null\");\r\n      }\r\n    });\r\n  } else {\r\n    return core.getOwnPropertyValues(groupMap) as EntityGroup[];\r\n  }\r\n}\r\n\r\nfunction checkEntityKey(em: EntityManager, entity: Entity) {\r\n  let ek = entity.entityAspect.getKey();\r\n  // return properties that are = to defaultValues\r\n  let keyPropsWithDefaultValues = core.arrayZip(entity.entityType.keyProperties, ek.values, function (kp, kv) {\r\n    return (kp.defaultValue === kv) ? kp : null;\r\n  }).filter(function (kp) {\r\n    return kp !== null;\r\n  });\r\n  if (keyPropsWithDefaultValues.length) {\r\n    if (entity.entityType.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {\r\n      em.generateTempKeyValue(entity);\r\n    } else {\r\n      // we will allow attaches of entities where only part of the key is set.\r\n      if (keyPropsWithDefaultValues.length === ek.values.length) {\r\n        throw new Error(\"Cannot attach an object of type  (\" + entity.entityType.name + \") to an EntityManager without first setting its key or setting its entityType 'AutoGeneratedKeyType' property to something other than 'None'\");\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction validateEntityStates(em: EntityManager, entityStates?: EntityState | EntityState[]) {\r\n  if (!entityStates) return [] as EntityState[];\r\n  let entStates = core.toArray(entityStates) as EntityState[];\r\n  entStates.forEach((es) => {\r\n    if (!(es instanceof EntityState)) {\r\n      throw new Error(\"The EntityManager.getChanges() 'entityStates' parameter must either be null, an entityState or an array of entityStates\");\r\n    }\r\n  });\r\n  return entStates;\r\n}\r\n\r\nfunction attachRelatedEntities(em: EntityManager, entity: Entity, entityState: EntityState, mergeStrategy: MergeStrategy) {\r\n  let navProps = entity.entityType.navigationProperties;\r\n  navProps.forEach(function (np) {\r\n    let related = entity.getProperty(np.name);\r\n    if (np.isScalar) {\r\n      if (!related) return;\r\n      em.attachEntity(related, entityState, mergeStrategy);\r\n    } else {\r\n      related.forEach(function (e: Entity) {\r\n        em.attachEntity(e, entityState, mergeStrategy);\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\n// returns a promise\r\nfunction executeQueryCore(em: EntityManager, query: EntityQuery | string, queryOptions: QueryOptions, dataService: DataService): Promise<QueryResult> {\r\n  try {\r\n    let results: any[];\r\n    let metadataStore = em.metadataStore;\r\n\r\n    if (metadataStore.isEmpty() && dataService.hasServerMetadata) {\r\n      throw new Error(\"cannot execute _executeQueryCore until metadataStore is populated.\");\r\n    }\r\n\r\n    if (queryOptions.fetchStrategy === FetchStrategy.FromLocalCache) {\r\n      try {\r\n        if (typeof query === 'string') {\r\n          throw new Error(\"cannot execute 'string' EntityQuery locally.\");\r\n        }\r\n        let qr = executeQueryLocallyCore(em, query);\r\n        return Promise.resolve({ results: qr.results, entityManager: em, inlineCount: qr.inlineCount, query: query });\r\n      } catch (e) {\r\n        return Promise.reject(e);\r\n      }\r\n    }\r\n\r\n    let mappingContext: MappingContext | undefined = new MappingContext({\r\n      query: query,\r\n      entityManager: em,\r\n      dataService: dataService,\r\n      mergeOptions: {\r\n        mergeStrategy: queryOptions.mergeStrategy,\r\n        noTracking: !!(query as any).noTrackingEnabled,\r\n        includeDeleted: queryOptions.includeDeleted\r\n      }\r\n    });\r\n\r\n    let validateOnQuery = em.validationOptions.validateOnQuery;\r\n\r\n    return dataService.adapterInstance!.executeQuery(mappingContext).then(function (data: any) {\r\n      let result = core.wrapExecution(function () {\r\n        let state = { isLoading: em.isLoading };\r\n        em.isLoading = true;\r\n        em._pendingPubs = [];\r\n        return state;\r\n      }, function (state) {\r\n        // cleanup\r\n        em.isLoading = state.isLoading;\r\n        em._pendingPubs!.forEach(function (fn) {\r\n          fn();\r\n        });\r\n        em._pendingPubs = undefined;\r\n        em._hasChangesAction && em._hasChangesAction();\r\n        // TODO: removed - not sure why needed in first place...\r\n        // // HACK for GC\r\n        // query = undefined;\r\n        mappingContext = undefined;\r\n        // HACK: some errors thrown in next function do not propogate properly - this catches them.\r\n\r\n        if (state.error) {\r\n          return Promise.reject(state.error);\r\n        }\r\n\r\n      }, function () {\r\n        let nodes = dataService.jsonResultsAdapter.extractResults(data);\r\n        nodes = core.toArray(nodes);\r\n\r\n        results = mappingContext!.visitAndMerge(nodes, { nodeType: \"root\" });\r\n        if (validateOnQuery) {\r\n          results.forEach(function (r: any) {\r\n            // anon types and simple types will not have an entityAspect.\r\n            r.entityAspect && r.entityAspect.validateEntity();\r\n          });\r\n        }\r\n        mappingContext!.processDeferred();\r\n        // if query has expand clauses walk each of the 'results' and mark the expanded props as loaded.\r\n        if (query instanceof EntityQuery) {\r\n          markLoadedNavProps(results, query);\r\n        }\r\n        let retrievedEntities = core.objectMap(mappingContext!.refMap);\r\n        return { results: results, query: query, entityManager: em, httpResponse: data.httpResponse, inlineCount: data.inlineCount, retrievedEntities: retrievedEntities };\r\n      });\r\n      return Promise.resolve(result);\r\n    }, function (e: any) {\r\n      if (e) {\r\n        e.query = query;\r\n        e.entityManager = em;\r\n      }\r\n      return Promise.reject(e);\r\n    });\r\n\r\n  } catch (e) {\r\n    if (e) {\r\n      e.query = query;\r\n    }\r\n    return Promise.reject(e);\r\n  }\r\n}\r\n\r\nfunction markLoadedNavProps(entities: Entity[], query: EntityQuery) {\r\n  if (query.noTrackingEnabled) return;\r\n  let expandClause = query.expandClause;\r\n  if (expandClause == null) return;\r\n  expandClause.propertyPaths.forEach(function (propertyPath) {\r\n    let propNames = propertyPath.split('.');\r\n    markLoadedNavPath(entities, propNames);\r\n  });\r\n}\r\n\r\nfunction markLoadedNavPath(entities: Entity[], propNames: string[]) {\r\n  let propName = propNames[0];\r\n  entities.forEach((entity) => {\r\n    let ea = entity.entityAspect;\r\n    if (!ea) return; // entity may not be a 'real' entity in the case of a projection.\r\n    ea._markAsLoaded(propName);\r\n    if (propNames.length === 1) return;\r\n    let next = entity.getProperty(propName);\r\n    if (!next) return; // no children to process.\r\n    // strange logic because nonscalar nav values are NOT really arrays\r\n    // otherwise we could use Array.isArray\r\n    if (!next.arrayChanged) next = [next];\r\n    markLoadedNavPath(next, propNames.slice(1));\r\n  });\r\n}\r\n\r\nfunction updateConcurrencyProperties(entities: Entity[]) {\r\n  let candidates = entities.filter((e) => {\r\n    e.entityAspect.isBeingSaved = true;\r\n    return e.entityAspect.entityState.isModified()\r\n      && e.entityType.concurrencyProperties.length > 0;\r\n\r\n  });\r\n  if (candidates.length === 0) return;\r\n  candidates.forEach(function (c) {\r\n    c.entityType.concurrencyProperties.forEach(function (cp) {\r\n      updateConcurrencyProperty(c, cp);\r\n    });\r\n  });\r\n}\r\n\r\nfunction updateConcurrencyProperty(entity: Entity, property: DataProperty) {\r\n  // check if property has already been updated\r\n  if (entity.entityAspect.originalValues[property.name]) return;\r\n  let value = entity.getProperty(property.name);\r\n  let dataType = property.dataType as DataType;\r\n  if (!value) value = dataType.defaultValue;\r\n  if (dataType.isNumeric) {\r\n    entity.setProperty(property.name, value + 1);\r\n  } else if (dataType.getConcurrencyValue) {\r\n    // DataType has its own implementation\r\n    let nextValue = dataType.getConcurrencyValue(value);\r\n    entity.setProperty(property.name, nextValue);\r\n  } else if (dataType === DataType.Binary) {\r\n    // best guess - that this is a timestamp column and is computed on the server during save\r\n    // - so no need to set it here.\r\n    return;\r\n  } else {\r\n    // this just leaves DataTypes of Boolean, String and Byte - none of which should be the\r\n    // type for a concurrency column.\r\n    // NOTE: thought about just returning here but would rather be safe for now.\r\n    throw new Error(\"Unable to update the value of concurrency property before saving: \" + property.name);\r\n  }\r\n}\r\n\r\n\r\nfunction findOrCreateEntityGroup(em: EntityManager, entityType: EntityType) {\r\n  let group = em._entityGroupMap[entityType.name];\r\n  if (!group) {\r\n    group = new EntityGroup(em, entityType);\r\n    em._entityGroupMap[entityType.name] = group;\r\n  }\r\n  return group;\r\n}\r\n\r\nfunction findOrCreateEntityGroups(em: EntityManager, entityType: EntityType) {\r\n  let entityTypes = entityType.getSelfAndSubtypes();\r\n  return entityTypes.map((et) => {\r\n    return findOrCreateEntityGroup(em, et);\r\n  });\r\n}\r\n\r\nfunction unwrapInstance(structObj: StructuralObject, transformFn?: (dp: DataProperty, val: any) => any) {\r\n\r\n  let rawObject: any = {};\r\n  let stype = EntityAspect.isEntity(structObj) ? structObj.entityType : structObj.complexType;\r\n  let serializerFn = getSerializerFn(stype);\r\n  let unmapped = {};\r\n  stype.dataProperties.forEach(function (dp) {\r\n    if (dp.isComplexProperty) {\r\n      rawObject[dp.nameOnServer] = core.map(structObj.getProperty(dp.name), function (co) {\r\n        return unwrapInstance(co, transformFn);\r\n      });\r\n    } else {\r\n      let val = structObj.getProperty(dp.name);\r\n      val = transformFn ? transformFn(dp, val) : val;\r\n      if (val === undefined) return;\r\n      val = serializerFn ? serializerFn(dp, val) : val;\r\n      if (val !== undefined) {\r\n        if (dp.isUnmapped) {\r\n          unmapped[dp.nameOnServer] = core.toJSONSafe(val, core.toJSONSafeReplacer);\r\n        } else {\r\n          rawObject[dp.nameOnServer] = val;\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  if (!core.isEmpty(unmapped)) {\r\n    // TODO: review this.\r\n    (rawObject as any).__unmapped = unmapped;\r\n  }\r\n  return rawObject;\r\n}\r\n\r\nfunction unwrapOriginalValues(target: StructuralObject, metadataStore: MetadataStore, transformFn?: (dp: DataProperty, val: any) => any) {\r\n  let stype = EntityAspect.isEntity(target) ? target.entityType : target.complexType;\r\n  let aspect = EntityAspect.isEntity(target) ? target.entityAspect : target.complexAspect;\r\n  let fn = metadataStore.namingConvention.clientPropertyNameToServer;\r\n  let result = {};\r\n  core.objectForEach(aspect.originalValues, function (propName, val) {\r\n    let prop = stype.getProperty(propName) as DataProperty;\r\n    val = transformFn ? transformFn(prop, val) : val;\r\n    if (val !== undefined) {\r\n      result[fn(propName, prop)] = val;\r\n    }\r\n  });\r\n  stype.complexProperties.forEach(function (cp) {\r\n    let nextTarget = target.getProperty(cp.name);\r\n    if (cp.isScalar) {\r\n      let unwrappedCo = unwrapOriginalValues(nextTarget, metadataStore, transformFn);\r\n      if (!core.isEmpty(unwrappedCo)) {\r\n        result[fn(cp.name, cp)] = unwrappedCo;\r\n      }\r\n    } else {\r\n      let unwrappedCos = nextTarget.map((item: any) => {\r\n        return unwrapOriginalValues(item, metadataStore, transformFn);\r\n      });\r\n      result[fn(cp.name, cp)] = unwrappedCos;\r\n    }\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction unwrapChangedValues(entity: Entity, metadataStore: MetadataStore, transformFn: (dp: DataProperty, val: any) => any) {\r\n  let stype = entity.entityType;\r\n  let serializerFn = getSerializerFn(stype);\r\n  let fn = metadataStore.namingConvention.clientPropertyNameToServer;\r\n  let result = {};\r\n  core.objectForEach(entity.entityAspect.originalValues, function (propName, value) {\r\n    let prop = stype.getProperty(propName) as DataProperty;\r\n    let val = entity.getProperty(propName);\r\n    val = transformFn ? transformFn(prop, val) : val;\r\n    if (val === undefined) return;\r\n    val = serializerFn ? serializerFn(prop, val) : val;\r\n    if (val !== undefined) {\r\n      result[fn(propName, prop)] = val;\r\n    }\r\n  });\r\n  // any change to any complex object or array of complex objects returns the ENTIRE\r\n  // current complex object or complex object array.  This is by design. Complex Objects\r\n  // are atomic.\r\n  stype.complexProperties.forEach((cp) => {\r\n    if (cpHasOriginalValues(entity, cp)) {\r\n      let coOrCos = entity.getProperty(cp.name);\r\n      result[fn(cp.name, cp)] = core.map(coOrCos, function (co) {\r\n        return unwrapInstance(co, transformFn);\r\n      });\r\n    }\r\n  });\r\n  return result;\r\n}\r\n\r\nfunction cpHasOriginalValues(structuralObject: StructuralObject, cp: DataProperty): boolean {\r\n  let coOrCos = structuralObject.getProperty(cp.name);\r\n  if (cp.isScalar) {\r\n    return coHasOriginalValues(coOrCos);\r\n  } else {\r\n    // this occurs when a nonscalar co array has had cos added or removed.\r\n    if (coOrCos._origValues) return true;\r\n    return coOrCos.some(function (co: ComplexObject) {\r\n      return coHasOriginalValues(co);\r\n    });\r\n  }\r\n}\r\n\r\nfunction executeQueryLocallyCore(em: EntityManager, query: EntityQuery) {\r\n  assertParam(query, \"query\").isInstanceOf(EntityQuery).check();\r\n\r\n  let metadataStore = em.metadataStore;\r\n  let entityType = query._getFromEntityType(metadataStore, true);\r\n  // there may be multiple groups is this is a base entity type.\r\n  let groups = findOrCreateEntityGroups(em, entityType!);\r\n  // filter then order then skip then take\r\n  let filterFunc = query.wherePredicate && query.wherePredicate.toFunction({ entityType: entityType });\r\n\r\n  let queryOptions = QueryOptions.resolve([query.queryOptions, em.queryOptions, QueryOptions.defaultInstance]);\r\n  let includeDeleted = queryOptions.includeDeleted === true;\r\n\r\n  let newFilterFunc = function (entity: Entity) {\r\n    return entity && (includeDeleted || !entity.entityAspect.entityState.isDeleted()) && (filterFunc ? filterFunc(entity) : true);\r\n  };\r\n\r\n  let result: any[] = [];\r\n  // TODO: mapMany\r\n  groups.forEach((group) => {\r\n    let entities = group._entities.filter(newFilterFunc) as Entity[];\r\n    if (entities.length) {\r\n      result = result.length ? result.concat(entities) : entities;\r\n    }\r\n  });\r\n\r\n  let orderByComparer = query.orderByClause && query.orderByClause.getComparer(entityType!);\r\n  if (orderByComparer) {\r\n    result.sort(orderByComparer);\r\n  }\r\n\r\n  let inlineCount = query.inlineCountEnabled ? result.length : undefined;\r\n\r\n  let skipCount = query.skipCount;\r\n  if (skipCount) {\r\n    result = result.slice(skipCount);\r\n  }\r\n  let takeCount = query.takeCount;\r\n  if (takeCount) {\r\n    result = result.slice(0, takeCount);\r\n  }\r\n\r\n  let selectClause = query.selectClause;\r\n  if (selectClause) {\r\n    let selectFn = selectClause.toFunction();\r\n    result = result.map(selectFn);\r\n  }\r\n  return { results: result, inlineCount: inlineCount };\r\n}\r\n\r\nfunction coHasOriginalValues(co: ComplexObject) {\r\n  // next line checks all non complex properties of the co.\r\n  if (!core.isEmpty(co.complexAspect.originalValues)) return true;\r\n  // now need to recursively check each of the cps\r\n  return co.complexType.complexProperties.some(function (cp) {\r\n    return cpHasOriginalValues(co, cp);\r\n  });\r\n}\r\n\r\nfunction getSerializerFn(stype: EntityType | ComplexType) {\r\n  return stype.serializerFn || (stype.metadataStore && stype.metadataStore.serializerFn);\r\n}\r\n\r\n","import { core } from './core';\r\nimport { assertConfig } from './assert-param';\r\nimport { config, InterfaceDef, BaseAdapter } from './config';\r\nimport { MappingContext } from './mapping-context';\r\nimport { EntityQuery } from './entity-query';\r\nimport { MetadataStore } from './entity-metadata';\r\nimport { JsonResultsAdapter, DataService } from './data-service';\r\nimport { Entity } from './entity-aspect';\r\nimport { SaveContext, SaveBundle, QueryResult, SaveResult, HttpResponse } from './entity-manager';\r\n\r\nexport interface InterfaceRegistryConfig {\r\n    ajax?: InterfaceDef<AjaxAdapter>;\r\n    modelLibrary?: InterfaceDef<ModelLibraryAdapter>;\r\n    dataService?: InterfaceDef<DataServiceAdapter>;\r\n    uriBuilder?: InterfaceDef<UriBuilderAdapter>;\r\n}\r\n\r\nexport class InterfaceRegistry {\r\n    ajax = new InterfaceDef<AjaxAdapter>(\"ajax\");\r\n    modelLibrary = new InterfaceDef<ModelLibraryAdapter>(\"modelLibrary\");\r\n    dataService = new InterfaceDef<DataServiceAdapter>(\"dataService\");\r\n    uriBuilder = new InterfaceDef<UriBuilderAdapter>(\"uriBuilder\");\r\n}\r\n\r\n// This module describes the interfaceRegistry by extending config\r\n/** @hidden @internal */\r\ndeclare module \"./config\" {\r\n    interface BreezeConfig {\r\n        /**\r\n        Initializes a collection of adapter implementations and makes each one the default for its corresponding interface.\r\n        @method initializeAdapterInstances\r\n        @param config {Object}\r\n        @param [config.ajax] {String} - the name of a previously registered \"ajax\" adapter\r\n        @param [config.dataService] {String} - the name of a previously registered \"dataService\" adapter\r\n        @param [config.modelLibrary] {String} - the name of a previously registered \"modelLibrary\" adapter\r\n        @param [config.uriBuilder] {String} - the name of a previously registered \"uriBuilder\" adapter\r\n        @return [array of instances]\r\n        **/\r\n        initializeAdapterInstances(irConfig: InterfaceRegistryConfig): void;\r\n\r\n        // strongly typed version\r\n        interfaceRegistry: InterfaceRegistry;\r\n    }\r\n}\r\n\r\nconfig.interfaceRegistry = new InterfaceRegistry();\r\nconfig._interfaceRegistry = config.interfaceRegistry;\r\nconfig.interfaceRegistry.modelLibrary.getDefaultInstance = function() {\r\n    if (!this.defaultInstance) {\r\n        throw new Error(\"Unable to locate the default implementation of the '\" + this.name +\r\n            \"' interface.  Possible options are 'ko', 'backingStore' or 'backbone'. See the breeze.config.initializeAdapterInstances method.\");\r\n    }\r\n    return this.defaultInstance;\r\n};\r\n\r\n/**\r\nInitializes a collection of adapter implementations and makes each one the default for its corresponding interface.\r\n@method initializeAdapterInstances\r\n@param config {Object}\r\n@param [config.ajax] {String} - the name of a previously registered \"ajax\" adapter\r\n@param [config.dataService] {String} - the name of a previously registered \"dataService\" adapter\r\n@param [config.modelLibrary] {String} - the name of a previously registered \"modelLibrary\" adapter\r\n@param [config.uriBuilder] {String} - the name of a previously registered \"uriBuilder\" adapter\r\n@return [array of instances]\r\n**/\r\nconfig.initializeAdapterInstances = function (irConfig: InterfaceRegistryConfig) {\r\n    assertConfig(irConfig)\r\n        .whereParam(\"dataService\").isOptional()\r\n        .whereParam(\"modelLibrary\").isOptional()\r\n        .whereParam(\"ajax\").isOptional()\r\n        .whereParam(\"uriBuilder\").isOptional()\r\n        .applyAll(this, false);\r\n    return core.objectMap(config, this.initializeAdapterInstance);\r\n};\r\n\r\n/** DataServiceAdapter Ajax request configuration */\r\nexport interface AjaxConfig {\r\n    url: string;\r\n    type?: string;\r\n    dataType?: string;\r\n    contentType?: string;\r\n    crossDomain?: string | boolean;\r\n    headers?: {};\r\n    data?: any;\r\n    params?: {};\r\n    success: (res: HttpResponse) => void;\r\n    error: (res: (HttpResponse | Error)) => void;\r\n}\r\n\r\nexport interface AjaxAdapter extends BaseAdapter {\r\n    ajax(config: AjaxConfig): void;\r\n}\r\n\r\nexport interface ModelLibraryAdapter extends BaseAdapter {\r\n    getTrackablePropertyNames: (entity: any) => string[];\r\n    initializeEntityPrototype(proto: Object): void;\r\n    startTracking(entity: any, entityCtor: Function): void;\r\n    createCtor?: Function;\r\n}\r\n\r\nexport interface DataServiceAdapter extends BaseAdapter {\r\n    fetchMetadata(metadataStore: MetadataStore, dataService: DataService): Promise<any>;  // result of Promise is either rawMetadata or a string explaining why not.\r\n    executeQuery(mappingContext: MappingContext): Promise<QueryResult>;   // result of executeQuery will get passed to JsonResultsAdapter extractResults method\r\n    saveChanges(saveContext: SaveContext, saveBundle: SaveBundle): Promise<SaveResult>;\r\n    changeRequestInterceptor: ChangeRequestInterceptorCtor;\r\n    jsonResultsAdapter: JsonResultsAdapter;\r\n}\r\n\r\n\r\n\r\nexport interface UriBuilderAdapter extends BaseAdapter {\r\n    buildUri(query: EntityQuery, metadataStore: MetadataStore): string;\r\n}\r\n\r\n// -----------------------------------\r\n\r\nexport interface ChangeRequestInterceptorCtor {\r\n    new (saveContext: SaveContext, saveBundle: SaveBundle): ChangeRequestInterceptor;\r\n}\r\n\r\nexport interface ChangeRequestInterceptor {\r\n    oneTime?: boolean;\r\n    /**\r\n     Prepare and return the save data for an entity change-set.\r\n  \r\n     The adapter calls this method for each entity in the change-set,\r\n     after it has prepared a \"change request\" for that object.\r\n  \r\n     The method can do anything to the request but it must return a valid, non-null request.\r\n     @example\r\n     this.getRequest = function (request, entity, index) {\r\n            // alter the request that the adapter prepared for this entity\r\n            // based on the entity, saveContext, and saveBundle\r\n            // e.g., add a custom header or prune the originalValuesMap\r\n            return request;\r\n        };\r\n     @method getRequest\r\n     @param request {Object} The object representing the adapter's request to save this entity.\r\n     @param entity {Entity} The entity-to-be-save as it is in cache\r\n     @param index {Integer} The zero-based index of this entity in the change-set array\r\n     @return {Function} The potentially revised request.\r\n     **/\r\n    getRequest(request: any, entity: Entity, index: number): any;\r\n\r\n    /**\r\n     Last chance to change anything about the 'requests' array\r\n     after it has been built with requests for all of the entities-to-be-saved.\r\n  \r\n     The 'requests' array is the same as 'saveBundle.entities' in many implementations\r\n  \r\n     This method can do anything to the array including add and remove requests.\r\n     It's up to you to ensure that server will accept the requests array data as valid.\r\n  \r\n     Returned value is ignored.\r\n     @example\r\n     this.done = function (requests) {\r\n            // alter the array of requests representing the entire change-set\r\n            // based on the saveContext and saveBundle\r\n        };\r\n     @method done\r\n     @param requests {Array of Object} The adapter's array of request for this changeset.\r\n     **/\r\n    done(requests: Object[]): void;\r\n}","import { core } from './core';\r\nimport { BreezeEvent } from './event';\r\nimport { EntityAspect } from './entity-aspect';\r\nimport { DataProperty } from './entity-metadata';\r\n\r\n/** @hidden */\r\nexport interface ObservableArray {\r\n  push: (...args: any[]) => number;\r\n  _push: (...args: any[]) => number;\r\n  unshift: (...args: any[]) =>  number;\r\n  pop: () => any;\r\n  shift: () => any;\r\n  splice: (...args: any[]) => any[];\r\n  slice: (a: number, b?: number) => any[]; // implemented on the native array\r\n  length: number;\r\n  \r\n  getEntityAspect: () => EntityAspect;\r\n  arrayChanged: BreezeEvent<ArrayChangedArgs>;\r\n  parent?: Object;\r\n  parentProperty?: DataProperty;\r\n  _getEventParent: () => Object;\r\n  _getPendingPubs: () => any[]; // TODO: Pub[]\r\n  _beforeChange: () => void;\r\n  _processAdds(items: any[]): void;\r\n  _processRemoves(items: any[]): void;\r\n  _origValues: any[];\r\n  _pendingArgs: any;\r\n}\r\n\r\nexport interface ArrayChangedArgs {\r\n  array: any[];\r\n  added?: any[]; \r\n  removed?: any[];\r\n}\r\n\r\nlet mixin = {\r\n  push: function(...args: any[]) {\r\n    if (this._inProgress) {\r\n      return -1;\r\n    }\r\n\r\n    let goodAdds = this._getGoodAdds(args);\r\n    if (!goodAdds.length) {\r\n      return this.length;\r\n    }\r\n    this._beforeChange();\r\n    let result;\r\n    let objPrototype = Object.getPrototypeOf(this);\r\n    if (objPrototype.push) {\r\n        result = objPrototype.push.apply(this, goodAdds);\r\n    } else {\r\n        result = Array.prototype.push.apply(this, goodAdds);\r\n    }\r\n    processAdds(this, goodAdds);\r\n    return result;\r\n  },\r\n\r\n  _push: function(...args: any[]) {\r\n    if (this._inProgress) {\r\n      return -1;\r\n    }\r\n    let goodAdds = args;\r\n    this._beforeChange();\r\n    let result;\r\n    let objPrototype = Object.getPrototypeOf(this);\r\n    if (objPrototype.push) {\r\n        result = objPrototype.push.apply(this, goodAdds);\r\n    } else {\r\n        result = Array.prototype.push.apply(this, goodAdds);\r\n    }\r\n    processAdds(this, goodAdds);\r\n    return result;\r\n  },\r\n\r\n  unshift: function(...args: any[]) {\r\n    let goodAdds = this._getGoodAdds(args);\r\n    if (!goodAdds.length) {\r\n      return this.length;\r\n    }\r\n    this._beforeChange();\r\n    let result;\r\n    let objPrototype = Object.getPrototypeOf(this);\r\n    if (objPrototype.unshift) {\r\n        result = objPrototype.unshift.apply(this, goodAdds);\r\n    } else {\r\n        result = Array.prototype.unshift.apply(this, goodAdds);\r\n    }\r\n    processAdds(this, goodAdds);\r\n    return result;\r\n  },\r\n\r\n  pop: function() {\r\n    this._beforeChange();\r\n    let result;\r\n    let objPrototype = Object.getPrototypeOf(this);\r\n    if (objPrototype.pop) {\r\n        result = objPrototype.pop.apply(this);\r\n    } else {\r\n        result = Array.prototype.pop.apply(this);\r\n    }\r\n    processRemoves(this, [result]);\r\n    return result;\r\n  },\r\n\r\n  shift: function() {\r\n    this._beforeChange();\r\n    let result;\r\n    let objPrototype = Object.getPrototypeOf(this);\r\n    if (objPrototype.shift) {\r\n        result = objPrototype.shift.apply(this);\r\n    } else {\r\n        result = Array.prototype.shift.apply(this);\r\n    }    \r\n    processRemoves(this, [result]);\r\n    return result;\r\n  },\r\n\r\n  splice: function(...args: any[]) {\r\n    let goodAdds = this._getGoodAdds(core.arraySlice(args, 2));\r\n    let newArgs = core.arraySlice(args, 0, 2).concat(goodAdds);\r\n    this._beforeChange();\r\n    let result;\r\n    let objPrototype = Object.getPrototypeOf(this);\r\n    if (objPrototype.splice) {\r\n        result = objPrototype.splice.apply(this, newArgs);\r\n    } else {\r\n        result = Array.prototype.splice.apply(this, newArgs);\r\n    }\r\n    processRemoves(this, result);\r\n\r\n    if (goodAdds.length) {\r\n      processAdds(this, goodAdds);\r\n    }\r\n    return result;\r\n  },\r\n\r\n  getEntityAspect: function() {\r\n    return this.parent.entityAspect || this.parent.complexAspect.getEntityAspect();\r\n  },\r\n\r\n  _getEventParent: function() {\r\n    return this.getEntityAspect();\r\n  },\r\n\r\n  _getPendingPubs: function () {\r\n    let em = this.getEntityAspect().entityManager;\r\n    return em && em._pendingPubs;\r\n  },\r\n\r\n  _beforeChange:  function () {\r\n    // default is to do nothing\r\n  }\r\n};\r\n\r\nfunction updateEntityState(obsArray: ObservableArray) {\r\n  let entityAspect = obsArray.getEntityAspect();\r\n  if (entityAspect.entityState.isUnchanged()) {\r\n    entityAspect.setModified();\r\n  }\r\n  if (entityAspect.entityState.isModified() && !obsArray._origValues) {\r\n    obsArray._origValues = obsArray.slice(0);\r\n  }\r\n}\r\n\r\nfunction publish(publisher: ObservableArray, eventName: string, eventArgs: any) {\r\n  let pendingPubs = publisher._getPendingPubs();\r\n  if (pendingPubs) {\r\n    if (!publisher._pendingArgs) {\r\n      publisher._pendingArgs = eventArgs;\r\n      pendingPubs.push(function () {\r\n        publisher[eventName].publish(publisher._pendingArgs);\r\n        publisher._pendingArgs = null;\r\n      });\r\n    } else {\r\n      combineArgs(publisher._pendingArgs, eventArgs);\r\n    }\r\n  } else {\r\n    publisher[eventName].publish(eventArgs);\r\n  }\r\n}\r\n\r\nfunction initializeParent(obsArray: any, parent: Object, parentProperty: DataProperty) {\r\n  obsArray.parent = parent;\r\n  obsArray.parentProperty = parentProperty;\r\n}\r\n\r\nfunction processAdds(obsArray: ObservableArray, adds: any[]) {\r\n  obsArray._processAdds(adds);\r\n  // this is referencing the name of the method on the complexArray not the name of the event\r\n  //var args = { added: adds };\r\n  //args[obsArray._typeName] = obsArray;\r\n  publish(obsArray, \"arrayChanged\", { array: obsArray, added: adds });\r\n}\r\n\r\nfunction processRemoves(obsArray: ObservableArray, removes: any[]) {\r\n  obsArray._processRemoves(removes);\r\n  // this is referencing the name of the method on the array not the name of the event\r\n  publish(obsArray, \"arrayChanged\", { array: obsArray, removed: removes });\r\n}\r\n\r\n// TODO: see if this function already exists in core and can be imported.\r\nfunction combineArgs(target: Object, source: Object) {\r\n  for (let key in source) {\r\n    if (key !== \"array\" && target.hasOwnProperty(key)) {\r\n      let sourceValue = source[key];\r\n      let targetValue = target[key];\r\n      if (targetValue) {\r\n        if (!Array.isArray(targetValue)) {\r\n          throw new Error(\"Cannot combine non array args\");\r\n        }\r\n        Array.prototype.push.apply(targetValue, sourceValue);\r\n      } else {\r\n        target[key] = sourceValue;\r\n      }\r\n    }\r\n  }\r\n}\r\n/** @hidden @internal */\r\nexport const observableArray = {\r\n  mixin: mixin,\r\n  updateEntityState: updateEntityState,\r\n  publish: publish,\r\n  initializeParent: initializeParent\r\n};\r\n","import { core, Callback, ErrorCallback } from './core';\r\nimport { ObservableArray, observableArray } from './observable-array';\r\nimport { BreezeEvent } from './event';\r\nimport { Entity  } from './entity-aspect';\r\nimport { DataProperty, NavigationProperty } from './entity-metadata';\r\nimport { EntityState } from './entity-state';\r\nimport { EntityQuery } from './entity-query';\r\nimport { QuerySuccessCallback, QueryErrorCallback, QueryResult } from './entity-manager';\r\n\r\n// TODO: mixin impl is not very typesafe\r\n\r\nexport interface RelationArray extends ObservableArray {\r\n  [index: number]: Entity;\r\n  parentEntity: Entity;\r\n  parentProperty?: DataProperty;\r\n  navigationProperty: NavigationProperty;\r\n  _inProgress?: boolean;\r\n  _addsInProcess: Entity[];\r\n  load(querySuccessCallback?: QuerySuccessCallback, queryErrorCallback?: QueryErrorCallback): Promise<QueryResult>; \r\n}\r\n\r\nlet relationArrayMixin = {\r\n\r\n  /**\r\n  Relation arrays are not actually classes, they are objects that mimic arrays. A relation array is collection of\r\n  entities associated with a navigation property on a single entity. i.e. customer.orders or order.orderDetails.\r\n  This collection looks like an array in that the basic methods on arrays such as 'push', 'pop', 'shift', 'unshift', 'splice'\r\n  are all provided as well as several special purpose methods.\r\n  @class {relationArray}\r\n  **/\r\n\r\n  /**\r\n  An [[Event]] that fires whenever the contents of this array changed.  This event\r\n  is fired any time a new entity is attached or added to the EntityManager and happens to belong to this collection.\r\n  Adds that occur as a result of query or import operations are batched so that all of the adds or removes to any individual\r\n  collections are collected into a single notification event for each relation array.\r\n  @example\r\n      // assume order is an order entity attached to an EntityManager.\r\n      orders.arrayChanged.subscribe(\r\n      function (arrayChangedArgs) {\r\n          let addedEntities = arrayChangedArgs.added;\r\n          let removedEntities = arrayChanged.removed;\r\n      });\r\n  @event arrayChanged\r\n  @param added {Array of Entity} An array of all of the entities added to this collection.\r\n  @param removed {Array of Entity} An array of all of the removed from this collection.\r\n  @readOnly\r\n  **/\r\n\r\n\r\n  /**\r\n  Performs an asynchronous load of all other the entities associated with this relationArray.\r\n  @example\r\n      // assume orders is an empty, as yet unpopulated, relation array of orders\r\n      // associated with a specific customer.\r\n      orders.load().then(...)\r\n  @method load\r\n  @param [callback] {Function}\r\n  @param [errorCallback] {Function}\r\n  @return {Promise}\r\n  **/\r\n  load: function(callback?: QuerySuccessCallback, errorCallback?: QueryErrorCallback): Promise<QueryResult> {\r\n    let parent = this.parentEntity;\r\n    let query = EntityQuery.fromEntityNavigation(this.parentEntity, this.navigationProperty);\r\n    let em = parent.entityAspect.entityManager;\r\n    return em.executeQuery(query, callback, errorCallback);\r\n  },\r\n\r\n  _getEventParent: function() {\r\n    return this.parentEntity.entityAspect;\r\n  },\r\n\r\n  _getPendingPubs: function() {\r\n    let em = this.parentEntity.entityAspect.entityManager;\r\n    return em && em._pendingPubs;\r\n  },\r\n\r\n  // virtual impls\r\n  _getGoodAdds: function(adds: Entity[]) {\r\n    return getGoodAdds(this, adds);\r\n  },\r\n\r\n  _processAdds: function(adds: Entity[]) {\r\n    processAdds(this, adds);\r\n  },\r\n\r\n  _processRemoves: function(removes: Entity[]) {\r\n    processRemoves(this, removes);\r\n  }\r\n\r\n};\r\n\r\nfunction getGoodAdds(relationArray: RelationArray, adds: Entity[]) {\r\n  let goodAdds = checkForDups(relationArray, adds);\r\n  if (!goodAdds.length) {\r\n    return goodAdds;\r\n  }\r\n  let parentEntity = relationArray.parentEntity;\r\n  let entityManager = parentEntity.entityAspect.entityManager;\r\n  // we do not want to attach an entity during loading\r\n  // because these will all be 'attached' at a later step.\r\n  if (entityManager && !entityManager.isLoading) {\r\n    goodAdds.forEach(function (add) {\r\n      if (add.entityAspect.entityState.isDetached()) {\r\n        relationArray._inProgress = true;\r\n        try {\r\n          entityManager!.attachEntity(add, EntityState.Added);\r\n        } finally {\r\n          relationArray._inProgress = false;\r\n        }\r\n      }\r\n    });\r\n  }\r\n  return goodAdds;\r\n}\r\n\r\nfunction processAdds(relationArray: RelationArray, adds: Entity[]) {\r\n  let parentEntity = relationArray.parentEntity;\r\n  let np = relationArray.navigationProperty;\r\n  let addsInProcess = relationArray._addsInProcess;\r\n\r\n  let invNp = np.inverse;\r\n  let startIx = addsInProcess.length;\r\n  try {\r\n    adds.forEach(function (childEntity) {\r\n      addsInProcess.push(childEntity);\r\n      if (invNp) {\r\n        childEntity.setProperty(invNp.name, parentEntity);\r\n      } else {\r\n        // This occurs with a unidirectional 1-n navigation - in this case\r\n        // we need to update the fks instead of the navProp\r\n        let pks = parentEntity.entityType.keyProperties;\r\n        np.invForeignKeyNames.forEach(function (fk, i) {\r\n          childEntity.setProperty(fk, parentEntity.getProperty(pks[i].name));\r\n        });\r\n      }\r\n    });\r\n  } finally {\r\n    addsInProcess.splice(startIx, adds.length);\r\n  }\r\n\r\n}\r\n\r\nfunction processRemoves(relationArray: RelationArray, removes: Entity[]) {\r\n  let inp = relationArray.navigationProperty.inverse;\r\n  if (inp) {\r\n    removes.forEach(function (childEntity) {\r\n      childEntity.setProperty(inp!.name, null);\r\n    });\r\n  }\r\n}\r\n\r\nfunction checkForDups(relationArray: RelationArray, adds: Entity[]) {\r\n  // don't allow dups in this array. - also prevents recursion\r\n  let parentEntity = relationArray.parentEntity;\r\n  let navProp = relationArray.navigationProperty;\r\n  let inverseProp = navProp.inverse;\r\n  let goodAdds: Entity[];\r\n  if (inverseProp) {\r\n    goodAdds = adds.filter(function (a) {\r\n      if (relationArray._addsInProcess.indexOf(a) >= 0) {\r\n        return false;\r\n      }\r\n      let inverseValue = a.getProperty(inverseProp!.name);\r\n      return inverseValue !== parentEntity;\r\n    });\r\n  } else {\r\n    // This occurs with a unidirectional 1->N relation ( where there is no n -> 1)\r\n    // in this case we compare fks.\r\n    let fkPropNames = navProp.invForeignKeyNames;\r\n    let keyProps = parentEntity.entityType.keyProperties;\r\n    goodAdds = adds.filter(function (a) {\r\n      if (relationArray._addsInProcess.indexOf(a) >= 0) {\r\n        return false;\r\n      }\r\n      return fkPropNames.some(function (fk, i) {\r\n        let keyProp = keyProps[i].name;\r\n        let keyVal = parentEntity.getProperty(keyProp);\r\n        let fkVal = a.getProperty(fk);\r\n        return keyVal !== fkVal;\r\n      });\r\n    });\r\n  }\r\n  return goodAdds;\r\n}\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IModelLibraryAdapter]] implementation. \r\n@adapter (see [[IModelLibraryAdapter]])    \r\n@hidden \r\n*/\r\nexport function makeRelationArray(arr: any[], parentEntity: Entity, navigationProperty: NavigationProperty): RelationArray {\r\n  let arrX = arr as any;\r\n  arrX.parentEntity = parentEntity;\r\n  arrX.navigationProperty = navigationProperty;\r\n  arrX.arrayChanged = new BreezeEvent(\"arrayChanged\", arrX);\r\n  // array of pushes currently in process on this relation array - used to prevent recursion.\r\n  arrX._addsInProcess = [];\r\n  // need to use mixins here instead of inheritance because we are starting from an existing array object.\r\n  core.extend(arrX, observableArray.mixin);\r\n  return core.extend(arrX, relationArrayMixin) as RelationArray;\r\n}\r\n","import { core  } from './core';\r\nimport { ObservableArray, observableArray } from './observable-array';\r\nimport { BreezeEvent } from './event';\r\nimport { ComplexObject, StructuralObject } from './entity-aspect';\r\nimport { DataProperty } from './entity-metadata';\r\n\r\n// TODO: mixin impl is not very typesafe\r\n\r\nexport interface ComplexArray extends ObservableArray {\r\n  [index: number]: ComplexObject;\r\n  parent?: StructuralObject;\r\n  parentProperty?: DataProperty;\r\n}\r\n\r\nlet complexArrayMixin = {\r\n\r\n  // complexArray will have the following props\r\n  //    parent\r\n  //    propertyPath\r\n  //    parentProperty\r\n  //    addedItems  - only if modified\r\n  //    removedItems  - only if modified\r\n  //  each complexAspect of any entity within a complexArray\r\n  //  will have its own _complexState = \"A/M\";\r\n\r\n  /**\r\n   Complex arrays are not actually classes, they are objects that mimic arrays. A complex array is collection of\r\n   complexTypes associated with a data property on a single entity or other complex object. i.e. customer.orders or order.orderDetails.\r\n   This collection looks like an array in that the basic methods on arrays such as 'push', 'pop', 'shift', 'unshift', 'splice'\r\n   are all provided as well as several special purpose methods.\r\n   @class {complexArray}\r\n   **/\r\n\r\n  /**\r\n  An [[Event]] that fires whenever the contents of this array changed.  This event\r\n  is fired any time a new entity is attached or added to the EntityManager and happens to belong to this collection.\r\n  Adds that occur as a result of query or import operations are batched so that all of the adds or removes to any individual\r\n  collections are collected into a single notification event for each relation array.\r\n  @example\r\n      // assume order is an order entity attached to an EntityManager.\r\n      orders.arrayChanged.subscribe(\r\n      function (arrayChangedArgs) {\r\n          var addedEntities = arrayChangedArgs.added;\r\n          var removedEntities = arrayChanged.removed;\r\n      });\r\n  @event arrayChanged\r\n  @param added {Array of Entity} An array of all of the entities added to this collection.\r\n  @param removed {Array of Entity} An array of all of the removed from this collection.\r\n  @readOnly\r\n  **/\r\n\r\n    // virtual impls\r\n  _getGoodAdds: function(adds: any[]) {\r\n    return getGoodAdds(this, adds);\r\n  },\r\n\r\n  _beforeChange: function() {\r\n    observableArray.updateEntityState(this);\r\n  },\r\n\r\n  _processAdds: function(adds: any[]) {\r\n    processAdds(this, adds);\r\n  },\r\n\r\n  _processRemoves: function(removes: any[]) {\r\n    processRemoves(this, removes);\r\n  },\r\n\r\n  _rejectChanges: function() {\r\n    if (!this._origValues) return;\r\n    let that = this;\r\n    this.forEach(function (co: ComplexObject) {\r\n      clearAspect(co, that);\r\n    });\r\n    this.length = 0;\r\n    this._origValues.forEach(function (co: ComplexObject) {\r\n      that.push(co);\r\n    });\r\n  },\r\n\r\n  _acceptChanges: function() {\r\n    this._origValues = null;\r\n  }\r\n};\r\n\r\n// local functions\r\n\r\n\r\nfunction getGoodAdds(complexArray: ComplexArray, adds: ComplexObject[]) {\r\n  // remove any that are already added here\r\n  return adds.filter(function (a) {\r\n    // return a.parent !== complexArray.parent;  // TODO: check if this is actually a bug in original breezejs ???\r\n    return a.complexAspect == null || a.complexAspect.parent !== complexArray.parent;\r\n  });\r\n}\r\n\r\nfunction processAdds(complexArray: ComplexArray, adds: ComplexObject[]) {\r\n  adds.forEach(function (a) {\r\n    // if (a.parent != null) { // TODO: check if this is actually a bug in original breezejs ???\r\n    if (a.complexAspect && a.complexAspect.parent != null) {\r\n      throw new Error(\"The complexObject is already attached. Either clone it or remove it from its current owner\");\r\n    }\r\n    setAspect(a, complexArray);\r\n  });\r\n}\r\n\r\nfunction processRemoves(complexArray: ComplexArray, removes: ComplexObject[]) {\r\n  removes.forEach(function (a) {\r\n    clearAspect(a, complexArray);\r\n  });\r\n}\r\n\r\nfunction clearAspect(co: ComplexObject, arr: ComplexArray) {\r\n  let coAspect = co.complexAspect;\r\n  // if not already attached - exit\r\n  if (coAspect.parent !== arr.parent) return null;\r\n\r\n  coAspect.parent = undefined;\r\n  coAspect.parentProperty = undefined;\r\n  return coAspect;\r\n}\r\n\r\nfunction setAspect(co: ComplexObject, arr: ComplexArray) {\r\n  let coAspect = co.complexAspect;\r\n  // if already attached - exit\r\n  if (coAspect.parent === arr.parent) return null;\r\n  coAspect.parent = arr.parent;\r\n  coAspect.parentProperty = arr.parentProperty;\r\n\r\n  return coAspect;\r\n}\r\n\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IModelLibraryAdapter]] implementation. \r\n@adapter (see [[IModelLibraryAdapter]])    \r\n@hidden \r\n*/\r\nexport function makeComplexArray(arr: any[], parent: StructuralObject, parentProperty: DataProperty) {\r\n  let arrX = arr as any;\r\n  observableArray.initializeParent(arrX, parent, parentProperty);\r\n  arrX.arrayChanged = new BreezeEvent(\"arrayChanged\", arrX);\r\n  core.extend(arrX, observableArray.mixin);\r\n  return core.extend(arrX, complexArrayMixin) as ComplexArray;\r\n}\r\n\r\n","import { core  } from './core';\r\nimport { observableArray } from './observable-array';\r\nimport { BreezeEvent } from './event';\r\nimport { StructuralObject } from './entity-aspect';\r\nimport { DataProperty } from './entity-metadata';\r\n\r\n// TODO: mixin impl is not very typesafe\r\n\r\n// Not needed\r\n// interface IPrimitiveArray extends IObservableArray {\r\n//   [index: number]: any;\r\n//   parent?: IStructuralObject;\r\n//   parentProperty?: DataProperty;\r\n// }\r\n\r\nlet primitiveArrayMixin = {\r\n\r\n  // complexArray will have the following props\r\n  //    parent\r\n  //    propertyPath\r\n  //    parentProperty\r\n  //    addedItems  - only if modified\r\n  //    removedItems  - only if modified\r\n  //  each complexAspect of any entity within a complexArray\r\n  //  will have its own _complexState = \"A/M\";\r\n\r\n  /**\r\n  Primitive arrays are not actually classes, they are objects that mimic arrays. A primitive array is collection of\r\n  primitive types associated with a data property on a single entity or complex object. i.e. customer.invoiceNumbers.\r\n  This collection looks like an array in that the basic methods on arrays such as 'push', 'pop', 'shift', 'unshift', 'splice'\r\n  are all provided as well as several special purpose methods.\r\n  @class {primitiveArray}\r\n  **/\r\n\r\n  /**\r\n  An [[Event]] that fires whenever the contents of this array changed.  This event\r\n  is fired any time a new entity is attached or added to the EntityManager and happens to belong to this collection.\r\n  Adds that occur as a result of query or import operations are batched so that all of the adds or removes to any individual\r\n  collections are collected into a single notification event for each relation array.\r\n  @example\r\n      // assume order is an order entity attached to an EntityManager.\r\n      orders.arrayChanged.subscribe(\r\n      function (arrayChangedArgs) {\r\n          let addedEntities = arrayChangedArgs.added;\r\n          let removedEntities = arrayChanged.removed;\r\n      });\r\n  @event arrayChanged\r\n  @param added {Array of Primitives} An array of all of the items added to this collection.\r\n  @param removed {Array of Primitives} An array of all of the items removed from this collection.\r\n  @readOnly\r\n  **/\r\n\r\n    // virtual impls\r\n  _getGoodAdds:  function(adds: any[]) {\r\n    return adds;\r\n  },\r\n\r\n  _beforeChange: function() {\r\n    let entityAspect = this.getEntityAspect();\r\n    if (entityAspect.entityState.isUnchanged()) {\r\n      entityAspect.setModified();\r\n    }\r\n    if (entityAspect.entityState.isModified() && !this._origValues) {\r\n      this._origValues = this.slice(0);\r\n    }\r\n  },\r\n\r\n  _processAdds: function(adds: any[]) {\r\n    // nothing needed\r\n  },\r\n\r\n  _processRemoves: function(removes: any[]) {\r\n    // nothing needed;\r\n  },\r\n\r\n\r\n  _rejectChanges: function() {\r\n    if (!this._origValues) return;\r\n    this.length = 0;\r\n    Array.prototype.push.apply(this, this._origValues);\r\n  },\r\n\r\n  _acceptChanges: function() {\r\n    this._origValues = null;\r\n  }\r\n};\r\n  // local functions\r\n\r\n/** For use by breeze plugin authors only. The class is for use in building a [[IModelLibraryAdapter]] implementation. \r\n@adapter (see [[IModelLibraryAdapter]])    \r\n@hidden \r\n*/\r\nexport function makePrimitiveArray(arr: any[], parent: StructuralObject, parentProperty: DataProperty) {\r\n  let arrX = arr as any;\r\n  observableArray.initializeParent(arrX, parent, parentProperty);\r\n  arrX.arrayChanged = new BreezeEvent(\"arrayChanged\", arrX);\r\n  core.extend(arrX, observableArray.mixin);\r\n  return core.extend(arrX, primitiveArrayMixin);\r\n}\r\n\r\n\r\n","\r\nimport { AbstractDataServiceAdapter} from './abstract-data-service-adapter';\r\nimport { assertParam, assertConfig, Param, IConfigParam} from './assert-param';\r\nimport { BreezeConfig } from './config';\r\nimport { BreezeEnum} from './enum';\r\nimport { BreezeEvent } from './event';\r\nimport { ComplexArray } from './complex-array';\r\nimport { DataService, DataServiceConfig, JsonResultsAdapter, JsonResultsAdapterConfig, NodeContext, NodeMeta } from './data-service';\r\nimport { DataType  } from './data-type';\r\nimport { EntityAction } from './entity-action';\r\nimport { EntityAspect, ComplexAspect, Entity, StructuralObject, PropertyChangedEventArgs } from './entity-aspect';\r\nimport { EntityKey } from './entity-key';\r\nimport { EntityManager, EntityManagerConfig, EntityError, EntityChangedEventArgs, SaveContext, SaveBundle, HttpResponse, KeyMapping, ServerError, SaveResult, QueryResult, ValidationErrorsChangedEventArgs, HasChangesChangedEventArgs } from './entity-manager';\r\nimport { EntityQuery, FilterQueryOp, BooleanQueryOp, OrderByClause, ExpandClause, SelectClause } from './entity-query';\r\nimport { EntityState } from './entity-state';\r\nimport { InterfaceRegistry, AjaxAdapter, AjaxConfig, DataServiceAdapter, ModelLibraryAdapter, ChangeRequestInterceptor, UriBuilderAdapter, InterfaceRegistryConfig } from './interface-registry';\r\nimport { KeyGenerator } from './key-generator';\r\nimport { LocalQueryComparisonOptions } from './local-query-comparison-options';\r\nimport { MappingContext } from './mapping-context';\r\nimport { MetadataStore, EntityType, ComplexType, StructuralType, DataProperty, EntityProperty, NavigationProperty, AutoGeneratedKeyType   } from './entity-metadata';\r\nimport { NamingConvention } from './naming-convention';\r\nimport { Predicate, VisitContext, Visitor, ExpressionContext, UnaryPredicate, BinaryPredicate, AnyAllPredicate, AndOrPredicate, LitExpr, FnExpr, PropExpr } from './predicate';\r\nimport { QueryOptions,  FetchStrategy, MergeStrategy } from './query-options';\r\nimport { SaveOptions } from './save-options';\r\nimport { ValidationError, Validator } from './validate';\r\nimport { ValidationOptions } from './validation-options';\r\n\r\nimport { config, BaseAdapter } from './config';\r\nimport { core } from './core';\r\nimport { makeRelationArray, makePrimitiveArray, makeComplexArray } from './array';\r\n\r\nimport { RelationArray } from './relation-array';\r\nimport { ArrayChangedArgs } from './observable-array';\r\nexport { BreezeConfig, ComplexArray, RelationArray };\r\n\r\nexport {\r\n  // Param,\r\n  AbstractDataServiceAdapter,\r\n  AjaxAdapter,\r\n  AjaxConfig,\r\n  AndOrPredicate,\r\n  AnyAllPredicate,\r\n  ArrayChangedArgs,\r\n  assertConfig,\r\n  assertParam,\r\n  AutoGeneratedKeyType,\r\n  BaseAdapter,\r\n  BinaryPredicate,\r\n  BreezeEnum,\r\n  BreezeEvent, \r\n  ChangeRequestInterceptor,\r\n  ComplexAspect,\r\n  ComplexType,\r\n  config,\r\n  core,\r\n  DataProperty,\r\n  DataService,\r\n  DataServiceAdapter,\r\n  DataServiceConfig,\r\n  DataType,\r\n  Entity,\r\n  EntityAction,\r\n  EntityAspect,\r\n  EntityChangedEventArgs,\r\n  EntityError,\r\n  EntityKey,\r\n  EntityManager,\r\n  EntityManagerConfig,\r\n  EntityProperty,\r\n  EntityQuery,\r\n  EntityState,\r\n  EntityType,\r\n  ExpandClause,\r\n  ExpressionContext,\r\n  FetchStrategy,\r\n  FilterQueryOp,\r\n  FnExpr,\r\n  HasChangesChangedEventArgs,\r\n  HttpResponse,\r\n  InterfaceRegistry,\r\n  InterfaceRegistryConfig,\r\n  JsonResultsAdapter,\r\n  JsonResultsAdapterConfig,\r\n  KeyGenerator,\r\n  KeyMapping,\r\n  LitExpr,\r\n  LocalQueryComparisonOptions,\r\n  makeComplexArray,\r\n  makePrimitiveArray,\r\n  makeRelationArray,\r\n  MappingContext,\r\n  MergeStrategy,\r\n  MetadataStore,\r\n  ModelLibraryAdapter,\r\n  NamingConvention,\r\n  NavigationProperty,\r\n  NodeContext,\r\n  NodeMeta,\r\n  OrderByClause,\r\n  Predicate,\r\n  PropertyChangedEventArgs,\r\n  PropExpr,\r\n  QueryOptions,\r\n  QueryResult,\r\n  SaveBundle,\r\n  SaveContext,\r\n  SaveOptions,\r\n  SaveResult,\r\n  SelectClause,\r\n  ServerError,\r\n  StructuralObject,\r\n  StructuralType,\r\n  UnaryPredicate,\r\n  UriBuilderAdapter,\r\n  ValidationErrorsChangedEventArgs,\r\n  ValidationError,\r\n  ValidationOptions,\r\n  Validator,\r\n  VisitContext,\r\n  Visitor,\r\n};\r\n\r\n// create a breeze variable here\r\nexport const breeze = {\r\n  AbstractDataServiceAdapter: AbstractDataServiceAdapter,\r\n  assertConfig: null as any,\r\n  assertParam: null as any,\r\n  AutoGeneratedKeyType: AutoGeneratedKeyType,\r\n  BooleanQueryOp: BooleanQueryOp,\r\n  ComplexAspect: ComplexAspect,\r\n  ComplexType: ComplexType,\r\n  config: config,\r\n  core: core,\r\n  DataProperty: DataProperty,\r\n  DataService: DataService,\r\n  DataType: DataType,\r\n  EntityAction: EntityAction,\r\n  EntityAspect: EntityAspect,\r\n  EntityKey: EntityKey,\r\n  EntityManager: EntityManager,\r\n  EntityQuery: EntityQuery,\r\n  EntityState: EntityState,\r\n  EntityType: EntityType,\r\n  Event: BreezeEvent,\r\n  FetchStrategy: FetchStrategy,\r\n  FilterQueryOp: FilterQueryOp,\r\n  InterfaceRegistry: InterfaceRegistry,\r\n  JsonResultsAdapter: JsonResultsAdapter,\r\n  KeyGenerator: KeyGenerator,\r\n  LocalQueryComparisonOptions: LocalQueryComparisonOptions,\r\n  makeComplexArray: makeComplexArray,\r\n  makePrimitiveArray: makePrimitiveArray,\r\n  makeRelationArray: makeRelationArray,\r\n  MergeStrategy: MergeStrategy,\r\n  MetadataStore: MetadataStore,\r\n  NamingConvention: NamingConvention,\r\n  NavigationProperty: NavigationProperty,\r\n  OrderByClause: OrderByClause, // for testing only\r\n  Predicate: Predicate,\r\n  QueryOptions: QueryOptions,\r\n  SaveOptions: SaveOptions,\r\n  ValidationError: ValidationError,\r\n  ValidationOptions: ValidationOptions,\r\n  Validator,\r\n  version: \"2.0.3\"\r\n};\r\n\r\n// breeze.assertConfig = assertConfig as any;\r\n// breeze.assertParam = assertParam as any;\r\n\r\n// no-op for backward compatibility with breeze-bridge2-angular\r\nexport namespace promises {\r\n  export interface IPromiseService {}\r\n}\r\n\r\n/** @hidden @internal */\r\ndeclare var window: any;\r\n\r\n/** @hidden @internal */\r\ndeclare var global: any;\r\n\r\n/** @hidden @internal */\r\nlet win: any;\r\ntry {\r\n  win = window ? window : (global ? global.window : undefined);\r\n} catch (e) {\r\n\r\n}\r\nif (win) {\r\n  win.breeze = breeze;\r\n}\r\n"]}