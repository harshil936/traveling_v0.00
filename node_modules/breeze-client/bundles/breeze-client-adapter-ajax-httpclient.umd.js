(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common/http'), require('breeze-client'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('breeze-client/adapter-ajax-httpclient', ['exports', '@angular/common/http', 'breeze-client', 'rxjs/operators'], factory) :
    (global = global || self, factory((global['breeze-client'] = global['breeze-client'] || {}, global['breeze-client']['adapter-ajax-httpclient'] = {}), global.ng.common.http, global['breeze-client'], global.rxjs.operators));
}(this, (function (exports, http, breezeClient, operators) { 'use strict';

    var AjaxHttpClientAdapter = /** @class */ (function () {
        function AjaxHttpClientAdapter(http) {
            this.http = http;
            this.name = AjaxHttpClientAdapter.adapterName;
            this.defaultSettings = {};
        }
        AjaxHttpClientAdapter.register = function (http, breezeConfig) {
            breezeConfig = breezeConfig || breezeClient.config;
            breezeConfig.registerAdapter("ajax", function () { return new AjaxHttpClientAdapter(http); });
            return breezeConfig.initializeAdapterInstance("ajax", AjaxHttpClientAdapter.adapterName, true);
        };
        AjaxHttpClientAdapter.prototype.initialize = function () { };
        AjaxHttpClientAdapter.prototype.ajax = function (config) {
            if (!this.http) {
                throw new Error('Unable to locate angular http module for ajax adapter');
            }
            // merge default DataSetAdapter Settings with config arg
            if (!breezeClient.core.isEmpty(this.defaultSettings)) {
                var compositeConfig = breezeClient.core.extend({}, this.defaultSettings);
                config = breezeClient.core.extend(compositeConfig, config);
                // extend is shallow; extend headers separately
                var headers_1 = breezeClient.core.extend({}, this.defaultSettings['headers']); // copy default headers 1st
                config['headers'] = breezeClient.core.extend(headers_1, config.headers);
            }
            if (config.crossDomain) {
                throw new Error(this.name + ' does not support JSONP (crossDomain) requests');
            }
            var url = config.url;
            if (!breezeClient.core.isEmpty(config.params)) {
                // Hack: Not sure how Angular handles writing 'search' parameters to the url.
                // so this approach takes over the url param writing completely.
                var delim = (url.indexOf('?') >= 0) ? '&' : '?';
                url = url + delim + encodeParams(config.params);
            }
            var headers = new http.HttpHeaders(config.headers || {});
            if (!headers.has('Content-Type')) {
                if (config.type !== 'GET' && config.type !== 'DELETE' && !!config.contentType) {
                    headers = headers.set('Content-Type', config.contentType || 'application/json; charset=utf-8');
                }
            }
            var body = config.data;
            var request = new http.HttpRequest((config.type || 'GET').toUpperCase(), url, body, { headers: headers, responseType: "text" });
            var requestInfo = {
                adapter: this,
                request: request,
                dsaConfig: config,
                success: successFn,
                error: errorFn // adapter's error callback
            };
            if (breezeClient.core.isFunction(this.requestInterceptor)) {
                this.requestInterceptor(requestInfo);
                if (this.requestInterceptor['oneTime']) {
                    this.requestInterceptor = null;
                }
            }
            if (requestInfo.request) { // exists unless requestInterceptor killed it.
                var ffilter = operators.filter(function (response) { return response instanceof http.HttpResponse; });
                var fmap = operators.map(extractData);
                fmap(ffilter(this.http.request(requestInfo.request)))
                    .forEach(requestInfo.success)
                    .catch(requestInfo.error);
            }
            function extractData(event) {
                var response = event;
                var data;
                var dt = requestInfo.dsaConfig.dataType;
                // beware:`res.json` and `res.text` will be async some day
                if (dt && dt !== 'json') {
                    data = response.body;
                }
                else {
                    data = JSON.parse(response.body);
                }
                return { data: data, response: response };
            }
            function successFn(arg) {
                if (arg.response.status < 200 || arg.response.status >= 300) {
                    throw { data: arg.data, response: arg.response };
                }
                var httpResponse = {
                    config: requestInfo.request,
                    data: arg.data,
                    getHeaders: makeGetHeaders(arg.response.headers),
                    status: arg.response.status
                };
                httpResponse['ngConfig'] = requestInfo.request;
                httpResponse['statusText'] = arg.response.statusText;
                httpResponse['response'] = arg.response;
                config.success(httpResponse);
            }
            function errorFn(response) {
                if (response instanceof Error) {
                    throw response; // program error; nothing we can do
                }
                else {
                    var data = void 0;
                    if (response.error instanceof http.HttpResponse) {
                        data = response.error.body;
                    }
                    else if (response.error instanceof Error) {
                        data = response.error.message;
                    }
                    else {
                        data = response.error;
                    }
                    // Timeout appears as an error with status===0 and no data.
                    if (response.status === 0 && data == null) {
                        data = 'timeout';
                    }
                    var errorMessage = response.status + ": " + response.statusText;
                    if (data && typeof data === 'object') {
                        data["message"] = data["message"] || errorMessage; // breeze looks at the message property
                    }
                    if (!data) {
                        data = errorMessage; // Return the error message as data
                    }
                    var httpResponse = {
                        config: requestInfo.request,
                        data: data,
                        getHeaders: makeGetHeaders(response.headers),
                        status: response.status
                    };
                    httpResponse['ngConfig'] = requestInfo.request;
                    httpResponse['statusText'] = response.statusText;
                    httpResponse['response'] = response;
                    config.error(httpResponse); // send error to breeze error handler
                }
            }
        };
        AjaxHttpClientAdapter.adapterName = 'httpclient';
        return AjaxHttpClientAdapter;
    }());
    ///// Helpers ////
    function encodeParams(obj) {
        var query = '';
        var subValue, innerObj, fullSubName;
        for (var name_1 in obj) {
            if (!obj.hasOwnProperty(name_1)) {
                continue;
            }
            var value = obj[name_1];
            if (value instanceof Array) {
                for (var i = 0; i < value.length; ++i) {
                    subValue = value[i];
                    fullSubName = name_1 + '[' + i + ']';
                    innerObj = {};
                    innerObj[fullSubName] = subValue;
                    query += encodeParams(innerObj) + '&';
                }
            }
            else if (value && value.toISOString) { // a feature of Date-like things
                query += encodeURIComponent(name_1) + '=' + encodeURIComponent(value.toISOString()) + '&';
            }
            else if (value instanceof Object) {
                for (var subName in value) {
                    if (obj.hasOwnProperty(name_1)) {
                        subValue = value[subName];
                        fullSubName = name_1 + '[' + subName + ']';
                        innerObj = {};
                        innerObj[fullSubName] = subValue;
                        query += encodeParams(innerObj) + '&';
                    }
                }
            }
            else if (value === null) {
                query += encodeURIComponent(name_1) + '=&';
            }
            else if (value !== undefined) {
                query += encodeURIComponent(name_1) + '=' + encodeURIComponent(value) + '&';
            }
        }
        return query.length ? query.substr(0, query.length - 1) : query;
    }
    function makeGetHeaders(headers) {
        return function getHeaders(headerName) { return headers.getAll(headerName).join('\r\n'); };
    }

    exports.AjaxHttpClientAdapter = AjaxHttpClientAdapter;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=breeze-client-adapter-ajax-httpclient.umd.js.map
