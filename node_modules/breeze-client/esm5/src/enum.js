/*
 * Copyright 2012-2019 IdeaBlade, Inc.  All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the IdeaBlade Breeze license, available at http://www.breezejs.com/license
 *
 * Author: Jay Traband
 */
/**
Base class for all Breeze enumerations, such as EntityState, DataType, FetchStrategy, MergeStrategy etc.
A Breeze Enum is a namespaced set of constant values.  Each Enum consists of a group of related constants, called 'symbols'.
Unlike enums in some other environments, each 'symbol' can have both methods and properties.
>     class DayOfWeek extends BreezeEnum {
>       dayIndex: number;
>       isWeekend?: boolean;
>       nextDay() {
>         let nextIndex = (this.dayIndex + 1) % 7;
>         return DayOfWeek.getSymbols()[nextIndex];
>       }
>
>       static Monday = new DayOfWeek( { dayIndex: 0});
>       static Tuesday = new DayOfWeek( { dayIndex: 1 });
>       static Wednesday = new DayOfWeek( { dayIndex: 2 });
>       static Thursday = new DayOfWeek( { dayIndex: 3 });
>       static Friday = new DayOfWeek( { dayIndex: 4 });
>       static Saturday = new DayOfWeek( { dayIndex: 5, isWeekend: true });
>       static Sunday = new DayOfWeek( { dayIndex: 6, isWeekend: true });
>     }
>
>     describe("DayOfWeek", () => {
>       test("should support full enum capabilities", function() {
>         // // custom methods
>         let dowSymbols = DayOfWeek.getSymbols();
>         expect(dowSymbols.length).toBe(7);
>         expect(DayOfWeek.Monday.nextDay()).toBe(DayOfWeek.Tuesday);
>         expect(DayOfWeek.Sunday.nextDay()).toBe(DayOfWeek.Monday);
>       // // custom properties
>         expect(DayOfWeek.Tuesday.isWeekend).toBe(undefined);
>         expect(DayOfWeek.Saturday.isWeekend).toBe(true);
>       // // Standard enum capabilities
>         expect(DayOfWeek.Thursday instanceof DayOfWeek).toBe(true);
>         expect(BreezeEnum.isSymbol(DayOfWeek.Wednesday)).toBe(true);
>         expect(DayOfWeek.contains(DayOfWeek.Thursday)).toBe(true);
>         expect(DayOfWeek.Friday.toString()).toBe("Friday");
>       });
>   });
Note that we have Error['x'] = ... in some places in the code to prevent Terser from optimizing out some important calls.
@dynamic
*/
var BreezeEnum = /** @class */ (function () {
    /**  */
    function BreezeEnum(propertiesObj) {
        var _this = this;
        if (propertiesObj) {
            Object.keys(propertiesObj).forEach(function (key) { return _this[key] = propertiesObj[key]; });
        }
    }
    /**
    Returns all of the symbols contained within this Enum.
    >     let symbols = DayOfWeek.getSymbols();
    @return All of the symbols contained within this Enum.
    **/
    BreezeEnum.getSymbols = function () {
        return this.resolveSymbols().map(function (ks) { return ks.symbol; });
    };
    /**
    Returns the names of all of the symbols contained within this Enum.
    >     let symbols = DayOfWeek.getNames();
    @return  All of the names of the symbols contained within this Enum.
    **/
    BreezeEnum.getNames = function () {
        return this.resolveSymbols().map(function (ks) { return ks.name; });
    };
    /**
    Returns an Enum symbol given its name.
    >     let dayOfWeek = DayOfWeek.from("Thursday");
    >     // nowdayOfWeek === DayOfWeek.Thursday
    @param name - Name for which an enum symbol should be returned.
    @return The symbol that matches the name or 'undefined' if not found.
    **/
    BreezeEnum.fromName = function (name) {
        return this[name];
    };
    /**
    Seals this enum so that no more symbols may be added to it. This should only be called after all symbols
    have already been added to the Enum. This method also sets the 'name' property on each of the symbols.
    >     DayOfWeek.resolveSymbols();
    **/
    BreezeEnum.resolveSymbols = function () {
        if (this._resolvedNamesAndSymbols)
            return this._resolvedNamesAndSymbols;
        var result = [];
        for (var key in this) {
            if (this.hasOwnProperty(key)) {
                var symb = this[key];
                if (symb instanceof BreezeEnum) {
                    result.push({ name: key, symbol: symb });
                    this[key] = symb;
                    symb.name = key;
                }
            }
        }
        this._resolvedNamesAndSymbols = result;
        return result;
    };
    /**
    Returns whether an Enum contains a specified symbol.
    >     let symbol = DayOfWeek.Friday;
    >     if (DayOfWeek.contains(symbol)) {
    >         // do something
    >     }
    @param sym - Object or symbol to test.
    @return Whether this Enum contains the specified symbol.
    **/
    BreezeEnum.contains = function (sym) {
        if (!(sym instanceof BreezeEnum)) {
            return false;
        }
        return this[sym.name] != null;
    };
    // /**
    // Checks if an object is an Enum 'symbol'. Use the 'contains' method instead of this one 
    // if you want to test for a specific Enum. 
    // >     if (Enum.isSymbol(DayOfWeek.Wednesday)) {
    // >       // do something ...
    // >     };
    // **/
    // static isSymbol(obj: any) {
    //   return obj instanceof BreezeEnum;
    // };
    /** Returns the string name of this Enum */
    BreezeEnum.prototype.toString = function () {
        return this.name;
    };
    /** Return enum name and symbol name */
    BreezeEnum.prototype.toJSON = function () {
        return {
            _$typeName: this['_$typeName'] || this.constructor.name,
            name: this.name
        };
    };
    return BreezeEnum;
}());
export { BreezeEnum };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW51bS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2JyZWV6ZS1jbGllbnQvIiwic291cmNlcyI6WyJzcmMvZW51bS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXdDRTtBQUNGO0lBU0UsT0FBTztJQUNQLG9CQUFZLGFBQXNCO1FBQWxDLGlCQUlDO1FBSEMsSUFBSSxhQUFhLEVBQUU7WUFDakIsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxHQUFHLElBQUssT0FBQSxLQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxFQUE5QixDQUE4QixDQUFDLENBQUM7U0FDN0U7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLHFCQUFVLEdBQWpCO1FBQ0UsT0FBTyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsR0FBRyxDQUFDLFVBQUEsRUFBRSxJQUFJLE9BQUEsRUFBRSxDQUFDLE1BQU0sRUFBVCxDQUFTLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLG1CQUFRLEdBQWY7UUFDRSxPQUFPLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQyxHQUFHLENBQUMsVUFBQSxFQUFFLElBQUksT0FBQSxFQUFFLENBQUMsSUFBSSxFQUFQLENBQU8sQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxtQkFBUSxHQUFmLFVBQWdCLElBQVk7UUFDMUIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSx5QkFBYyxHQUFyQjtRQUNFLElBQUksSUFBSSxDQUFDLHdCQUF3QjtZQUFFLE9BQU8sSUFBSSxDQUFDLHdCQUF3QixDQUFDO1FBQ3hFLElBQUksTUFBTSxHQUEwQyxFQUFFLENBQUM7UUFFdkQsS0FBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7WUFDcEIsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUM1QixJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3JCLElBQUksSUFBSSxZQUFZLFVBQVUsRUFBRTtvQkFDOUIsTUFBTSxDQUFDLElBQUksQ0FBRSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7b0JBQzFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7b0JBQ2pCLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDO2lCQUNqQjthQUNGO1NBQ0Y7UUFDRCxJQUFJLENBQUMsd0JBQXdCLEdBQUcsTUFBTSxDQUFDO1FBQ3ZDLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLG1CQUFRLEdBQWYsVUFBZ0IsR0FBZTtRQUM3QixJQUFJLENBQUMsQ0FBQyxHQUFHLFlBQVksVUFBVSxDQUFDLEVBQUU7WUFDaEMsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUdELE1BQU07SUFDTiwwRkFBMEY7SUFDMUYsNENBQTRDO0lBQzVDLGtEQUFrRDtJQUNsRCw4QkFBOEI7SUFDOUIsV0FBVztJQUNYLE1BQU07SUFDTiw4QkFBOEI7SUFDOUIsc0NBQXNDO0lBQ3RDLEtBQUs7SUFFTCwyQ0FBMkM7SUFDM0MsNkJBQVEsR0FBUjtRQUNFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUNuQixDQUFDO0lBRUQsdUNBQXVDO0lBQ3ZDLDJCQUFNLEdBQU47UUFDRSxPQUFPO1lBQ0wsVUFBVSxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSyxJQUFJLENBQUMsV0FBbUIsQ0FBQyxJQUFJO1lBQ2hFLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtTQUNoQixDQUFDO0lBQ0osQ0FBQztJQUVILGlCQUFDO0FBQUQsQ0FBQyxBQTlHRCxJQThHQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIENvcHlyaWdodCAyMDEyLTIwMTkgSWRlYUJsYWRlLCBJbmMuICBBbGwgUmlnaHRzIFJlc2VydmVkLiAgXHJcbiAqIFVzZSwgcmVwcm9kdWN0aW9uLCBkaXN0cmlidXRpb24sIGFuZCBtb2RpZmljYXRpb24gb2YgdGhpcyBjb2RlIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZCBcclxuICogY29uZGl0aW9ucyBvZiB0aGUgSWRlYUJsYWRlIEJyZWV6ZSBsaWNlbnNlLCBhdmFpbGFibGUgYXQgaHR0cDovL3d3dy5icmVlemVqcy5jb20vbGljZW5zZVxyXG4gKlxyXG4gKiBBdXRob3I6IEpheSBUcmFiYW5kXHJcbiAqL1xyXG5cclxuLyoqXHJcbkJhc2UgY2xhc3MgZm9yIGFsbCBCcmVlemUgZW51bWVyYXRpb25zLCBzdWNoIGFzIEVudGl0eVN0YXRlLCBEYXRhVHlwZSwgRmV0Y2hTdHJhdGVneSwgTWVyZ2VTdHJhdGVneSBldGMuXHJcbkEgQnJlZXplIEVudW0gaXMgYSBuYW1lc3BhY2VkIHNldCBvZiBjb25zdGFudCB2YWx1ZXMuICBFYWNoIEVudW0gY29uc2lzdHMgb2YgYSBncm91cCBvZiByZWxhdGVkIGNvbnN0YW50cywgY2FsbGVkICdzeW1ib2xzJy5cclxuVW5saWtlIGVudW1zIGluIHNvbWUgb3RoZXIgZW52aXJvbm1lbnRzLCBlYWNoICdzeW1ib2wnIGNhbiBoYXZlIGJvdGggbWV0aG9kcyBhbmQgcHJvcGVydGllcy5cclxuPiAgICAgY2xhc3MgRGF5T2ZXZWVrIGV4dGVuZHMgQnJlZXplRW51bSB7XHJcbj4gICAgICAgZGF5SW5kZXg6IG51bWJlcjtcclxuPiAgICAgICBpc1dlZWtlbmQ/OiBib29sZWFuO1xyXG4+ICAgICAgIG5leHREYXkoKSB7XHJcbj4gICAgICAgICBsZXQgbmV4dEluZGV4ID0gKHRoaXMuZGF5SW5kZXggKyAxKSAlIDc7XHJcbj4gICAgICAgICByZXR1cm4gRGF5T2ZXZWVrLmdldFN5bWJvbHMoKVtuZXh0SW5kZXhdO1xyXG4+ICAgICAgIH1cclxuPlxyXG4+ICAgICAgIHN0YXRpYyBNb25kYXkgPSBuZXcgRGF5T2ZXZWVrKCB7IGRheUluZGV4OiAwfSk7XHJcbj4gICAgICAgc3RhdGljIFR1ZXNkYXkgPSBuZXcgRGF5T2ZXZWVrKCB7IGRheUluZGV4OiAxIH0pO1xyXG4+ICAgICAgIHN0YXRpYyBXZWRuZXNkYXkgPSBuZXcgRGF5T2ZXZWVrKCB7IGRheUluZGV4OiAyIH0pO1xyXG4+ICAgICAgIHN0YXRpYyBUaHVyc2RheSA9IG5ldyBEYXlPZldlZWsoIHsgZGF5SW5kZXg6IDMgfSk7XHJcbj4gICAgICAgc3RhdGljIEZyaWRheSA9IG5ldyBEYXlPZldlZWsoIHsgZGF5SW5kZXg6IDQgfSk7XHJcbj4gICAgICAgc3RhdGljIFNhdHVyZGF5ID0gbmV3IERheU9mV2VlayggeyBkYXlJbmRleDogNSwgaXNXZWVrZW5kOiB0cnVlIH0pO1xyXG4+ICAgICAgIHN0YXRpYyBTdW5kYXkgPSBuZXcgRGF5T2ZXZWVrKCB7IGRheUluZGV4OiA2LCBpc1dlZWtlbmQ6IHRydWUgfSk7XHJcbj4gICAgIH1cclxuPlxyXG4+ICAgICBkZXNjcmliZShcIkRheU9mV2Vla1wiLCAoKSA9PiB7XHJcbj4gICAgICAgdGVzdChcInNob3VsZCBzdXBwb3J0IGZ1bGwgZW51bSBjYXBhYmlsaXRpZXNcIiwgZnVuY3Rpb24oKSB7XHJcbj4gICAgICAgICAvLyAvLyBjdXN0b20gbWV0aG9kc1xyXG4+ICAgICAgICAgbGV0IGRvd1N5bWJvbHMgPSBEYXlPZldlZWsuZ2V0U3ltYm9scygpO1xyXG4+ICAgICAgICAgZXhwZWN0KGRvd1N5bWJvbHMubGVuZ3RoKS50b0JlKDcpO1xyXG4+ICAgICAgICAgZXhwZWN0KERheU9mV2Vlay5Nb25kYXkubmV4dERheSgpKS50b0JlKERheU9mV2Vlay5UdWVzZGF5KTtcclxuPiAgICAgICAgIGV4cGVjdChEYXlPZldlZWsuU3VuZGF5Lm5leHREYXkoKSkudG9CZShEYXlPZldlZWsuTW9uZGF5KTtcclxuPiAgICAgICAvLyAvLyBjdXN0b20gcHJvcGVydGllc1xyXG4+ICAgICAgICAgZXhwZWN0KERheU9mV2Vlay5UdWVzZGF5LmlzV2Vla2VuZCkudG9CZSh1bmRlZmluZWQpO1xyXG4+ICAgICAgICAgZXhwZWN0KERheU9mV2Vlay5TYXR1cmRheS5pc1dlZWtlbmQpLnRvQmUodHJ1ZSk7XHJcbj4gICAgICAgLy8gLy8gU3RhbmRhcmQgZW51bSBjYXBhYmlsaXRpZXNcclxuPiAgICAgICAgIGV4cGVjdChEYXlPZldlZWsuVGh1cnNkYXkgaW5zdGFuY2VvZiBEYXlPZldlZWspLnRvQmUodHJ1ZSk7XHJcbj4gICAgICAgICBleHBlY3QoQnJlZXplRW51bS5pc1N5bWJvbChEYXlPZldlZWsuV2VkbmVzZGF5KSkudG9CZSh0cnVlKTtcclxuPiAgICAgICAgIGV4cGVjdChEYXlPZldlZWsuY29udGFpbnMoRGF5T2ZXZWVrLlRodXJzZGF5KSkudG9CZSh0cnVlKTtcclxuPiAgICAgICAgIGV4cGVjdChEYXlPZldlZWsuRnJpZGF5LnRvU3RyaW5nKCkpLnRvQmUoXCJGcmlkYXlcIik7XHJcbj4gICAgICAgfSk7XHJcbj4gICB9KTtcclxuTm90ZSB0aGF0IHdlIGhhdmUgRXJyb3JbJ3gnXSA9IC4uLiBpbiBzb21lIHBsYWNlcyBpbiB0aGUgY29kZSB0byBwcmV2ZW50IFRlcnNlciBmcm9tIG9wdGltaXppbmcgb3V0IHNvbWUgaW1wb3J0YW50IGNhbGxzLlxyXG5AZHluYW1pY1xyXG4qL1xyXG5leHBvcnQgY2xhc3MgQnJlZXplRW51bSB7XHJcbiAgLy8gLy8gVE9ETzogdGhpbmsgYWJvdXQgQ29tcG9zaXRlRW51bSAoZmxhZ3MgaW1wbCkuXHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgc3ltYm9sICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIC8qKiBUeXBlIG9mIHRoZSBlbnVtOyBzZXQgaW4gcHJvdG90eXBlIG9mIGVhY2ggZW51bSAqL1xyXG4gIF8kdHlwZU5hbWU6IHN0cmluZztcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgX3Jlc29sdmVkTmFtZXNBbmRTeW1ib2xzOiB7IG5hbWU6IHN0cmluZywgc3ltYm9sOiBCcmVlemVFbnVtIH1bXTtcclxuXHJcbiAgLyoqICAqL1xyXG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXNPYmo/OiBPYmplY3QpIHtcclxuICAgIGlmIChwcm9wZXJ0aWVzT2JqKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXNPYmopLmZvckVhY2goKGtleSkgPT4gdGhpc1trZXldID0gcHJvcGVydGllc09ialtrZXldKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYWxsIG9mIHRoZSBzeW1ib2xzIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBFbnVtLlxyXG4gID4gICAgIGxldCBzeW1ib2xzID0gRGF5T2ZXZWVrLmdldFN5bWJvbHMoKTtcclxuICBAcmV0dXJuIEFsbCBvZiB0aGUgc3ltYm9scyBjb250YWluZWQgd2l0aGluIHRoaXMgRW51bS5cclxuICAqKi9cclxuICBzdGF0aWMgZ2V0U3ltYm9scygpIHtcclxuICAgIHJldHVybiB0aGlzLnJlc29sdmVTeW1ib2xzKCkubWFwKGtzID0+IGtzLnN5bWJvbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIHRoZSBuYW1lcyBvZiBhbGwgb2YgdGhlIHN5bWJvbHMgY29udGFpbmVkIHdpdGhpbiB0aGlzIEVudW0uXHJcbiAgPiAgICAgbGV0IHN5bWJvbHMgPSBEYXlPZldlZWsuZ2V0TmFtZXMoKTtcclxuICBAcmV0dXJuICBBbGwgb2YgdGhlIG5hbWVzIG9mIHRoZSBzeW1ib2xzIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBFbnVtLlxyXG4gICoqL1xyXG4gIHN0YXRpYyBnZXROYW1lcygpIHtcclxuICAgIHJldHVybiB0aGlzLnJlc29sdmVTeW1ib2xzKCkubWFwKGtzID0+IGtzLm5hbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhbiBFbnVtIHN5bWJvbCBnaXZlbiBpdHMgbmFtZS5cclxuICA+ICAgICBsZXQgZGF5T2ZXZWVrID0gRGF5T2ZXZWVrLmZyb20oXCJUaHVyc2RheVwiKTtcclxuICA+ICAgICAvLyBub3dkYXlPZldlZWsgPT09IERheU9mV2Vlay5UaHVyc2RheVxyXG4gIEBwYXJhbSBuYW1lIC0gTmFtZSBmb3Igd2hpY2ggYW4gZW51bSBzeW1ib2wgc2hvdWxkIGJlIHJldHVybmVkLlxyXG4gIEByZXR1cm4gVGhlIHN5bWJvbCB0aGF0IG1hdGNoZXMgdGhlIG5hbWUgb3IgJ3VuZGVmaW5lZCcgaWYgbm90IGZvdW5kLlxyXG4gICoqL1xyXG4gIHN0YXRpYyBmcm9tTmFtZShuYW1lOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiB0aGlzW25hbWVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgU2VhbHMgdGhpcyBlbnVtIHNvIHRoYXQgbm8gbW9yZSBzeW1ib2xzIG1heSBiZSBhZGRlZCB0byBpdC4gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgYWZ0ZXIgYWxsIHN5bWJvbHNcclxuICBoYXZlIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGUgRW51bS4gVGhpcyBtZXRob2QgYWxzbyBzZXRzIHRoZSAnbmFtZScgcHJvcGVydHkgb24gZWFjaCBvZiB0aGUgc3ltYm9scy5cclxuICA+ICAgICBEYXlPZldlZWsucmVzb2x2ZVN5bWJvbHMoKTtcclxuICAqKi9cclxuICBzdGF0aWMgcmVzb2x2ZVN5bWJvbHMoKSB7XHJcbiAgICBpZiAodGhpcy5fcmVzb2x2ZWROYW1lc0FuZFN5bWJvbHMpIHJldHVybiB0aGlzLl9yZXNvbHZlZE5hbWVzQW5kU3ltYm9scztcclxuICAgIGxldCByZXN1bHQ6IHtuYW1lOiBzdHJpbmcsIHN5bWJvbDogQnJlZXplRW51bSB9W10gPSBbXTtcclxuXHJcbiAgICBmb3IgKGxldCBrZXkgaW4gdGhpcykge1xyXG4gICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgbGV0IHN5bWIgPSB0aGlzW2tleV07XHJcbiAgICAgICAgaWYgKHN5bWIgaW5zdGFuY2VvZiBCcmVlemVFbnVtKSB7XHJcbiAgICAgICAgICByZXN1bHQucHVzaCggeyBuYW1lOiBrZXksIHN5bWJvbDogc3ltYiB9KTtcclxuICAgICAgICAgIHRoaXNba2V5XSA9IHN5bWI7XHJcbiAgICAgICAgICBzeW1iLm5hbWUgPSBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLl9yZXNvbHZlZE5hbWVzQW5kU3ltYm9scyA9IHJlc3VsdDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIHdoZXRoZXIgYW4gRW51bSBjb250YWlucyBhIHNwZWNpZmllZCBzeW1ib2wuXHJcbiAgPiAgICAgbGV0IHN5bWJvbCA9IERheU9mV2Vlay5GcmlkYXk7XHJcbiAgPiAgICAgaWYgKERheU9mV2Vlay5jb250YWlucyhzeW1ib2wpKSB7XHJcbiAgPiAgICAgICAgIC8vIGRvIHNvbWV0aGluZ1xyXG4gID4gICAgIH1cclxuICBAcGFyYW0gc3ltIC0gT2JqZWN0IG9yIHN5bWJvbCB0byB0ZXN0LlxyXG4gIEByZXR1cm4gV2hldGhlciB0aGlzIEVudW0gY29udGFpbnMgdGhlIHNwZWNpZmllZCBzeW1ib2wuXHJcbiAgKiovXHJcbiAgc3RhdGljIGNvbnRhaW5zKHN5bTogQnJlZXplRW51bSkge1xyXG4gICAgaWYgKCEoc3ltIGluc3RhbmNlb2YgQnJlZXplRW51bSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzW3N5bS5uYW1lXSAhPSBudWxsO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIC8qKlxyXG4gIC8vIENoZWNrcyBpZiBhbiBvYmplY3QgaXMgYW4gRW51bSAnc3ltYm9sJy4gVXNlIHRoZSAnY29udGFpbnMnIG1ldGhvZCBpbnN0ZWFkIG9mIHRoaXMgb25lIFxyXG4gIC8vIGlmIHlvdSB3YW50IHRvIHRlc3QgZm9yIGEgc3BlY2lmaWMgRW51bS4gXHJcbiAgLy8gPiAgICAgaWYgKEVudW0uaXNTeW1ib2woRGF5T2ZXZWVrLldlZG5lc2RheSkpIHtcclxuICAvLyA+ICAgICAgIC8vIGRvIHNvbWV0aGluZyAuLi5cclxuICAvLyA+ICAgICB9O1xyXG4gIC8vICoqL1xyXG4gIC8vIHN0YXRpYyBpc1N5bWJvbChvYmo6IGFueSkge1xyXG4gIC8vICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEJyZWV6ZUVudW07XHJcbiAgLy8gfTtcclxuXHJcbiAgLyoqIFJldHVybnMgdGhlIHN0cmluZyBuYW1lIG9mIHRoaXMgRW51bSAqL1xyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubmFtZTtcclxuICB9XHJcblxyXG4gIC8qKiBSZXR1cm4gZW51bSBuYW1lIGFuZCBzeW1ib2wgbmFtZSAqL1xyXG4gIHRvSlNPTigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIF8kdHlwZU5hbWU6IHRoaXNbJ18kdHlwZU5hbWUnXSB8fCAodGhpcy5jb25zdHJ1Y3RvciBhcyBhbnkpLm5hbWUsXHJcbiAgICAgIG5hbWU6IHRoaXMubmFtZVxyXG4gICAgfTtcclxuICB9XHJcblxyXG59XHJcblxyXG5cclxuIl19