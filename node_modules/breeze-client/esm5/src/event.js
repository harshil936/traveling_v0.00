import { core } from './core';
import { assertParam } from './assert-param';
function publishCore(that, data, errorCallback) {
    var subscribers = that._subscribers;
    if (!subscribers)
        return true;
    // subscribers from outer scope.
    subscribers.forEach(function (s) {
        try {
            s.callback(data);
        }
        catch (e) {
            e.context = "unable to publish on topic: " + that.name;
            if (errorCallback) {
                errorCallback(e);
            }
            else if (that._defaultErrorCallback) {
                that._defaultErrorCallback(e);
            }
            else {
                fallbackErrorHandler(e);
            }
        }
    });
}
function fallbackErrorHandler(e) {
    // TODO: maybe log this
    // for now do nothing;
}
/**
Class to support basic event publication and subscription semantics.
@dynamic
**/
var BreezeEvent = /** @class */ (function () {
    /**
    Constructor for an Event
    >     salaryEvent = new BreezeEvent("salaryEvent", person);
    @param name - The name of the event.
    @param publisher - The object that will be doing the publication. i.e. the object to which this event is attached.
    @param defaultErrorCallback - Function to call when an error occurs during subscription execution.
    If omitted then subscriber notification failures will be ignored.
    **/
    function BreezeEvent(name, publisher, defaultErrorCallback) {
        /**
        Unsubscribe from this event.
        >      // Assume order is a preexisting 'order' entity
        >      let token = order.entityAspect.propertyChanged.subscribe(function (pcEvent) {
        >              // do something
        >      });
        >      // sometime later
        >      order.entityAspect.propertyChanged.unsubscribe(token);
        @param unsubKey - The value returned from the 'subscribe' method may be used to unsubscribe here.
        @return Whether unsubscription occured. This will return false if already unsubscribed or if the key simply
        cannot be found.
        **/
        this.unsubscribe = function (unsubKey) {
            if (!this._subscribers)
                return false;
            var subs = this._subscribers;
            var ix = core.arrayIndexOf(subs, function (s) {
                return s.unsubKey === unsubKey;
            });
            if (ix !== -1) {
                subs.splice(ix, 1);
                if (subs.length === 0) {
                    this._subscribers = null;
                }
                return true;
            }
            else {
                return false;
            }
        };
        assertParam(name, "eventName").isNonEmptyString().check();
        assertParam(publisher, "publisher").isObject().check();
        this.name = name;
        // register the name
        BreezeEvent.__eventNameMap[name] = true;
        this.publisher = publisher;
        if (defaultErrorCallback) {
            this._defaultErrorCallback = defaultErrorCallback;
        }
    }
    /**
    Publish data for this event.
    >      // Assume 'salaryEvent' is previously constructed Event
    >      salaryEvent.publish( { eventType: "payRaise", amount: 100 });
  
    This event can also be published asychronously
    >      salaryEvent.publish( { eventType: "payRaise", amount: 100 }, true);
  
    And we can add a handler in case the subscriber 'mishandles' the event.
    >      salaryEvent.publish( { eventType: "payRaise", amount: 100 }, true, function(error) {
    >          // do something with the 'error' object
    >      });
    @param data - Data to publish
    @param publishAsync - (default=false) Whether to publish asynchonously or not.
    @param errorCallback - Function to be called for any errors that occur during publication. If omitted,
    errors will be eaten.
    @return false if event is disabled; true otherwise.
    **/
    BreezeEvent.prototype.publish = function (data, publishAsync, errorCallback) {
        if (publishAsync === void 0) { publishAsync = false; }
        if (!BreezeEvent._isEnabled(this.name, this.publisher))
            return false;
        if (publishAsync === true) {
            setTimeout(publishCore, 0, this, data, errorCallback);
        }
        else {
            publishCore(this, data, errorCallback);
        }
        return true;
    };
    /**
    Publish data for this event asynchronously.
    >      // Assume 'salaryEvent' is previously constructed Event
    >      salaryEvent.publishAsync( { eventType: "payRaise", amount: 100 });
  
    And we can add a handler in case the subscriber 'mishandles' the event.
    >      salaryEvent.publishAsync( { eventType: "payRaise", amount: 100 }, function(error) {
    >          // do something with the 'error' object
    >      });
    @param data - Data to publish
    @param errorCallback - Function to be called for any errors that occur during publication. If omitted,
    errors will be eaten.
    **/
    BreezeEvent.prototype.publishAsync = function (data, errorCallback) {
        this.publish(data, true, errorCallback);
    };
    /**
    Subscribe to this event.
    >      // Assume 'salaryEvent' is previously constructed Event
    >      salaryEvent.subscribe(function (eventArgs) {
    >          if (eventArgs.eventType === "payRaise") {
    >              // do something
    >          }
    >      });
  
    There are several built in Breeze events, such as [[EntityAspect.propertyChanged]], [[EntityAspect.validationErrorsChanged]] as well.
    >      // Assume order is a preexisting 'order' entity
    >      order.entityAspect.propertyChanged.subscribe(function (pcEvent) {
    >          if ( pcEvent.propertyName === "OrderDate") {
    >              // do something
    >          }
    >      });
    @param callback- Function to be called whenever 'data' is published for this event.
    @param callback.data - {Object} Whatever 'data' was published.  This should be documented on the specific event.
    @return This is a key for 'unsubscription'.  It can be passed to the 'unsubscribe' method.
    **/
    BreezeEvent.prototype.subscribe = function (callback) {
        if (!this._subscribers) {
            this._subscribers = [];
        }
        var unsubKey = BreezeEvent.__nextUnsubKey;
        this._subscribers.push({ unsubKey: unsubKey, callback: callback });
        ++BreezeEvent.__nextUnsubKey;
        return unsubKey;
    };
    /** remove all subscribers */
    BreezeEvent.prototype.clear = function () {
        this._subscribers = null;
    };
    /** event bubbling - document later. */
    // null or undefined 'getParentFn' means Event does not need to bubble i.e. that it is always enabled - .
    BreezeEvent.bubbleEvent = function (target, getParentFn) {
        target._getEventParent = getParentFn || null;
    };
    /**
    Enables or disables the named event for an object and all of its children.
    >      BreezeEvent.enable(“propertyChanged”, myEntityManager, false)
  
    will disable all EntityAspect.propertyChanged events within a EntityManager.
    >      BreezeEvent.enable(“propertyChanged”, myEntityManager, true)
  
    will enable all EntityAspect.propertyChanged events within a EntityManager.
    >      BreezeEvent.enable(“propertyChanged”, myEntity.entityAspect, false)
  
    will disable EntityAspect.propertyChanged events for a specific entity.
    >      BreezeEvent.enable(“propertyChanged”, myEntity.entityAspect, null)
  
    will removes any enabling / disabling at the entity aspect level so now any 'Event.enable' calls at the EntityManager level,
    made either previously or in the future, will control notification.
    >      BreezeEvent.enable(“validationErrorsChanged”, myEntityManager, function(em) {
    >          return em.customTag === “blue”;
    >      })
  
  
    will either enable or disable myEntityManager based on the current value of a ‘customTag’ property on myEntityManager.
    Note that this is dynamic, changing the customTag value will cause events to be enabled or disabled immediately.
    @param eventName - The name of the event.
    @param target - The object at which enabling or disabling will occur.  All event notifications that occur to this object or
    children of this object will be enabled or disabled.
    @param isEnabled - A boolean, a null or a function that returns either a boolean or a null.
    **/
    BreezeEvent.enable = function (eventName, obj, isEnabled) {
        assertParam(eventName, "eventName").isNonEmptyString().check();
        assertParam(obj, "obj").isObject().check();
        assertParam(isEnabled, "isEnabled").isBoolean().isOptional().or().isFunction().check();
        var ob = obj;
        if (!ob._$eventMap) {
            ob._$eventMap = {};
        }
        ob._$eventMap[eventName] = isEnabled;
    };
    /**
    Returns whether for a specific event and a specific object and its children, notification is enabled or disabled or not set.
    >      BreezeEvent.isEnabled(“propertyChanged”, myEntityManager)
    >
    @param eventName - The name of the event.
    @param target - The object for which we want to know if notifications are enabled.
    @return A null is returned if this value has not been set.
    **/
    BreezeEvent.isEnabled = function (eventName, obj) {
        assertParam(eventName, "eventName").isNonEmptyString().check();
        assertParam(obj, "obj").isObject().check();
        // null is ok - it just means that the object is at the top level.
        if (obj._getEventParent === undefined) {
            throw new Error("This object does not support event enabling/disabling");
        }
        // return ctor._isEnabled(getFullEventName(eventName), obj);
        return BreezeEvent._isEnabled(eventName, 3);
    };
    /** @hidden @internal */
    BreezeEvent.__eventNameMap = {};
    /** @hidden @internal */
    BreezeEvent.__nextUnsubKey = 1;
    /** @hidden @internal */
    BreezeEvent._isEnabled = function (eventName, obj) {
        var isEnabled = null;
        var ob = obj;
        var eventMap = ob._$eventMap;
        if (eventMap) {
            isEnabled = eventMap[eventName];
        }
        if (isEnabled != null) {
            if (typeof isEnabled === 'function') {
                return !!isEnabled(obj);
            }
            else {
                return !!isEnabled;
            }
        }
        else {
            var parent_1 = ob._getEventParent && ob._getEventParent();
            if (parent_1) {
                return !!this._isEnabled(eventName, parent_1);
            }
            else {
                // default if not explicitly disabled.
                return true;
            }
        }
    };
    return BreezeEvent;
}());
export { BreezeEvent };
// legacy support - deliberately not typed
core.Event = BreezeEvent;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9icmVlemUtY2xpZW50LyIsInNvdXJjZXMiOlsic3JjL2V2ZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDOUIsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTdDLFNBQVMsV0FBVyxDQUFJLElBQW9CLEVBQUUsSUFBTyxFQUFFLGFBQWlDO0lBQ3RGLElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDcEMsSUFBSSxDQUFDLFdBQVc7UUFBRSxPQUFPLElBQUksQ0FBQztJQUM5QixnQ0FBZ0M7SUFDaEMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7UUFDN0IsSUFBSTtZQUNGLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDbEI7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLENBQUMsQ0FBQyxPQUFPLEdBQUcsOEJBQThCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN2RCxJQUFJLGFBQWEsRUFBRTtnQkFDakIsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2xCO2lCQUFNLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFO2dCQUNyQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDL0I7aUJBQU07Z0JBQ0wsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDekI7U0FDRjtJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQVMsb0JBQW9CLENBQUMsQ0FBUTtJQUNwQyx1QkFBdUI7SUFDdkIsc0JBQXNCO0FBQ3hCLENBQUM7QUFTRDs7O0dBR0c7QUFDSDtJQWdCRTs7Ozs7OztPQU9HO0lBQ0gscUJBQVksSUFBWSxFQUFFLFNBQWlCLEVBQUUsb0JBQXdDO1FBMkZyRjs7Ozs7Ozs7Ozs7V0FXRztRQUNILGdC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eyBjb3JlIH0gZnJvbSAnLi9jb3JlJztcclxuaW1wb3J0IHsgYXNzZXJ0UGFyYW0gfSBmcm9tICcuL2Fzc2VydC1wYXJhbSc7XHJcblxyXG5mdW5jdGlvbiBwdWJsaXNoQ29yZTxUPih0aGF0OiBCcmVlemVFdmVudDxUPiwgZGF0YTogVCwgZXJyb3JDYWxsYmFjaz86IChlOiBFcnJvcikgPT4gYW55KSB7XHJcbiAgbGV0IHN1YnNjcmliZXJzID0gdGhhdC5fc3Vic2NyaWJlcnM7XHJcbiAgaWYgKCFzdWJzY3JpYmVycykgcmV0dXJuIHRydWU7XHJcbiAgLy8gc3Vic2NyaWJlcnMgZnJvbSBvdXRlciBzY29wZS5cclxuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBzLmNhbGxiYWNrKGRhdGEpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBlLmNvbnRleHQgPSBcInVuYWJsZSB0byBwdWJsaXNoIG9uIHRvcGljOiBcIiArIHRoYXQubmFtZTtcclxuICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICBlcnJvckNhbGxiYWNrKGUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoYXQuX2RlZmF1bHRFcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhhdC5fZGVmYXVsdEVycm9yQ2FsbGJhY2soZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmFsbGJhY2tFcnJvckhhbmRsZXIoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmFsbGJhY2tFcnJvckhhbmRsZXIoZTogRXJyb3IpIHtcclxuICAvLyBUT0RPOiBtYXliZSBsb2cgdGhpc1xyXG4gIC8vIGZvciBub3cgZG8gbm90aGluZztcclxufVxyXG5cclxuXHJcbi8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNjcmlwdGlvbiB7XHJcbiAgdW5zdWJLZXk6IG51bWJlcjtcclxuICBjYWxsYmFjazogKGRhdGE6IGFueSkgPT4gYW55O1xyXG59XHJcblxyXG4vKipcclxuQ2xhc3MgdG8gc3VwcG9ydCBiYXNpYyBldmVudCBwdWJsaWNhdGlvbiBhbmQgc3Vic2NyaXB0aW9uIHNlbWFudGljcy5cclxuQGR5bmFtaWNcclxuKiovXHJcbmV4cG9ydCBjbGFzcyBCcmVlemVFdmVudDxUPiB7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgc3RhdGljIF9fZXZlbnROYW1lTWFwID0ge307XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgc3RhdGljIF9fbmV4dFVuc3ViS2V5ID0gMTtcclxuICAvKiogVGhlIG5hbWUgb2YgdGhpcyBFdmVudCAqL1xyXG4gIG5hbWU6IHN0cmluZztcclxuICAvKiogVGhlIG9iamVjdCBkb2luZyB0aGUgcHVibGljYXRpb24uIGkuZS4gdGhlIG9iamVjdCB0byB3aGljaCB0aGlzIGV2ZW50IGlzIGF0dGFjaGVkLiAqL1xyXG4gIHB1Ymxpc2hlcjogT2JqZWN0O1xyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfc3Vic2NyaWJlcnM6IFN1YnNjcmlwdGlvbltdO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9kZWZhdWx0RXJyb3JDYWxsYmFjazogKGU6IEVycm9yKSA9PiBhbnk7XHJcblxyXG5cclxuICAvKipcclxuICBDb25zdHJ1Y3RvciBmb3IgYW4gRXZlbnRcclxuICA+ICAgICBzYWxhcnlFdmVudCA9IG5ldyBCcmVlemVFdmVudChcInNhbGFyeUV2ZW50XCIsIHBlcnNvbik7XHJcbiAgQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgQHBhcmFtIHB1Ymxpc2hlciAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGRvaW5nIHRoZSBwdWJsaWNhdGlvbi4gaS5lLiB0aGUgb2JqZWN0IHRvIHdoaWNoIHRoaXMgZXZlbnQgaXMgYXR0YWNoZWQuXHJcbiAgQHBhcmFtIGRlZmF1bHRFcnJvckNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFuIGVycm9yIG9jY3VycyBkdXJpbmcgc3Vic2NyaXB0aW9uIGV4ZWN1dGlvbi4gXHJcbiAgSWYgb21pdHRlZCB0aGVuIHN1YnNjcmliZXIgbm90aWZpY2F0aW9uIGZhaWx1cmVzIHdpbGwgYmUgaWdub3JlZC5cclxuICAqKi9cclxuICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIHB1Ymxpc2hlcjogT2JqZWN0LCBkZWZhdWx0RXJyb3JDYWxsYmFjaz86IChlOiBFcnJvcikgPT4gYW55KSB7XHJcbiAgICBhc3NlcnRQYXJhbShuYW1lLCBcImV2ZW50TmFtZVwiKS5pc05vbkVtcHR5U3RyaW5nKCkuY2hlY2soKTtcclxuICAgIGFzc2VydFBhcmFtKHB1Ymxpc2hlciwgXCJwdWJsaXNoZXJcIikuaXNPYmplY3QoKS5jaGVjaygpO1xyXG5cclxuICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAvLyByZWdpc3RlciB0aGUgbmFtZVxyXG4gICAgQnJlZXplRXZlbnQuX19ldmVudE5hbWVNYXBbbmFtZV0gPSB0cnVlO1xyXG4gICAgdGhpcy5wdWJsaXNoZXIgPSBwdWJsaXNoZXI7XHJcbiAgICBpZiAoZGVmYXVsdEVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgdGhpcy5fZGVmYXVsdEVycm9yQ2FsbGJhY2sgPSBkZWZhdWx0RXJyb3JDYWxsYmFjaztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFB1Ymxpc2ggZGF0YSBmb3IgdGhpcyBldmVudC5cclxuICA+ICAgICAgLy8gQXNzdW1lICdzYWxhcnlFdmVudCcgaXMgcHJldmlvdXNseSBjb25zdHJ1Y3RlZCBFdmVudFxyXG4gID4gICAgICBzYWxhcnlFdmVudC5wdWJsaXNoKCB7IGV2ZW50VHlwZTogXCJwYXlSYWlzZVwiLCBhbW91bnQ6IDEwMCB9KTtcclxuXHJcbiAgVGhpcyBldmVudCBjYW4gYWxzbyBiZSBwdWJsaXNoZWQgYXN5Y2hyb25vdXNseVxyXG4gID4gICAgICBzYWxhcnlFdmVudC5wdWJsaXNoKCB7IGV2ZW50VHlwZTogXCJwYXlSYWlzZVwiLCBhbW91bnQ6IDEwMCB9LCB0cnVlKTtcclxuXHJcbiAgQW5kIHdlIGNhbiBhZGQgYSBoYW5kbGVyIGluIGNhc2UgdGhlIHN1YnNjcmliZXIgJ21pc2hhbmRsZXMnIHRoZSBldmVudC5cclxuICA+ICAgICAgc2FsYXJ5RXZlbnQucHVibGlzaCggeyBldmVudFR5cGU6IFwicGF5UmFpc2VcIiwgYW1vdW50OiAxMDAgfSwgdHJ1ZSwgZnVuY3Rpb24oZXJyb3IpIHtcclxuICA+ICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSAnZXJyb3InIG9iamVjdFxyXG4gID4gICAgICB9KTtcclxuICBAcGFyYW0gZGF0YSAtIERhdGEgdG8gcHVibGlzaFxyXG4gIEBwYXJhbSBwdWJsaXNoQXN5bmMgLSAoZGVmYXVsdD1mYWxzZSkgV2hldGhlciB0byBwdWJsaXNoIGFzeW5jaG9ub3VzbHkgb3Igbm90LlxyXG4gIEBwYXJhbSBlcnJvckNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBhbnkgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIHB1YmxpY2F0aW9uLiBJZiBvbWl0dGVkLFxyXG4gIGVycm9ycyB3aWxsIGJlIGVhdGVuLlxyXG4gIEByZXR1cm4gZmFsc2UgaWYgZXZlbnQgaXMgZGlzYWJsZWQ7IHRydWUgb3RoZXJ3aXNlLlxyXG4gICoqL1xyXG4gIHB1Ymxpc2goZGF0YTogVCwgcHVibGlzaEFzeW5jOiBib29sZWFuID0gZmFsc2UsIGVycm9yQ2FsbGJhY2s/OiAoZTogRXJyb3IpID0+IGFueSkge1xyXG5cclxuICAgIGlmICghQnJlZXplRXZlbnQuX2lzRW5hYmxlZCh0aGlzLm5hbWUsIHRoaXMucHVibGlzaGVyKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIGlmIChwdWJsaXNoQXN5bmMgPT09IHRydWUpIHtcclxuICAgICAgc2V0VGltZW91dChwdWJsaXNoQ29yZSwgMCwgdGhpcywgZGF0YSwgZXJyb3JDYWxsYmFjayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwdWJsaXNoQ29yZSh0aGlzLCBkYXRhLCBlcnJvckNhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUHVibGlzaCBkYXRhIGZvciB0aGlzIGV2ZW50IGFzeW5jaHJvbm91c2x5LlxyXG4gID4gICAgICAvLyBBc3N1bWUgJ3NhbGFyeUV2ZW50JyBpcyBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIEV2ZW50XHJcbiAgPiAgICAgIHNhbGFyeUV2ZW50LnB1Ymxpc2hBc3luYyggeyBldmVudFR5cGU6IFwicGF5UmFpc2VcIiwgYW1vdW50OiAxMDAgfSk7XHJcblxyXG4gIEFuZCB3ZSBjYW4gYWRkIGEgaGFuZGxlciBpbiBjYXNlIHRoZSBzdWJzY3JpYmVyICdtaXNoYW5kbGVzJyB0aGUgZXZlbnQuXHJcbiAgPiAgICAgIHNhbGFyeUV2ZW50LnB1Ymxpc2hBc3luYyggeyBldmVudFR5cGU6IFwicGF5UmFpc2VcIiwgYW1vdW50OiAxMDAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcclxuICA+ICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSAnZXJyb3InIG9iamVjdFxyXG4gID4gICAgICB9KTtcclxuICBAcGFyYW0gZGF0YSAtIERhdGEgdG8gcHVibGlzaFxyXG4gIEBwYXJhbSBlcnJvckNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBhbnkgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIHB1YmxpY2F0aW9uLiBJZiBvbWl0dGVkLFxyXG4gIGVycm9ycyB3aWxsIGJlIGVhdGVuLlxyXG4gICoqL1xyXG4gIHB1Ymxpc2hBc3luYyhkYXRhOiBULCBlcnJvckNhbGxiYWNrOiAoZTogRXJyb3IpID0+IGFueSkge1xyXG4gICAgdGhpcy5wdWJsaXNoKGRhdGEsIHRydWUsIGVycm9yQ2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgU3Vic2NyaWJlIHRvIHRoaXMgZXZlbnQuXHJcbiAgPiAgICAgIC8vIEFzc3VtZSAnc2FsYXJ5RXZlbnQnIGlzIHByZXZpb3VzbHkgY29uc3RydWN0ZWQgRXZlbnRcclxuICA+ICAgICAgc2FsYXJ5RXZlbnQuc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudEFyZ3MpIHtcclxuICA+ICAgICAgICAgIGlmIChldmVudEFyZ3MuZXZlbnRUeXBlID09PSBcInBheVJhaXNlXCIpIHtcclxuICA+ICAgICAgICAgICAgICAvLyBkbyBzb21ldGhpbmdcclxuICA+ICAgICAgICAgIH1cclxuICA+ICAgICAgfSk7XHJcblxyXG4gIFRoZXJlIGFyZSBzZXZlcmFsIGJ1aWx0IGluIEJyZWV6ZSBldmVudHMsIHN1Y2ggYXMgW1tFbnRpdHlBc3BlY3QucHJvcGVydHlDaGFuZ2VkXV0sIFtbRW50aXR5QXNwZWN0LnZhbGlkYXRpb25FcnJvcnNDaGFuZ2VkXV0gYXMgd2VsbC5cclxuICA+ICAgICAgLy8gQXNzdW1lIG9yZGVyIGlzIGEgcHJlZXhpc3RpbmcgJ29yZGVyJyBlbnRpdHlcclxuICA+ICAgICAgb3JkZXIuZW50aXR5QXNwZWN0LnByb3BlcnR5Q2hhbmdlZC5zdWJzY3JpYmUoZnVuY3Rpb24gKHBjRXZlbnQpIHtcclxuICA+ICAgICAgICAgIGlmICggcGNFdmVudC5wcm9wZXJ0eU5hbWUgPT09IFwiT3JkZXJEYXRlXCIpIHtcclxuICA+ICAgICAgICAgICAgICAvLyBkbyBzb21ldGhpbmdcclxuICA+ICAgICAgICAgIH1cclxuICA+ICAgICAgfSk7XHJcbiAgQHBhcmFtIGNhbGxiYWNrLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgJ2RhdGEnIGlzIHB1Ymxpc2hlZCBmb3IgdGhpcyBldmVudC5cclxuICBAcGFyYW0gY2FsbGJhY2suZGF0YSAtIHtPYmplY3R9IFdoYXRldmVyICdkYXRhJyB3YXMgcHVibGlzaGVkLiAgVGhpcyBzaG91bGQgYmUgZG9jdW1lbnRlZCBvbiB0aGUgc3BlY2lmaWMgZXZlbnQuXHJcbiAgQHJldHVybiBUaGlzIGlzIGEga2V5IGZvciAndW5zdWJzY3JpcHRpb24nLiAgSXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgJ3Vuc3Vic2NyaWJlJyBtZXRob2QuXHJcbiAgKiovXHJcbiAgc3Vic2NyaWJlKGNhbGxiYWNrOiAoZGF0YTogVCkgPT4gYW55KSB7XHJcbiAgICBpZiAoIXRoaXMuX3N1YnNjcmliZXJzKSB7XHJcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHVuc3ViS2V5ID0gQnJlZXplRXZlbnQuX19uZXh0VW5zdWJLZXk7XHJcbiAgICB0aGlzLl9zdWJzY3JpYmVycy5wdXNoKHsgdW5zdWJLZXk6IHVuc3ViS2V5LCBjYWxsYmFjazogY2FsbGJhY2sgfSk7XHJcbiAgICArK0JyZWV6ZUV2ZW50Ll9fbmV4dFVuc3ViS2V5O1xyXG4gICAgcmV0dXJuIHVuc3ViS2V5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgVW5zdWJzY3JpYmUgZnJvbSB0aGlzIGV2ZW50LlxyXG4gID4gICAgICAvLyBBc3N1bWUgb3JkZXIgaXMgYSBwcmVleGlzdGluZyAnb3JkZXInIGVudGl0eVxyXG4gID4gICAgICBsZXQgdG9rZW4gPSBvcmRlci5lbnRpdHlBc3BlY3QucHJvcGVydHlDaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbiAocGNFdmVudCkge1xyXG4gID4gICAgICAgICAgICAgIC8vIGRvIHNvbWV0aGluZ1xyXG4gID4gICAgICB9KTtcclxuICA+ICAgICAgLy8gc29tZXRpbWUgbGF0ZXJcclxuICA+ICAgICAgb3JkZXIuZW50aXR5QXNwZWN0LnByb3BlcnR5Q2hhbmdlZC51bnN1YnNjcmliZSh0b2tlbik7XHJcbiAgQHBhcmFtIHVuc3ViS2V5IC0gVGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlICdzdWJzY3JpYmUnIG1ldGhvZCBtYXkgYmUgdXNlZCB0byB1bnN1YnNjcmliZSBoZXJlLlxyXG4gIEByZXR1cm4gV2hldGhlciB1bnN1YnNjcmlwdGlvbiBvY2N1cmVkLiBUaGlzIHdpbGwgcmV0dXJuIGZhbHNlIGlmIGFscmVhZHkgdW5zdWJzY3JpYmVkIG9yIGlmIHRoZSBrZXkgc2ltcGx5XHJcbiAgY2Fubm90IGJlIGZvdW5kLlxyXG4gICoqL1xyXG4gIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHVuc3ViS2V5OiBudW1iZXIpIHtcclxuICAgIGlmICghdGhpcy5fc3Vic2NyaWJlcnMpIHJldHVybiBmYWxzZTtcclxuICAgIGxldCBzdWJzID0gdGhpcy5fc3Vic2NyaWJlcnM7XHJcbiAgICBsZXQgaXggPSBjb3JlLmFycmF5SW5kZXhPZihzdWJzLCBmdW5jdGlvbiAocykge1xyXG4gICAgICByZXR1cm4gcy51bnN1YktleSA9PT0gdW5zdWJLZXk7XHJcbiAgICB9KTtcclxuICAgIGlmIChpeCAhPT0gLTEpIHtcclxuICAgICAgc3Vicy5zcGxpY2UoaXgsIDEpO1xyXG4gICAgICBpZiAoc3Vicy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpYmVycyA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqIHJlbW92ZSBhbGwgc3Vic2NyaWJlcnMgKi9cclxuICBjbGVhcigpIHtcclxuICAgIHRoaXMuX3N1YnNjcmliZXJzID0gPGFueT5udWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqIGV2ZW50IGJ1YmJsaW5nIC0gZG9jdW1lbnQgbGF0ZXIuICovXHJcblxyXG4gIC8vIG51bGwgb3IgdW5kZWZpbmVkICdnZXRQYXJlbnRGbicgbWVhbnMgRXZlbnQgZG9lcyBub3QgbmVlZCB0byBidWJibGUgaS5lLiB0aGF0IGl0IGlzIGFsd2F5cyBlbmFibGVkIC0gLlxyXG4gIHN0YXRpYyBidWJibGVFdmVudCh0YXJnZXQ6IGFueSwgZ2V0UGFyZW50Rm4/OiAoKCkgPT4gYW55KSkge1xyXG4gICAgdGFyZ2V0Ll9nZXRFdmVudFBhcmVudCA9IGdldFBhcmVudEZuIHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBuYW1lZCBldmVudCBmb3IgYW4gb2JqZWN0IGFuZCBhbGwgb2YgaXRzIGNoaWxkcmVuLlxyXG4gID4gICAgICBCcmVlemVFdmVudC5lbmFibGUo4oCccHJvcGVydHlDaGFuZ2Vk4oCdLCBteUVudGl0eU1hbmFnZXIsIGZhbHNlKVxyXG5cclxuICB3aWxsIGRpc2FibGUgYWxsIEVudGl0eUFzcGVjdC5wcm9wZXJ0eUNoYW5nZWQgZXZlbnRzIHdpdGhpbiBhIEVudGl0eU1hbmFnZXIuXHJcbiAgPiAgICAgIEJyZWV6ZUV2ZW50LmVuYWJsZSjigJxwcm9wZXJ0eUNoYW5nZWTigJ0sIG15RW50aXR5TWFuYWdlciwgdHJ1ZSlcclxuXHJcbiAgd2lsbCBlbmFibGUgYWxsIEVudGl0eUFzcGVjdC5wcm9wZXJ0eUNoYW5nZWQgZXZlbnRzIHdpdGhpbiBhIEVudGl0eU1hbmFnZXIuXHJcbiAgPiAgICAgIEJyZWV6ZUV2ZW50LmVuYWJsZSjigJxwcm9wZXJ0eUNoYW5nZWTigJ0sIG15RW50aXR5LmVudGl0eUFzcGVjdCwgZmFsc2UpXHJcblxyXG4gIHdpbGwgZGlzYWJsZSBFbnRpdHlBc3BlY3QucHJvcGVydHlDaGFuZ2VkIGV2ZW50cyBmb3IgYSBzcGVjaWZpYyBlbnRpdHkuXHJcbiAgPiAgICAgIEJyZWV6ZUV2ZW50LmVuYWJsZSjigJxwcm9wZXJ0eUNoYW5nZWTigJ0sIG15RW50aXR5LmVudGl0eUFzcGVjdCwgbnVsbClcclxuXHJcbiAgd2lsbCByZW1vdmVzIGFueSBlbmFibGluZyAvIGRpc2FibGluZyBhdCB0aGUgZW50aXR5IGFzcGVjdCBsZXZlbCBzbyBub3cgYW55ICdFdmVudC5lbmFibGUnIGNhbGxzIGF0IHRoZSBFbnRpdHlNYW5hZ2VyIGxldmVsLFxyXG4gIG1hZGUgZWl0aGVyIHByZXZpb3VzbHkgb3IgaW4gdGhlIGZ1dHVyZSwgd2lsbCBjb250cm9sIG5vdGlmaWNhdGlvbi5cclxuICA+ICAgICAgQnJlZXplRXZlbnQuZW5hYmxlKOKAnHZhbGlkYXRpb25FcnJvcnNDaGFuZ2Vk4oCdLCBteUVudGl0eU1hbmFnZXIsIGZ1bmN0aW9uKGVtKSB7XHJcbiAgPiAgICAgICAgICByZXR1cm4gZW0uY3VzdG9tVGFnID09PSDigJxibHVl4oCdO1xyXG4gID4gICAgICB9KVxyXG5cclxuXHJcbiAgd2lsbCBlaXRoZXIgZW5hYmxlIG9yIGRpc2FibGUgbXlFbnRpdHlNYW5hZ2VyIGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEg4oCYY3VzdG9tVGFn4oCZIHByb3BlcnR5IG9uIG15RW50aXR5TWFuYWdlci5cclxuICBOb3RlIHRoYXQgdGhpcyBpcyBkeW5hbWljLCBjaGFuZ2luZyB0aGUgY3VzdG9tVGFnIHZhbHVlIHdpbGwgY2F1c2UgZXZlbnRzIHRvIGJlIGVuYWJsZWQgb3IgZGlzYWJsZWQgaW1tZWRpYXRlbHkuXHJcbiAgQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICBAcGFyYW0gdGFyZ2V0IC0gVGhlIG9iamVjdCBhdCB3aGljaCBlbmFibGluZyBvciBkaXNhYmxpbmcgd2lsbCBvY2N1ci4gIEFsbCBldmVudCBub3RpZmljYXRpb25zIHRoYXQgb2NjdXIgdG8gdGhpcyBvYmplY3Qgb3JcclxuICBjaGlsZHJlbiBvZiB0aGlzIG9iamVjdCB3aWxsIGJlIGVuYWJsZWQgb3IgZGlzYWJsZWQuXHJcbiAgQHBhcmFtIGlzRW5hYmxlZCAtIEEgYm9vbGVhbiwgYSBudWxsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGVpdGhlciBhIGJvb2xlYW4gb3IgYSBudWxsLlxyXG4gICoqL1xyXG4gc3RhdGljIGVuYWJsZShldmVudE5hbWU6IHN0cmluZywgb2JqOiBPYmplY3QsIGlzRW5hYmxlZDogYm9vbGVhbiB8ICgoeDogYW55KSA9PiBib29sZWFuKSkge1xyXG4gICAgYXNzZXJ0UGFyYW0oZXZlbnROYW1lLCBcImV2ZW50TmFtZVwiKS5pc05vbkVtcHR5U3RyaW5nKCkuY2hlY2soKTtcclxuICAgIGFzc2VydFBhcmFtKG9iaiwgXCJvYmpcIikuaXNPYmplY3QoKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0oaXNFbmFibGVkLCBcImlzRW5hYmxlZFwiKS5pc0Jvb2xlYW4oKS5pc09wdGlvbmFsKCkub3IoKS5pc0Z1bmN0aW9uKCkuY2hlY2soKTtcclxuICAgIGxldCBvYiA9IDxhbnk+b2JqO1xyXG4gICAgaWYgKCFvYi5fJGV2ZW50TWFwKSB7XHJcbiAgICAgIG9iLl8kZXZlbnRNYXAgPSB7fTtcclxuICAgIH1cclxuICAgIG9iLl8kZXZlbnRNYXBbZXZlbnROYW1lXSA9IGlzRW5hYmxlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgd2hldGhlciBmb3IgYSBzcGVjaWZpYyBldmVudCBhbmQgYSBzcGVjaWZpYyBvYmplY3QgYW5kIGl0cyBjaGlsZHJlbiwgbm90aWZpY2F0aW9uIGlzIGVuYWJsZWQgb3IgZGlzYWJsZWQgb3Igbm90IHNldC5cclxuICA+ICAgICAgQnJlZXplRXZlbnQuaXNFbmFibGVkKOKAnHByb3BlcnR5Q2hhbmdlZOKAnSwgbXlFbnRpdHlNYW5hZ2VyKVxyXG4gID4gXHJcbiAgQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICBAcGFyYW0gdGFyZ2V0IC0gVGhlIG9iamVjdCBmb3Igd2hpY2ggd2Ugd2FudCB0byBrbm93IGlmIG5vdGlmaWNhdGlvbnMgYXJlIGVuYWJsZWQuXHJcbiAgQHJldHVybiBBIG51bGwgaXMgcmV0dXJuZWQgaWYgdGhpcyB2YWx1ZSBoYXMgbm90IGJlZW4gc2V0LlxyXG4gICoqL1xyXG4gIHN0YXRpYyBpc0VuYWJsZWQoZXZlbnROYW1lOiBzdHJpbmcsIG9iajogT2JqZWN0KSB7XHJcbiAgICBhc3NlcnRQYXJhbShldmVudE5hbWUsIFwiZXZlbnROYW1lXCIpLmlzTm9uRW1wdHlTdHJpbmcoKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0ob2JqLCBcIm9ialwiKS5pc09iamVjdCgpLmNoZWNrKCk7XHJcbiAgICAvLyBudWxsIGlzIG9rIC0gaXQganVzdCBtZWFucyB0aGF0IHRoZSBvYmplY3QgaXMgYXQgdGhlIHRvcCBsZXZlbC5cclxuICAgIGlmICgoPGFueT5vYmopLl9nZXRFdmVudFBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgb2JqZWN0IGRvZXMgbm90IHN1cHBvcnQgZXZlbnQgZW5hYmxpbmcvZGlzYWJsaW5nXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gcmV0dXJuIGN0b3IuX2lzRW5hYmxlZChnZXRGdWxsRXZlbnROYW1lKGV2ZW50TmFtZSksIG9iaik7XHJcbiAgICByZXR1cm4gQnJlZXplRXZlbnQuX2lzRW5hYmxlZChldmVudE5hbWUsIDMpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgc3RhdGljIF9pc0VuYWJsZWQgPSBmdW5jdGlvbiAoZXZlbnROYW1lOiBzdHJpbmcsIG9iajogT2JqZWN0KSB7XHJcbiAgICBsZXQgaXNFbmFibGVkOiBhbnkgPSBudWxsO1xyXG4gICAgbGV0IG9iID0gPGFueT5vYmo7XHJcbiAgICBsZXQgZXZlbnRNYXAgPSBvYi5fJGV2ZW50TWFwO1xyXG4gICAgaWYgKGV2ZW50TWFwKSB7XHJcbiAgICAgIGlzRW5hYmxlZCA9IGV2ZW50TWFwW2V2ZW50TmFtZV07XHJcbiAgICB9XHJcbiAgICBpZiAoaXNFbmFibGVkICE9IG51bGwpIHtcclxuICAgICAgaWYgKHR5cGVvZiBpc0VuYWJsZWQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gISFpc0VuYWJsZWQob2JqKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gISFpc0VuYWJsZWQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBwYXJlbnQgPSBvYi5fZ2V0RXZlbnRQYXJlbnQgJiYgb2IuX2dldEV2ZW50UGFyZW50KCk7XHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9pc0VuYWJsZWQoZXZlbnROYW1lLCBwYXJlbnQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGRlZmF1bHQgaWYgbm90IGV4cGxpY2l0bHkgZGlzYWJsZWQuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuXHJcbn1cclxuXHJcbi8vIGxlZ2FjeSBzdXBwb3J0IC0gZGVsaWJlcmF0ZWx5IG5vdCB0eXBlZFxyXG4oY29yZSBhcyBhbnkpLkV2ZW50ID0gQnJlZXplRXZlbnQ7Il19