import { core } from './core';
import { assertParam } from './assert-param';
import { EntityType } from './entity-metadata';
import { DataType } from './data-type';
/**
An EntityKey is an object that represents the unique identity of an entity.  EntityKey's are immutable.


**/
var EntityKey = /** @class */ (function () {
    /**
    Constructs a new EntityKey.  Each entity within an EntityManager will have a unique EntityKey.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     var empType = em1.metadataStore.getEntityType("Employee");
    >     var entityKey = new EntityKey(empType, 1);
  
    EntityKey's may also be found by calling EntityAspect.getKey()
    >     // assume employee1 is an existing Employee entity
    >     var empKey = employee1.entityAspect.getKey();
  
    Multipart keys are created by passing an array as the 'keyValues' parameter
    >     var empTerrType = em1.metadataStore.getEntityType("EmployeeTerritory");
    >     var empTerrKey = new EntityKey(empTerrType, [ 1, 77]);
    >     // The order of the properties in the 'keyValues' array must be the same as that
    >     // returned by empTerrType.keyProperties
    @param entityType - The [[EntityType]] of the entity.
    @param keyValues - A single value or an array of values.
    */
    function EntityKey(entityType, keyValues) {
        assertParam(entityType, "entityType").isInstanceOf(EntityType).check();
        var subtypes = entityType.getSelfAndSubtypes();
        if (subtypes.length > 1) {
            this._subtypes = subtypes.filter(function (st) {
                return st.isAbstract === false;
            });
        }
        if (!Array.isArray(keyValues)) {
            keyValues = [keyValues];
        }
        this.entityType = entityType;
        entityType.keyProperties.forEach(function (kp, i) {
            // insure that guid keys are comparable.
            if (kp.dataType === DataType.Guid) {
                keyValues[i] = keyValues[i] && keyValues[i].toLowerCase ? keyValues[i].toLowerCase() : keyValues[i];
            }
        });
        this.values = keyValues;
        this._keyInGroup = EntityKey.createKeyString(keyValues);
    }
    EntityKey.prototype.toJSON = function () {
        return {
            entityType: this.entityType.name,
            values: this.values
        };
    };
    EntityKey.fromJSON = function (json, metadataStore) {
        var et = metadataStore._getStructuralType(json.entityType, true);
        return new EntityKey(et, json.values);
    };
    /**
    Used to compare EntityKeys are determine if they refer to the same Entity.
    There is also an static version of 'equals' with the same functionality.
    
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      var empType = em1.metadataStore.getEntityType("Employee");
    >      var empKey1 = new EntityKey(empType, 1);
    >      // assume employee1 is an existing Employee entity
    >      var empKey2 = employee1.entityAspect.getKey();
    >      if (empKey1.equals(empKey2)) {
    >          // do something  ...
    >      }
    **/
    EntityKey.prototype.equals = function (entityKey) {
        if (!(entityKey instanceof EntityKey))
            return false;
        return (this.entityType === entityKey.entityType) &&
            core.arrayEquals(this.values, entityKey.values);
    };
    /*
    Returns a human readable representation of this EntityKey.
    */
    EntityKey.prototype.toString = function (altEntityType) {
        return (altEntityType || this.entityType).name + '-' + this._keyInGroup;
    };
    /**
    Used to compare EntityKeys are determine if they refer to the same Entity.
    There is also an instance version of 'equals' with the same functionality.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      var empType = em1.metadataStore.getEntityType("Employee");
    >      var empKey1 = new EntityKey(empType, 1);
    >      // assume employee1 is an existing Employee entity
    >      var empKey2 = employee1.entityAspect.getKey();
    >      if (EntityKey.equals(empKey1, empKey2)) {
    >          // do something  ...
    >      }
    **/
    EntityKey.equals = function (k1, k2) {
        if (!(k1 instanceof EntityKey))
            return false;
        return k1.equals(k2);
    };
    /** @hidden @internal */
    // TODO: we may want to compare to default values later.
    EntityKey.prototype._isEmpty = function () {
        return this.values.join("").length === 0;
    };
    /** hidden */
    // TODO: think about giving _ prefix or documenting.
    EntityKey.createKeyString = function (keyValues) {
        return keyValues.join(EntityKey.ENTITY_KEY_DELIMITER);
    };
    /** @hidden @internal */
    EntityKey.ENTITY_KEY_DELIMITER = ":::";
    return EntityKey;
}());
export { EntityKey };
EntityKey.prototype._$typeName = "EntityKey";
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXR5LWtleS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2JyZWV6ZS1jbGllbnQvIiwic291cmNlcyI6WyJzcmMvZW50aXR5LWtleS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzlCLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsVUFBVSxFQUFpQixNQUFNLG1CQUFtQixDQUFDO0FBQzlELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFdkM7Ozs7R0FJRztBQUNIO0lBZUU7Ozs7Ozs7Ozs7Ozs7Ozs7O01BaUJFO0lBQ0YsbUJBQVksVUFBc0IsRUFBRSxTQUFjO1FBQ2hELFdBQVcsQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3ZFLElBQUksUUFBUSxHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQy9DLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDdkIsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRTtnQkFDM0MsT0FBTyxFQUFFLENBQUMsVUFBVSxLQUFLLEtBQUssQ0FBQztZQUNqQyxDQUFDLENBQUMsQ0FBQztTQUNKO1FBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDN0IsU0FBUyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDekI7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixVQUFVLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDO1lBQzlDLHdDQUF3QztZQUN4QyxJQUFJLEVBQUUsQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLElBQUksRUFBRTtnQkFDakMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNyRztRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUM7UUFDeEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBRTFELENBQUM7SUFHRCwwQkFBTSxHQUFOO1FBQ0UsT0FBTztZQUNMLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUk7WUFDaEMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1NBQ3BCLENBQUM7SUFDSixDQUFDO0lBRU0sa0JBQVEsR0FBZixVQUFnQixJQUFTLEVBQUUsYUFBNEI7UUFDckQsSUFBSSxFQUFFLEdBQUcsYUFBYSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFlLENBQUM7UUFDL0UsT0FBTyxJQUFJLFNBQVMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCwwQkFBTSxHQUFOLFVBQU8sU0FBb0I7UUFDekIsSUFBSSxDQUFDLENBQUMsU0FBUyxZQUFZLFNBQVMsQ0FBQztZQUFFLE9BQU8sS0FBSyxDQUFDO1FBQ3BELE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxLQUFLLFNBQVMsQ0FBQyxVQUFVLENBQUM7WUFDL0MsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7O01BRUU7SUFDRiw0QkFBUSxHQUFSLFVBQVMsYUFBMEI7UUFDakMsT0FBTyxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNJLGdCQUFNLEdBQWIsVUFBYyxFQUFhLEVBQUUsRUFBYTtRQUN4QyxJQUFJLENBQUMsQ0FBQyxFQUFFLFlBQVksU0FBUyxDQUFDO1lBQUUsT0FBTyxLQUFLLENBQUM7UUFDN0MsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCx3QkFBd0I7SUFDeEIsd0RBQXdEO0lBQ3hELDRCQUFRLEdBQVI7UUFDRSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELGFBQWE7SUFDYixvREFBb0Q7SUFDN0MseUJBQWUsR0FBdEIsVUFBdUIsU0FBZ0I7UUFDckMsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUExSEQsd0JBQXdCO0lBQ2pCLDhCQUFvQixHQUFHLEtBQUssQ0FBQztJQTJIdEMsZ0JBQUM7Q0FBQSxBQS9IRCxJQStIQztTQS9IWSxTQUFTO0FBZ0l0QixTQUFTLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb3JlIH0gZnJvbSAnLi9jb3JlJztcclxuaW1wb3J0IHsgYXNzZXJ0UGFyYW0gfSBmcm9tICcuL2Fzc2VydC1wYXJhbSc7XHJcbmltcG9ydCB7IEVudGl0eVR5cGUsIE1ldGFkYXRhU3RvcmUgfSBmcm9tICcuL2VudGl0eS1tZXRhZGF0YSc7XHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi9kYXRhLXR5cGUnO1xyXG5cclxuLyoqXHJcbkFuIEVudGl0eUtleSBpcyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB1bmlxdWUgaWRlbnRpdHkgb2YgYW4gZW50aXR5LiAgRW50aXR5S2V5J3MgYXJlIGltbXV0YWJsZS5cclxuXHJcblxyXG4qKi9cclxuZXhwb3J0IGNsYXNzIEVudGl0eUtleSB7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgXyR0eXBlTmFtZTogc3RyaW5nOyAvLyBhY3R1YWxseSBwbGFjZWQgb24gcHJvdG90eXBlXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgc3RhdGljIEVOVElUWV9LRVlfREVMSU1JVEVSID0gXCI6OjpcIjtcclxuICAvKiogIFRoZSAnRW50aXR5VHlwZScgdGhhdCB0aGlzIGlzIGEga2V5IGZvci4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGVudGl0eVR5cGU6IEVudGl0eVR5cGU7XHJcbiAgLyoqICBBbiBhcnJheSBvZiB0aGUgdmFsdWVzIGZvciB0aGlzIGtleS4gVGhpcyB3aWxsIHVzdWFsbHkgb25seSBoYXZlIGEgc2luZ2xlIGVsZW1lbnQsIFxyXG4gIHVubGVzcyB0aGUgZW50aXR5IHR5cGUgaGFzIGEgbXVsdGlwYXJ0IGtleS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIHZhbHVlczogYW55W107XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2tleUluR3JvdXA6IHN0cmluZztcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfc3VidHlwZXM6IEVudGl0eVR5cGVbXTtcclxuXHJcbiAgLyoqXHJcbiAgQ29uc3RydWN0cyBhIG5ldyBFbnRpdHlLZXkuICBFYWNoIGVudGl0eSB3aXRoaW4gYW4gRW50aXR5TWFuYWdlciB3aWxsIGhhdmUgYSB1bmlxdWUgRW50aXR5S2V5LlxyXG4gID4gICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgIHZhciBlbXBUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkVtcGxveWVlXCIpO1xyXG4gID4gICAgIHZhciBlbnRpdHlLZXkgPSBuZXcgRW50aXR5S2V5KGVtcFR5cGUsIDEpO1xyXG5cclxuICBFbnRpdHlLZXkncyBtYXkgYWxzbyBiZSBmb3VuZCBieSBjYWxsaW5nIEVudGl0eUFzcGVjdC5nZXRLZXkoKVxyXG4gID4gICAgIC8vIGFzc3VtZSBlbXBsb3llZTEgaXMgYW4gZXhpc3RpbmcgRW1wbG95ZWUgZW50aXR5XHJcbiAgPiAgICAgdmFyIGVtcEtleSA9IGVtcGxveWVlMS5lbnRpdHlBc3BlY3QuZ2V0S2V5KCk7XHJcblxyXG4gIE11bHRpcGFydCBrZXlzIGFyZSBjcmVhdGVkIGJ5IHBhc3NpbmcgYW4gYXJyYXkgYXMgdGhlICdrZXlWYWx1ZXMnIHBhcmFtZXRlclxyXG4gID4gICAgIHZhciBlbXBUZXJyVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJFbXBsb3llZVRlcnJpdG9yeVwiKTtcclxuICA+ICAgICB2YXIgZW1wVGVycktleSA9IG5ldyBFbnRpdHlLZXkoZW1wVGVyclR5cGUsIFsgMSwgNzddKTtcclxuICA+ICAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIHByb3BlcnRpZXMgaW4gdGhlICdrZXlWYWx1ZXMnIGFycmF5IG11c3QgYmUgdGhlIHNhbWUgYXMgdGhhdFxyXG4gID4gICAgIC8vIHJldHVybmVkIGJ5IGVtcFRlcnJUeXBlLmtleVByb3BlcnRpZXNcclxuICBAcGFyYW0gZW50aXR5VHlwZSAtIFRoZSBbW0VudGl0eVR5cGVdXSBvZiB0aGUgZW50aXR5LlxyXG4gIEBwYXJhbSBrZXlWYWx1ZXMgLSBBIHNpbmdsZSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZXMuIFxyXG4gICovXHJcbiAgY29uc3RydWN0b3IoZW50aXR5VHlwZTogRW50aXR5VHlwZSwga2V5VmFsdWVzOiBhbnkpIHtcclxuICAgIGFzc2VydFBhcmFtKGVudGl0eVR5cGUsIFwiZW50aXR5VHlwZVwiKS5pc0luc3RhbmNlT2YoRW50aXR5VHlwZSkuY2hlY2soKTtcclxuICAgIGxldCBzdWJ0eXBlcyA9IGVudGl0eVR5cGUuZ2V0U2VsZkFuZFN1YnR5cGVzKCk7XHJcbiAgICBpZiAoc3VidHlwZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICB0aGlzLl9zdWJ0eXBlcyA9IHN1YnR5cGVzLmZpbHRlcihmdW5jdGlvbiAoc3QpIHtcclxuICAgICAgICByZXR1cm4gc3QuaXNBYnN0cmFjdCA9PT0gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlWYWx1ZXMpKSB7XHJcbiAgICAgIGtleVZhbHVlcyA9IFtrZXlWYWx1ZXNdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZW50aXR5VHlwZSA9IGVudGl0eVR5cGU7XHJcbiAgICBlbnRpdHlUeXBlLmtleVByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoa3AsIGkpIHtcclxuICAgICAgLy8gaW5zdXJlIHRoYXQgZ3VpZCBrZXlzIGFyZSBjb21wYXJhYmxlLlxyXG4gICAgICBpZiAoa3AuZGF0YVR5cGUgPT09IERhdGFUeXBlLkd1aWQpIHtcclxuICAgICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZXNbaV0gJiYga2V5VmFsdWVzW2ldLnRvTG93ZXJDYXNlID8ga2V5VmFsdWVzW2ldLnRvTG93ZXJDYXNlKCkgOiBrZXlWYWx1ZXNbaV07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMudmFsdWVzID0ga2V5VmFsdWVzO1xyXG4gICAgdGhpcy5fa2V5SW5Hcm91cCA9IEVudGl0eUtleS5jcmVhdGVLZXlTdHJpbmcoa2V5VmFsdWVzKTtcclxuXHJcbiAgfVxyXG5cclxuXHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZW50aXR5VHlwZTogdGhpcy5lbnRpdHlUeXBlLm5hbWUsXHJcbiAgICAgIHZhbHVlczogdGhpcy52YWx1ZXNcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbUpTT04oanNvbjogYW55LCBtZXRhZGF0YVN0b3JlOiBNZXRhZGF0YVN0b3JlKSB7XHJcbiAgICBsZXQgZXQgPSBtZXRhZGF0YVN0b3JlLl9nZXRTdHJ1Y3R1cmFsVHlwZShqc29uLmVudGl0eVR5cGUsIHRydWUpIGFzIEVudGl0eVR5cGU7XHJcbiAgICByZXR1cm4gbmV3IEVudGl0eUtleShldCwganNvbi52YWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgVXNlZCB0byBjb21wYXJlIEVudGl0eUtleXMgYXJlIGRldGVybWluZSBpZiB0aGV5IHJlZmVyIHRvIHRoZSBzYW1lIEVudGl0eS5cclxuICBUaGVyZSBpcyBhbHNvIGFuIHN0YXRpYyB2ZXJzaW9uIG9mICdlcXVhbHMnIHdpdGggdGhlIHNhbWUgZnVuY3Rpb25hbGl0eS5cclxuICBcclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIHZhciBlbXBUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkVtcGxveWVlXCIpO1xyXG4gID4gICAgICB2YXIgZW1wS2V5MSA9IG5ldyBFbnRpdHlLZXkoZW1wVHlwZSwgMSk7XHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbXBsb3llZTEgaXMgYW4gZXhpc3RpbmcgRW1wbG95ZWUgZW50aXR5XHJcbiAgPiAgICAgIHZhciBlbXBLZXkyID0gZW1wbG95ZWUxLmVudGl0eUFzcGVjdC5nZXRLZXkoKTtcclxuICA+ICAgICAgaWYgKGVtcEtleTEuZXF1YWxzKGVtcEtleTIpKSB7XHJcbiAgPiAgICAgICAgICAvLyBkbyBzb21ldGhpbmcgIC4uLlxyXG4gID4gICAgICB9XHJcbiAgKiovXHJcbiAgZXF1YWxzKGVudGl0eUtleTogRW50aXR5S2V5KTogYm9vbGVhbiB7XHJcbiAgICBpZiAoIShlbnRpdHlLZXkgaW5zdGFuY2VvZiBFbnRpdHlLZXkpKSByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gKHRoaXMuZW50aXR5VHlwZSA9PT0gZW50aXR5S2V5LmVudGl0eVR5cGUpICYmXHJcbiAgICAgIGNvcmUuYXJyYXlFcXVhbHModGhpcy52YWx1ZXMsIGVudGl0eUtleS52YWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICBSZXR1cm5zIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBFbnRpdHlLZXkuXHJcbiAgKi9cclxuICB0b1N0cmluZyhhbHRFbnRpdHlUeXBlPzogRW50aXR5VHlwZSkge1xyXG4gICAgcmV0dXJuIChhbHRFbnRpdHlUeXBlIHx8IHRoaXMuZW50aXR5VHlwZSkubmFtZSArICctJyArIHRoaXMuX2tleUluR3JvdXA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBVc2VkIHRvIGNvbXBhcmUgRW50aXR5S2V5cyBhcmUgZGV0ZXJtaW5lIGlmIHRoZXkgcmVmZXIgdG8gdGhlIHNhbWUgRW50aXR5LlxyXG4gIFRoZXJlIGlzIGFsc28gYW4gaW5zdGFuY2UgdmVyc2lvbiBvZiAnZXF1YWxzJyB3aXRoIHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHkuXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICB2YXIgZW1wVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJFbXBsb3llZVwiKTtcclxuICA+ICAgICAgdmFyIGVtcEtleTEgPSBuZXcgRW50aXR5S2V5KGVtcFR5cGUsIDEpO1xyXG4gID4gICAgICAvLyBhc3N1bWUgZW1wbG95ZWUxIGlzIGFuIGV4aXN0aW5nIEVtcGxveWVlIGVudGl0eVxyXG4gID4gICAgICB2YXIgZW1wS2V5MiA9IGVtcGxveWVlMS5lbnRpdHlBc3BlY3QuZ2V0S2V5KCk7XHJcbiAgPiAgICAgIGlmIChFbnRpdHlLZXkuZXF1YWxzKGVtcEtleTEsIGVtcEtleTIpKSB7XHJcbiAgPiAgICAgICAgICAvLyBkbyBzb21ldGhpbmcgIC4uLlxyXG4gID4gICAgICB9XHJcbiAgKiovXHJcbiAgc3RhdGljIGVxdWFscyhrMTogRW50aXR5S2V5LCBrMjogRW50aXR5S2V5KSB7XHJcbiAgICBpZiAoIShrMSBpbnN0YW5jZW9mIEVudGl0eUtleSkpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBrMS5lcXVhbHMoazIpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgLy8gVE9ETzogd2UgbWF5IHdhbnQgdG8gY29tcGFyZSB0byBkZWZhdWx0IHZhbHVlcyBsYXRlci5cclxuICBfaXNFbXB0eSgpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlcy5qb2luKFwiXCIpLmxlbmd0aCA9PT0gMDtcclxuICB9XHJcblxyXG4gIC8qKiBoaWRkZW4gKi9cclxuICAvLyBUT0RPOiB0aGluayBhYm91dCBnaXZpbmcgXyBwcmVmaXggb3IgZG9jdW1lbnRpbmcuXHJcbiAgc3RhdGljIGNyZWF0ZUtleVN0cmluZyhrZXlWYWx1ZXM6IGFueVtdKSB7XHJcbiAgICByZXR1cm4ga2V5VmFsdWVzLmpvaW4oRW50aXR5S2V5LkVOVElUWV9LRVlfREVMSU1JVEVSKTtcclxuICB9XHJcblxyXG59XHJcbkVudGl0eUtleS5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IFwiRW50aXR5S2V5XCI7XHJcblxyXG5cclxuIl19