import { core } from './core';
import { assertParam } from './assert-param';
import { BreezeEvent } from './event';
var InterfaceDef = /** @class */ (function () {
    function InterfaceDef(name) {
        this.name = name;
        this.defaultInstance = undefined;
        this._implMap = {};
    }
    /** Define an implementation of the given adaptername */
    InterfaceDef.prototype.registerCtor = function (adapterName, ctor) {
        this._implMap[adapterName.toLowerCase()] = { ctor: ctor, defaultInstance: undefined };
    };
    /** Return the definition for the given adapterName */
    InterfaceDef.prototype.getImpl = function (adapterName) {
        return this._implMap[adapterName.toLowerCase()];
    };
    /** Return the first implementation for this InterfaceDef */
    InterfaceDef.prototype.getFirstImpl = function () {
        var kv = core.objectFirst(this._implMap, function () {
            return true;
        });
        return kv ? kv.value : null;
    };
    InterfaceDef.prototype.getDefaultInstance = function () {
        return this.defaultInstance;
    };
    return InterfaceDef;
}());
export { InterfaceDef };
var BreezeConfig = /** @class */ (function () {
    function BreezeConfig() {
        this.functionRegistry = {};
        this.typeRegistry = {};
        this.objectRegistry = {};
        this.stringifyPad = '';
        this.interfaceInitialized = new BreezeEvent("interfaceInitialized", this);
        if (this.noEval === undefined) {
            try {
                Error['x'] = Function('');
                this.noEval = false; // eval succeeded
            }
            catch (_a) {
                this.noEval = true; // eval failed, probably due to CSP
            }
        }
    }
    /**
    Method use to register implementations of standard breeze interfaces.  Calls to this method are usually
    made as the last step within an adapter implementation.
    @method registerAdapter
    @param interfaceName {String} - one of the following interface names: "ajax", "dataService", "modelLibrary", "uriBuilder"
    @param adapterCtor {Function} - an ctor function that returns an instance of the specified interface.
    **/
    BreezeConfig.prototype.registerAdapter = function (interfaceName, adapterCtor) {
        assertParam(interfaceName, "interfaceName").isNonEmptyString().check();
        assertParam(adapterCtor, "adapterCtor").isFunction().check();
        // this impl will be thrown away after the name is retrieved.
        var impl = new adapterCtor();
        var implName = impl.name;
        if (!implName) {
            throw new Error("Unable to locate a 'name' property on the constructor passed into the 'registerAdapter' call.");
        }
        var idef = this.getInterfaceDef(interfaceName);
        idef.registerCtor(implName, adapterCtor);
    };
    /**
    Returns the ctor function used to implement a specific interface with a specific adapter name.
    @method getAdapter
    @param interfaceName {String} One of the following interface names: "ajax", "dataService", "modelLibrary", "uriBuilder"
    @param [adapterName] {String} The name of any previously registered adapter. If this parameter is omitted then
    this method returns the "default" adapter for this interface. If there is no default adapter, then a null is returned.
    @return {Function|null} Returns either a ctor function or null.
    **/
    BreezeConfig.prototype.getAdapter = function (interfaceName, adapterName) {
        var idef = this.getInterfaceDef(interfaceName);
        if (adapterName) {
            var impl = idef.getImpl(adapterName);
            return impl ? impl.ctor : null;
        }
        else {
            return idef.defaultInstance ? idef.defaultInstance._$impl.ctor : null;
        }
    };
    /**
    Initializes a single adapter implementation. Initialization means either newing a instance of the
    specified interface and then calling "initialize" on it or simply calling "initialize" on the instance
    if it already exists.
    @method initializeAdapterInstance
    @param interfaceName {String} The name of the interface to which the adapter to initialize belongs.
    @param adapterName {String} - The name of a previously registered adapter to initialize.
    @param [isDefault=true] {Boolean} - Whether to make this the default "adapter" for this interface.
    @return {an instance of the specified adapter}
    **/
    BreezeConfig.prototype.initializeAdapterInstance = function (interfaceName, adapterName, isDefault) {
        if (isDefault === void 0) { isDefault = true; }
        isDefault = isDefault === undefined ? true : isDefault;
        assertParam(interfaceName, "interfaceName").isNonEmptyString().check();
        assertParam(adapterName, "adapterName").isNonEmptyString().check();
        assertParam(isDefault, "isDefault").isBoolean().check();
        var idef = this.getInterfaceDef(interfaceName);
        var impl = idef.getImpl(adapterName);
        if (!impl) {
            throw new Error("Unregistered adapter.  Interface: " + interfaceName + " AdapterName: " + adapterName);
        }
        return this._initializeAdapterInstanceCore(idef, impl, isDefault);
    };
    /**
    Returns the adapter instance corresponding to the specified interface and adapter names.
    @method getAdapterInstance
    @param interfaceName {String} The name of the interface.
    @param [adapterName] {String} - The name of a previously registered adapter.  If this parameter is
    omitted then the default implementation of the specified interface is returned. If there is
    no defaultInstance of this interface, then the first registered instance of this interface is returned.
    @return {an instance of the specified adapter}
    @internal
    **/
    BreezeConfig.prototype.getAdapterInstance = function (interfaceName, adapterName) {
        var idef = this.getInterfaceDef(interfaceName);
        var impl;
        var isDefault = adapterName == null || adapterName === "";
        if (isDefault) {
            if (idef.defaultInstance)
                return idef.defaultInstance;
            impl = idef.getFirstImpl();
        }
        else {
            impl = idef.getImpl(adapterName);
        }
        if (!impl)
            return undefined;
        if (impl.defaultInstance) {
            return impl.defaultInstance;
        }
        else {
            return this._initializeAdapterInstanceCore(idef, impl, isDefault);
        }
    };
    /** this is needed for reflection purposes when deserializing an object that needs a fn or ctor.
        Used to register validators. */
    BreezeConfig.prototype.registerFunction = function (fn, fnName) {
        assertParam(fn, "fn").isFunction().check();
        assertParam(fnName, "fnName").isString().check();
        if (fn.prototype) {
            fn.prototype._$fnName = fnName;
        }
        this.functionRegistry[fnName] = fn;
    };
    BreezeConfig.prototype.registerType = function (ctor, typeName) {
        assertParam(ctor, "ctor").isFunction().check();
        assertParam(typeName, "typeName").isString().check();
        if (ctor.prototype) {
            ctor.prototype._$typeName = typeName;
        }
        this.typeRegistry[typeName] = ctor;
    };
    BreezeConfig.prototype.getRegisteredFunction = function (fnName) {
        return this.functionRegistry[fnName];
    };
    BreezeConfig.prototype.getInterfaceDef = function (interfaceName) {
        var lcName = interfaceName.toLowerCase();
        // source may be null
        var kv = core.objectFirst(this._interfaceRegistry || {}, function (k, v) {
            return k.toLowerCase() === lcName;
        });
        if (!kv) {
            throw new Error("Unknown interface name: " + interfaceName);
        }
        return kv.value;
    };
    /** @deprecated @internal no-op kept for backward compatibility */
    BreezeConfig.prototype.setQ = function (q) {
        console && console.warn("setQ does nothing; ES6 Promise support is required - use a shim if necessary.");
    };
    /** @hidden @internal */
    BreezeConfig.prototype._storeObject = function (obj, type, name) {
        // uncomment this if we make this public.
        //assertParam(obj, "obj").isObject().check();
        //assertParam(name, "objName").isString().check();
        var key = (typeof (type) === "string" ? type : type.prototype._$typeName) + "." + name;
        this.objectRegistry[key] = obj;
    };
    /** @hidden @internal */
    BreezeConfig.prototype._fetchObject = function (type, name) {
        if (!name)
            return undefined;
        var key = (typeof (type) === "string" ? type : type.prototype._$typeName) + "." + name;
        var result = this.objectRegistry[key];
        if (!result) {
            throw new Error("Unable to locate a registered object by the name: " + key);
        }
        return result;
    };
    /** @hidden @internal */
    BreezeConfig.prototype._initializeAdapterInstanceCore = function (interfaceDef, impl, isDefault) {
        var instance;
        var inst = impl.defaultInstance;
        if (!inst) {
            instance = new (impl.ctor)();
            impl.defaultInstance = instance;
            instance._$impl = impl;
        }
        else {
            instance = inst;
        }
        instance.initialize();
        if (isDefault) {
            // next line needs to occur before any recomposition
            interfaceDef.defaultInstance = instance;
        }
        // recomposition of other impls will occur here.
        this.interfaceInitialized.publish({ interfaceName: interfaceDef.name, instance: instance, isDefault: true });
        if (instance.checkForRecomposition != null) {
            // now register for own dependencies.
            this.interfaceInitialized.subscribe(function (interfaceInitializedArgs) {
                // TODO: why '!'s needed here for typescript to compile correctly???
                instance.checkForRecomposition(interfaceInitializedArgs);
            });
        }
        return instance;
    };
    return BreezeConfig;
}());
export { BreezeConfig };
export var config = new BreezeConfig();
// legacy
core.config = config;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlnLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYnJlZXplLWNsaWVudC8iLCJzb3VyY2VzIjpbInNyYy9jb25maWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUM5QixPQUFPLEVBQUUsV0FBVyxFQUFHLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQVN0QztJQU9JLHNCQUFZLElBQVk7UUFDcEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLGVBQWUsR0FBRyxTQUFTLENBQUM7UUFDakMsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVELHdEQUF3RDtJQUN4RCxtQ0FBWSxHQUFaLFVBQWEsV0FBbUIsRUFBRSxJQUFvQjtRQUNsRCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxlQUFlLEVBQUUsU0FBUyxFQUFFLENBQUM7SUFDMUYsQ0FBQztJQUVELHNEQUFzRDtJQUN0RCw4QkFBTyxHQUFQLFVBQVEsV0FBbUI7UUFDdkIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRCw0REFBNEQ7SUFDNUQsbUNBQVksR0FBWjtRQUNJLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNyQyxPQUFPLElBQUksQ0FBQztRQUNoQixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUVELHlDQUFrQixHQUFsQjtRQUNJLE9B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QUFNLE1BQU0sR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO0FBRXpDLFNBQVM7QUFDUixJQUFZLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvcmUgfSBmcm9tICcuL2NvcmUnO1xyXG5pbXBvcnQgeyBhc3NlcnRQYXJhbSAgfSBmcm9tICcuL2Fzc2VydC1wYXJhbSc7XHJcbmltcG9ydCB7IEJyZWV6ZUV2ZW50IH0gZnJvbSAnLi9ldmVudCc7XHJcblxyXG4vKiogQGhpZGRlbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEFkYXB0ZXJDdG9yPFQgZXh0ZW5kcyBCYXNlQWRhcHRlcj4geyBuZXcgKC4uLmFyZ3M6IGFueVtdKTogVDsgfVxyXG4vKiogQGhpZGRlbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElEZWY8VCBleHRlbmRzIEJhc2VBZGFwdGVyPiB7IGN0b3I6IEFkYXB0ZXJDdG9yPFQ+OyBkZWZhdWx0SW5zdGFuY2U/OiBUOyB9XHJcblxyXG5leHBvcnQgdHlwZSBBZGFwdGVyVHlwZSA9ICdkYXRhU2VydmljZSd8J21vZGVsTGlicmFyeSd8J2FqYXgnfCd1cmlCdWlsZGVyJztcclxuXHJcbmV4cG9ydCBjbGFzcyBJbnRlcmZhY2VEZWY8VCBleHRlbmRzIEJhc2VBZGFwdGVyPiB7XHJcblxyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgZGVmYXVsdEluc3RhbmNlPzogVDtcclxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gICAgX2ltcGxNYXA6IHsgW25hbWU6IHN0cmluZ106IElEZWY8VD4gfTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdEluc3RhbmNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2ltcGxNYXAgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRGVmaW5lIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBnaXZlbiBhZGFwdGVybmFtZSAqL1xyXG4gICAgcmVnaXN0ZXJDdG9yKGFkYXB0ZXJOYW1lOiBzdHJpbmcsIGN0b3I6IEFkYXB0ZXJDdG9yPFQ+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5faW1wbE1hcFthZGFwdGVyTmFtZS50b0xvd2VyQ2FzZSgpXSA9IHsgY3RvcjogY3RvciwgZGVmYXVsdEluc3RhbmNlOiB1bmRlZmluZWQgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmV0dXJuIHRoZSBkZWZpbml0aW9uIGZvciB0aGUgZ2l2ZW4gYWRhcHRlck5hbWUgKi9cclxuICAgIGdldEltcGwoYWRhcHRlck5hbWU6IHN0cmluZyk6IElEZWY8VD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbXBsTWFwW2FkYXB0ZXJOYW1lLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZXR1cm4gdGhlIGZpcnN0IGltcGxlbWVudGF0aW9uIGZvciB0aGlzIEludGVyZmFjZURlZiAqL1xyXG4gICAgZ2V0Rmlyc3RJbXBsKCk6IElEZWY8VD4ge1xyXG4gICAgICAgIGxldCBrdiA9IGNvcmUub2JqZWN0Rmlyc3QodGhpcy5faW1wbE1hcCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ga3YgPyBrdi52YWx1ZSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGVmYXVsdEluc3RhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRJbnN0YW5jZSBhcyBUO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhc2VBZGFwdGVyIHtcclxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gICAgXyRpbXBsPzogYW55O1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgaW5pdGlhbGl6ZSgpOiB2b2lkO1xyXG4gICAgY2hlY2tGb3JSZWNvbXBvc2l0aW9uPzogKGNvbnRleHQ6IGFueSkgPT4gdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEJyZWV6ZUNvbmZpZyB7XHJcbiAgICBmdW5jdGlvblJlZ2lzdHJ5ID0ge307XHJcbiAgICB0eXBlUmVnaXN0cnkgPSB7fTtcclxuICAgIG9iamVjdFJlZ2lzdHJ5ID0ge307XHJcbiAgICBpbnRlcmZhY2VJbml0aWFsaXplZDogQnJlZXplRXZlbnQ8eyBpbnRlcmZhY2VOYW1lOiBzdHJpbmcsIGluc3RhbmNlOiBCYXNlQWRhcHRlciwgaXNEZWZhdWx0OiBib29sZWFuIH0+O1xyXG5cclxuICAgIHN0cmluZ2lmeVBhZCA9ICcnO1xyXG4gICAgLyoqIHdoZXRoZXIgdG8gcHJvaGliaXQgZXZhbCgpIGFuZCBGdW5jdGlvbigpIGluIGJyZWV6ZSBjb2RlICovXHJcbiAgICBub0V2YWw6IGJvb2xlYW47XHJcbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICAgIF9pbnRlcmZhY2VSZWdpc3RyeTogYW55OyAgLy8gd2lsbCBiZSBzZXQgaW4gYWRhcHRlci1pbnRlcmZhY2VzLiB1bnR5cGVkIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXJpdHkgaXNzdWVzLlxyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaW50ZXJmYWNlSW5pdGlhbGl6ZWQgPSBuZXcgQnJlZXplRXZlbnQoXCJpbnRlcmZhY2VJbml0aWFsaXplZFwiLCB0aGlzKTtcclxuICAgICAgICBpZiAodGhpcy5ub0V2YWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgRXJyb3JbJ3gnXSA9IEZ1bmN0aW9uKCcnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9FdmFsID0gZmFsc2U7IC8vIGV2YWwgc3VjY2VlZGVkXHJcbiAgICAgICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub0V2YWwgPSB0cnVlOyAvLyBldmFsIGZhaWxlZCwgcHJvYmFibHkgZHVlIHRvIENTUFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgTWV0aG9kIHVzZSB0byByZWdpc3RlciBpbXBsZW1lbnRhdGlvbnMgb2Ygc3RhbmRhcmQgYnJlZXplIGludGVyZmFjZXMuICBDYWxscyB0byB0aGlzIG1ldGhvZCBhcmUgdXN1YWxseVxyXG4gICAgbWFkZSBhcyB0aGUgbGFzdCBzdGVwIHdpdGhpbiBhbiBhZGFwdGVyIGltcGxlbWVudGF0aW9uLlxyXG4gICAgQG1ldGhvZCByZWdpc3RlckFkYXB0ZXJcclxuICAgIEBwYXJhbSBpbnRlcmZhY2VOYW1lIHtTdHJpbmd9IC0gb25lIG9mIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlIG5hbWVzOiBcImFqYXhcIiwgXCJkYXRhU2VydmljZVwiLCBcIm1vZGVsTGlicmFyeVwiLCBcInVyaUJ1aWxkZXJcIlxyXG4gICAgQHBhcmFtIGFkYXB0ZXJDdG9yIHtGdW5jdGlvbn0gLSBhbiBjdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIGludGVyZmFjZS5cclxuICAgICoqL1xyXG4gICAgcmVnaXN0ZXJBZGFwdGVyPFQgZXh0ZW5kcyBCYXNlQWRhcHRlcj4oaW50ZXJmYWNlTmFtZTogQWRhcHRlclR5cGUsIGFkYXB0ZXJDdG9yOiBBZGFwdGVyQ3RvcjxUPikge1xyXG4gICAgICAgIGFzc2VydFBhcmFtKGludGVyZmFjZU5hbWUsIFwiaW50ZXJmYWNlTmFtZVwiKS5pc05vbkVtcHR5U3RyaW5nKCkuY2hlY2soKTtcclxuICAgICAgICBhc3NlcnRQYXJhbShhZGFwdGVyQ3RvciwgXCJhZGFwdGVyQ3RvclwiKS5pc0Z1bmN0aW9uKCkuY2hlY2soKTtcclxuICAgICAgICAvLyB0aGlzIGltcGwgd2lsbCBiZSB0aHJvd24gYXdheSBhZnRlciB0aGUgbmFtZSBpcyByZXRyaWV2ZWQuXHJcbiAgICAgICAgbGV0IGltcGwgPSBuZXcgYWRhcHRlckN0b3IoKTtcclxuICAgICAgICBsZXQgaW1wbE5hbWUgPSBpbXBsLm5hbWU7XHJcbiAgICAgICAgaWYgKCFpbXBsTmFtZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbG9jYXRlIGEgJ25hbWUnIHByb3BlcnR5IG9uIHRoZSBjb25zdHJ1Y3RvciBwYXNzZWQgaW50byB0aGUgJ3JlZ2lzdGVyQWRhcHRlcicgY2FsbC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpZGVmID0gdGhpcy5nZXRJbnRlcmZhY2VEZWYoaW50ZXJmYWNlTmFtZSk7XHJcbiAgICAgICAgaWRlZi5yZWdpc3RlckN0b3IoaW1wbE5hbWUsIGFkYXB0ZXJDdG9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgIFJldHVybnMgdGhlIGN0b3IgZnVuY3Rpb24gdXNlZCB0byBpbXBsZW1lbnQgYSBzcGVjaWZpYyBpbnRlcmZhY2Ugd2l0aCBhIHNwZWNpZmljIGFkYXB0ZXIgbmFtZS5cclxuICAgIEBtZXRob2QgZ2V0QWRhcHRlclxyXG4gICAgQHBhcmFtIGludGVyZmFjZU5hbWUge1N0cmluZ30gT25lIG9mIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlIG5hbWVzOiBcImFqYXhcIiwgXCJkYXRhU2VydmljZVwiLCBcIm1vZGVsTGlicmFyeVwiLCBcInVyaUJ1aWxkZXJcIlxyXG4gICAgQHBhcmFtIFthZGFwdGVyTmFtZV0ge1N0cmluZ30gVGhlIG5hbWUgb2YgYW55IHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBhZGFwdGVyLiBJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkIHRoZW5cclxuICAgIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIFwiZGVmYXVsdFwiIGFkYXB0ZXIgZm9yIHRoaXMgaW50ZXJmYWNlLiBJZiB0aGVyZSBpcyBubyBkZWZhdWx0IGFkYXB0ZXIsIHRoZW4gYSBudWxsIGlzIHJldHVybmVkLlxyXG4gICAgQHJldHVybiB7RnVuY3Rpb258bnVsbH0gUmV0dXJucyBlaXRoZXIgYSBjdG9yIGZ1bmN0aW9uIG9yIG51bGwuXHJcbiAgICAqKi9cclxuICAgIGdldEFkYXB0ZXIoaW50ZXJmYWNlTmFtZTogQWRhcHRlclR5cGUsIGFkYXB0ZXJOYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgaWRlZiA9IHRoaXMuZ2V0SW50ZXJmYWNlRGVmKGludGVyZmFjZU5hbWUpO1xyXG4gICAgICAgIGlmIChhZGFwdGVyTmFtZSkge1xyXG4gICAgICAgICAgICBsZXQgaW1wbCA9IGlkZWYuZ2V0SW1wbChhZGFwdGVyTmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbXBsID8gaW1wbC5jdG9yIDogbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaWRlZi5kZWZhdWx0SW5zdGFuY2UgPyBpZGVmLmRlZmF1bHRJbnN0YW5jZS5fJGltcGwuY3RvciA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgSW5pdGlhbGl6ZXMgYSBzaW5nbGUgYWRhcHRlciBpbXBsZW1lbnRhdGlvbi4gSW5pdGlhbGl6YXRpb24gbWVhbnMgZWl0aGVyIG5ld2luZyBhIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgc3BlY2lmaWVkIGludGVyZmFjZSBhbmQgdGhlbiBjYWxsaW5nIFwiaW5pdGlhbGl6ZVwiIG9uIGl0IG9yIHNpbXBseSBjYWxsaW5nIFwiaW5pdGlhbGl6ZVwiIG9uIHRoZSBpbnN0YW5jZVxyXG4gICAgaWYgaXQgYWxyZWFkeSBleGlzdHMuXHJcbiAgICBAbWV0aG9kIGluaXRpYWxpemVBZGFwdGVySW5zdGFuY2VcclxuICAgIEBwYXJhbSBpbnRlcmZhY2VOYW1lIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBpbnRlcmZhY2UgdG8gd2hpY2ggdGhlIGFkYXB0ZXIgdG8gaW5pdGlhbGl6ZSBiZWxvbmdzLlxyXG4gICAgQHBhcmFtIGFkYXB0ZXJOYW1lIHtTdHJpbmd9IC0gVGhlIG5hbWUgb2YgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgYWRhcHRlciB0byBpbml0aWFsaXplLlxyXG4gICAgQHBhcmFtIFtpc0RlZmF1bHQ9dHJ1ZV0ge0Jvb2xlYW59IC0gV2hldGhlciB0byBtYWtlIHRoaXMgdGhlIGRlZmF1bHQgXCJhZGFwdGVyXCIgZm9yIHRoaXMgaW50ZXJmYWNlLlxyXG4gICAgQHJldHVybiB7YW4gaW5zdGFuY2Ugb2YgdGhlIHNwZWNpZmllZCBhZGFwdGVyfVxyXG4gICAgKiovXHJcbiAgICBpbml0aWFsaXplQWRhcHRlckluc3RhbmNlKGludGVyZmFjZU5hbWU6IEFkYXB0ZXJUeXBlLCBhZGFwdGVyTmFtZTogc3RyaW5nLCBpc0RlZmF1bHQ6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICAgICAgaXNEZWZhdWx0ID0gaXNEZWZhdWx0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogaXNEZWZhdWx0O1xyXG4gICAgICAgIGFzc2VydFBhcmFtKGludGVyZmFjZU5hbWUsIFwiaW50ZXJmYWNlTmFtZVwiKS5pc05vbkVtcHR5U3RyaW5nKCkuY2hlY2soKTtcclxuICAgICAgICBhc3NlcnRQYXJhbShhZGFwdGVyTmFtZSwgXCJhZGFwdGVyTmFtZVwiKS5pc05vbkVtcHR5U3RyaW5nKCkuY2hlY2soKTtcclxuICAgICAgICBhc3NlcnRQYXJhbShpc0RlZmF1bHQsIFwiaXNEZWZhdWx0XCIpLmlzQm9vbGVhbigpLmNoZWNrKCk7XHJcblxyXG4gICAgICAgIGxldCBpZGVmID0gdGhpcy5nZXRJbnRlcmZhY2VEZWYoaW50ZXJmYWNlTmFtZSk7XHJcbiAgICAgICAgbGV0IGltcGwgPSBpZGVmLmdldEltcGwoYWRhcHRlck5hbWUpO1xyXG4gICAgICAgIGlmICghaW1wbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlZ2lzdGVyZWQgYWRhcHRlci4gIEludGVyZmFjZTogXCIgKyBpbnRlcmZhY2VOYW1lICsgXCIgQWRhcHRlck5hbWU6IFwiICsgYWRhcHRlck5hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxpemVBZGFwdGVySW5zdGFuY2VDb3JlKGlkZWYsIGltcGwsIGlzRGVmYXVsdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICBSZXR1cm5zIHRoZSBhZGFwdGVyIGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbnRlcmZhY2UgYW5kIGFkYXB0ZXIgbmFtZXMuXHJcbiAgICBAbWV0aG9kIGdldEFkYXB0ZXJJbnN0YW5jZVxyXG4gICAgQHBhcmFtIGludGVyZmFjZU5hbWUge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGludGVyZmFjZS5cclxuICAgIEBwYXJhbSBbYWRhcHRlck5hbWVdIHtTdHJpbmd9IC0gVGhlIG5hbWUgb2YgYSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgYWRhcHRlci4gIElmIHRoaXMgcGFyYW1ldGVyIGlzXHJcbiAgICBvbWl0dGVkIHRoZW4gdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBpbnRlcmZhY2UgaXMgcmV0dXJuZWQuIElmIHRoZXJlIGlzXHJcbiAgICBubyBkZWZhdWx0SW5zdGFuY2Ugb2YgdGhpcyBpbnRlcmZhY2UsIHRoZW4gdGhlIGZpcnN0IHJlZ2lzdGVyZWQgaW5zdGFuY2Ugb2YgdGhpcyBpbnRlcmZhY2UgaXMgcmV0dXJuZWQuXHJcbiAgICBAcmV0dXJuIHthbiBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIGFkYXB0ZXJ9XHJcbiAgICBAaW50ZXJuYWxcclxuICAgICoqL1xyXG4gICAgZ2V0QWRhcHRlckluc3RhbmNlPFQgZXh0ZW5kcyBCYXNlQWRhcHRlcj4oaW50ZXJmYWNlTmFtZTogQWRhcHRlclR5cGUsIGFkYXB0ZXJOYW1lPzogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGlkZWYgPSB0aGlzLmdldEludGVyZmFjZURlZjxUPihpbnRlcmZhY2VOYW1lKTtcclxuICAgICAgICBsZXQgaW1wbDogSURlZjxUPjtcclxuXHJcbiAgICAgICAgbGV0IGlzRGVmYXVsdCA9IGFkYXB0ZXJOYW1lID09IG51bGwgfHwgYWRhcHRlck5hbWUgPT09IFwiXCI7XHJcbiAgICAgICAgaWYgKGlzRGVmYXVsdCkge1xyXG4gICAgICAgICAgICBpZiAoaWRlZi5kZWZhdWx0SW5zdGFuY2UpIHJldHVybiBpZGVmLmRlZmF1bHRJbnN0YW5jZTtcclxuICAgICAgICAgICAgaW1wbCA9IGlkZWYuZ2V0Rmlyc3RJbXBsKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW1wbCA9IGlkZWYuZ2V0SW1wbChhZGFwdGVyTmFtZSEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWltcGwpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGltcGwuZGVmYXVsdEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbXBsLmRlZmF1bHRJbnN0YW5jZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6ZUFkYXB0ZXJJbnN0YW5jZUNvcmUoaWRlZiwgaW1wbCwgaXNEZWZhdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIHRoaXMgaXMgbmVlZGVkIGZvciByZWZsZWN0aW9uIHB1cnBvc2VzIHdoZW4gZGVzZXJpYWxpemluZyBhbiBvYmplY3QgdGhhdCBuZWVkcyBhIGZuIG9yIGN0b3IuXHJcbiAgICAgICAgVXNlZCB0byByZWdpc3RlciB2YWxpZGF0b3JzLiAqL1xyXG4gICAgcmVnaXN0ZXJGdW5jdGlvbihmbjogRnVuY3Rpb24sIGZuTmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgYXNzZXJ0UGFyYW0oZm4sIFwiZm5cIikuaXNGdW5jdGlvbigpLmNoZWNrKCk7XHJcbiAgICAgICAgYXNzZXJ0UGFyYW0oZm5OYW1lLCBcImZuTmFtZVwiKS5pc1N0cmluZygpLmNoZWNrKCk7XHJcbiAgICAgICAgaWYgKGZuLnByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICBmbi5wcm90b3R5cGUuXyRmbk5hbWUgPSBmbk5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZnVuY3Rpb25SZWdpc3RyeVtmbk5hbWVdID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJUeXBlKGN0b3I6IEZ1bmN0aW9uLCB0eXBlTmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgYXNzZXJ0UGFyYW0oY3RvciwgXCJjdG9yXCIpLmlzRnVuY3Rpb24oKS5jaGVjaygpO1xyXG4gICAgICAgIGFzc2VydFBhcmFtKHR5cGVOYW1lLCBcInR5cGVOYW1lXCIpLmlzU3RyaW5nKCkuY2hlY2soKTtcclxuICAgICAgICBpZiAoY3Rvci5wcm90b3R5cGUpIHtcclxuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IHR5cGVOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnR5cGVSZWdpc3RyeVt0eXBlTmFtZV0gPSBjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFJlZ2lzdGVyZWRGdW5jdGlvbihmbk5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uUmVnaXN0cnlbZm5OYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRJbnRlcmZhY2VEZWY8VCBleHRlbmRzIEJhc2VBZGFwdGVyPihpbnRlcmZhY2VOYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgbGNOYW1lID0gaW50ZXJmYWNlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIC8vIHNvdXJjZSBtYXkgYmUgbnVsbFxyXG4gICAgICAgIGxldCBrdiA9IGNvcmUub2JqZWN0Rmlyc3QodGhpcy5faW50ZXJmYWNlUmVnaXN0cnkgfHwge30sIGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrLnRvTG93ZXJDYXNlKCkgPT09IGxjTmFtZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWt2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gaW50ZXJmYWNlIG5hbWU6IFwiICsgaW50ZXJmYWNlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiA8SW50ZXJmYWNlRGVmPFQ+Pmt2LnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCBAaW50ZXJuYWwgbm8tb3Aga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAqL1xyXG4gICAgc2V0UShxOiBhbnkpIHtcclxuICAgICAgICBjb25zb2xlICYmIGNvbnNvbGUud2FybihcInNldFEgZG9lcyBub3RoaW5nOyBFUzYgUHJvbWlzZSBzdXBwb3J0IGlzIHJlcXVpcmVkIC0gdXNlIGEgc2hpbSBpZiBuZWNlc3NhcnkuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gICAgX3N0b3JlT2JqZWN0KG9iajogT2JqZWN0LCB0eXBlOiBzdHJpbmcgfCBGdW5jdGlvbiwgbmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgLy8gdW5jb21tZW50IHRoaXMgaWYgd2UgbWFrZSB0aGlzIHB1YmxpYy5cclxuICAgICAgICAvL2Fzc2VydFBhcmFtKG9iaiwgXCJvYmpcIikuaXNPYmplY3QoKS5jaGVjaygpO1xyXG4gICAgICAgIC8vYXNzZXJ0UGFyYW0obmFtZSwgXCJvYmpOYW1lXCIpLmlzU3RyaW5nKCkuY2hlY2soKTtcclxuICAgICAgICBsZXQga2V5ID0gKHR5cGVvZiAodHlwZSkgPT09IFwic3RyaW5nXCIgPyB0eXBlIDogdHlwZS5wcm90b3R5cGUuXyR0eXBlTmFtZSkgKyBcIi5cIiArIG5hbWU7XHJcbiAgICAgICAgdGhpcy5vYmplY3RSZWdpc3RyeVtrZXldID0gb2JqO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gICAgX2ZldGNoT2JqZWN0KHR5cGU6IHN0cmluZyB8IEZ1bmN0aW9uLCBuYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoIW5hbWUpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGtleSA9ICh0eXBlb2YgKHR5cGUpID09PSBcInN0cmluZ1wiID8gdHlwZSA6IHR5cGUucHJvdG90eXBlLl8kdHlwZU5hbWUpICsgXCIuXCIgKyBuYW1lO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm9iamVjdFJlZ2lzdHJ5W2tleV07XHJcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvY2F0ZSBhIHJlZ2lzdGVyZWQgb2JqZWN0IGJ5IHRoZSBuYW1lOiBcIiArIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgICBfaW5pdGlhbGl6ZUFkYXB0ZXJJbnN0YW5jZUNvcmU8VCBleHRlbmRzIEJhc2VBZGFwdGVyPihpbnRlcmZhY2VEZWY6IEludGVyZmFjZURlZjxUPiwgaW1wbDogSURlZjxUPiwgaXNEZWZhdWx0OiBib29sZWFuKSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlOiBUO1xyXG4gICAgICAgIGxldCBpbnN0ID0gaW1wbC5kZWZhdWx0SW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKCFpbnN0KSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlID0gbmV3IChpbXBsLmN0b3IpKCk7XHJcbiAgICAgICAgICAgIGltcGwuZGVmYXVsdEluc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLl8kaW1wbCA9IGltcGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UgPSBpbnN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5zdGFuY2UuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgICAgICBpZiAoaXNEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgIC8vIG5leHQgbGluZSBuZWVkcyB0byBvY2N1ciBiZWZvcmUgYW55IHJlY29tcG9zaXRpb25cclxuICAgICAgICAgICAgaW50ZXJmYWNlRGVmLmRlZmF1bHRJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVjb21wb3NpdGlvbiBvZiBvdGhlciBpbXBscyB3aWxsIG9jY3VyIGhlcmUuXHJcbiAgICAgICAgdGhpcy5pbnRlcmZhY2VJbml0aWFsaXplZC5wdWJsaXNoKHsgaW50ZXJmYWNlTmFtZTogaW50ZXJmYWNlRGVmLm5hbWUsIGluc3RhbmNlOiBpbnN0YW5jZSwgaXNEZWZhdWx0OiB0cnVlIH0pO1xyXG5cclxuICAgICAgICBpZiAoaW5zdGFuY2UuY2hlY2tGb3JSZWNvbXBvc2l0aW9uICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gbm93IHJlZ2lzdGVyIGZvciBvd24gZGVwZW5kZW5jaWVzLlxyXG4gICAgICAgICAgICB0aGlzLmludGVyZmFjZUluaXRpYWxpemVkLnN1YnNjcmliZSgoaW50ZXJmYWNlSW5pdGlhbGl6ZWRBcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aHkgJyEncyBuZWVkZWQgaGVyZSBmb3IgdHlwZXNjcmlwdCB0byBjb21waWxlIGNvcnJlY3RseT8/P1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuY2hlY2tGb3JSZWNvbXBvc2l0aW9uIShpbnRlcmZhY2VJbml0aWFsaXplZEFyZ3MpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBjb25maWcgPSBuZXcgQnJlZXplQ29uZmlnKCk7XHJcblxyXG4vLyBsZWdhY3lcclxuKGNvcmUgYXMgYW55KS5jb25maWcgPSBjb25maWc7XHJcblxyXG5cclxuXHJcbiJdfQ==