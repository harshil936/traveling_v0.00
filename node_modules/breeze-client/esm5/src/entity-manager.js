import { core } from './core';
import { assertParam, assertConfig } from './assert-param';
import { config } from './config';
import { BreezeEvent } from './event';
import { EntityAspect } from './entity-aspect';
import { MetadataStore, EntityType, DataProperty, AutoGeneratedKeyType } from './entity-metadata';
import { EntityKey } from './entity-key';
import { EntityAction } from './entity-action';
import { EntityState } from './entity-state';
import { DataService } from './data-service';
import { DataType } from './data-type';
import { ValidationError } from './validate';
import { ValidationOptions } from './validation-options';
import { QueryOptions, MergeStrategy, FetchStrategy } from './query-options';
import { SaveOptions } from './save-options';
import { KeyGenerator } from './key-generator';
import { EntityGroup } from './entity-group';
import { MappingContext } from './mapping-context';
import { EntityQuery } from './entity-query';
import { UnattachedChildrenMap } from './unattached-children-map';
/**
Instances of the EntityManager contain and manage collections of entities, either retrieved from a backend datastore or created on the client.
**/
var EntityManager = /** @class */ (function () {
    /**
    EntityManager constructor.
  
    At its most basic an EntityManager can be constructed with just a service name
    >     let entityManager = new EntityManager( "breeze/NorthwindIBModel");
  
    This is the same as calling it with the following configuration object
    >     let entityManager = new EntityManager( {serviceName: "breeze/NorthwindIBModel" });
  
    Usually however, configuration objects will contain more than just the 'serviceName';
    >     let metadataStore = new MetadataStore();
    >     let entityManager = new EntityManager( {
    >       serviceName: "breeze/NorthwindIBModel",
    >       metadataStore: metadataStore
    >     });
  
    or
    >     return new QueryOptions({
    >         mergeStrategy: obj,
    >         fetchStrategy: this.fetchStrategy
    >     });
    >     let queryOptions = new QueryOptions({
    >         mergeStrategy: MergeStrategy.OverwriteChanges,
    >         fetchStrategy: FetchStrategy.FromServer
    >     });
    >     let validationOptions = new ValidationOptions({
    >         validateOnAttach: true,
    >         validateOnSave: true,
    >         validateOnQuery: false
    >     });
    >     let entityManager = new EntityManager({
    >         serviceName: "breeze/NorthwindIBModel",
    >         queryOptions: queryOptions,
    >         validationOptions: validationOptions
    >     });
    @param emConfig - Configuration settings or a service name.
    **/
    function EntityManager(emConfig) {
        this.helper = {
            unwrapInstance: unwrapInstance,
            unwrapOriginalValues: unwrapOriginalValues,
            unwrapChangedValues: unwrapChangedValues
        };
        if (arguments.length > 1) {
            throw new Error("The EntityManager ctor has a single optional argument that is either a 'serviceName' or a configuration object.");
        }
        var config;
        if (arguments.length === 0) {
            config = { serviceName: "" };
        }
        else if (typeof emConfig === 'string') {
            config = { serviceName: emConfig };
        }
        else {
            config = emConfig || {};
        }
        EntityManager._updateWithConfig(this, config, true);
        this.entityChanged = new BreezeEvent("entityChanged", this);
        this.validationErrorsChanged = new BreezeEvent("validationErrorsChanged", this);
        this.hasChangesChanged = new BreezeEvent("hasChangesChanged", this);
        this.clear();
    }
    /**
    General purpose property set method.  Any of the properties in the [[EntityManagerConfig]]
    may be set.
    >      // assume em1 is a previously created EntityManager
    >      // where we want to change some of its settings.
    >      em1.setProperties( {
    >          serviceName: "breeze/foo"
    >      });
    @param config - An object containing the selected properties and values to set.
    **/
    EntityManager.prototype.setProperties = function (config) {
        EntityManager._updateWithConfig(this, config, false);
    };
    /** @hidden @internal */
    EntityManager._updateWithConfig = function (em, config, isCtor) {
        var defaultQueryOptions = isCtor ? QueryOptions.defaultInstance : em.queryOptions;
        var defaultSaveOptions = isCtor ? SaveOptions.defaultInstance : em.saveOptions;
        var defaultValidationOptions = isCtor ? ValidationOptions.defaultInstance : em.validationOptions;
        var configParam = assertConfig(config)
            .whereParam("serviceName").isOptional().isString()
            .whereParam("dataService").isOptional().isInstanceOf(DataService)
            .whereParam("queryOptions").isInstanceOf(QueryOptions).isOptional().withDefault(defaultQueryOptions)
            .whereParam("saveOptions").isInstanceOf(SaveOptions).isOptional().withDefault(defaultSaveOptions)
            .whereParam("validationOptions").isInstanceOf(ValidationOptions).isOptional().withDefault(defaultValidationOptions)
            .whereParam("keyGeneratorCtor").isFunction().isOptional();
        if (isCtor) {
            configParam = configParam
                .whereParam("metadataStore").isInstanceOf(MetadataStore).isOptional().withDefault(new MetadataStore());
        }
        configParam.applyAll(em);
        // insure that entityManager's options versions are completely populated
        core.updateWithDefaults(em.queryOptions, defaultQueryOptions);
        core.updateWithDefaults(em.saveOptions, defaultSaveOptions);
        core.updateWithDefaults(em.validationOptions, defaultValidationOptions);
        if (config.serviceName) {
            em.dataService = new DataService({
                serviceName: em.serviceName
            });
        }
        em.serviceName = em.dataService && em.dataService.serviceName;
        em.keyGeneratorCtor = em.keyGeneratorCtor || KeyGenerator;
        if (isCtor || config.keyGeneratorCtor) {
            em.keyGenerator = new em.keyGeneratorCtor();
        }
    };
    /**
    Creates a new entity of a specified type and optionally initializes it. By default the new entity is created with an EntityState of Added
    but you can also optionally specify an EntityState.  An EntityState of 'Detached' will insure that the entity is created but not yet added
    to the EntityManager.
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      // create and add an entity;
    >      let emp1 = em1.createEntity("Employee");
    >      // create and add an initialized entity;
    >      let emp2 = em1.createEntity("Employee", { lastName: "Smith", firstName: "John" });
    >      // create and attach (not add) an initialized entity
    >      let emp3 = em1.createEntity("Employee", { id: 435, lastName: "Smith", firstName: "John" }, EntityState.Unchanged);
    >      // create but don't attach an entity;
    >      let emp4 = em1.createEntity("Employee", { id: 435, lastName: "Smith", firstName: "John" }, EntityState.Detached);
    @param typeName - The name of the EntityType for which an instance should be created.
    @param entityType - The EntityType of the type for which an instance should be created.
    @param initialValues - (default=null) Configuration object of the properties to set immediately after creation.
    @param entityState - (default = [[EntityState.Added]]) The EntityState of the entity after being created and added to this EntityManager.
    @param mergeStrategy - (default = [[MergeStrategy.Disallowed]]) - How to handle conflicts if an entity with the same key already exists within this EntityManager.
    @return {Entity} A new Entity of the specified type.
    */
    EntityManager.prototype.createEntity = function (entityType, initialValues, entityState, mergeStrategy) {
        assertParam(entityType, "entityType").isString().or().isInstanceOf(EntityType).check();
        assertParam(entityState, "entityState").isEnumOf(EntityState).isOptional().check();
        assertParam(mergeStrategy, "mergeStrategy").isEnumOf(MergeStrategy).isOptional().check();
        var et = (typeof entityType === "string") ? this.metadataStore._getStructuralType(entityType) : entityType;
        entityState = entityState || EntityState.Added;
        var entity = {};
        core.using(this, "isLoading", true, function () {
            entity = et.createEntity(initialValues);
        });
        if (entityState !== EntityState.Detached) {
            entity = this.attachEntity(entity, entityState, mergeStrategy);
        }
        return entity;
    };
    /**
    Creates a new EntityManager and imports a previously exported result into it.
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let bundle = em1.exportEntities();
    >      // can be stored via the web storage api
    >      window.localStorage.setItem("myEntityManager", bundle);
    >      // assume the code below occurs in a different session.
    >      let bundleFromStorage = window.localStorage.getItem("myEntityManager");
    >      // and imported
    >      let em2 = EntityManager.importEntities(bundleFromStorage);
    >      // em2 will now have a complete copy of what was in em1
    @param exportedString - The result of a previous 'exportEntities' call as a string
    @param exportedData - The result of a previous 'exportEntities' call as an Object.
    @param config - A configuration object.
    @param config.mergeStrategy - A  [[MergeStrategy]] to use when
    merging into an existing EntityManager.
    @param config.metadataVersionFn - A function that takes two arguments (the current metadataVersion and the imported store's 'name')
    and may be used to perform version checking.
    @return A new EntityManager.  Note that the return value of this method call is different from that
    provided by the same named method on an EntityManager instance. Use that method if you need additional information
    regarding the imported entities.
    **/
    EntityManager.importEntities = function (exported, config) {
        var em = new EntityManager();
        em.importEntities(exported, config);
        return em;
    };
    // instance methods
    /**
    Calls [[EntityAspect.acceptChanges]] on every changed entity in this EntityManager.
    **/
    EntityManager.prototype.acceptChanges = function () {
        this.getChanges().map(function (entity) {
            return entity.entityAspect._checkOperation("acceptChanges");
        }).forEach(function (aspect) {
            aspect.acceptChanges();
        });
    };
    /**
    Exports selected entities, all entities of selected types, or an entire EntityManager cache.
  
    This method takes a snapshot of an EntityManager that can be stored offline or held in memory.
    Use the [[EntityManager.importEntities]] method to restore or merge the snapshot
    into another EntityManager at some later time.
    >      // let em1 be an EntityManager containing a number of existing entities.
    >     // export every entity in em1.
    >     let bundle = em1.exportEntities();
    >     // save to the browser's local storage
    >     window.localStorage.setItem("myEntityManager", bundle);
    >     // later retrieve the export
    >     let bundleFromStorage = window.localStorage.getItem("myEntityManager");
    >     // import the retrieved export bundle into another manager
    >     let em2 = em1.createEmptyCopy();
    >     em2.importEntities(bundleFromStorage);
    >     // em2 now has a complete, faithful copy of the entities that were in em1
  
    You can also control exactly which entities are exported.
    >     // get em1's unsaved changes (an array) and export them.
    >     let changes = em1.getChanges();
    >     let bundle = em1.exportEntities(changes);
    >     // merge these entities into em2 which may contains some of the same entities.
    >     // do NOT overwrite the entities in em2 if they themselves have unsaved changes.
    >     em2.importEntities(bundle, { mergeStrategy: MergeStrategy.PreserveChanges} );
  
    Metadata are included in an export by default. You may want to exclude the metadata
    especially if you're exporting just a few entities for local storage.
    >     let bundle = em1.exportEntities(arrayOfSelectedEntities, {includeMetadata: false});
    >     window.localStorage.setItem("goodStuff", bundle);
  
    You may still express this option as a boolean value although this older syntax is deprecated.
    >     // Exclude the metadata (deprecated syntax)
    >     let bundle = em1.exportEntities(arrayOfSelectedEntities, false);
  
    You can export all entities of one or more specified EntityTypes.
    >     // Export all Customer and Employee entities (and also exclude metadata)
    >     let bundle = em1.exportEntities(['Customer', 'Employee'], {includeMetadata: false});
  
    All of the above examples return an export bundle as a string which is the default format.
    You can export the bundle as JSON if you prefer by setting the `asString` option to false.
    >     // Export all Customer and Employee entities as JSON and exclude the metadata
    >     let bundle = em1.exportEntities(['Customer', 'Employee'],
    >                                     {asString: false, includeMetadata: false});
    >     // store JSON bundle somewhere ... perhaps indexDb ... and later import as we do here.
    >     em2.importEntities(bundle);
    @param entities - The entities to export or the EntityType(s) of the entities to export;
      all entities are exported if this parameter is omitted or null.
    @param exportConfig - Export configuration options or a boolean
      - asString - (boolean) - If true (default), return export bundle as a string.
      - includeMetadata - (boolean) - If true (default), include metadata in the export bundle.
    @return The export bundle either serialized as a string (default) or as a JSON object.
    The bundle contains the metadata (unless excluded) and the entity data grouped by type.
    The entity data include property values, change-state, and temporary key mappings (if any).
  
    The export bundle internals are deliberately undocumented.  This Breeze-internal representation of entity data is
    suitable for export, storage, and import. The schema and contents of the bundle may change in future versions of Breeze.
    Manipulate it at your own risk with appropriate caution.
    **/
    EntityManager.prototype.exportEntities = function (entities, exportConfig) {
        assertParam(entities, "entities").isArray().isEntity()
            .or().isNonEmptyArray().isInstanceOf(EntityType)
            .or().isNonEmptyArray().isString()
            .or().isOptional().check();
        // assertParam(exportConfig, "exportConfig").isObject()
        //   .or().isBoolean()
        //   .or().isOptional().check();
        if (exportConfig == null) {
            exportConfig = { includeMetadata: true, asString: true };
        }
        else if (typeof exportConfig === 'boolean') { // deprecated
            exportConfig = { includeMetadata: exportConfig, asString: true };
        }
        assertConfig(exportConfig)
            .whereParam("asString").isBoolean().isOptional().withDefault(true)
            .whereParam("includeMetadata").isBoolean().isOptional().withDefault(true)
            .applyAll(exportConfig);
        var exportBundle = exportEntityGroups(this, entities);
        var json = core.extend({}, exportBundle, ["tempKeys", "entityGroupMap"]);
        if (exportConfig.includeMetadata) {
            json = core.extend(json, this, ["dataService", "saveOptions", "queryOptions", "validationOptions"]);
            json.metadataStore = this.metadataStore.exportMetadata();
        }
        else {
            json.metadataVersion = MetadataStore.metadataVersion;
            json.metadataStoreName = this.metadataStore.name;
        }
        var result = exportConfig.asString ? JSON.stringify(json, null, config.stringifyPad) : json;
        return result;
    };
    /**
    Imports a previously exported result into this EntityManager.
  
    This method can be used to make a complete copy of any previously created entityManager, even if created
    in a previous session and stored in localStorage. The static version of this method performs a
    very similar process.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     let bundle = em1.exportEntities();
    >     // bundle can be stored in window.localStorage or just held in memory.
    >     let em2 = new EntityManager({
    >         serviceName: em1.serviceName,
    >         metadataStore: em1.metadataStore
    >     });
    >     em2.importEntities(bundle);
    >     // em2 will now have a complete copy of what was in em1
  
    It can also be used to merge the contents of a previously created EntityManager with an
    existing EntityManager with control over how the two are merged.
    >     let bundle = em1.exportEntities();
    >     // assume em2 is another entityManager containing some of the same entities possibly with modifications.
    >     em2.importEntities(bundle, { mergeStrategy: MergeStrategy.PreserveChanges} );
    >     // em2 will now contain all of the entities from both em1 and em2.  Any em2 entities with previously
    >     // made modifications will not have been touched, but all other entities from em1 will have been imported.
    @param exportedString - The result of a previous 'export' call.
    @param importConfig - A configuration object.
    @param importConfig.mergeStrategy -  A [[MergeStrategy]] to use when
    merging into an existing EntityManager.
    @param importConfig.metadataVersionFn - A function that takes two arguments (the current metadataVersion and the imported store's 'name')
    and may be used to perform version checking.
    @return result
      - result.entities {Array of Entities} The entities that were imported.
      - result.tempKeyMap {Object} Mapping from original EntityKey in the import bundle to its corresponding EntityKey in this EntityManager.
    **/
    EntityManager.prototype.importEntities = function (exported, importConfig) {
        var _this = this;
        importConfig = importConfig || {};
        assertConfig(importConfig)
            .whereParam("mergeStrategy").isEnumOf(MergeStrategy).isOptional().withDefault(this.queryOptions.mergeStrategy)
            .whereParam("metadataVersionFn").isFunction().isOptional()
            .whereParam("mergeAdds").isBoolean().isOptional()
            .applyAll(importConfig);
        var json = (typeof exported === "string") ? JSON.parse(exported) : exported;
        if (json.metadataStore) {
            this.metadataStore.importMetadata(json.metadataStore);
            // the || clause is for backwards compat with an earlier serialization format.
            this.dataService = (json.dataService && DataService.fromJSON(json.dataService)) || new DataService({ serviceName: json.serviceName });
            this.saveOptions = new SaveOptions(json.saveOptions);
            this.queryOptions = QueryOptions.fromJSON(json.queryOptions);
            this.validationOptions = new ValidationOptions(json.validationOptions);
        }
        else {
            importConfig.metadataVersionFn && importConfig.metadataVersionFn({
                metadataVersion: json.metadataVersion,
                metadataStoreName: json.metadataStoreName
            });
        }
        var tempKeyMap = {};
        json.tempKeys.forEach(function (k) {
            var oldKey = EntityKey.fromJSON(k, _this.metadataStore);
            // try to use oldKey if not already used in this keyGenerator.
            tempKeyMap[oldKey.toString()] = new EntityKey(oldKey.entityType, _this.keyGenerator.generateTempKeyValue(oldKey.entityType, oldKey.values[0]));
        });
        var entitiesToLink = [];
        var impConfig = importConfig;
        impConfig.tempKeyMap = tempKeyMap;
        core.wrapExecution(function () {
            _this._pendingPubs = [];
        }, function (state) {
            _this._pendingPubs.forEach(function (fn) { return fn(); });
            _this._pendingPubs = undefined;
            _this._hasChangesAction && _this._hasChangesAction();
        }, function () {
            core.objectForEach(json.entityGroupMap, function (entityTypeName, jsonGroup) {
                var entityType = _this.metadataStore._getStructuralType(entityTypeName, false);
                var targetEntityGroup = findOrCreateEntityGroup(_this, entityType);
                var entities = importEntityGroup(targetEntityGroup, jsonGroup, impConfig);
                if (entities && entities.length) {
                    entitiesToLink = entitiesToLink.concat(entities);
                }
            });
            entitiesToLink.forEach(function (entity) {
                if (!entity.entityAspect.entityState.isDeleted()) {
                    _this._linkRelatedEntities(entity);
                }
            });
        });
        return {
            entities: entitiesToLink,
            tempKeyMapping: tempKeyMap
        };
    };
    /**
    Clears this EntityManager's cache but keeps all other settings. Note that this
    method is not as fast as creating a new EntityManager via 'new EntityManager'.
    This is because clear actually detaches all of the entities from the EntityManager.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     em1.clear();
    >     // em1 is will now contain no entities, but all other setting will be maintained.
    **/
    EntityManager.prototype.clear = function () {
        core.objectMap(this._entityGroupMap, function (key, entityGroup) {
            return entityGroup._checkOperation('clear');
        }).forEach(function (entityGroup) {
            entityGroup._clear();
        });
        this._entityGroupMap = {};
        this._unattachedChildrenMap = new UnattachedChildrenMap();
        this.keyGenerator = new this.keyGeneratorCtor();
        this.entityChanged.publish({ entityAction: EntityAction.Clear });
        this._setHasChanges(false);
    };
    /**
    Creates an empty copy of this EntityManager but with the same DataService, MetadataStore, QueryOptions, SaveOptions, ValidationOptions, etc.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     let em2 = em1.createEmptyCopy();
    >     // em2 is a new EntityManager with all of em1's settings
    >     // but no entities.
    @return A new EntityManager.
    **/
    EntityManager.prototype.createEmptyCopy = function () {
        var copy = new EntityManager(core.extend({}, this, ["dataService", "metadataStore", "queryOptions", "saveOptions", "validationOptions", "keyGeneratorCtor"]));
        return copy;
    };
    /**
    Attaches an entity to this EntityManager with an  [[EntityState]] of 'Added'.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     let custType = em1.metadataStore.getEntityType("Customer");
    >     let cust1 = custType.createEntity();
    >     em1.addEntity(cust1);
  
    Note that this is the same as using 'attachEntity' with an [[EntityState]] of 'Added'.
  
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     let custType = em1.metadataStore.getEntityType("Customer");
    >     let cust1 = custType.createEntity();
    >     em1.attachEntity(cust1, EntityState.Added);
    @param entity - The entity to add.
    @return The added entity.
    **/
    EntityManager.prototype.addEntity = function (entity) {
        return this.attachEntity(entity, EntityState.Added);
    };
    /**
    Attaches an entity to this EntityManager with a specified [[EntityState]].
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     let custType = em1.metadataStore.getEntityType("Customer");
    >     let cust1 = custType.createEntity();
    >     em1.attachEntity(cust1, EntityState.Added);
    @param entity - The entity to add.
    @param entityState - (default=EntityState.Unchanged) The EntityState of the newly attached entity. If omitted this defaults to EntityState.Unchanged.
    @param mergeStrategy - (default = MergeStrategy.Disallowed) How the specified entity should be merged into the EntityManager if this EntityManager already contains an entity with the same key.
    @return The attached entity.
    **/
    EntityManager.prototype.attachEntity = function (entity, entityState, mergeStrategy) {
        var _this = this;
        assertParam(entity, "entity").isRequired().check();
        this.metadataStore._checkEntityType(entity);
        var esSymbol = assertParam(entityState, "entityState").isEnumOf(EntityState).isOptional().check(EntityState.Unchanged);
        var msSymbol = assertParam(mergeStrategy, "mergeStrategy").isEnumOf(MergeStrategy).isOptional().check(MergeStrategy.Disallowed);
        if (entity.entityType.metadataStore !== this.metadataStore) {
            throw new Error("Cannot attach this entity because the EntityType (" + entity.entityType.name +
                ") and MetadataStore associated with this entity does not match this EntityManager's MetadataStore.");
        }
        var aspect = entity.entityAspect;
        if (aspect) {
            // to avoid reattaching an entity in progress
            if (aspect._inProcessEntity)
                return aspect._inProcessEntity;
        }
        else {
            // this occur's when attaching an entity created via new instead of via createEntity.
            aspect = new EntityAspect(entity);
        }
        var manager = aspect.entityManager;
        if (manager) {
            if (manager === this) {
                return entity;
            }
            else {
                throw new Error("This entity already belongs to another EntityManager");
            }
        }
        var attachedEntity = {};
        core.using(this, "isLoading", true, function () {
            if (esSymbol.isAdded()) {
                checkEntityKey(_this, entity);
            }
            // attachedEntity === entity EXCEPT in the case of a merge.
            attachedEntity = _this._attachEntityCore(entity, esSymbol, msSymbol);
            aspect._inProcessEntity = attachedEntity;
            try {
                // entity ( not attachedEntity) is deliberate here.
                attachRelatedEntities(_this, entity, esSymbol, msSymbol);
            }
            finally {
                // insure that _inProcessEntity is cleared.
                aspect._inProcessEntity = undefined;
            }
        });
        if (this.validationOptions.validateOnAttach) {
            attachedEntity.entityAspect.validateEntity();
        }
        if (!esSymbol.isUnchanged()) {
            this._notifyStateChange(attachedEntity, true);
        }
        this.entityChanged.publish({ entityAction: EntityAction.Attach, entity: attachedEntity });
        return attachedEntity;
    };
    /**
    Detaches an entity from this EntityManager.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     // assume cust1 is a customer Entity previously attached to em1
    >     em1.detachEntity(cust1);
    >     // em1 will now no longer contain cust1 and cust1 will have an
    >     // entityAspect.entityState of EntityState.Detached
    @param entity - The entity to detach.
    @return Whether the entity could be detached. This will return false if the entity is already detached or was never attached.
    **/
    EntityManager.prototype.detachEntity = function (entity) {
        assertParam(entity, "entity").isEntity().check();
        var aspect = entity.entityAspect;
        if (!aspect) {
            // no aspect means in couldn't appear in any group
            return false;
        }
        if (aspect.entityManager !== this) {
            throw new Error("This entity does not belong to this EntityManager.");
        }
        return aspect.setDetached();
    };
    /**
    Fetches the metadata associated with the EntityManager's current 'serviceName'.  This call
    occurs internally before the first query to any service if the metadata hasn't already been
    loaded. __Async__
  
    Usually you will not actually process the results of a fetchMetadata call directly, but will instead
    ask for the metadata from the EntityManager after the fetchMetadata call returns.
    >     let em1 = new EntityManager( "breeze/NorthwindIBModel");
    >     em1.fetchMetadata()
    >       .then(function() {
    >           let metadataStore = em1.metadataStore;
    >           // do something with the metadata
    >       }).catch(function(exception) {
    >           // handle exception here
    >       });
    
    @param callback - Function called on success.
    @param errorCallback - Function called on failure.
    @return {Promise}
      - schema {Object} The raw Schema object from metadata provider - Because this schema will differ depending on the metadata provider
          it is usually better to access metadata via the 'metadataStore' property of the EntityManager instead of using this 'raw' data.
    **/
    EntityManager.prototype.fetchMetadata = function (dataService, callback, errorCallback) {
        if (typeof (dataService) === "function") {
            // legacy support for when dataService was not an arg. i.e. first arg was callback
            errorCallback = callback;
            callback = dataService;
            dataService = undefined;
        }
        else {
            assertParam(dataService, "dataService").isInstanceOf(DataService).isOptional().check();
            assertParam(callback, "callback").isFunction().isOptional().check();
            assertParam(errorCallback, "errorCallback").isFunction().isOptional().check();
        }
        var promise = this.metadataStore.fetchMetadata(dataService || this.dataService);
        return promiseWithCallbacks(promise, callback, errorCallback);
    };
    /**
    Executes the specified query. __Async__
    
    >     let em = new EntityManager(serviceName);
    >     let query = new EntityQuery("Orders");
    >     em.executeQuery(query).then( function(data) {
    >         let orders = data.results;
    >         ... query results processed here
    >     }).catch( function(err) {
    >         ... query failure processed here
    >     });
  
    or with callbacks
    >     let em = new EntityManager(serviceName);
    >     let query = new EntityQuery("Orders");
    >     em.executeQuery(query,
    >         function(data) {
    >             let orders = data.results;
    >             ... query results processed here
    >         },
    >         function(err) {
    >             ... query failure processed here
    >         });
  
    Either way this method is the same as calling the The [[EntityQuery]] 'execute' method.
    >     let em = new EntityManager(serviceName);
    >     let query = new EntityQuery("Orders").using(em);
    >     query.execute().then( function(data) {
    >         let orders = data.results;
    >         ... query results processed here
    >     }).catch( function(err) {
    >         ... query failure processed here
    >     });
    @param query - The [[EntityQuery]] or OData query string to execute.
    @param callback - Function called on success.
    @param errorCallback - {Function} Function called on failure.
    @return Promise of
      - results - An array of entities
      - retrievedEntities - A array of all of the entities returned by the query.  Differs from results (above) when .expand() is used.
      - query - The original [[EntityQuery]] or query string
      - entityManager -  The EntityManager.
      - httpResponse - The [[IHttpResponse]] returned from the server.
      - inlineCount -  Only available if 'inlineCount(true)' was applied to the query.  Returns the count of
      items that would have been returned by the query before applying any skip or take operators, but after any filter/where predicates
      would have been applied.
    **/
    EntityManager.prototype.executeQuery = function (query, callback, errorCallback) {
        var _this = this;
        assertParam(query, "query").isInstanceOf(EntityQuery).or().isString().check();
        assertParam(callback, "callback").isFunction().isOptional().check();
        assertParam(errorCallback, "errorCallback").isFunction().isOptional().check();
        var promise;
        // 'resolve' methods create a new typed object with all of its properties fully resolved against a list of sources.
        // Thought about creating a 'normalized' query with these 'resolved' objects
        // but decided not to because the 'query' may not be an EntityQuery (it can be a string) and hence might not have a queryOptions or dataServices property on it.
        var queryOptions = QueryOptions.resolve([query.queryOptions, this.queryOptions, QueryOptions.defaultInstance]);
        var dataService = DataService.resolve([query.dataService, this.dataService]);
        if ((!dataService.hasServerMetadata) || this.metadataStore.hasMetadataFor(dataService.serviceName)) {
            promise = executeQueryCore(this, query, queryOptions, dataService);
        }
        else {
            promise = this.fetchMetadata(dataService).then(function () {
                return executeQueryCore(_this, query, queryOptions, dataService);
            });
        }
        return promiseWithCallbacks(promise, callback, errorCallback);
    };
    /**
    Executes the specified query against this EntityManager's local cache.
  
    Because this method is executed immediately there is no need for a promise or a callback
    >     let em = new EntityManager(serviceName);
    >     let query = new EntityQuery("Orders");
    >     let orders = em.executeQueryLocally(query);
  
    Note that this can also be accomplished using the 'executeQuery' method with
    a FetchStrategy of FromLocalCache and making use of the Promise or callback
    >     let em = new EntityManager(serviceName);
    >     let query = new EntityQuery("Orders").using(FetchStrategy.FromLocalCache);
    >     em.executeQuery(query).then( function(data) {
    >         let orders = data.results;
    >         ... query results processed here
    >     }).catch( function(err) {
    >         ... query failure processed here
    >     });
    @param query - The [[EntityQuery]] to execute.
    @return  {Array of Entity}  Array of entities from cache that satisfy the query
    **/
    EntityManager.prototype.executeQueryLocally = function (query) {
        return executeQueryLocallyCore(this, query).results;
    };
    /**
    Saves either a list of specified entities or all changed entities within this EntityManager. If there are no changes to any of the entities
    specified then there will be no server side call made but a valid 'empty' saveResult will still be returned. __Async__
  
    Often we will be saving all of the entities within an EntityManager that are either added, modified or deleted
    and we will let the 'saveChanges' call determine which entities these are.
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      // This could include added, modified and deleted entities.
    >      em.saveChanges().then(function(saveResult) {
    >          let savedEntities = saveResult.entities;
    >          let keyMappings = saveResult.keyMappings;
    >      }).catch(function (e) {
    >          // e is any exception that was thrown.
    >      });
  
    But we can also control exactly which entities to save and can specify specific SaveOptions
  
    >      // assume entitiesToSave is an array of entities to save.
    >      let saveOptions = new SaveOptions({ allowConcurrentSaves: true });
    >      em.saveChanges(entitiesToSave, saveOptions).then(function(saveResult) {
    >          let savedEntities = saveResult.entities;
    >          let keyMappings = saveResult.keyMappings;
    >      }).catch(function (e) {
    >          // e is any exception that was thrown.
    >      });
  
    Callback methods can also be used
    >      em.saveChanges(entitiesToSave, null,
    >          function(saveResult) {
    >              let savedEntities = saveResult.entities;
    >              let keyMappings = saveResult.keyMappings;
    >          }, function (e) {
    >              // e is any exception that was thrown.
    >          }
    >      );
  
    @param entities - The list of entities to save.
    Every entity in that list will be sent to the server, whether changed or unchanged,
    as long as it is attached to this EntityManager.
    If this parameter is omitted, null or empty (the usual case),
    every entity with pending changes in this EntityManager will be saved.
    @param saveOptions - [[SaveOptions]] for the save - will default to
    [[EntityManager.saveOptions]] if null.
    @param callback -  Function called on success.
    @param errorCallback - Function called on failure.
    @return {Promise} Promise
    **/
    EntityManager.prototype.saveChanges = function (entities, saveOptions, callback, errorCallback) {
        assertParam(entities, "entities").isOptional().isArray().isEntity().check();
        assertParam(saveOptions, "saveOptions").isInstanceOf(SaveOptions).isOptional().check();
        assertParam(callback, "callback").isFunction().isOptional().check();
        assertParam(errorCallback, "errorCallback").isFunction().isOptional().check();
        saveOptions = saveOptions || this.saveOptions || SaveOptions.defaultInstance;
        var entitiesToSave = getEntitiesToSave(this, entities ? entities : undefined);
        if (entitiesToSave.length === 0) {
            var result = { entities: [], keyMappings: [] };
            if (callback)
                callback(result);
            return Promise.resolve(result);
        }
        if (!saveOptions.allowConcurrentSaves) {
            var anyPendingSaves = entitiesToSave.some(function (entity) {
                return entity.entityAspect.isBeingSaved;
            });
            if (anyPendingSaves) {
                var err = new Error("Concurrent saves not allowed - SaveOptions.allowConcurrentSaves is false");
                if (errorCallback)
                    errorCallback(err);
                return Promise.reject(err);
            }
        }
        clearServerErrors(entitiesToSave);
        var valError = this.saveChangesValidateOnClient(entitiesToSave);
        if (valError) {
            if (errorCallback)
                errorCallback(valError);
            return Promise.reject(valError);
        }
        var dataService = DataService.resolve([saveOptions.dataService, this.dataService]);
        var saveContext = {
            entityManager: this,
            dataService: dataService,
            processSavedEntities: processSavedEntities,
            resourceName: saveOptions.resourceName || this.saveOptions.resourceName || "SaveChanges"
        };
        // TODO: need to check that if we are doing a partial save that all entities whose temp keys
        // are referenced are also in the partial save group
        var saveBundle = { entities: entitiesToSave, saveOptions: saveOptions };
        try { // Guard against exception thrown in dataservice adapter before it goes async
            updateConcurrencyProperties(entitiesToSave);
            return dataService.adapterInstance.saveChanges(saveContext, saveBundle)
                .then(saveSuccess).then(function (r) { return r; }, saveFail);
        }
        catch (err) {
            // undo the marking by updateConcurrencyProperties
            markIsBeingSaved(entitiesToSave, false);
            if (errorCallback)
                errorCallback(err);
            return Promise.reject(err);
        }
        function saveSuccess(saveResult) {
            var em = saveContext.entityManager;
            markIsBeingSaved(entitiesToSave, false);
            var savedEntities = saveContext.processSavedEntities(saveResult);
            saveResult.entities = savedEntities;
            // update _hasChanges after save.
            em._setHasChanges();
            // can't do this anymore because other changes might have been made while saved entities in flight.
            //      let hasChanges = (isFullSave && haveSameContents(entitiesToSave, savedEntities)) ? false : null;
            //      em._setHasChanges(hasChanges);
            if (callback)
                callback(saveResult);
            return Promise.resolve(saveResult);
        }
        function processSavedEntities(saveResult) {
            var savedEntities = saveResult.entities;
            var deletedKeys = saveResult.deletedKeys || [];
            if (savedEntities.length === 0 && deletedKeys.length === 0) {
                return [];
            }
            var keyMappings = saveResult.keyMappings;
            var em = saveContext.entityManager;
            // must occur outside of isLoading block
            fixupKeys(em, keyMappings);
            core.using(em, "isLoading", true, function () {
                var mappingContext = new MappingContext({
                    query: undefined,
                    entityManager: em,
                    mergeOptions: { mergeStrategy: MergeStrategy.OverwriteChanges },
                    dataService: dataService
                });
                // The visitAndMerge operation has been optimized so that we do not actually perform a merge if the
                // the save operation did not actually return the entity - i.e. during OData and Mongo updates and deletes.
                savedEntities = mappingContext.visitAndMerge(savedEntities, { nodeType: "root" });
            });
            // detach any entities found in the em that appear in the deletedKeys list. 
            deletedKeys.forEach(function (key) {
                var entityType = em.metadataStore._getStructuralType(key.entityTypeName);
                var ekey = new EntityKey(entityType, key.keyValues);
                var entity = em.findEntityByKey(ekey);
                if (entity) {
                    entity.entityAspect.setDetached();
                }
            });
            return savedEntities;
        }
        function saveFail(serverError) {
            markIsBeingSaved(entitiesToSave, false);
            var clientError = processServerErrors(saveContext, serverError);
            if (errorCallback)
                errorCallback(clientError);
            return Promise.reject(clientError);
        }
    };
    /**
    Run the "saveChanges" pre-save client validation logic.
    
    This is NOT a general purpose validation method.
    It is intended for utilities that must know if saveChanges
    would reject the save due to client validation errors.
    
    It only validates entities if the EntityManager's
    [[ValidationOptions]].validateOnSave is true.
    
    @param entitiesToSave {Array of Entity} The list of entities to save (to validate).
    @return {Error} Validation error or null if no error
    **/
    EntityManager.prototype.saveChangesValidateOnClient = function (entitiesToSave) {
        if (this.validationOptions.validateOnSave) {
            var failedEntities = entitiesToSave.filter(function (entity) {
                var aspect = entity.entityAspect;
                var isValid = aspect.entityState.isDeleted() || aspect.validateEntity();
                return !isValid;
            });
            if (failedEntities.length > 0) {
                var valError = new Error("Client side validation errors encountered - see the entityErrors collection on this object for more detail");
                valError.entityErrors = createEntityErrors(failedEntities);
                return valError; // TODO: type this.
            }
        }
        return null;
    };
    /** @hidden @internal */
    EntityManager.prototype._findEntityGroup = function (entityType) {
        return this._entityGroupMap[entityType.name];
    };
    /**
    Attempts to locate an entity within this EntityManager by its [EntityKey].
    @param entityKey - The [[EntityKey]] of the Entity to be located.
    @param type - The [[EntityType]] for this key.
    @param typeName - The EntityType name for this key.
    @param keyValues - The values for this key - will usually just be a single value; an array is only needed for multipart keys.
    @return An Entity or null;
    **/
    EntityManager.prototype.getEntityByKey = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var entityKey = createEntityKey(this, args).entityKey;
        var entityTypes = entityKey._subtypes || [entityKey.entityType];
        var e;
        // hack use of some to simulate mapFirst logic.
        entityTypes.some(function (et) {
            var group = _this._findEntityGroup(et);
            // group version of findEntityByKey doesn't care about entityType
            e = group && group.findEntityByKey(entityKey);
            return e != null;
        });
        return e || null;
    };
    /**
    Attempts to fetch an entity from the server by its [[EntityKey]] with
    an option to check the local cache first. Note the this EntityManager's queryOptions.mergeStrategy
    will be used to merge any server side entity returned by this method.
    >     // assume em1 is an EntityManager containing a number of preexisting entities.
    >     let employeeType = em1.metadataStore.getEntityType("Employee");
    >     let employeeKey = new EntityKey(employeeType, 1);
    >     em1.fetchEntityByKey(employeeKey).then(function(result) {
    >       let employee = result.entity;
    >       let entityKey = result.entityKey;
    >       let fromCache = result.fromCache;
    >     });
    @param typeName  - The EntityType name for this key.
    @param entityType  - The EntityType for this key.
    @param keyValues - The values for this key - will usually just be a single value; an array is only needed for multipart keys.
    @param entityKey - The [[EntityKey]] of the Entity to be located.
    @param checkLocalCacheFirst - (default = false) - Whether to check this EntityManager first before going to the server. By default, the query will NOT do this.
    @return {Promise}
      - Properties on the promise success result
        - entity {Object} The entity returned or null
        - entityKey {EntityKey} The entityKey of the entity to fetch.
        - fromCache {Boolean} Whether this entity was fetched from the server or was found in the local cache.
    **/
    EntityManager.prototype.fetchEntityByKey = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var dataService = DataService.resolve([this.dataService]);
        if ((!dataService.hasServerMetadata) || this.metadataStore.hasMetadataFor(dataService.serviceName)) {
            return fetchEntityByKeyCore(this, args);
        }
        else {
            return this.fetchMetadata(dataService).then(function () {
                return fetchEntityByKeyCore(_this, args);
            });
        }
    };
    /**
    [Deprecated] - Attempts to locate an entity within this EntityManager by its  [[EntityKey]].
    >     // assume em1 is an EntityManager containing a number of preexisting entities.
    >     let employeeType = em1.metadataStore.getEntityType("Employee");
    >     let employeeKey = new EntityKey(employeeType, 1);
    >     let employee = em1.findEntityByKey(employeeKey);
    >     // employee will either be an entity or null.
    @deprecated    Use getEntityByKey instead
    @param entityKey - The  [[EntityKey]] of the Entity to be located.
    @return An Entity or null;
    **/
    EntityManager.prototype.findEntityByKey = function (entityKey) {
        return this.getEntityByKey(entityKey);
    };
    /**
    Generates a temporary key for the specified entity.  This is used to insure that newly
    created entities have unique keys and to register that these keys are temporary and
    need to be automatically replaced with 'real' key values once these entities are saved.
    
    The [[EntityManager.keyGeneratorCtor]] property is used internally by this method to actually generate
    the keys - See the  KeyGenerator interface interface description to see
    how a custom key generator can be plugged in.
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let customer = custType.createEntity();
    >      let customerId = em.generateTempKeyValue(customer);
    >      // The 'customer' entity 'CustomerID' property is now set to a newly generated unique id value
    >      // This property will change again after a successful save of the 'customer' entity.
    >
    >      em1.saveChanges().then( function( data) {
    >          let sameCust1 = data.results[0];
    >          // cust1 === sameCust1;
    >          // but cust1.getProperty("CustomerId") != customerId
    >          // because the server will have generated a new id
    >          // and the client will have been updated with this
    >          // new id.
    >      })
    @param entity - The Entity to generate a key for.
    @return The new key value
    **/
    EntityManager.prototype.generateTempKeyValue = function (entity) {
        // TODO - check if this entity is attached to this EntityManager.
        assertParam(entity, "entity").isEntity().check();
        var entityType = entity.entityType;
        var nextKeyValue = this.keyGenerator.generateTempKeyValue(entityType);
        var keyProp = entityType.keyProperties[0];
        entity.setProperty(keyProp.name, nextKeyValue);
        entity.entityAspect.hasTempKey = true;
        return nextKeyValue;
    };
    /**
    Returns whether there are any changed entities of the specified [[EntityType]]s. A 'changed' Entity has
    has an [[EntityState]] of either Added, Modified or Deleted.
  
    This method can be used to determine if an EntityManager has any changes
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      if ( em1.hasChanges() {
    >          // do something interesting
    >      }
  
    or if it has any changes on to a specific [[EntityType]].
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      if ( em1.hasChanges(custType) {
    >          // do something interesting
    >      }
  
    or to a collection of [[EntityType]]s
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let orderType = em1.metadataStore.getEntityType("Order");
    >      if ( em1.hasChanges( [custType, orderType]) {
    >          // do something interesting
    >      }
    @param entityTypes - The [[EntityType]] or EntityTypes for which 'changed' entities will be found.
    @param entityTypeNames - The [[EntityType]] name or names for which 'changed' entities will be found.
    @return Whether there are any changed entities that match the types specified..
    **/
    EntityManager.prototype.hasChanges = function (entityTypes) {
        if (!this._hasChanges)
            return false;
        if (entityTypes === undefined)
            return this._hasChanges;
        return this._hasChangesCore(entityTypes);
    };
    /** @hidden @internal */
    // backdoor to "really" check for changes.
    EntityManager.prototype._hasChangesCore = function (entityTypes) {
        var ets = checkEntityTypes(this, entityTypes);
        var entityGroups = getEntityGroups(this, ets);
        return entityGroups.some(function (eg) {
            return eg && eg.hasChanges();
        });
    };
    /**
    Returns a array of all changed entities of the specified [[EntityType]]s. A 'changed' Entity has
    has an [[EntityState]] of either Added, Modified or Deleted.
    
    This method can be used to get all of the changed entities within an EntityManager
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let changedEntities = em1.getChanges();
  
    or you can specify that you only want the changes on a specific [[EntityType]]
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let changedCustomers = em1.getChanges(custType);
  
    or to a collection of [[EntityType]]s
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let orderType = em1.metadataStore.getEntityType("Order");
    >      let changedCustomersAndOrders = em1.getChanges([custType, orderType]);
    @param entityTypes - The [[EntityType]] or EntityTypes for which 'changed' entities will be found.
    @param entityTypeNames - The [[EntityType]] name or names for which 'changed' entities will be found.
    @return An array of Entities
    **/
    EntityManager.prototype.getChanges = function (entityTypes) {
        var ets = checkEntityTypes(this, entityTypes);
        return getChangesCore(this, ets);
    };
    /**
    Rejects (reverses the effects) all of the additions, modifications and deletes from this EntityManager.
    Calls [[EntityAspect.rejectChanges]] on every changed entity in this EntityManager.
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let entities = em1.rejectChanges();
    @return The entities whose changes were rejected. These entities will all have EntityStates of
    either 'Unchanged' or 'Detached'
    **/
    EntityManager.prototype.rejectChanges = function () {
        if (!this._hasChanges)
            return [];
        var changes = getChangesCore(this);
        // next line stops individual reject changes from each calling _hasChangesCore
        var aspects = changes.map(function (e) {
            return e.entityAspect._checkOperation("rejectChanges");
        });
        this._hasChanges = false;
        aspects.forEach(function (aspect) {
            aspect.rejectChanges();
        });
        this.hasChangesChanged.publish({ entityManager: this, hasChanges: false });
        return changes;
    };
    /**
    Returns a array of all entities of the specified [[EntityType]]s with the specified [[EntityState]]s.
  
    This method can be used to get all of the entities within an EntityManager
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let entities = em1.getEntities();
  
    or you can specify that you only want the changes on a specific [[EntityType]]
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let customers = em1.getEntities(custType);
  
    or to a collection of [[EntityType]]s
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let orderType = em1.metadataStore.getEntityType("Order");
    >      let customersAndOrders = em1.getChanges([custType, orderType]);
  
    You can also ask for entities with a particular [[EntityState]] or EntityStates.
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let orderType = em1.metadataStore.getEntityType("Order");
    >      let addedCustomersAndOrders = em1.getEntities([custType, orderType], EntityState.Added);
   
    @param entityTypeName - The [[EntityType]] name or names for which entities will be found.
    If this parameter is omitted, all EntityTypes are searched.
    @param entityTypes - The [[EntityType]] or EntityTypes for which entities will be found.
    If this parameter is omitted, all EntityTypes are searched.
    @param entityStates - The [[EntityState]]s for which entities will be found.
    If this parameter is omitted, entities of all EntityStates are returned.
    @return An array of Entities
    **/
    EntityManager.prototype.getEntities = function (entityTypes, entityStates) {
        var entTypes = checkEntityTypes(this, entityTypes);
        assertParam(entityStates, "entityStates").isOptional().isEnumOf(EntityState).or().isNonEmptyArray().isEnumOf(EntityState).check();
        var states = validateEntityStates(this, entityStates);
        return getEntitiesCore(this, entTypes, states);
    };
    // protected methods
    /** @hidden @internal */
    EntityManager.prototype._notifyStateChange = function (entity, needsSave) {
        var ecArgs = { entityAction: EntityAction.EntityStateChange, entity: entity };
        if (needsSave) {
            if (!this._hasChanges)
                this._setHasChanges(true);
        }
        else {
            // called when rejecting a change or merging an unchanged record.
            // NOTE: this can be slow with lots of entities in the cache.
            // so defer it during a query/import or save and call it once when complete ( if needed).
            if (this._hasChanges) {
                if (this.isLoading) {
                    this._hasChangesAction = this._hasChangesAction || function () {
                        this._setHasChanges(null);
                        this.entityChanged.publish(ecArgs);
                    }.bind(this);
                    return;
                }
                else {
                    this._setHasChanges();
                }
            }
        }
        this.entityChanged.publish(ecArgs);
    };
    /** @hidden @internal */
    EntityManager.prototype._setHasChanges = function (hasChanges) {
        if (hasChanges == null)
            hasChanges = this._hasChangesCore();
        var hadChanges = this._hasChanges;
        this._hasChanges = hasChanges;
        if (hasChanges !== hadChanges) {
            this.hasChangesChanged.publish({ entityManager: this, hasChanges: hasChanges });
        }
        this._hasChangesAction = undefined;
    };
    /** @hidden @internal */
    EntityManager.prototype._linkRelatedEntities = function (entity) {
        var em = this;
        var entityAspect = entity.entityAspect;
        // we do not want entityState to change as a result of linkage.
        core.using(em, "isLoading", true, function () {
            var unattachedMap = em._unattachedChildrenMap;
            var entityKey = entityAspect.getKey();
            var entityType = entityKey.entityType;
            var _loop_1 = function () {
                var keystring = entityKey.toString(entityType);
                // attach any unattachedChildren
                var tuples = unattachedMap.getTuplesByString(keystring);
                if (tuples) {
                    tuples.slice(0).forEach(function (tpl) {
                        var unattachedChildren = tpl.children.filter(function (e) {
                            return e.entityAspect.entityState !== EntityState.Detached;
                        });
                        var childToParentNp;
                        var parentToChildNp;
                        // np is usually childToParentNp
                        // except with unidirectional 1-n where it is parentToChildNp;
                        var np = tpl.navigationProperty;
                        var inverseNp = np.inverse;
                        if (inverseNp) {
                            // bidirectional
                            childToParentNp = np;
                            parentToChildNp = inverseNp;
                            if (parentToChildNp.isScalar) {
                                var onlyChild = unattachedChildren[0];
                                entity.setProperty(parentToChildNp.name, onlyChild);
                                onlyChild.setProperty(childToParentNp.name, entity);
                            }
                            else {
                                var currentChildren_1 = entity.getProperty(parentToChildNp.name);
                                unattachedChildren.forEach(function (child) {
                                    currentChildren_1.push(child);
                                    child.setProperty(childToParentNp.name, entity);
                                });
                            }
                            unattachedMap.removeChildren(keystring, childToParentNp);
                        }
                        else {
                            // unidirectional
                            // if (np.isScalar || np.parentType !== entity.entityType) {
                            if (np.isScalar) {
                                // n -> 1  eg: child: OrderDetail parent: Product
                                // 1 -> 1 eg child: Employee parent: Employee ( only Manager, no DirectReports property)
                                childToParentNp = np;
                                unattachedChildren.forEach(function (child) {
                                    child.setProperty(childToParentNp.name, entity);
                                });
                                unattachedMap.removeChildren(keystring, childToParentNp);
                            }
                            else {
                                // 1 -> n  eg: parent: Region child: Terr
                                // TODO: need to remove unattached children from the map after this; only a perf issue.
                                parentToChildNp = np;
                                var currentChildren_2 = entity.getProperty(parentToChildNp.name);
                                unattachedChildren.forEach(function (child) {
                                    // we know if can't already be there.
                                    currentChildren_2._push(child);
                                });
                            }
                        }
                    });
                }
                entityType = entityType.baseEntityType; // look for relationships up the hierarchy
            };
            while (entityType) {
                _loop_1();
            }
            // now add to unattachedMap if needed.
            entity.entityType.navigationProperties.forEach(function (np) {
                if (np.isScalar) {
                    var value = entity.getProperty(np.name);
                    // property is already linked up
                    if (value)
                        return;
                }
                // first determine if np contains a parent or child
                // having a parentKey means that this is a child
                // if a parent then no need for more work because children will attach to it.
                var parentKey = entityAspect.getParentKey(np);
                if (parentKey) {
                    // check for empty keys - meaning that parent id's are not yet set.
                    if (parentKey._isEmpty())
                        return;
                    // if a child - look for parent in the em cache
                    var parent_1 = em.findEntityByKey(parentKey);
                    if (parent_1) {
                        // if found hook it up
                        entity.setProperty(np.name, parent_1);
                    }
                    else {
                        // else add parent to unresolvedParentMap;
                        unattachedMap.addChild(parentKey, np, entity);
                    }
                }
            });
            // handle unidirectional 1-x where we set x.fk
            entity.entityType.foreignKeyProperties.forEach(function (fkProp) {
                var invNp = fkProp.inverseNavigationProperty;
                if (!invNp)
                    return;
                // unidirectional fk props only
                var fkValue = entity.getProperty(fkProp.name);
                var parentKey = new EntityKey(invNp.parentType, [fkValue]);
                var parent = em.findEntityByKey(parentKey);
                if (parent) {
                    if (invNp.isScalar) {
                        parent.setProperty(invNp.name, entity);
                    }
                    else {
                        if (em.isLoading) {
                            parent.getProperty(invNp.name)._push(entity);
                        }
                        else {
                            parent.getProperty(invNp.name).push(entity);
                        }
                    }
                }
                else {
                    // else add parent to unresolvedParentMap;
                    unattachedMap.addChild(parentKey, invNp, entity);
                }
            });
        });
    };
    /** @hidden @internal */
    EntityManager.prototype._attachEntityCore = function (entity, entityState, mergeStrategy) {
        var group = findOrCreateEntityGroup(this, entity.entityType);
        var attachedEntity = group.attachEntity(entity, entityState, mergeStrategy);
        this._linkRelatedEntities(attachedEntity);
        return attachedEntity;
    };
    /** @hidden @internal */
    EntityManager.prototype._updateFkVal = function (fkProp, oldValue, newValue) {
        var group = this._entityGroupMap[fkProp.parentType.name];
        if (!group)
            return;
        group._updateFkVal(fkProp, oldValue, newValue);
    };
    return EntityManager;
}());
export { EntityManager };
EntityManager.prototype._$typeName = "EntityManager";
BreezeEvent.bubbleEvent(EntityManager.prototype);
function clearServerErrors(entities) {
    entities.forEach(function (entity) {
        var serverKeys = [];
        var aspect = entity.entityAspect;
        core.objectForEach(aspect._validationErrors, function (key, ve) {
            if (ve.isServerError)
                serverKeys.push(key);
        });
        if (serverKeys.length === 0)
            return;
        aspect._processValidationOpAndPublish(function () {
            serverKeys.forEach(function (key) {
                aspect._removeValidationError(key);
            });
        });
    });
}
function createEntityErrors(entities) {
    var entityErrors = [];
    entities.forEach(function (entity) {
        core.objectForEach(entity.entityAspect._validationErrors, function (key, ve) {
            var cfg = core.extend({
                entity: entity,
                errorName: ve.validator.name
            }, ve, ["errorMessage", "propertyName", "isServerError"]);
            entityErrors.push(cfg);
        });
    });
    return entityErrors;
}
function processServerErrors(saveContext, saveError) {
    // converting ISaveErrorFromServer -> ISaveError
    var serverErrors = saveError.entityErrors;
    if (!serverErrors)
        return saveError;
    var entityManager = saveContext.entityManager;
    var metadataStore = entityManager.metadataStore;
    var entityErrors = serverErrors.map(function (serr) {
        var entity = null;
        var entityType;
        if (serr.keyValues) {
            entityType = metadataStore._getStructuralType(serr.entityTypeName);
            var ekey = new EntityKey(entityType, serr.keyValues);
            entity = entityManager.findEntityByKey(ekey);
        }
        if (entityType && entity) {
            var context = serr.propertyName ?
                {
                    propertyName: serr.propertyName,
                    property: entityType.getProperty(serr.propertyName)
                } : {};
            var key = ValidationError.getKey(serr.errorName || serr.errorMessage, serr.propertyName);
            var ve = new ValidationError(null, context, serr.errorMessage, key);
            ve.isServerError = true;
            entity.entityAspect.addValidationError(ve);
        }
        var entityError = core.extend({
            entity: entity,
            isServerError: true
        }, serr, ["errorName", "errorMessage", "propertyName"]);
        return entityError;
    });
    // converting ISaveErrorFromServer -> ISaveError 
    saveError.entityErrors = entityErrors;
    return saveError;
}
function fetchEntityByKeyCore(em, args) {
    var tpl = createEntityKey(em, args);
    var entityKey = tpl.entityKey;
    var checkLocalCacheFirst = tpl.remainingArgs.length === 0 ? false : !!tpl.remainingArgs[0];
    var entity = null;
    var foundIt = false;
    if (checkLocalCacheFirst) {
        entity = em.getEntityByKey(entityKey);
        foundIt = entity != null;
        if (entity != null &&
            // null the entity if it is deleted and we should exclude deleted entities
            !em.queryOptions.includeDeleted && entity.entityAspect.entityState.isDeleted()) {
            entity = null;
            // but resume looking if we'd overwrite deleted entity with a remote entity
            // note: em.queryOptions is always fully resolved by now
            foundIt = em.queryOptions.mergeStrategy !== MergeStrategy.OverwriteChanges;
        }
    }
    if (foundIt) {
        return Promise.resolve({ entity: entity || undefined, entityKey: entityKey, fromCache: true });
    }
    else {
        return EntityQuery.fromEntityKey(entityKey).using(em).execute().then(function (data) {
            entity = (data.results.length === 0) ? null : data.results[0];
            return Promise.resolve({ entity: entity || undefined, entityKey: entityKey, fromCache: false });
        });
    }
}
// private fns
// takes in entityTypes as either strings or entityTypes or arrays of either
// and returns either an entityType or an array of entityTypes or throws an error
function checkEntityTypes(em, entityTypes) {
    assertParam(entityTypes, "entityTypes").isString().isOptional().or().isNonEmptyArray().isString()
        .or().isInstanceOf(EntityType).or().isNonEmptyArray().isInstanceOf(EntityType).check();
    var resultTypes;
    if (typeof entityTypes === "string") {
        resultTypes = em.metadataStore._getStructuralType(entityTypes, false);
    }
    else if (Array.isArray(entityTypes) && typeof entityTypes[0] === "string") {
        resultTypes = entityTypes.map(function (etName) {
            return em.metadataStore._getStructuralType(etName, false);
        });
    }
    else {
        resultTypes = entityTypes;
    }
    return resultTypes;
}
function getChangesCore(em, entityTypes) {
    var entityGroups = getEntityGroups(em, entityTypes);
    // TODO: think about writing a core.mapMany method if we see more of these.
    var selected = [];
    entityGroups.forEach(function (eg) {
        // eg may be undefined or null
        if (!eg)
            return;
        var entities = eg.getChanges();
        if (selected && selected.length) {
            selected = selected.concat(entities);
        }
        else {
            selected = entities;
        }
    });
    return selected;
}
function getEntitiesCore(em, entityTypes, entityStates) {
    var entityGroups = getEntityGroups(em, entityTypes);
    // TODO: think about writing a core.mapMany method if we see more of these.
    var selected = [];
    entityGroups.forEach(function (eg) {
        // eg may be undefined or null
        if (!eg)
            return;
        var entities = eg.getEntities(entityStates);
        if (selected && selected.length) {
            selected = selected.concat(entities);
        }
        else {
            selected = entities;
        }
    });
    return selected;
}
function createEntityKey(em, args) {
    try {
        if (args[0] instanceof EntityKey) {
            return { entityKey: args[0], remainingArgs: core.arraySlice(args, 1) };
        }
        else if (args.length >= 2) {
            var entityType = (typeof args[0] === 'string') ? em.metadataStore._getStructuralType(args[0], false) : args[0];
            return { entityKey: new EntityKey(entityType, args[1]), remainingArgs: core.arraySlice(args, 2) };
        }
    }
    catch (e) { /* throw below */
        // throw new Error("Must supply an EntityKey OR an EntityType name or EntityType followed by a key value or an array of key values.");
    }
    throw new Error("Must supply an EntityKey OR an EntityType name or EntityType followed by a key value or an array of key values.");
}
function markIsBeingSaved(entities, flag) {
    entities.forEach(function (entity) {
        entity.entityAspect.isBeingSaved = flag;
    });
}
function exportEntityGroups(em, entitiesOrEntityTypes) {
    var entityGroupMap;
    var first = entitiesOrEntityTypes && entitiesOrEntityTypes[0];
    // check if array
    if (first) {
        // group entities by entityType and
        // create 'groups' that look like entityGroups.
        entityGroupMap = {};
        if (first.entityType) {
            var entities = entitiesOrEntityTypes;
            // assume "entities" is an array of entities;
            entities.forEach(function (e) {
                if (e.entityAspect.entityState === EntityState.Detached) {
                    throw new Error("Unable to export an entity with an EntityState of 'Detached'");
                }
                var group = entityGroupMap[e.entityType.name];
                if (!group) {
                    group = {};
                    group.entityType = e.entityType;
                    group._entities = [];
                    entityGroupMap[e.entityType.name] = group;
                }
                group._entities.push(e);
            });
        }
        else {
            // assume "entities" is an array of EntityTypes (or names)
            var entityTypes = checkEntityTypes(em, entitiesOrEntityTypes);
            if (entityTypes != null) {
                entityTypes.forEach(function (et) {
                    var group = em._entityGroupMap[et.name];
                    if (group && group._entities.length) {
                        entityGroupMap[et.name] = group;
                    }
                });
            }
        }
    }
    else if (entitiesOrEntityTypes && entitiesOrEntityTypes.length === 0) {
        // empty array = export nothing
        entityGroupMap = {};
    }
    else {
        entityGroupMap = em._entityGroupMap;
    }
    var tempKeys = [];
    var newGroupMap = {};
    core.objectForEach(entityGroupMap, function (entityTypeName, entityGroup) {
        newGroupMap[entityTypeName] = exportEntityGroup(entityGroup, tempKeys);
    });
    return { entityGroupMap: newGroupMap, tempKeys: tempKeys };
}
function exportEntityGroup(entityGroup, tempKeys) {
    var resultGroup = {};
    var entityType = entityGroup.entityType;
    var dps = entityType.dataProperties;
    var serializerFn = getSerializerFn(entityType);
    var rawEntities = [];
    entityGroup._entities.forEach(function (entity) {
        if (entity) {
            var rawEntity = structuralObjectToJson(entity, dps, serializerFn, tempKeys);
            rawEntities.push(rawEntity);
        }
    });
    resultGroup.entities = rawEntities;
    return resultGroup;
}
function structuralObjectToJson(so, dps, serializerFn, tempKeys) {
    var result = {};
    dps.forEach(function (dp) {
        var dpName = dp.name;
        var value = so.getProperty(dpName);
        if (value == null && dp.defaultValue == null)
            return;
        if (value && dp.isComplexProperty) {
            var coDps_1 = dp.dataType.dataProperties;
            value = core.map(value, function (v) {
                return structuralObjectToJson(v, coDps_1, serializerFn);
            });
        }
        else {
            value = serializerFn ? serializerFn(dp, value) : value;
            if (dp.isUnmapped) {
                value = core.toJSONSafe(value, core.toJSONSafeReplacer);
            }
        }
        if (value === undefined)
            return;
        result[dpName] = value;
    });
    // if (so.entityAspect) {
    if (EntityAspect.isEntity(so)) {
        var aspect = so.entityAspect;
        var entityState = aspect.entityState;
        var newAspect = {
            tempNavPropNames: exportTempKeyInfo(aspect, tempKeys || []),
            entityState: entityState.name
        };
        if (aspect.extraMetadata) {
            newAspect.extraMetadata = aspect.extraMetadata;
        }
        if (entityState.isModified() || entityState.isDeleted()) {
            newAspect.originalValuesMap = aspect.originalValues;
        }
        result.entityAspect = newAspect;
    }
    else {
        var aspect = so.complexAspect;
        var newAspect = {};
        if (aspect.originalValues && !core.isEmpty(aspect.originalValues)) {
            newAspect.originalValuesMap = aspect.originalValues;
        }
        result.complexAspect = newAspect;
    }
    return result;
}
function exportTempKeyInfo(entityAspect, tempKeys) {
    var entity = entityAspect.entity;
    if (entityAspect.hasTempKey) {
        tempKeys.push(entityAspect.getKey().toJSON());
    }
    // create map for this entity with foreignKeys that are 'temporary'
    // map -> key: tempKey, value: fkPropName
    var tempNavPropNames = [];
    entity.entityType.navigationProperties.forEach(function (np) {
        if (np.relatedDataProperties) {
            var relatedValue = entity.getProperty(np.name);
            if (relatedValue && relatedValue.entityAspect.hasTempKey) {
                tempNavPropNames.push(np.name);
            }
        }
    });
    return tempNavPropNames;
}
function importEntityGroup(entityGroup, jsonGroup, importConfig) {
    var tempKeyMap = importConfig.tempKeyMap;
    var mergeAdds = !!importConfig.mergeAdds;
    var entityType = entityGroup.entityType;
    var mergeStrategy = importConfig.mergeStrategy;
    var targetEntity;
    var em = entityGroup.entityManager;
    var entityChanged = em.entityChanged;
    var entitiesToLink = [];
    var rawValueFn = DataProperty.getRawValueFromClient;
    jsonGroup.entities.forEach(function (rawEntity) {
        var newAspect = rawEntity.entityAspect;
        var entityKey = entityType.getEntityKeyFromRawEntity(rawEntity, rawValueFn);
        var entityState = EntityState.fromName(newAspect.entityState);
        if (!entityState || entityState === EntityState.Detached) {
            throw new Error("Only entities with a non detached entity state may be imported.");
        }
        // Merge if raw entity is in cache UNLESS this is a new entity w/ a temp key
        // Cannot safely merge such entities even if could match temp key to an entity in cache.
        // Can enable merge of entities w/temp key using "mergeAdds" - use at your own risk!
        var newTempKey = !mergeAdds && entityState.isAdded() && getMappedKey(tempKeyMap, entityKey);
        targetEntity = newTempKey ? undefined : entityGroup.findEntityByKey(entityKey);
        if (targetEntity) {
            if (mergeStrategy === MergeStrategy.SkipMerge) {
                // deliberate fall thru
            }
            else if (mergeStrategy === MergeStrategy.Disallowed) {
                throw new Error("A MergeStrategy of 'Disallowed' prevents " + entityKey.toString() + " from being merged");
            }
            else {
                var targetEntityState = targetEntity.entityAspect.entityState;
                var wasUnchanged = targetEntityState.isUnchanged();
                if (mergeStrategy === MergeStrategy.OverwriteChanges || wasUnchanged) {
                    entityType._updateTargetFromRaw(targetEntity, rawEntity, rawValueFn);
                    targetEntity.entityAspect.setEntityState(entityState);
                    entityChanged.publish({ entityAction: EntityAction.MergeOnImport, entity: targetEntity });
                }
            }
        }
        else {
            targetEntity = entityType._createInstanceCore();
            entityType._updateTargetFromRaw(targetEntity, rawEntity, rawValueFn);
            if (newTempKey) {
                targetEntity.entityAspect.hasTempKey = true;
                // fixup pk
                targetEntity.setProperty(entityType.keyProperties[0].name, newTempKey.values[0]);
                // fixup foreign keys
                // This is safe because the entity is detached here and therefore originalValues will not be updated.
                if (newAspect.tempNavPropNames) {
                    newAspect.tempNavPropNames.forEach(function (npName) {
                        var np = entityType.getNavigationProperty(npName);
                        var fkPropName = np.relatedDataProperties[0].name;
                        var oldFkValue = targetEntity.getProperty(fkPropName);
                        var fk = new EntityKey(np.entityType, [oldFkValue]);
                        var newFk = getMappedKey(tempKeyMap, fk);
                        targetEntity.setProperty(fkPropName, newFk.values[0]);
                    });
                }
            }
            // Now performed in attachEntity
            targetEntity = entityGroup.attachEntity(targetEntity, entityState);
            entityChanged.publish({ entityAction: EntityAction.AttachOnImport, entity: targetEntity });
            if (!entityState.isUnchanged()) {
                em._notifyStateChange(targetEntity, true);
            }
        }
        entitiesToLink.push(targetEntity);
    });
    return entitiesToLink;
}
function getMappedKey(tempKeyMap, entityKey) {
    var newKey = tempKeyMap[entityKey.toString()];
    if (newKey)
        return newKey;
    var subtypes = entityKey._subtypes;
    if (!subtypes)
        return null;
    for (var i = 0, j = subtypes.length; i < j; i++) {
        newKey = tempKeyMap[entityKey.toString(subtypes[i])];
        if (newKey)
            return newKey;
    }
    return null;
}
function promiseWithCallbacks(promise, callback, errorCallback) {
    promise = promise.then(function (data) {
        if (callback)
            callback(data);
        return Promise.resolve(data);
    }, function (error) {
        if (errorCallback)
            errorCallback(error);
        return Promise.reject(error);
    });
    return promise;
}
function getEntitiesToSave(em, entities) {
    var entitiesToSave;
    if (entities) {
        entitiesToSave = entities.filter(function (e) {
            if (e.entityAspect.entityManager !== em) {
                throw new Error("Only entities in this entityManager may be saved");
            }
            return !e.entityAspect.entityState.isDetached();
        });
    }
    else {
        entitiesToSave = em.getChanges();
    }
    return entitiesToSave;
}
function fixupKeys(em, keyMappings) {
    em._inKeyFixup = true;
    keyMappings.forEach(function (km) {
        var group = em._entityGroupMap[km.entityTypeName];
        if (!group) {
            throw new Error("Unable to locate the following fully qualified EntityType name: " + km.entityTypeName);
        }
        group._fixupKey(km.tempValue, km.realValue);
    });
    em._inKeyFixup = false;
}
function getEntityGroups(em, entityTypes) {
    var groupMap = em._entityGroupMap;
    if (entityTypes) {
        return core.toArray(entityTypes).map(function (et) {
            if (et instanceof EntityType) {
                return groupMap[et.name];
            }
            else {
                throw new Error("The EntityManager.getChanges() 'entityTypes' parameter must be either an entityType or an array of entityTypes or null");
            }
        });
    }
    else {
        return core.getOwnPropertyValues(groupMap);
    }
}
function checkEntityKey(em, entity) {
    var ek = entity.entityAspect.getKey();
    // return properties that are = to defaultValues
    var keyPropsWithDefaultValues = core.arrayZip(entity.entityType.keyProperties, ek.values, function (kp, kv) {
        return (kp.defaultValue === kv) ? kp : null;
    }).filter(function (kp) {
        return kp !== null;
    });
    if (keyPropsWithDefaultValues.length) {
        if (entity.entityType.autoGeneratedKeyType !== AutoGeneratedKeyType.None) {
            em.generateTempKeyValue(entity);
        }
        else {
            // we will allow attaches of entities where only part of the key is set.
            if (keyPropsWithDefaultValues.length === ek.values.length) {
                throw new Error("Cannot attach an object of type  (" + entity.entityType.name + ") to an EntityManager without first setting its key or setting its entityType 'AutoGeneratedKeyType' property to something other than 'None'");
            }
        }
    }
}
function validateEntityStates(em, entityStates) {
    if (!entityStates)
        return [];
    var entStates = core.toArray(entityStates);
    entStates.forEach(function (es) {
        if (!(es instanceof EntityState)) {
            throw new Error("The EntityManager.getChanges() 'entityStates' parameter must either be null, an entityState or an array of entityStates");
        }
    });
    return entStates;
}
function attachRelatedEntities(em, entity, entityState, mergeStrategy) {
    var navProps = entity.entityType.navigationProperties;
    navProps.forEach(function (np) {
        var related = entity.getProperty(np.name);
        if (np.isScalar) {
            if (!related)
                return;
            em.attachEntity(related, entityState, mergeStrategy);
        }
        else {
            related.forEach(function (e) {
                em.attachEntity(e, entityState, mergeStrategy);
            });
        }
    });
}
// returns a promise
function executeQueryCore(em, query, queryOptions, dataService) {
    try {
        var results_1;
        var metadataStore = em.metadataStore;
        if (metadataStore.isEmpty() && dataService.hasServerMetadata) {
            throw new Error("cannot execute _executeQueryCore until metadataStore is populated.");
        }
        if (queryOptions.fetchStrategy === FetchStrategy.FromLocalCache) {
            try {
                if (typeof query === 'string') {
                    throw new Error("cannot execute 'string' EntityQuery locally.");
                }
                var qr = executeQueryLocallyCore(em, query);
                return Promise.resolve({ results: qr.results, entityManager: em, inlineCount: qr.inlineCount, query: query });
            }
            catch (e) {
                return Promise.reject(e);
            }
        }
        var mappingContext_1 = new MappingContext({
            query: query,
            entityManager: em,
            dataService: dataService,
            mergeOptions: {
                mergeStrategy: queryOptions.mergeStrategy,
                noTracking: !!query.noTrackingEnabled,
                includeDeleted: queryOptions.includeDeleted
            }
        });
        var validateOnQuery_1 = em.validationOptions.validateOnQuery;
        return dataService.adapterInstance.executeQuery(mappingContext_1).then(function (data) {
            var result = core.wrapExecution(function () {
                var state = { isLoading: em.isLoading };
                em.isLoading = true;
                em._pendingPubs = [];
                return state;
            }, function (state) {
                // cleanup
                em.isLoading = state.isLoading;
                em._pendingPubs.forEach(function (fn) {
                    fn();
                });
                em._pendingPubs = undefined;
                em._hasChangesAction && em._hasChangesAction();
                // TODO: removed - not sure why needed in first place...
                // // HACK for GC
                // query = undefined;
                mappingContext_1 = undefined;
                // HACK: some errors thrown in next function do not propogate properly - this catches them.
                if (state.error) {
                    return Promise.reject(state.error);
                }
            }, function () {
                var nodes = dataService.jsonResultsAdapter.extractResults(data);
                nodes = core.toArray(nodes);
                results_1 = mappingContext_1.visitAndMerge(nodes, { nodeType: "root" });
                if (validateOnQuery_1) {
                    results_1.forEach(function (r) {
                        // anon types and simple types will not have an entityAspect.
                        r.entityAspect && r.entityAspect.validateEntity();
                    });
                }
                mappingContext_1.processDeferred();
                // if query has expand clauses walk each of the 'results' and mark the expanded props as loaded.
                if (query instanceof EntityQuery) {
                    markLoadedNavProps(results_1, query);
                }
                var retrievedEntities = core.objectMap(mappingContext_1.refMap);
                return { results: results_1, query: query, entityManager: em, httpResponse: data.httpResponse, inlineCount: data.inlineCount, retrievedEntities: retrievedEntities };
            });
            return Promise.resolve(result);
        }, function (e) {
            if (e) {
                e.query = query;
                e.entityManager = em;
            }
            return Promise.reject(e);
        });
    }
    catch (e) {
        if (e) {
            e.query = query;
        }
        return Promise.reject(e);
    }
}
function markLoadedNavProps(entities, query) {
    if (query.noTrackingEnabled)
        return;
    var expandClause = query.expandClause;
    if (expandClause == null)
        return;
    expandClause.propertyPaths.forEach(function (propertyPath) {
        var propNames = propertyPath.split('.');
        markLoadedNavPath(entities, propNames);
    });
}
function markLoadedNavPath(entities, propNames) {
    var propName = propNames[0];
    entities.forEach(function (entity) {
        var ea = entity.entityAspect;
        if (!ea)
            return; // entity may not be a 'real' entity in the case of a projection.
        ea._markAsLoaded(propName);
        if (propNames.length === 1)
            return;
        var next = entity.getProperty(propName);
        if (!next)
            return; // no children to process.
        // strange logic because nonscalar nav values are NOT really arrays
        // otherwise we could use Array.isArray
        if (!next.arrayChanged)
            next = [next];
        markLoadedNavPath(next, propNames.slice(1));
    });
}
function updateConcurrencyProperties(entities) {
    var candidates = entities.filter(function (e) {
        e.entityAspect.isBeingSaved = true;
        return e.entityAspect.entityState.isModified()
            && e.entityType.concurrencyProperties.length > 0;
    });
    if (candidates.length === 0)
        return;
    candidates.forEach(function (c) {
        c.entityType.concurrencyProperties.forEach(function (cp) {
            updateConcurrencyProperty(c, cp);
        });
    });
}
function updateConcurrencyProperty(entity, property) {
    // check if property has already been updated
    if (entity.entityAspect.originalValues[property.name])
        return;
    var value = entity.getProperty(property.name);
    var dataType = property.dataType;
    if (!value)
        value = dataType.defaultValue;
    if (dataType.isNumeric) {
        entity.setProperty(property.name, value + 1);
    }
    else if (dataType.getConcurrencyValue) {
        // DataType has its own implementation
        var nextValue = dataType.getConcurrencyValue(value);
        entity.setProperty(property.name, nextValue);
    }
    else if (dataType === DataType.Binary) {
        // best guess - that this is a timestamp column and is computed on the server during save
        // - so no need to set it here.
        return;
    }
    else {
        // this just leaves DataTypes of Boolean, String and Byte - none of which should be the
        // type for a concurrency column.
        // NOTE: thought about just returning here but would rather be safe for now.
        throw new Error("Unable to update the value of concurrency property before saving: " + property.name);
    }
}
function findOrCreateEntityGroup(em, entityType) {
    var group = em._entityGroupMap[entityType.name];
    if (!group) {
        group = new EntityGroup(em, entityType);
        em._entityGroupMap[entityType.name] = group;
    }
    return group;
}
function findOrCreateEntityGroups(em, entityType) {
    var entityTypes = entityType.getSelfAndSubtypes();
    return entityTypes.map(function (et) {
        return findOrCreateEntityGroup(em, et);
    });
}
function unwrapInstance(structObj, transformFn) {
    var rawObject = {};
    var stype = EntityAspect.isEntity(structObj) ? structObj.entityType : structObj.complexType;
    var serializerFn = getSerializerFn(stype);
    var unmapped = {};
    stype.dataProperties.forEach(function (dp) {
        if (dp.isComplexProperty) {
            rawObject[dp.nameOnServer] = core.map(structObj.getProperty(dp.name), function (co) {
                return unwrapInstance(co, transformFn);
            });
        }
        else {
            var val = structObj.getProperty(dp.name);
            val = transformFn ? transformFn(dp, val) : val;
            if (val === undefined)
                return;
            val = serializerFn ? serializerFn(dp, val) : val;
            if (val !== undefined) {
                if (dp.isUnmapped) {
                    unmapped[dp.nameOnServer] = core.toJSONSafe(val, core.toJSONSafeReplacer);
                }
                else {
                    rawObject[dp.nameOnServer] = val;
                }
            }
        }
    });
    if (!core.isEmpty(unmapped)) {
        // TODO: review this.
        rawObject.__unmapped = unmapped;
    }
    return rawObject;
}
function unwrapOriginalValues(target, metadataStore, transformFn) {
    var stype = EntityAspect.isEntity(target) ? target.entityType : target.complexType;
    var aspect = EntityAspect.isEntity(target) ? target.entityAspect : target.complexAspect;
    var fn = metadataStore.namingConvention.clientPropertyNameToServer;
    var result = {};
    core.objectForEach(aspect.originalValues, function (propName, val) {
        var prop = stype.getProperty(propName);
        val = transformFn ? transformFn(prop, val) : val;
        if (val !== undefined) {
            result[fn(propName, prop)] = val;
        }
    });
    stype.complexProperties.forEach(function (cp) {
        var nextTarget = target.getProperty(cp.name);
        if (cp.isScalar) {
            var unwrappedCo = unwrapOriginalValues(nextTarget, metadataStore, transformFn);
            if (!core.isEmpty(unwrappedCo)) {
                result[fn(cp.name, cp)] = unwrappedCo;
            }
        }
        else {
            var unwrappedCos = nextTarget.map(function (item) {
                return unwrapOriginalValues(item, metadataStore, transformFn);
            });
            result[fn(cp.name, cp)] = unwrappedCos;
        }
    });
    return result;
}
function unwrapChangedValues(entity, metadataStore, transformFn) {
    var stype = entity.entityType;
    var serializerFn = getSerializerFn(stype);
    var fn = metadataStore.namingConvention.clientPropertyNameToServer;
    var result = {};
    core.objectForEach(entity.entityAspect.originalValues, function (propName, value) {
        var prop = stype.getProperty(propName);
        var val = entity.getProperty(propName);
        val = transformFn ? transformFn(prop, val) : val;
        if (val === undefined)
            return;
        val = serializerFn ? serializerFn(prop, val) : val;
        if (val !== undefined) {
            result[fn(propName, prop)] = val;
        }
    });
    // any change to any complex object or array of complex objects returns the ENTIRE
    // current complex object or complex object array.  This is by design. Complex Objects
    // are atomic.
    stype.complexProperties.forEach(function (cp) {
        if (cpHasOriginalValues(entity, cp)) {
            var coOrCos = entity.getProperty(cp.name);
            result[fn(cp.name, cp)] = core.map(coOrCos, function (co) {
                return unwrapInstance(co, transformFn);
            });
        }
    });
    return result;
}
function cpHasOriginalValues(structuralObject, cp) {
    var coOrCos = structuralObject.getProperty(cp.name);
    if (cp.isScalar) {
        return coHasOriginalValues(coOrCos);
    }
    else {
        // this occurs when a nonscalar co array has had cos added or removed.
        if (coOrCos._origValues)
            return true;
        return coOrCos.some(function (co) {
            return coHasOriginalValues(co);
        });
    }
}
function executeQueryLocallyCore(em, query) {
    assertParam(query, "query").isInstanceOf(EntityQuery).check();
    var metadataStore = em.metadataStore;
    var entityType = query._getFromEntityType(metadataStore, true);
    // there may be multiple groups is this is a base entity type.
    var groups = findOrCreateEntityGroups(em, entityType);
    // filter then order then skip then take
    var filterFunc = query.wherePredicate && query.wherePredicate.toFunction({ entityType: entityType });
    var queryOptions = QueryOptions.resolve([query.queryOptions, em.queryOptions, QueryOptions.defaultInstance]);
    var includeDeleted = queryOptions.includeDeleted === true;
    var newFilterFunc = function (entity) {
        return entity && (includeDeleted || !entity.entityAspect.entityState.isDeleted()) && (filterFunc ? filterFunc(entity) : true);
    };
    var result = [];
    // TODO: mapMany
    groups.forEach(function (group) {
        var entities = group._entities.filter(newFilterFunc);
        if (entities.length) {
            result = result.length ? result.concat(entities) : entities;
        }
    });
    var orderByComparer = query.orderByClause && query.orderByClause.getComparer(entityType);
    if (orderByComparer) {
        result.sort(orderByComparer);
    }
    var inlineCount = query.inlineCountEnabled ? result.length : undefined;
    var skipCount = query.skipCount;
    if (skipCount) {
        result = result.slice(skipCount);
    }
    var takeCount = query.takeCount;
    if (takeCount) {
        result = result.slice(0, takeCount);
    }
    var selectClause = query.selectClause;
    if (selectClause) {
        var selectFn = selectClause.toFunction();
        result = result.map(selectFn);
    }
    return { results: result, inlineCount: inlineCount };
}
function coHasOriginalValues(co) {
    // next line checks all non complex properties of the co.
    if (!core.isEmpty(co.complexAspect.originalValues))
        return true;
    // now need to recursively check each of the cps
    return co.complexType.complexProperties.some(function (cp) {
        return cpHasOriginalValues(co, cp);
    });
}
function getSerializerFn(stype) {
    return stype.serializerFn || (stype.metadataStore && stype.metadataStore.serializerFn);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXR5LW1hbmFnZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9icmVlemUtY2xpZW50LyIsInNvdXJjZXMiOlsic3JjL2VudGl0eS1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxJQUFJLEVBQTJCLE1BQU0sUUFBUSxDQUFDO0FBQ3ZELE9BQU8sRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0QsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUNsQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxZQUFZLEVBQXFFLE1BQU0saUJBQWlCLENBQUM7QUFDbEgsT0FBTyxFQUFFLGFBQWEsRUFBRSxVQUFVLEVBQWUsWUFBWSxFQUFzQixvQkFBb0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ25JLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDekMsT0FBTyxFQUFFLFlBQVksRUFBRyxNQUFNLGlCQUFpQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUN2QyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzdFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUFFLFdBQVcsRUFB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RSxXQUFXLEVBQUUsV0FBVyxFQUFFLENBQUM7QUFDdkQsQ0FBQztBQUVELFNBQVMsbUJBQW1CLENBQUMsRUFBaUI7SUFDNUMseURBQXlEO0lBQ3pELElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDO1FBQUUsT0FBTyxJQUFJLENBQUM7SUFDaEUsZ0RBQWdEO0lBQ2hELE9BQU8sRUFBRSxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO1FBQ3ZELE9BQU8sbUJBQW1CLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3JDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQVMsZUFBZSxDQUFDLEtBQStCO0lBQ3RELE9BQU8sS0FBSyxDQUFDLFlBQVksSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLElBQUksS0FBSyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN6RixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0YVNlcnZpY2VBZGFwdGVyIH0gZnJvbSAnLi9pbnRlcmZhY2UtcmVnaXN0cnknO1xyXG5pbXBvcnQgeyBjb3JlLCBDYWxsYmFjaywgRXJyb3JDYWxsYmFjayB9IGZyb20gJy4vY29yZSc7XHJcbmltcG9ydCB7IGFzc2VydFBhcmFtLCBhc3NlcnRDb25maWcgfSBmcm9tICcuL2Fzc2VydC1wYXJhbSc7XHJcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgQnJlZXplRXZlbnQgfSBmcm9tICcuL2V2ZW50JztcclxuaW1wb3J0IHsgRW50aXR5QXNwZWN0LCBFbnRpdHksIENvbXBsZXhPYmplY3QsIFN0cnVjdHVyYWxPYmplY3QsIFByb3BlcnR5Q2hhbmdlZEV2ZW50QXJncyB9IGZyb20gJy4vZW50aXR5LWFzcGVjdCc7XHJcbmltcG9ydCB7IE1ldGFkYXRhU3RvcmUsIEVudGl0eVR5cGUsIENvbXBsZXhUeXBlLCBEYXRhUHJvcGVydHksIE5hdmlnYXRpb25Qcm9wZXJ0eSwgQXV0b0dlbmVyYXRlZEtleVR5cGUgfSBmcm9tICcuL2VudGl0eS1tZXRhZGF0YSc7XHJcbmltcG9ydCB7IEVudGl0eUtleSB9IGZyb20gJy4vZW50aXR5LWtleSc7XHJcbmltcG9ydCB7IEVudGl0eUFjdGlvbiAgfSBmcm9tICcuL2VudGl0eS1hY3Rpb24nO1xyXG5pbXBvcnQgeyBFbnRpdHlTdGF0ZSB9IGZyb20gJy4vZW50aXR5LXN0YXRlJztcclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuL2RhdGEtc2VydmljZSc7XHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi9kYXRhLXR5cGUnO1xyXG5pbXBvcnQgeyBWYWxpZGF0aW9uRXJyb3IgfSBmcm9tICcuL3ZhbGlkYXRlJztcclxuaW1wb3J0IHsgVmFsaWRhdGlvbk9wdGlvbnMgfSBmcm9tICcuL3ZhbGlkYXRpb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IFF1ZXJ5T3B0aW9ucywgTWVyZ2VTdHJhdGVneSwgRmV0Y2hTdHJhdGVneSB9IGZyb20gJy4vcXVlcnktb3B0aW9ucyc7XHJcbmltcG9ydCB7IFNhdmVPcHRpb25zIH0gZnJvbSAnLi9zYXZlLW9wdGlvbnMnO1xyXG5pbXBvcnQgeyBLZXlHZW5lcmF0b3IgfSBmcm9tICcuL2tleS1nZW5lcmF0b3InO1xyXG5pbXBvcnQgeyBFbnRpdHlHcm91cCB9IGZyb20gJy4vZW50aXR5LWdyb3VwJztcclxuaW1wb3J0IHsgTWFwcGluZ0NvbnRleHQgfSBmcm9tICcuL21hcHBpbmctY29udGV4dCc7XHJcbmltcG9ydCB7IEVudGl0eVF1ZXJ5IH0gZnJvbSAnLi9lbnRpdHktcXVlcnknO1xyXG5pbXBvcnQgeyBVbmF0dGFjaGVkQ2hpbGRyZW5NYXAgfSBmcm9tICcuL3VuYXR0YWNoZWQtY2hpbGRyZW4tbWFwJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSHR0cFJlc3BvbnNlIHtcclxuICBjb25maWc6IGFueTtcclxuICBkYXRhOiBhbnk7XHJcbiAgZXJyb3I/OiBhbnk7XHJcbiAgc2F2ZUNvbnRleHQ/OiBhbnk7XHJcbiAgc3RhdHVzOiBudW1iZXI7XHJcbiAgZ2V0SGVhZGVycyhoZWFkZXJOYW1lOiBzdHJpbmcpOiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0UmVzdWx0IHtcclxuICBlbnRpdGllczogRW50aXR5W107XHJcbiAgdGVtcEtleU1hcHBpbmc6IElUZW1wS2V5TWFwO1xyXG59XHJcblxyXG4vLyBzdWJjbGFzc2VzIG9mIEVycm9yXHJcblxyXG4vKiogQmFzZSBzaGFwZSBvZiBhbnkgZXJyb3JzIHJldHVybmVkIGZyb20gdGhlIHNlcnZlci4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTZXJ2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICBodHRwUmVzcG9uc2U6IEh0dHBSZXNwb25zZTtcclxuICBzdGF0dXM6IG51bWJlcjtcclxuICBtZXNzYWdlOiBzdHJpbmc7XHJcbiAgc3RhdHVzVGV4dD86IHN0cmluZztcclxuICBib2R5PzogYW55O1xyXG4gIHVybD86IHN0cmluZztcclxufVxyXG5cclxuLyoqIFNoYXBlIG9mIGEgc2F2ZSBlcnJvciByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIuIFxyXG5Gb3IgdXNlIGJ5IGJyZWV6ZSBwbHVnaW4gYXV0aG9ycyBvbmx5LiBUaGUgY2xhc3MgaXMgZm9yIHVzZSBpbiBidWlsZGluZyBhIFtbSURhdGFTZXJ2aWNlQWRhcHRlcl1dIGltcGxlbWVudGF0aW9uLiBcclxuQGFkYXB0ZXIgKHNlZSBbW0lEYXRhU2VydmljZUFkYXB0ZXJdXSkgICAgXHJcbkBoaWRkZW4gQGludGVybmFsIFxyXG4qL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNhdmVFcnJvckZyb21TZXJ2ZXIgZXh0ZW5kcyBTZXJ2ZXJFcnJvciB7XHJcbiAgZW50aXR5RXJyb3JzOiBFbnRpdHlFcnJvckZyb21TZXJ2ZXJbXTtcclxufVxyXG5cclxuLyoqIFNoYXBlIG9mIGEgc2F2ZSBlcnJvciB3aGVuIHJldHVybmVkIHRvIHRoZSBjbGllbnQuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2F2ZUVycm9yIGV4dGVuZHMgU2VydmVyRXJyb3Ige1xyXG4gIGVudGl0eUVycm9yczogRW50aXR5RXJyb3JbXTtcclxufVxyXG5cclxuLy8gbm90IHN1YmNsYXNzZXMgb2YgRXJyb3JcclxuLyoqIFxyXG5Gb3IgdXNlIGJ5IGJyZWV6ZSBwbHVnaW4gYXV0aG9ycyBvbmx5LiBUaGUgY2xhc3MgaXMgZm9yIHVzZSBpbiBidWlsZGluZyBhIFtbSURhdGFTZXJ2aWNlQWRhcHRlcl1dIGltcGxlbWVudGF0aW9uLiBcclxuQGFkYXB0ZXIgKHNlZSBbW0lEYXRhU2VydmljZUFkYXB0ZXJdXSkgICAgXHJcbkBoaWRkZW4gQGludGVybmFsIFxyXG4qL1xyXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eUVycm9yRnJvbVNlcnZlciB7XHJcbiAgZW50aXR5VHlwZU5hbWU6IHN0cmluZztcclxuICBrZXlWYWx1ZXM6IGFueVtdO1xyXG5cclxuICBlcnJvck5hbWU6IHN0cmluZztcclxuICBlcnJvck1lc3NhZ2U6IHN0cmluZztcclxuICBwcm9wZXJ0eU5hbWU6IHN0cmluZztcclxufVxyXG5cclxuLyoqIFNoYXBlIG9mIGFuIGVycm9yIG9uIGEgc3BlY2lmaWMgZW50aXR5LiAgUGFydCBvZiBhIFtbSVNhdmVFcnJvcl1dICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRW50aXR5RXJyb3Ige1xyXG4gIGVudGl0eTogRW50aXR5O1xyXG4gIGVycm9yTmFtZTogc3RyaW5nO1xyXG4gIGVycm9yTWVzc2FnZTogc3RyaW5nO1xyXG4gIHByb3BlcnR5TmFtZTogc3RyaW5nO1xyXG4gIGlzU2VydmVyRXJyb3I6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKiBUaGUgc2hhcGUgb2YgdGhlIFByb21pc2UgcmV0dXJuZWQgYnkgYW4gW1tFbnRpdHlNYW5hZ2VyLmV4ZWN1dGVRdWVyeV1dIGNhbGwuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlSZXN1bHQge1xyXG4gIC8qKiBUb3AgbGV2ZWwgZW50aXRpZXMgcmV0dXJuZWQgKi9cclxuICByZXN1bHRzOiBhbnlbXTtcclxuICAvKiogUXVlcnkgdGhhdCB3YXMgZXhlY3V0ZWQgKi9cclxuICBxdWVyeTogRW50aXR5UXVlcnkgfCBzdHJpbmc7XHJcbiAgLyoqIEVudGl0eU1hbmFnZXIgdGhhdCBleGVjdXRlZCB0aGUgcXVlcnkgKi9cclxuICBlbnRpdHlNYW5hZ2VyPzogRW50aXR5TWFuYWdlcjtcclxuICAvKiogVG90YWwgbnVtYmVyIG9mIHJlc3VsdHMgYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXIgKi9cclxuICBpbmxpbmVDb3VudD86IG51bWJlcjtcclxuICAvKiogQWxsIGVudGl0aWVzIHJldHVybmVkIGJ5IHRoZSBxdWVyeS4gIERpZmZlcnMgZnJvbSByZXN1bHRzIHdoZW4gYW4gZXhwYW5kIGlzIHVzZWQuICovXHJcbiAgcmV0cmlldmVkRW50aXRpZXM/OiBFbnRpdHlbXTtcclxuICAgIC8qKiBSYXcgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyICovXHJcbiAgaHR0cFJlc3BvbnNlPzogSHR0cFJlc3BvbnNlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5U3VjY2Vzc0NhbGxiYWNrIHtcclxuICAoZGF0YTogUXVlcnlSZXN1bHQpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5RXJyb3JDYWxsYmFjayB7XHJcbiAgKGVycm9yOiB7IHF1ZXJ5OiBFbnRpdHlRdWVyeTsgaHR0cFJlc3BvbnNlOiBIdHRwUmVzcG9uc2U7IGVudGl0eU1hbmFnZXI6IEVudGl0eU1hbmFnZXI7IG1lc3NhZ2U/OiBzdHJpbmc7IHN0YWNrPzogc3RyaW5nIH0pOiB2b2lkO1xyXG59XHJcblxyXG4vKiogS2V5IG1hcHBpbmcgaW5mb3JtYXRpb24gcmV0dXJuZWQgYXMgcGFydCBvZiBhbiBbW0lTYXZlUmVzdWx0XV0uICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgS2V5TWFwcGluZyB7XHJcbiAgZW50aXR5VHlwZU5hbWU6IHN0cmluZztcclxuICB0ZW1wVmFsdWU6IGFueTtcclxuICByZWFsVmFsdWU6IGFueTtcclxufVxyXG5cclxuaW50ZXJmYWNlIElUZW1wS2V5TWFwIHtcclxuICBbaW5kZXg6IHN0cmluZ106IEVudGl0eUtleTtcclxufVxyXG5cclxuLyoqIENvbmZpZ3VyYXRpb24gaW5mbyB0byBiZSBwYXNzZWQgdG8gdGhlIFtbRW50aXR5TWFuYWdlci5pbXBvcnRFbnRpdGllc11dIG1ldGhvZCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEltcG9ydENvbmZpZyB7XHJcbiAgLyoqIElmIHRydWUsIG1lcmdlIEFkZGVkIGVudGl0aWVzICh3aXRoIHRlbXAga2V5cykgYXMgd2VsbC4gIFRoaXMgY2FuIGJlIGRhbmdlcm91cy4gKi9cclxuICBtZXJnZUFkZHM/OiBib29sZWFuO1xyXG4gIG1lcmdlU3RyYXRlZ3k/OiBNZXJnZVN0cmF0ZWd5OyAgXHJcbiAgbWV0YWRhdGFWZXJzaW9uRm4/OiAoYXJnOiB7IG1ldGFkYXRhVmVyc2lvbjogYW55LCBtZXRhZGF0YVN0b3JlTmFtZTogYW55IH0pID0+IHZvaWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBJbXBvcnRDb25maWdFeHQgZXh0ZW5kcyBJbXBvcnRDb25maWcge1xyXG4gIHRlbXBLZXlNYXA/OiBJVGVtcEtleU1hcDtcclxufVxyXG5cclxuLyoqIFRoZSBzaGFwZSBvZiB0aGUgUHJvbWlzZSByZXR1cm5lZCBieSBhbiBbW0VudGl0eU1hbmFnZXIuc2F2ZUNoYW5nZXNdXSBjYWxsLiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNhdmVSZXN1bHQge1xyXG4gIGVudGl0aWVzOiBFbnRpdHlbXTtcclxuICBrZXlNYXBwaW5nczogS2V5TWFwcGluZ1tdO1xyXG4gIGRlbGV0ZWRLZXlzPzogeyBlbnRpdHlUeXBlTmFtZTogc3RyaW5nLCBrZXlWYWx1ZXM6IGFueVtdfVtdO1xyXG4gIGh0dHBSZXNwb25zZT86IEh0dHBSZXNwb25zZTtcclxufVxyXG5cclxuLyoqIEZvciB1c2UgYnkgYnJlZXplIHBsdWdpbiBhdXRob3JzIG9ubHkuIFRoZSBjbGFzcyBpcyBmb3IgdXNlIGluIGJ1aWxkaW5nIGEgW1tJRGF0YVNlcnZpY2VBZGFwdGVyXV0gaW1wbGVtZW50YXRpb24uIFxyXG5AYWRhcHRlciAoc2VlIFtbSURhdGFTZXJ2aWNlQWRhcHRlcl1dKSAgICBcclxuQGhpZGRlbiBcclxuKi9cclxuZXhwb3J0IGludGVyZmFjZSBTYXZlQ29udGV4dCB7XHJcbiAgZW50aXR5TWFuYWdlcjogRW50aXR5TWFuYWdlcjtcclxuICBkYXRhU2VydmljZTogRGF0YVNlcnZpY2U7XHJcbiAgcHJvY2Vzc1NhdmVkRW50aXRpZXM6IChzYXZlUmVzdWx0OiBTYXZlUmVzdWx0KSA9PiBFbnRpdHlbXTtcclxuICByZXNvdXJjZU5hbWU6IHN0cmluZztcclxuICBhZGFwdGVyPzogRGF0YVNlcnZpY2VBZGFwdGVyO1xyXG4gIHJvdXRlUHJlZml4Pzogc3RyaW5nO1xyXG59XHJcblxyXG4vKiogRm9yIHVzZSBieSBicmVlemUgcGx1Z2luIGF1dGhvcnMgb25seS4gVGhlIGNsYXNzIGlzIGZvciB1c2UgaW4gYnVpbGRpbmcgYSBbW0lEYXRhU2VydmljZUFkYXB0ZXJdXSBpbXBsZW1lbnRhdGlvbi4gXHJcbkBhZGFwdGVyIChzZWUgW1tJRGF0YVNlcnZpY2VBZGFwdGVyXV0pICAgIFxyXG5AaGlkZGVuIFxyXG4qL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNhdmVCdW5kbGUge1xyXG4gIGVudGl0aWVzOiBFbnRpdHlbXTtcclxuICBzYXZlT3B0aW9uczogU2F2ZU9wdGlvbnM7XHJcbn1cclxuXHJcbi8qKiBDb25maWd1cmF0aW9uIGluZm8gdG8gYmUgcGFzc2VkIHRvIHRoZSBbW0VudGl0eU1hbmFnZXJdXSBjb25zdHJ1Y3RvciAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eU1hbmFnZXJDb25maWcge1xyXG4gIC8qKiBUaGUgc2VydmljZSBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eU1hbmFnZXIuICAqKi9cclxuICBzZXJ2aWNlTmFtZT86IHN0cmluZztcclxuICAvKiogVGhlIERhdGFTZXJ2aWNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eU1hbmFnZXIuICoqL1xyXG4gIGRhdGFTZXJ2aWNlPzogRGF0YVNlcnZpY2U7XHJcbiAgLyoqIFRoZSBbW1F1ZXJ5T3B0aW9uc11dIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eU1hbmFnZXIuICAqKi9cclxuICBxdWVyeU9wdGlvbnM/OiBRdWVyeU9wdGlvbnM7XHJcbiAgLyoqIFRoZSBbW1NhdmVPcHRpb25zXV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5TWFuYWdlci4gKiovXHJcbiAgc2F2ZU9wdGlvbnM/OiBTYXZlT3B0aW9ucztcclxuICAvKiogVGhlIFtbVmFsaWRhdGlvbk9wdGlvbnNdXSBhc3NvY2lhdGVkIHdpdGggdGhpcyBFbnRpdHlNYW5hZ2VyLiAgKiovXHJcbiAgdmFsaWRhdGlvbk9wdGlvbnM/OiBWYWxpZGF0aW9uT3B0aW9ucztcclxuICAvKiogVGhlIFtbS2V5R2VuZXJhdG9yXV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5TWFuYWdlci4gKiovXHJcbiAga2V5R2VuZXJhdG9yPzogS2V5R2VuZXJhdG9yO1xyXG4gIC8qKiBUaGUgW1tLZXlHZW5lcmF0b3JdXSBjb25zdHJ1Y3RvciBhc3NvY2lhdGVkIHdpdGggdGhpcyBFbnRpdHlNYW5hZ2VyLiAqKi9cclxuICBrZXlHZW5lcmF0b3JDdG9yPzogeyBuZXcgKCk6IEtleUdlbmVyYXRvciB9OyAvLyBUT0RPOiByZXZpZXcgdGhpc1xyXG4gIC8qKiBUaGUgW1tNZXRhZGF0YVN0b3JlXV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5TWFuYWdlci4gKiovXHJcbiAgbWV0YWRhdGFTdG9yZT86IE1ldGFkYXRhU3RvcmU7XHJcbn1cclxuXHJcbi8qKiBUaGUgc2hhcGUgcmV0dXJuZWQgYnkgY2FsbGJhY2tzIHJlZ2lzdGVyZWQgd2l0aCBbW0VudGl0eU1hbmFnZXIuZW50aXR5Q2hhbmdlZF1dIGV2ZW50ICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRW50aXR5Q2hhbmdlZEV2ZW50QXJncyB7XHJcbiAgZW50aXR5QWN0aW9uOiBFbnRpdHlBY3Rpb247XHJcbiAgZW50aXR5PzogRW50aXR5O1xyXG4gIGFyZ3M/OiBQcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3M7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvbkVycm9yc0NoYW5nZWRFdmVudEFyZ3Mge1xyXG4gIGVudGl0eTogRW50aXR5OyBcclxuICBhZGRlZDogVmFsaWRhdGlvbkVycm9yW107IFxyXG4gIHJlbW92ZWQ6IFZhbGlkYXRpb25FcnJvcltdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEhhc0NoYW5nZXNDaGFuZ2VkRXZlbnRBcmdzIHtcclxuICBlbnRpdHlNYW5hZ2VyOiBFbnRpdHlNYW5hZ2VyOyBcclxuICBoYXNDaGFuZ2VzOiBib29sZWFuO1xyXG59XHJcblxyXG4vKipcclxuSW5zdGFuY2VzIG9mIHRoZSBFbnRpdHlNYW5hZ2VyIGNvbnRhaW4gYW5kIG1hbmFnZSBjb2xsZWN0aW9ucyBvZiBlbnRpdGllcywgZWl0aGVyIHJldHJpZXZlZCBmcm9tIGEgYmFja2VuZCBkYXRhc3RvcmUgb3IgY3JlYXRlZCBvbiB0aGUgY2xpZW50LlxyXG4qKi9cclxuZXhwb3J0IGNsYXNzIEVudGl0eU1hbmFnZXIge1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF8kdHlwZU5hbWU6IHN0cmluZzsgLy8gYWN0dWFsbHkgZGVmaW5lZCBvbiBwcm90b3R5cGVcclxuXHJcbiAgLyoqIFRoZSBzZXJ2aWNlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5TWFuYWdlci4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBzZXJ2aWNlTmFtZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgRGF0YVNlcnZpY2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5TWFuYWdlci4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBkYXRhU2VydmljZTogRGF0YVNlcnZpY2U7XHJcbiAgLyoqIFRoZSBbW1F1ZXJ5T3B0aW9uc11dIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eU1hbmFnZXIuIF9fUmVhZCBPbmx5X18gKiovXHJcbiAgcXVlcnlPcHRpb25zOiBRdWVyeU9wdGlvbnM7XHJcbiAgLyoqIFRoZSBbW1NhdmVPcHRpb25zXV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5TWFuYWdlci4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBzYXZlT3B0aW9uczogU2F2ZU9wdGlvbnM7XHJcbiAgLyoqIFRoZSBbW1ZhbGlkYXRpb25PcHRpb25zXV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5TWFuYWdlci4gX19SZWFkIE9ubHlfXyAqKi9cclxuICB2YWxpZGF0aW9uT3B0aW9uczogVmFsaWRhdGlvbk9wdGlvbnM7XHJcbiAgLyoqIFRoZSBbW0tleUdlbmVyYXRvcl1dIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eU1hbmFnZXIuIF9fUmVhZCBPbmx5X18gKiovXHJcbiAga2V5R2VuZXJhdG9yOiBLZXlHZW5lcmF0b3I7XHJcbiAgLyoqIFRoZSBbW0tleUdlbmVyYXRvcl1dIGNvbnN0cnVjdG9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eU1hbmFnZXIuIF9fUmVhZCBPbmx5X18gKiovXHJcbiAga2V5R2VuZXJhdG9yQ3RvcjogeyBuZXcgKCk6IEtleUdlbmVyYXRvciB9OyAvLyBUT0RPOiByZXZpZXcgdGhpc1xyXG4gIC8qKiBUaGUgW1tNZXRhZGF0YVN0b3JlXV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5TWFuYWdlci4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBtZXRhZGF0YVN0b3JlOiBNZXRhZGF0YVN0b3JlO1xyXG4gIGlzTG9hZGluZzogYm9vbGVhbjtcclxuICBpc1JlamVjdGluZ0NoYW5nZXM6IGJvb2xlYW47XHJcblxyXG4gIC8vIGV2ZW50c1xyXG4gIC8qKlxyXG4gIEEgW1tCcmVlemVFdmVudF1dIHRoYXQgZmlyZXMgd2hlbmV2ZXIgYSBjaGFuZ2UgdG8gYW55IGVudGl0eSBpbiB0aGlzIEVudGl0eU1hbmFnZXIgb2NjdXJzLiBfX1JlYWQgT25seV9fXHJcblxyXG4gIEBldmVudEFyZ3MgLSBcclxuICAtIGVudGl0eUFjdGlvbiAtIFRoZSBbW0VudGl0eUFjdGlvbl1dIHRoYXQgb2NjdXJlZC5cclxuICAtIGVudGl0eSAtIFRoZSBlbnRpdHkgdGhhdCBjaGFuZ2VkLiAgSWYgdGhpcyBpcyBudWxsLCB0aGVuIGFsbCBlbnRpdGllcyBpbiB0aGUgZW50aXR5TWFuYWdlciB3ZXJlIGFmZmVjdGVkLlxyXG4gIC0gYXJncyAtIEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBldmVudC4gVGhpcyB3aWxsIGRpZmZlciBiYXNlZCBvbiB0aGUgZW50aXR5QWN0aW9uLlxyXG5cclxuICA+ICAgICAgbGV0IGVtID0gbmV3IEVudGl0eU1hbmFnZXIoIHtzZXJ2aWNlTmFtZTogXCJicmVlemUvTm9ydGh3aW5kSUJNb2RlbFwiIH0pO1xyXG4gID4gICAgICBlbS5lbnRpdHlDaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbihjaGFuZ2VBcmdzKSB7XHJcbiAgPiAgICAgICAgICAvLyBUaGlzIGNvZGUgd2lsbCBiZSBleGVjdXRlZCBhbnkgdGltZSBhbnkgZW50aXR5IHdpdGhpbiB0aGUgZW50aXR5TWFuYWdlciBcclxuICA+ICAgICAgICAgIC8vIGlzIGFkZGVkLCBtb2RpZmllZCwgZGVsZXRlZCBvciBkZXRhY2hlZCBmb3IgYW55IHJlYXNvbi5cclxuICA+ICAgICAgICAgIGxldCBhY3Rpb24gPSBjaGFuZ2VBcmdzLmVudGl0eUFjdGlvbjtcclxuICA+ICAgICAgICAgIGxldCBlbnRpdHkgPSBjaGFuZ2VBcmdzLmVudGl0eTtcclxuICA+ICAgICAgICAgIC8vIC4uIGRvIHNvbWV0aGluZyB0byB0aGlzIGVudGl0eSB3aGVuIGl0IGlzIGNoYW5nZWQuXHJcbiAgPiAgICAgIH0pO1xyXG4gID4gIH0pO1xyXG4gIEBldmVudFxyXG4gICoqL1xyXG4gIGVudGl0eUNoYW5nZWQ6IEJyZWV6ZUV2ZW50PEVudGl0eUNoYW5nZWRFdmVudEFyZ3M+O1xyXG5cclxuICAvKipcclxuICBBbiBbW0JyZWV6ZUV2ZW50XV0gdGhhdCBmaXJlcyB3aGVuZXZlciB2YWxpZGF0aW9uRXJyb3JzIGNoYW5nZSBmb3IgYW55IGVudGl0eSBpbiB0aGlzIEVudGl0eU1hbmFnZXIuIF9fUmVhZCBPbmx5X19cclxuICBAZXZlbnRBcmdzIC1cclxuICAgIC0gZW50aXR5IC0gVGhlIGVudGl0eSBvbiB3aGljaCB0aGUgdmFsaWRhdGlvbiBlcnJvcnMgaGF2ZSBiZWVuIGFkZGVkIG9yIHJlbW92ZWQuXHJcbiAgICAtIGFkZGVkIC0gQW4gYXJyYXkgY29udGFpbmluZyBhbnkgbmV3bHkgYWRkZWQgW1tWYWxpZGF0aW9uRXJyb3JdXXNcclxuICAgIC0gcmVtb3ZlZCAtIEFuIGFycmF5IGNvbnRhaW5pbmcgYW55IG5ld2x5IHJlbW92ZWQgW1tWYWxpZGF0aW9uRXJyb3JdXXMuIFRoaXMgaXMgdGhvc2UgZXJyb3JzIHRoYXQgaGF2ZSBiZWVuICdmaXhlZCcgIFxyXG5cclxuICA+ICAgICAgbGV0IGVtID0gbmV3IEVudGl0eU1hbmFnZXIoIHtzZXJ2aWNlTmFtZTogXCJicmVlemUvTm9ydGh3aW5kSUJNb2RlbFwiIH0pO1xyXG4gID4gICAgICBlbS52YWxpZGF0aW9uRXJyb3JzQ2hhbmdlZC5zdWJzY3JpYmUoZnVuY3Rpb24oY2hhbmdlQXJncykge1xyXG4gID4gICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3aWxsIGJlIGV4ZWN1dGVkIGFueSB0aW1lIGFueSBlbnRpdHkgd2l0aGluIHRoZSBlbnRpdHlNYW5hZ2VyIGV4cGVyaWVuY2VzIGEgY2hhbmdlIHRvIGl0cyB2YWxpZGF0aW9uRXJyb3JzIGNvbGxlY3Rpb24uXHJcbiAgPiAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbGlkYXRpb25DaGFuZ2VBcmdzKSB7XHJcbiAgPiAgICAgICAgICAgICAgICAgIGxldCBlbnRpdHkgPT0gdmFsaWRhdGlvbkNoYW5nZUFyZ3MuZW50aXR5O1xyXG4gID4gICAgICAgICAgICAgICAgICBsZXQgZXJyb3JzQWRkZWQgPSB2YWxpZGF0aW9uQ2hhbmdlQXJncy5hZGRlZDtcclxuICA+ICAgICAgICAgICAgICAgICAgbGV0IGVycm9yc0NsZWFyZWQgPSB2YWxpZGF0aW9uQ2hhbmdlQXJncy5yZW1vdmVkO1xyXG4gID4gICAgICAgICAgICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nIGludGVyZXN0aW5nIHdpdGggdGhlIG9yZGVyLlxyXG4gID4gICAgICAgICAgICAgIH0pO1xyXG4gID4gICAgICAgICAgfSk7XHJcbiAgPiAgICAgIH0pO1xyXG4gIEBldmVudFxyXG4gICoqL1xyXG4gIHZhbGlkYXRpb25FcnJvcnNDaGFuZ2VkOiBCcmVlemVFdmVudDxWYWxpZGF0aW9uRXJyb3JzQ2hhbmdlZEV2ZW50QXJncz47XHJcblxyXG4gIC8qKlxyXG4gIEEgW1tCcmVlemVFdmVudF1dIHRoYXQgZmlyZXMgd2hlbmV2ZXIgYW4gRW50aXR5TWFuYWdlciB0cmFuc2l0aW9ucyB0byBvciBmcm9tIGhhdmluZyBjaGFuZ2VzLiBfX1JlYWQgT25seV9fXHJcbiAgQGV2ZW50QXJncyAtXHJcbiAgICAtIGVudGl0eU1hbmFnZXIgLSBUaGUgRW50aXR5TWFuYWdlciB3aG9zZSAnaGFzQ2hhbmdlcycgc3RhdHVzIGhhcyBjaGFuZ2VkLlxyXG4gICAgLSBoYXNDaGFuZ2VzIC0gV2hldGhlciBvciBub3QgdGhpcyBFbnRpdHlNYW5hZ2VyIGhhcyBjaGFuZ2VzLlxyXG5cclxuICA+ICAgICAgbGV0IGVtID0gbmV3IEVudGl0eU1hbmFnZXIoIHtzZXJ2aWNlTmFtZTogXCJicmVlemUvTm9ydGh3aW5kSUJNb2RlbFwiIH0pO1xyXG4gID4gICAgICBlbS5oYXNDaGFuZ2VzQ2hhbmdlZC5zdWJzY3JpYmUoZnVuY3Rpb24oYXJncykge1xyXG4gID4gICAgICAgICAgICAgIGxldCBoYXNDaGFuZ2VzQ2hhbmdlZCA9IGFyZ3MuaGFzQ2hhbmdlcztcclxuICA+ICAgICAgICAgICAgICBsZXQgZW50aXR5TWFuYWdlciA9IGFyZ3MuZW50aXR5TWFuYWdlcjtcclxuICA+ICAgICAgICAgIH0pO1xyXG4gID4gICAgICB9KTtcclxuICBAZXZlbnQgXHJcbiAgKiovXHJcbiAgaGFzQ2hhbmdlc0NoYW5nZWQ6IEJyZWV6ZUV2ZW50PEhhc0NoYW5nZXNDaGFuZ2VkRXZlbnRBcmdzPjtcclxuXHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9wZW5kaW5nUHVicz86IGFueVtdOyAvLyBUT0RPOiByZWZpbmUgbGF0ZXJcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfaGFzQ2hhbmdlc0FjdGlvbj86ICgoKSA9PiBib29sZWFuKTsgLy8gVE9ETyByZWZpbmUgbGF0ZXJcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfaGFzQ2hhbmdlczogYm9vbGVhbjtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfZW50aXR5R3JvdXBNYXA6IHsgW2luZGV4OiBzdHJpbmddOiBFbnRpdHlHcm91cCB9O1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF91bmF0dGFjaGVkQ2hpbGRyZW5NYXA6IFVuYXR0YWNoZWRDaGlsZHJlbk1hcDtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfaW5LZXlGaXh1cDogYm9vbGVhbjtcclxuXHJcbiAgaGVscGVyID0ge1xyXG4gICAgdW53cmFwSW5zdGFuY2U6IHVud3JhcEluc3RhbmNlLFxyXG4gICAgdW53cmFwT3JpZ2luYWxWYWx1ZXM6IHVud3JhcE9yaWdpbmFsVmFsdWVzLFxyXG4gICAgdW53cmFwQ2hhbmdlZFZhbHVlczogdW53cmFwQ2hhbmdlZFZhbHVlc1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIEVudGl0eU1hbmFnZXIgY29uc3RydWN0b3IuXHJcblxyXG4gIEF0IGl0cyBtb3N0IGJhc2ljIGFuIEVudGl0eU1hbmFnZXIgY2FuIGJlIGNvbnN0cnVjdGVkIHdpdGgganVzdCBhIHNlcnZpY2UgbmFtZVxyXG4gID4gICAgIGxldCBlbnRpdHlNYW5hZ2VyID0gbmV3IEVudGl0eU1hbmFnZXIoIFwiYnJlZXplL05vcnRod2luZElCTW9kZWxcIik7XHJcblxyXG4gIFRoaXMgaXMgdGhlIHNhbWUgYXMgY2FsbGluZyBpdCB3aXRoIHRoZSBmb2xsb3dpbmcgY29uZmlndXJhdGlvbiBvYmplY3RcclxuICA+ICAgICBsZXQgZW50aXR5TWFuYWdlciA9IG5ldyBFbnRpdHlNYW5hZ2VyKCB7c2VydmljZU5hbWU6IFwiYnJlZXplL05vcnRod2luZElCTW9kZWxcIiB9KTtcclxuXHJcbiAgVXN1YWxseSBob3dldmVyLCBjb25maWd1cmF0aW9uIG9iamVjdHMgd2lsbCBjb250YWluIG1vcmUgdGhhbiBqdXN0IHRoZSAnc2VydmljZU5hbWUnO1xyXG4gID4gICAgIGxldCBtZXRhZGF0YVN0b3JlID0gbmV3IE1ldGFkYXRhU3RvcmUoKTtcclxuICA+ICAgICBsZXQgZW50aXR5TWFuYWdlciA9IG5ldyBFbnRpdHlNYW5hZ2VyKCB7XHJcbiAgPiAgICAgICBzZXJ2aWNlTmFtZTogXCJicmVlemUvTm9ydGh3aW5kSUJNb2RlbFwiLFxyXG4gID4gICAgICAgbWV0YWRhdGFTdG9yZTogbWV0YWRhdGFTdG9yZVxyXG4gID4gICAgIH0pO1xyXG5cclxuICBvclxyXG4gID4gICAgIHJldHVybiBuZXcgUXVlcnlPcHRpb25zKHtcclxuICA+ICAgICAgICAgbWVyZ2VTdHJhdGVneTogb2JqLFxyXG4gID4gICAgICAgICBmZXRjaFN0cmF0ZWd5OiB0aGlzLmZldGNoU3RyYXRlZ3lcclxuICA+ICAgICB9KTtcclxuICA+ICAgICBsZXQgcXVlcnlPcHRpb25zID0gbmV3IFF1ZXJ5T3B0aW9ucyh7XHJcbiAgPiAgICAgICAgIG1lcmdlU3RyYXRlZ3k6IE1lcmdlU3RyYXRlZ3kuT3ZlcndyaXRlQ2hhbmdlcyxcclxuICA+ICAgICAgICAgZmV0Y2hTdHJhdGVneTogRmV0Y2hTdHJhdGVneS5Gcm9tU2VydmVyXHJcbiAgPiAgICAgfSk7XHJcbiAgPiAgICAgbGV0IHZhbGlkYXRpb25PcHRpb25zID0gbmV3IFZhbGlkYXRpb25PcHRpb25zKHtcclxuICA+ICAgICAgICAgdmFsaWRhdGVPbkF0dGFjaDogdHJ1ZSxcclxuICA+ICAgICAgICAgdmFsaWRhdGVPblNhdmU6IHRydWUsXHJcbiAgPiAgICAgICAgIHZhbGlkYXRlT25RdWVyeTogZmFsc2VcclxuICA+ICAgICB9KTtcclxuICA+ICAgICBsZXQgZW50aXR5TWFuYWdlciA9IG5ldyBFbnRpdHlNYW5hZ2VyKHtcclxuICA+ICAgICAgICAgc2VydmljZU5hbWU6IFwiYnJlZXplL05vcnRod2luZElCTW9kZWxcIixcclxuICA+ICAgICAgICAgcXVlcnlPcHRpb25zOiBxdWVyeU9wdGlvbnMsXHJcbiAgPiAgICAgICAgIHZhbGlkYXRpb25PcHRpb25zOiB2YWxpZGF0aW9uT3B0aW9uc1xyXG4gID4gICAgIH0pO1xyXG4gIEBwYXJhbSBlbUNvbmZpZyAtIENvbmZpZ3VyYXRpb24gc2V0dGluZ3Mgb3IgYSBzZXJ2aWNlIG5hbWUuICBcclxuICAqKi9cclxuICBjb25zdHJ1Y3RvcihlbUNvbmZpZz86IEVudGl0eU1hbmFnZXJDb25maWcgfCBzdHJpbmcpIHtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEVudGl0eU1hbmFnZXIgY3RvciBoYXMgYSBzaW5nbGUgb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBlaXRoZXIgYSAnc2VydmljZU5hbWUnIG9yIGEgY29uZmlndXJhdGlvbiBvYmplY3QuXCIpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNvbmZpZzogRW50aXR5TWFuYWdlckNvbmZpZztcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNvbmZpZyA9IHsgc2VydmljZU5hbWU6IFwiXCIgfTtcclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVtQ29uZmlnID09PSAnc3RyaW5nJykge1xyXG4gICAgICBjb25maWcgPSB7IHNlcnZpY2VOYW1lOiBlbUNvbmZpZyB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29uZmlnID0gZW1Db25maWcgfHwge307XHJcbiAgICB9XHJcblxyXG4gICAgRW50aXR5TWFuYWdlci5fdXBkYXRlV2l0aENvbmZpZyh0aGlzLCBjb25maWcsIHRydWUpO1xyXG5cclxuICAgIHRoaXMuZW50aXR5Q2hhbmdlZCA9IG5ldyBCcmVlemVFdmVudChcImVudGl0eUNoYW5nZWRcIiwgdGhpcyk7XHJcbiAgICB0aGlzLnZhbGlkYXRpb25FcnJvcnNDaGFuZ2VkID0gbmV3IEJyZWV6ZUV2ZW50KFwidmFsaWRhdGlvbkVycm9yc0NoYW5nZWRcIiwgdGhpcyk7XHJcbiAgICB0aGlzLmhhc0NoYW5nZXNDaGFuZ2VkID0gbmV3IEJyZWV6ZUV2ZW50KFwiaGFzQ2hhbmdlc0NoYW5nZWRcIiwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5jbGVhcigpO1xyXG5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIEdlbmVyYWwgcHVycG9zZSBwcm9wZXJ0eSBzZXQgbWV0aG9kLiAgQW55IG9mIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBbW0VudGl0eU1hbmFnZXJDb25maWddXVxyXG4gIG1heSBiZSBzZXQuXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYSBwcmV2aW91c2x5IGNyZWF0ZWQgRW50aXR5TWFuYWdlclxyXG4gID4gICAgICAvLyB3aGVyZSB3ZSB3YW50IHRvIGNoYW5nZSBzb21lIG9mIGl0cyBzZXR0aW5ncy5cclxuICA+ICAgICAgZW0xLnNldFByb3BlcnRpZXMoIHtcclxuICA+ICAgICAgICAgIHNlcnZpY2VOYW1lOiBcImJyZWV6ZS9mb29cIlxyXG4gID4gICAgICB9KTtcclxuICBAcGFyYW0gY29uZmlnIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB0byBzZXQuXHJcbiAgKiovXHJcbiAgc2V0UHJvcGVydGllcyhjb25maWc6IEVudGl0eU1hbmFnZXJDb25maWcpIHtcclxuICAgIEVudGl0eU1hbmFnZXIuX3VwZGF0ZVdpdGhDb25maWcodGhpcywgY29uZmlnLCBmYWxzZSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgX3VwZGF0ZVdpdGhDb25maWcoZW06IEVudGl0eU1hbmFnZXIsIGNvbmZpZzogRW50aXR5TWFuYWdlckNvbmZpZywgaXNDdG9yOiBib29sZWFuKSB7XHJcbiAgICBsZXQgZGVmYXVsdFF1ZXJ5T3B0aW9ucyA9IGlzQ3RvciA/IFF1ZXJ5T3B0aW9ucy5kZWZhdWx0SW5zdGFuY2UgOiBlbS5xdWVyeU9wdGlvbnM7XHJcbiAgICBsZXQgZGVmYXVsdFNhdmVPcHRpb25zID0gaXNDdG9yID8gU2F2ZU9wdGlvbnMuZGVmYXVsdEluc3RhbmNlIDogZW0uc2F2ZU9wdGlvbnM7XHJcbiAgICBsZXQgZGVmYXVsdFZhbGlkYXRpb25PcHRpb25zID0gaXNDdG9yID8gVmFsaWRhdGlvbk9wdGlvbnMuZGVmYXVsdEluc3RhbmNlIDogZW0udmFsaWRhdGlvbk9wdGlvbnM7XHJcblxyXG4gICAgbGV0IGNvbmZpZ1BhcmFtID0gYXNzZXJ0Q29uZmlnKGNvbmZpZylcclxuICAgICAgLndoZXJlUGFyYW0oXCJzZXJ2aWNlTmFtZVwiKS5pc09wdGlvbmFsKCkuaXNTdHJpbmcoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImRhdGFTZXJ2aWNlXCIpLmlzT3B0aW9uYWwoKS5pc0luc3RhbmNlT2YoRGF0YVNlcnZpY2UpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwicXVlcnlPcHRpb25zXCIpLmlzSW5zdGFuY2VPZihRdWVyeU9wdGlvbnMpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChkZWZhdWx0UXVlcnlPcHRpb25zKVxyXG4gICAgICAud2hlcmVQYXJhbShcInNhdmVPcHRpb25zXCIpLmlzSW5zdGFuY2VPZihTYXZlT3B0aW9ucykuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KGRlZmF1bHRTYXZlT3B0aW9ucylcclxuICAgICAgLndoZXJlUGFyYW0oXCJ2YWxpZGF0aW9uT3B0aW9uc1wiKS5pc0luc3RhbmNlT2YoVmFsaWRhdGlvbk9wdGlvbnMpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChkZWZhdWx0VmFsaWRhdGlvbk9wdGlvbnMpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwia2V5R2VuZXJhdG9yQ3RvclwiKS5pc0Z1bmN0aW9uKCkuaXNPcHRpb25hbCgpO1xyXG4gICAgaWYgKGlzQ3Rvcikge1xyXG4gICAgICBjb25maWdQYXJhbSA9IGNvbmZpZ1BhcmFtXHJcbiAgICAgICAgLndoZXJlUGFyYW0oXCJtZXRhZGF0YVN0b3JlXCIpLmlzSW5zdGFuY2VPZihNZXRhZGF0YVN0b3JlKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQobmV3IE1ldGFkYXRhU3RvcmUoKSk7XHJcbiAgICB9XHJcbiAgICBjb25maWdQYXJhbS5hcHBseUFsbChlbSk7XHJcblxyXG4gICAgLy8gaW5zdXJlIHRoYXQgZW50aXR5TWFuYWdlcidzIG9wdGlvbnMgdmVyc2lvbnMgYXJlIGNvbXBsZXRlbHkgcG9wdWxhdGVkXHJcbiAgICBjb3JlLnVwZGF0ZVdpdGhEZWZhdWx0cyhlbS5xdWVyeU9wdGlvbnMsIGRlZmF1bHRRdWVyeU9wdGlvbnMpO1xyXG4gICAgY29yZS51cGRhdGVXaXRoRGVmYXVsdHMoZW0uc2F2ZU9wdGlvbnMsIGRlZmF1bHRTYXZlT3B0aW9ucyk7XHJcbiAgICBjb3JlLnVwZGF0ZVdpdGhEZWZhdWx0cyhlbS52YWxpZGF0aW9uT3B0aW9ucywgZGVmYXVsdFZhbGlkYXRpb25PcHRpb25zKTtcclxuXHJcbiAgICBpZiAoY29uZmlnLnNlcnZpY2VOYW1lKSB7XHJcbiAgICAgIGVtLmRhdGFTZXJ2aWNlID0gbmV3IERhdGFTZXJ2aWNlKHtcclxuICAgICAgICBzZXJ2aWNlTmFtZTogZW0uc2VydmljZU5hbWVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbS5zZXJ2aWNlTmFtZSA9IGVtLmRhdGFTZXJ2aWNlICYmIGVtLmRhdGFTZXJ2aWNlLnNlcnZpY2VOYW1lO1xyXG5cclxuICAgIGVtLmtleUdlbmVyYXRvckN0b3IgPSBlbS5rZXlHZW5lcmF0b3JDdG9yIHx8IEtleUdlbmVyYXRvcjtcclxuICAgIGlmIChpc0N0b3IgfHwgY29uZmlnLmtleUdlbmVyYXRvckN0b3IpIHtcclxuICAgICAgZW0ua2V5R2VuZXJhdG9yID0gbmV3IGVtLmtleUdlbmVyYXRvckN0b3IoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNyZWF0ZUVudGl0eSh0eXBlTmFtZTogc3RyaW5nLCBpbml0aWFsVmFsdWVzPzogT2JqZWN0LCBlbnRpdHlTdGF0ZT86IEVudGl0eVN0YXRlLCBtZXJnZVN0cmF0ZWd5PzogTWVyZ2VTdHJhdGVneSk6IEVudGl0eTtcclxuICBjcmVhdGVFbnRpdHkoZW50aXR5VHlwZTogRW50aXR5VHlwZSwgaW5pdGlhbFZhbHVlcz86IE9iamVjdCwgZW50aXR5U3RhdGU/OiBFbnRpdHlTdGF0ZSwgbWVyZ2VTdHJhdGVneT86IE1lcmdlU3RyYXRlZ3kpOiBFbnRpdHk7XHJcbiAgLyoqXHJcbiAgQ3JlYXRlcyBhIG5ldyBlbnRpdHkgb2YgYSBzcGVjaWZpZWQgdHlwZSBhbmQgb3B0aW9uYWxseSBpbml0aWFsaXplcyBpdC4gQnkgZGVmYXVsdCB0aGUgbmV3IGVudGl0eSBpcyBjcmVhdGVkIHdpdGggYW4gRW50aXR5U3RhdGUgb2YgQWRkZWRcclxuICBidXQgeW91IGNhbiBhbHNvIG9wdGlvbmFsbHkgc3BlY2lmeSBhbiBFbnRpdHlTdGF0ZS4gIEFuIEVudGl0eVN0YXRlIG9mICdEZXRhY2hlZCcgd2lsbCBpbnN1cmUgdGhhdCB0aGUgZW50aXR5IGlzIGNyZWF0ZWQgYnV0IG5vdCB5ZXQgYWRkZWRcclxuICB0byB0aGUgRW50aXR5TWFuYWdlci4gXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIHByZWV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICAvLyBjcmVhdGUgYW5kIGFkZCBhbiBlbnRpdHk7XHJcbiAgPiAgICAgIGxldCBlbXAxID0gZW0xLmNyZWF0ZUVudGl0eShcIkVtcGxveWVlXCIpO1xyXG4gID4gICAgICAvLyBjcmVhdGUgYW5kIGFkZCBhbiBpbml0aWFsaXplZCBlbnRpdHk7XHJcbiAgPiAgICAgIGxldCBlbXAyID0gZW0xLmNyZWF0ZUVudGl0eShcIkVtcGxveWVlXCIsIHsgbGFzdE5hbWU6IFwiU21pdGhcIiwgZmlyc3ROYW1lOiBcIkpvaG5cIiB9KTtcclxuICA+ICAgICAgLy8gY3JlYXRlIGFuZCBhdHRhY2ggKG5vdCBhZGQpIGFuIGluaXRpYWxpemVkIGVudGl0eVxyXG4gID4gICAgICBsZXQgZW1wMyA9IGVtMS5jcmVhdGVFbnRpdHkoXCJFbXBsb3llZVwiLCB7IGlkOiA0MzUsIGxhc3ROYW1lOiBcIlNtaXRoXCIsIGZpcnN0TmFtZTogXCJKb2huXCIgfSwgRW50aXR5U3RhdGUuVW5jaGFuZ2VkKTtcclxuICA+ICAgICAgLy8gY3JlYXRlIGJ1dCBkb24ndCBhdHRhY2ggYW4gZW50aXR5O1xyXG4gID4gICAgICBsZXQgZW1wNCA9IGVtMS5jcmVhdGVFbnRpdHkoXCJFbXBsb3llZVwiLCB7IGlkOiA0MzUsIGxhc3ROYW1lOiBcIlNtaXRoXCIsIGZpcnN0TmFtZTogXCJKb2huXCIgfSwgRW50aXR5U3RhdGUuRGV0YWNoZWQpO1xyXG4gIEBwYXJhbSB0eXBlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBFbnRpdHlUeXBlIGZvciB3aGljaCBhbiBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZC5cclxuICBAcGFyYW0gZW50aXR5VHlwZSAtIFRoZSBFbnRpdHlUeXBlIG9mIHRoZSB0eXBlIGZvciB3aGljaCBhbiBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZC5cclxuICBAcGFyYW0gaW5pdGlhbFZhbHVlcyAtIChkZWZhdWx0PW51bGwpIENvbmZpZ3VyYXRpb24gb2JqZWN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRvIHNldCBpbW1lZGlhdGVseSBhZnRlciBjcmVhdGlvbi5cclxuICBAcGFyYW0gZW50aXR5U3RhdGUgLSAoZGVmYXVsdCA9IFtbRW50aXR5U3RhdGUuQWRkZWRdXSkgVGhlIEVudGl0eVN0YXRlIG9mIHRoZSBlbnRpdHkgYWZ0ZXIgYmVpbmcgY3JlYXRlZCBhbmQgYWRkZWQgdG8gdGhpcyBFbnRpdHlNYW5hZ2VyLlxyXG4gIEBwYXJhbSBtZXJnZVN0cmF0ZWd5IC0gKGRlZmF1bHQgPSBbW01lcmdlU3RyYXRlZ3kuRGlzYWxsb3dlZF1dKSAtIEhvdyB0byBoYW5kbGUgY29uZmxpY3RzIGlmIGFuIGVudGl0eSB3aXRoIHRoZSBzYW1lIGtleSBhbHJlYWR5IGV4aXN0cyB3aXRoaW4gdGhpcyBFbnRpdHlNYW5hZ2VyLlxyXG4gIEByZXR1cm4ge0VudGl0eX0gQSBuZXcgRW50aXR5IG9mIHRoZSBzcGVjaWZpZWQgdHlwZS4gXHJcbiAgKi9cclxuICBjcmVhdGVFbnRpdHkoZW50aXR5VHlwZTogRW50aXR5VHlwZSB8IHN0cmluZywgaW5pdGlhbFZhbHVlczogT2JqZWN0LCBlbnRpdHlTdGF0ZTogRW50aXR5U3RhdGUsIG1lcmdlU3RyYXRlZ3k6IE1lcmdlU3RyYXRlZ3kpIHtcclxuICAgIGFzc2VydFBhcmFtKGVudGl0eVR5cGUsIFwiZW50aXR5VHlwZVwiKS5pc1N0cmluZygpLm9yKCkuaXNJbnN0YW5jZU9mKEVudGl0eVR5cGUpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShlbnRpdHlTdGF0ZSwgXCJlbnRpdHlTdGF0ZVwiKS5pc0VudW1PZihFbnRpdHlTdGF0ZSkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShtZXJnZVN0cmF0ZWd5LCBcIm1lcmdlU3RyYXRlZ3lcIikuaXNFbnVtT2YoTWVyZ2VTdHJhdGVneSkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcblxyXG4gICAgbGV0IGV0ID0gKHR5cGVvZiBlbnRpdHlUeXBlID09PSBcInN0cmluZ1wiKSA/IHRoaXMubWV0YWRhdGFTdG9yZS5fZ2V0U3RydWN0dXJhbFR5cGUoZW50aXR5VHlwZSkgYXMgRW50aXR5VHlwZSA6IGVudGl0eVR5cGU7XHJcbiAgICBlbnRpdHlTdGF0ZSA9IGVudGl0eVN0YXRlIHx8IEVudGl0eVN0YXRlLkFkZGVkO1xyXG4gICAgbGV0IGVudGl0eSA9IHt9IGFzIEVudGl0eTtcclxuICAgIGNvcmUudXNpbmcodGhpcywgXCJpc0xvYWRpbmdcIiwgdHJ1ZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBlbnRpdHkgPSBldC5jcmVhdGVFbnRpdHkoaW5pdGlhbFZhbHVlcyk7XHJcbiAgICB9KTtcclxuICAgIGlmIChlbnRpdHlTdGF0ZSAhPT0gRW50aXR5U3RhdGUuRGV0YWNoZWQpIHtcclxuICAgICAgZW50aXR5ID0gdGhpcy5hdHRhY2hFbnRpdHkoZW50aXR5LCBlbnRpdHlTdGF0ZSwgbWVyZ2VTdHJhdGVneSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW50aXR5O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGltcG9ydEVudGl0aWVzKGV4cG9ydGVkU3RyaW5nOiBzdHJpbmcsIGNvbmZpZz86IEltcG9ydENvbmZpZyk6IEVudGl0eU1hbmFnZXI7XHJcbiAgc3RhdGljIGltcG9ydEVudGl0aWVzKGV4cG9ydGVkRGF0YTogT2JqZWN0LCBjb25maWc/OiBJbXBvcnRDb25maWcpOiBFbnRpdHlNYW5hZ2VyO1xyXG4gIC8qKlxyXG4gIENyZWF0ZXMgYSBuZXcgRW50aXR5TWFuYWdlciBhbmQgaW1wb3J0cyBhIHByZXZpb3VzbHkgZXhwb3J0ZWQgcmVzdWx0IGludG8gaXQuXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIHByZWV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgYnVuZGxlID0gZW0xLmV4cG9ydEVudGl0aWVzKCk7XHJcbiAgPiAgICAgIC8vIGNhbiBiZSBzdG9yZWQgdmlhIHRoZSB3ZWIgc3RvcmFnZSBhcGlcclxuICA+ICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibXlFbnRpdHlNYW5hZ2VyXCIsIGJ1bmRsZSk7XHJcbiAgPiAgICAgIC8vIGFzc3VtZSB0aGUgY29kZSBiZWxvdyBvY2N1cnMgaW4gYSBkaWZmZXJlbnQgc2Vzc2lvbi5cclxuICA+ICAgICAgbGV0IGJ1bmRsZUZyb21TdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibXlFbnRpdHlNYW5hZ2VyXCIpO1xyXG4gID4gICAgICAvLyBhbmQgaW1wb3J0ZWRcclxuICA+ICAgICAgbGV0IGVtMiA9IEVudGl0eU1hbmFnZXIuaW1wb3J0RW50aXRpZXMoYnVuZGxlRnJvbVN0b3JhZ2UpO1xyXG4gID4gICAgICAvLyBlbTIgd2lsbCBub3cgaGF2ZSBhIGNvbXBsZXRlIGNvcHkgb2Ygd2hhdCB3YXMgaW4gZW0xXHJcbiAgQHBhcmFtIGV4cG9ydGVkU3RyaW5nIC0gVGhlIHJlc3VsdCBvZiBhIHByZXZpb3VzICdleHBvcnRFbnRpdGllcycgY2FsbCBhcyBhIHN0cmluZ1xyXG4gIEBwYXJhbSBleHBvcnRlZERhdGEgLSBUaGUgcmVzdWx0IG9mIGEgcHJldmlvdXMgJ2V4cG9ydEVudGl0aWVzJyBjYWxsIGFzIGFuIE9iamVjdC5cclxuICBAcGFyYW0gY29uZmlnIC0gQSBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICBAcGFyYW0gY29uZmlnLm1lcmdlU3RyYXRlZ3kgLSBBICBbW01lcmdlU3RyYXRlZ3ldXSB0byB1c2Ugd2hlbiBcclxuICBtZXJnaW5nIGludG8gYW4gZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICBAcGFyYW0gY29uZmlnLm1ldGFkYXRhVmVyc2lvbkZuIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIHR3byBhcmd1bWVudHMgKHRoZSBjdXJyZW50IG1ldGFkYXRhVmVyc2lvbiBhbmQgdGhlIGltcG9ydGVkIHN0b3JlJ3MgJ25hbWUnKVxyXG4gIGFuZCBtYXkgYmUgdXNlZCB0byBwZXJmb3JtIHZlcnNpb24gY2hlY2tpbmcuXHJcbiAgQHJldHVybiBBIG5ldyBFbnRpdHlNYW5hZ2VyLiAgTm90ZSB0aGF0IHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBtZXRob2QgY2FsbCBpcyBkaWZmZXJlbnQgZnJvbSB0aGF0XHJcbiAgcHJvdmlkZWQgYnkgdGhlIHNhbWUgbmFtZWQgbWV0aG9kIG9uIGFuIEVudGl0eU1hbmFnZXIgaW5zdGFuY2UuIFVzZSB0aGF0IG1ldGhvZCBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAgcmVnYXJkaW5nIHRoZSBpbXBvcnRlZCBlbnRpdGllcy5cclxuICAqKi9cclxuICBzdGF0aWMgaW1wb3J0RW50aXRpZXMoZXhwb3J0ZWQ6IHN0cmluZyB8IE9iamVjdCwgY29uZmlnPzogSW1wb3J0Q29uZmlnKSB7XHJcbiAgICBsZXQgZW0gPSBuZXcgRW50aXR5TWFuYWdlcigpO1xyXG4gICAgZW0uaW1wb3J0RW50aXRpZXMoZXhwb3J0ZWQsIGNvbmZpZyk7XHJcbiAgICByZXR1cm4gZW07XHJcbiAgfVxyXG5cclxuICAvLyBpbnN0YW5jZSBtZXRob2RzXHJcblxyXG4gIC8qKlxyXG4gIENhbGxzIFtbRW50aXR5QXNwZWN0LmFjY2VwdENoYW5nZXNdXSBvbiBldmVyeSBjaGFuZ2VkIGVudGl0eSBpbiB0aGlzIEVudGl0eU1hbmFnZXIuXHJcbiAgKiovXHJcbiAgYWNjZXB0Q2hhbmdlcygpIHtcclxuICAgIHRoaXMuZ2V0Q2hhbmdlcygpLm1hcChmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgIHJldHVybiBlbnRpdHkuZW50aXR5QXNwZWN0Ll9jaGVja09wZXJhdGlvbihcImFjY2VwdENoYW5nZXNcIik7XHJcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChhc3BlY3QpIHtcclxuICAgICAgYXNwZWN0LmFjY2VwdENoYW5nZXMoKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgRXhwb3J0cyBzZWxlY3RlZCBlbnRpdGllcywgYWxsIGVudGl0aWVzIG9mIHNlbGVjdGVkIHR5cGVzLCBvciBhbiBlbnRpcmUgRW50aXR5TWFuYWdlciBjYWNoZS5cclxuXHJcbiAgVGhpcyBtZXRob2QgdGFrZXMgYSBzbmFwc2hvdCBvZiBhbiBFbnRpdHlNYW5hZ2VyIHRoYXQgY2FuIGJlIHN0b3JlZCBvZmZsaW5lIG9yIGhlbGQgaW4gbWVtb3J5LlxyXG4gIFVzZSB0aGUgW1tFbnRpdHlNYW5hZ2VyLmltcG9ydEVudGl0aWVzXV0gbWV0aG9kIHRvIHJlc3RvcmUgb3IgbWVyZ2UgdGhlIHNuYXBzaG90XHJcbiAgaW50byBhbm90aGVyIEVudGl0eU1hbmFnZXIgYXQgc29tZSBsYXRlciB0aW1lLlxyXG4gID4gICAgICAvLyBsZXQgZW0xIGJlIGFuIEVudGl0eU1hbmFnZXIgY29udGFpbmluZyBhIG51bWJlciBvZiBleGlzdGluZyBlbnRpdGllcy5cclxuICA+ICAgICAvLyBleHBvcnQgZXZlcnkgZW50aXR5IGluIGVtMS5cclxuICA+ICAgICBsZXQgYnVuZGxlID0gZW0xLmV4cG9ydEVudGl0aWVzKCk7XHJcbiAgPiAgICAgLy8gc2F2ZSB0byB0aGUgYnJvd3NlcidzIGxvY2FsIHN0b3JhZ2VcclxuICA+ICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJteUVudGl0eU1hbmFnZXJcIiwgYnVuZGxlKTtcclxuICA+ICAgICAvLyBsYXRlciByZXRyaWV2ZSB0aGUgZXhwb3J0XHJcbiAgPiAgICAgbGV0IGJ1bmRsZUZyb21TdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibXlFbnRpdHlNYW5hZ2VyXCIpO1xyXG4gID4gICAgIC8vIGltcG9ydCB0aGUgcmV0cmlldmVkIGV4cG9ydCBidW5kbGUgaW50byBhbm90aGVyIG1hbmFnZXJcclxuICA+ICAgICBsZXQgZW0yID0gZW0xLmNyZWF0ZUVtcHR5Q29weSgpO1xyXG4gID4gICAgIGVtMi5pbXBvcnRFbnRpdGllcyhidW5kbGVGcm9tU3RvcmFnZSk7XHJcbiAgPiAgICAgLy8gZW0yIG5vdyBoYXMgYSBjb21wbGV0ZSwgZmFpdGhmdWwgY29weSBvZiB0aGUgZW50aXRpZXMgdGhhdCB3ZXJlIGluIGVtMVxyXG5cclxuICBZb3UgY2FuIGFsc28gY29udHJvbCBleGFjdGx5IHdoaWNoIGVudGl0aWVzIGFyZSBleHBvcnRlZC5cclxuICA+ICAgICAvLyBnZXQgZW0xJ3MgdW5zYXZlZCBjaGFuZ2VzIChhbiBhcnJheSkgYW5kIGV4cG9ydCB0aGVtLlxyXG4gID4gICAgIGxldCBjaGFuZ2VzID0gZW0xLmdldENoYW5nZXMoKTtcclxuICA+ICAgICBsZXQgYnVuZGxlID0gZW0xLmV4cG9ydEVudGl0aWVzKGNoYW5nZXMpO1xyXG4gID4gICAgIC8vIG1lcmdlIHRoZXNlIGVudGl0aWVzIGludG8gZW0yIHdoaWNoIG1heSBjb250YWlucyBzb21lIG9mIHRoZSBzYW1lIGVudGl0aWVzLlxyXG4gID4gICAgIC8vIGRvIE5PVCBvdmVyd3JpdGUgdGhlIGVudGl0aWVzIGluIGVtMiBpZiB0aGV5IHRoZW1zZWx2ZXMgaGF2ZSB1bnNhdmVkIGNoYW5nZXMuXHJcbiAgPiAgICAgZW0yLmltcG9ydEVudGl0aWVzKGJ1bmRsZSwgeyBtZXJnZVN0cmF0ZWd5OiBNZXJnZVN0cmF0ZWd5LlByZXNlcnZlQ2hhbmdlc30gKTtcclxuXHJcbiAgTWV0YWRhdGEgYXJlIGluY2x1ZGVkIGluIGFuIGV4cG9ydCBieSBkZWZhdWx0LiBZb3UgbWF5IHdhbnQgdG8gZXhjbHVkZSB0aGUgbWV0YWRhdGFcclxuICBlc3BlY2lhbGx5IGlmIHlvdSdyZSBleHBvcnRpbmcganVzdCBhIGZldyBlbnRpdGllcyBmb3IgbG9jYWwgc3RvcmFnZS5cclxuICA+ICAgICBsZXQgYnVuZGxlID0gZW0xLmV4cG9ydEVudGl0aWVzKGFycmF5T2ZTZWxlY3RlZEVudGl0aWVzLCB7aW5jbHVkZU1ldGFkYXRhOiBmYWxzZX0pO1xyXG4gID4gICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImdvb2RTdHVmZlwiLCBidW5kbGUpO1xyXG5cclxuICBZb3UgbWF5IHN0aWxsIGV4cHJlc3MgdGhpcyBvcHRpb24gYXMgYSBib29sZWFuIHZhbHVlIGFsdGhvdWdoIHRoaXMgb2xkZXIgc3ludGF4IGlzIGRlcHJlY2F0ZWQuXHJcbiAgPiAgICAgLy8gRXhjbHVkZSB0aGUgbWV0YWRhdGEgKGRlcHJlY2F0ZWQgc3ludGF4KVxyXG4gID4gICAgIGxldCBidW5kbGUgPSBlbTEuZXhwb3J0RW50aXRpZXMoYXJyYXlPZlNlbGVjdGVkRW50aXRpZXMsIGZhbHNlKTtcclxuXHJcbiAgWW91IGNhbiBleHBvcnQgYWxsIGVudGl0aWVzIG9mIG9uZSBvciBtb3JlIHNwZWNpZmllZCBFbnRpdHlUeXBlcy5cclxuICA+ICAgICAvLyBFeHBvcnQgYWxsIEN1c3RvbWVyIGFuZCBFbXBsb3llZSBlbnRpdGllcyAoYW5kIGFsc28gZXhjbHVkZSBtZXRhZGF0YSlcclxuICA+ICAgICBsZXQgYnVuZGxlID0gZW0xLmV4cG9ydEVudGl0aWVzKFsnQ3VzdG9tZXInLCAnRW1wbG95ZWUnXSwge2luY2x1ZGVNZXRhZGF0YTogZmFsc2V9KTtcclxuXHJcbiAgQWxsIG9mIHRoZSBhYm92ZSBleGFtcGxlcyByZXR1cm4gYW4gZXhwb3J0IGJ1bmRsZSBhcyBhIHN0cmluZyB3aGljaCBpcyB0aGUgZGVmYXVsdCBmb3JtYXQuXHJcbiAgWW91IGNhbiBleHBvcnQgdGhlIGJ1bmRsZSBhcyBKU09OIGlmIHlvdSBwcmVmZXIgYnkgc2V0dGluZyB0aGUgYGFzU3RyaW5nYCBvcHRpb24gdG8gZmFsc2UuXHJcbiAgPiAgICAgLy8gRXhwb3J0IGFsbCBDdXN0b21lciBhbmQgRW1wbG95ZWUgZW50aXRpZXMgYXMgSlNPTiBhbmQgZXhjbHVkZSB0aGUgbWV0YWRhdGFcclxuICA+ICAgICBsZXQgYnVuZGxlID0gZW0xLmV4cG9ydEVudGl0aWVzKFsnQ3VzdG9tZXInLCAnRW1wbG95ZWUnXSxcclxuICA+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHthc1N0cmluZzogZmFsc2UsIGluY2x1ZGVNZXRhZGF0YTogZmFsc2V9KTtcclxuICA+ICAgICAvLyBzdG9yZSBKU09OIGJ1bmRsZSBzb21ld2hlcmUgLi4uIHBlcmhhcHMgaW5kZXhEYiAuLi4gYW5kIGxhdGVyIGltcG9ydCBhcyB3ZSBkbyBoZXJlLlxyXG4gID4gICAgIGVtMi5pbXBvcnRFbnRpdGllcyhidW5kbGUpO1xyXG4gIEBwYXJhbSBlbnRpdGllcyAtIFRoZSBlbnRpdGllcyB0byBleHBvcnQgb3IgdGhlIEVudGl0eVR5cGUocykgb2YgdGhlIGVudGl0aWVzIHRvIGV4cG9ydDtcclxuICAgIGFsbCBlbnRpdGllcyBhcmUgZXhwb3J0ZWQgaWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCBvciBudWxsLlxyXG4gIEBwYXJhbSBleHBvcnRDb25maWcgLSBFeHBvcnQgY29uZmlndXJhdGlvbiBvcHRpb25zIG9yIGEgYm9vbGVhblxyXG4gICAgLSBhc1N0cmluZyAtIChib29sZWFuKSAtIElmIHRydWUgKGRlZmF1bHQpLCByZXR1cm4gZXhwb3J0IGJ1bmRsZSBhcyBhIHN0cmluZy5cclxuICAgIC0gaW5jbHVkZU1ldGFkYXRhIC0gKGJvb2xlYW4pIC0gSWYgdHJ1ZSAoZGVmYXVsdCksIGluY2x1ZGUgbWV0YWRhdGEgaW4gdGhlIGV4cG9ydCBidW5kbGUuXHJcbiAgQHJldHVybiBUaGUgZXhwb3J0IGJ1bmRsZSBlaXRoZXIgc2VyaWFsaXplZCBhcyBhIHN0cmluZyAoZGVmYXVsdCkgb3IgYXMgYSBKU09OIG9iamVjdC5cclxuICBUaGUgYnVuZGxlIGNvbnRhaW5zIHRoZSBtZXRhZGF0YSAodW5sZXNzIGV4Y2x1ZGVkKSBhbmQgdGhlIGVudGl0eSBkYXRhIGdyb3VwZWQgYnkgdHlwZS5cclxuICBUaGUgZW50aXR5IGRhdGEgaW5jbHVkZSBwcm9wZXJ0eSB2YWx1ZXMsIGNoYW5nZS1zdGF0ZSwgYW5kIHRlbXBvcmFyeSBrZXkgbWFwcGluZ3MgKGlmIGFueSkuXHJcblxyXG4gIFRoZSBleHBvcnQgYnVuZGxlIGludGVybmFscyBhcmUgZGVsaWJlcmF0ZWx5IHVuZG9jdW1lbnRlZC4gIFRoaXMgQnJlZXplLWludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGVudGl0eSBkYXRhIGlzXHJcbiAgc3VpdGFibGUgZm9yIGV4cG9ydCwgc3RvcmFnZSwgYW5kIGltcG9ydC4gVGhlIHNjaGVtYSBhbmQgY29udGVudHMgb2YgdGhlIGJ1bmRsZSBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBCcmVlemUuXHJcbiAgTWFuaXB1bGF0ZSBpdCBhdCB5b3VyIG93biByaXNrIHdpdGggYXBwcm9wcmlhdGUgY2F1dGlvbi5cclxuICAqKi9cclxuICBleHBvcnRFbnRpdGllcyhlbnRpdGllcz86IEVudGl0eVtdIHwgRW50aXR5VHlwZVtdIHwgc3RyaW5nW10sIGV4cG9ydENvbmZpZz86IHsgYXNTdHJpbmc/OiBib29sZWFuLCBpbmNsdWRlTWV0YWRhdGE/OiBib29sZWFuIH0gfCBib29sZWFuKTogc3RyaW5nIHwgT2JqZWN0IHtcclxuICAgIGFzc2VydFBhcmFtKGVudGl0aWVzLCBcImVudGl0aWVzXCIpLmlzQXJyYXkoKS5pc0VudGl0eSgpXHJcbiAgICAgIC5vcigpLmlzTm9uRW1wdHlBcnJheSgpLmlzSW5zdGFuY2VPZihFbnRpdHlUeXBlKVxyXG4gICAgICAub3IoKS5pc05vbkVtcHR5QXJyYXkoKS5pc1N0cmluZygpXHJcbiAgICAgIC5vcigpLmlzT3B0aW9uYWwoKS5jaGVjaygpO1xyXG5cclxuICAgIC8vIGFzc2VydFBhcmFtKGV4cG9ydENvbmZpZywgXCJleHBvcnRDb25maWdcIikuaXNPYmplY3QoKVxyXG4gICAgLy8gICAub3IoKS5pc0Jvb2xlYW4oKVxyXG4gICAgLy8gICAub3IoKS5pc09wdGlvbmFsKCkuY2hlY2soKTtcclxuXHJcbiAgICBpZiAoZXhwb3J0Q29uZmlnID09IG51bGwpIHtcclxuICAgICAgZXhwb3J0Q29uZmlnID0geyBpbmNsdWRlTWV0YWRhdGE6IHRydWUsIGFzU3RyaW5nOiB0cnVlIH07XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRDb25maWcgPT09ICdib29sZWFuJykgeyAvLyBkZXByZWNhdGVkXHJcbiAgICAgIGV4cG9ydENvbmZpZyA9IHsgaW5jbHVkZU1ldGFkYXRhOiBleHBvcnRDb25maWcsIGFzU3RyaW5nOiB0cnVlIH07XHJcbiAgICB9XHJcblxyXG4gICAgYXNzZXJ0Q29uZmlnKGV4cG9ydENvbmZpZylcclxuICAgICAgLndoZXJlUGFyYW0oXCJhc1N0cmluZ1wiKS5pc0Jvb2xlYW4oKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQodHJ1ZSlcclxuICAgICAgLndoZXJlUGFyYW0oXCJpbmNsdWRlTWV0YWRhdGFcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KHRydWUpXHJcbiAgICAgIC5hcHBseUFsbChleHBvcnRDb25maWcpO1xyXG5cclxuICAgIGxldCBleHBvcnRCdW5kbGUgPSBleHBvcnRFbnRpdHlHcm91cHModGhpcywgZW50aXRpZXMpO1xyXG4gICAgbGV0IGpzb24gPSBjb3JlLmV4dGVuZCh7fSwgZXhwb3J0QnVuZGxlLCBbXCJ0ZW1wS2V5c1wiLCBcImVudGl0eUdyb3VwTWFwXCJdKTtcclxuXHJcbiAgICBpZiAoZXhwb3J0Q29uZmlnLmluY2x1ZGVNZXRhZGF0YSkge1xyXG4gICAgICBqc29uID0gY29yZS5leHRlbmQoanNvbiwgdGhpcywgW1wiZGF0YVNlcnZpY2VcIiwgXCJzYXZlT3B0aW9uc1wiLCBcInF1ZXJ5T3B0aW9uc1wiLCBcInZhbGlkYXRpb25PcHRpb25zXCJdKTtcclxuICAgICAgKGpzb24gYXMgYW55KS5tZXRhZGF0YVN0b3JlID0gdGhpcy5tZXRhZGF0YVN0b3JlLmV4cG9ydE1ldGFkYXRhKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAoanNvbiBhcyBhbnkpLm1ldGFkYXRhVmVyc2lvbiA9IE1ldGFkYXRhU3RvcmUubWV0YWRhdGFWZXJzaW9uO1xyXG4gICAgICAoanNvbiBhcyBhbnkpLm1ldGFkYXRhU3RvcmVOYW1lID0gdGhpcy5tZXRhZGF0YVN0b3JlLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJlc3VsdCA9IGV4cG9ydENvbmZpZy5hc1N0cmluZyA/IEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIGNvbmZpZy5zdHJpbmdpZnlQYWQpIDoganNvbjtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiB0eXBlIHRoZSByZXR1cm4gdmFsdWUgeyBlbnRpdGllczogZW50aXRpZXNUb0xpbmssIHRlbXBLZXlNYXBwaW5nOiB0ZW1wS2V5TWFwIH1cclxuICBpbXBvcnRFbnRpdGllcyhleHBvcnRlZFN0cmluZzogc3RyaW5nLCBjb25maWc/OiBJbXBvcnRDb25maWcpOiBJbXBvcnRSZXN1bHQ7XHJcbiAgaW1wb3J0RW50aXRpZXMoZXhwb3J0ZWREYXRhOiBPYmplY3QsIGNvbmZpZz86IEltcG9ydENvbmZpZyk6IEltcG9ydFJlc3VsdDtcclxuICAvKipcclxuICBJbXBvcnRzIGEgcHJldmlvdXNseSBleHBvcnRlZCByZXN1bHQgaW50byB0aGlzIEVudGl0eU1hbmFnZXIuXHJcblxyXG4gIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIGFueSBwcmV2aW91c2x5IGNyZWF0ZWQgZW50aXR5TWFuYWdlciwgZXZlbiBpZiBjcmVhdGVkXHJcbiAgaW4gYSBwcmV2aW91cyBzZXNzaW9uIGFuZCBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlLiBUaGUgc3RhdGljIHZlcnNpb24gb2YgdGhpcyBtZXRob2QgcGVyZm9ybXMgYVxyXG4gIHZlcnkgc2ltaWxhciBwcm9jZXNzLlxyXG4gID4gICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgIGxldCBidW5kbGUgPSBlbTEuZXhwb3J0RW50aXRpZXMoKTtcclxuICA+ICAgICAvLyBidW5kbGUgY2FuIGJlIHN0b3JlZCBpbiB3aW5kb3cubG9jYWxTdG9yYWdlIG9yIGp1c3QgaGVsZCBpbiBtZW1vcnkuXHJcbiAgPiAgICAgbGV0IGVtMiA9IG5ldyBFbnRpdHlNYW5hZ2VyKHtcclxuICA+ICAgICAgICAgc2VydmljZU5hbWU6IGVtMS5zZXJ2aWNlTmFtZSxcclxuICA+ICAgICAgICAgbWV0YWRhdGFTdG9yZTogZW0xLm1ldGFkYXRhU3RvcmVcclxuICA+ICAgICB9KTtcclxuICA+ICAgICBlbTIuaW1wb3J0RW50aXRpZXMoYnVuZGxlKTtcclxuICA+ICAgICAvLyBlbTIgd2lsbCBub3cgaGF2ZSBhIGNvbXBsZXRlIGNvcHkgb2Ygd2hhdCB3YXMgaW4gZW0xXHJcblxyXG4gIEl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gbWVyZ2UgdGhlIGNvbnRlbnRzIG9mIGEgcHJldmlvdXNseSBjcmVhdGVkIEVudGl0eU1hbmFnZXIgd2l0aCBhblxyXG4gIGV4aXN0aW5nIEVudGl0eU1hbmFnZXIgd2l0aCBjb250cm9sIG92ZXIgaG93IHRoZSB0d28gYXJlIG1lcmdlZC5cclxuICA+ICAgICBsZXQgYnVuZGxlID0gZW0xLmV4cG9ydEVudGl0aWVzKCk7XHJcbiAgPiAgICAgLy8gYXNzdW1lIGVtMiBpcyBhbm90aGVyIGVudGl0eU1hbmFnZXIgY29udGFpbmluZyBzb21lIG9mIHRoZSBzYW1lIGVudGl0aWVzIHBvc3NpYmx5IHdpdGggbW9kaWZpY2F0aW9ucy5cclxuICA+ICAgICBlbTIuaW1wb3J0RW50aXRpZXMoYnVuZGxlLCB7IG1lcmdlU3RyYXRlZ3k6IE1lcmdlU3RyYXRlZ3kuUHJlc2VydmVDaGFuZ2VzfSApO1xyXG4gID4gICAgIC8vIGVtMiB3aWxsIG5vdyBjb250YWluIGFsbCBvZiB0aGUgZW50aXRpZXMgZnJvbSBib3RoIGVtMSBhbmQgZW0yLiAgQW55IGVtMiBlbnRpdGllcyB3aXRoIHByZXZpb3VzbHlcclxuICA+ICAgICAvLyBtYWRlIG1vZGlmaWNhdGlvbnMgd2lsbCBub3QgaGF2ZSBiZWVuIHRvdWNoZWQsIGJ1dCBhbGwgb3RoZXIgZW50aXRpZXMgZnJvbSBlbTEgd2lsbCBoYXZlIGJlZW4gaW1wb3J0ZWQuXHJcbiAgQHBhcmFtIGV4cG9ydGVkU3RyaW5nIC0gVGhlIHJlc3VsdCBvZiBhIHByZXZpb3VzICdleHBvcnQnIGNhbGwuXHJcbiAgQHBhcmFtIGltcG9ydENvbmZpZyAtIEEgY29uZmlndXJhdGlvbiBvYmplY3QuXHJcbiAgQHBhcmFtIGltcG9ydENvbmZpZy5tZXJnZVN0cmF0ZWd5IC0gIEEgW1tNZXJnZVN0cmF0ZWd5XV0gdG8gdXNlIHdoZW5cclxuICBtZXJnaW5nIGludG8gYW4gZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICBAcGFyYW0gaW1wb3J0Q29uZmlnLm1ldGFkYXRhVmVyc2lvbkZuIC0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIHR3byBhcmd1bWVudHMgKHRoZSBjdXJyZW50IG1ldGFkYXRhVmVyc2lvbiBhbmQgdGhlIGltcG9ydGVkIHN0b3JlJ3MgJ25hbWUnKVxyXG4gIGFuZCBtYXkgYmUgdXNlZCB0byBwZXJmb3JtIHZlcnNpb24gY2hlY2tpbmcuXHJcbiAgQHJldHVybiByZXN1bHQgXHJcbiAgICAtIHJlc3VsdC5lbnRpdGllcyB7QXJyYXkgb2YgRW50aXRpZXN9IFRoZSBlbnRpdGllcyB0aGF0IHdlcmUgaW1wb3J0ZWQuXHJcbiAgICAtIHJlc3VsdC50ZW1wS2V5TWFwIHtPYmplY3R9IE1hcHBpbmcgZnJvbSBvcmlnaW5hbCBFbnRpdHlLZXkgaW4gdGhlIGltcG9ydCBidW5kbGUgdG8gaXRzIGNvcnJlc3BvbmRpbmcgRW50aXR5S2V5IGluIHRoaXMgRW50aXR5TWFuYWdlci5cclxuICAqKi9cclxuICBpbXBvcnRFbnRpdGllcyhleHBvcnRlZDogc3RyaW5nIHwgT2JqZWN0LCBpbXBvcnRDb25maWc/OiBJbXBvcnRDb25maWcpIHtcclxuICAgIGltcG9ydENvbmZpZyA9IGltcG9ydENvbmZpZyB8fCB7fTtcclxuICAgIGFzc2VydENvbmZpZyhpbXBvcnRDb25maWcpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwibWVyZ2VTdHJhdGVneVwiKS5pc0VudW1PZihNZXJnZVN0cmF0ZWd5KS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQodGhpcy5xdWVyeU9wdGlvbnMubWVyZ2VTdHJhdGVneSlcclxuICAgICAgLndoZXJlUGFyYW0oXCJtZXRhZGF0YVZlcnNpb25GblwiKS5pc0Z1bmN0aW9uKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwibWVyZ2VBZGRzXCIpLmlzQm9vbGVhbigpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAuYXBwbHlBbGwoaW1wb3J0Q29uZmlnKTtcclxuXHJcbiAgICBsZXQganNvbiA9ICh0eXBlb2YgZXhwb3J0ZWQgPT09IFwic3RyaW5nXCIpID8gSlNPTi5wYXJzZShleHBvcnRlZCkgOiBleHBvcnRlZDtcclxuICAgIGlmIChqc29uLm1ldGFkYXRhU3RvcmUpIHtcclxuICAgICAgdGhpcy5tZXRhZGF0YVN0b3JlLmltcG9ydE1ldGFkYXRhKGpzb24ubWV0YWRhdGFTdG9yZSk7XHJcbiAgICAgIC8vIHRoZSB8fCBjbGF1c2UgaXMgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBhbiBlYXJsaWVyIHNlcmlhbGl6YXRpb24gZm9ybWF0LlxyXG4gICAgICB0aGlzLmRhdGFTZXJ2aWNlID0gKGpzb24uZGF0YVNlcnZpY2UgJiYgRGF0YVNlcnZpY2UuZnJvbUpTT04oanNvbi5kYXRhU2VydmljZSkpIHx8IG5ldyBEYXRhU2VydmljZSh7IHNlcnZpY2VOYW1lOiBqc29uLnNlcnZpY2VOYW1lIH0pO1xyXG5cclxuICAgICAgdGhpcy5zYXZlT3B0aW9ucyA9IG5ldyBTYXZlT3B0aW9ucyhqc29uLnNhdmVPcHRpb25zKTtcclxuICAgICAgdGhpcy5xdWVyeU9wdGlvbnMgPSBRdWVyeU9wdGlvbnMuZnJvbUpTT04oanNvbi5xdWVyeU9wdGlvbnMpO1xyXG4gICAgICB0aGlzLnZhbGlkYXRpb25PcHRpb25zID0gbmV3IFZhbGlkYXRpb25PcHRpb25zKGpzb24udmFsaWRhdGlvbk9wdGlvbnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW1wb3J0Q29uZmlnLm1ldGFkYXRhVmVyc2lvbkZuICYmIGltcG9ydENvbmZpZy5tZXRhZGF0YVZlcnNpb25Gbih7XHJcbiAgICAgICAgbWV0YWRhdGFWZXJzaW9uOiBqc29uLm1ldGFkYXRhVmVyc2lvbixcclxuICAgICAgICBtZXRhZGF0YVN0b3JlTmFtZToganNvbi5tZXRhZGF0YVN0b3JlTmFtZVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdGVtcEtleU1hcDogSVRlbXBLZXlNYXAgPSB7fTtcclxuICAgIGpzb24udGVtcEtleXMuZm9yRWFjaCgoazogYW55KSA9PiB7XHJcbiAgICAgIGxldCBvbGRLZXkgPSBFbnRpdHlLZXkuZnJvbUpTT04oaywgdGhpcy5tZXRhZGF0YVN0b3JlKTtcclxuICAgICAgLy8gdHJ5IHRvIHVzZSBvbGRLZXkgaWYgbm90IGFscmVhZHkgdXNlZCBpbiB0aGlzIGtleUdlbmVyYXRvci5cclxuICAgICAgdGVtcEtleU1hcFtvbGRLZXkudG9TdHJpbmcoKV0gPSBuZXcgRW50aXR5S2V5KG9sZEtleS5lbnRpdHlUeXBlLCB0aGlzLmtleUdlbmVyYXRvci5nZW5lcmF0ZVRlbXBLZXlWYWx1ZShvbGRLZXkuZW50aXR5VHlwZSwgb2xkS2V5LnZhbHVlc1swXSkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IGVudGl0aWVzVG9MaW5rOiBFbnRpdHlbXSA9IFtdO1xyXG4gICAgbGV0IGltcENvbmZpZyA9IGltcG9ydENvbmZpZyBhcyBJbXBvcnRDb25maWdFeHQ7XHJcblxyXG4gICAgaW1wQ29uZmlnLnRlbXBLZXlNYXAgPSB0ZW1wS2V5TWFwO1xyXG4gICAgY29yZS53cmFwRXhlY3V0aW9uKCgpID0+IHtcclxuICAgICAgdGhpcy5fcGVuZGluZ1B1YnMgPSBbXTtcclxuICAgIH0sIChzdGF0ZSkgPT4ge1xyXG4gICAgICB0aGlzLl9wZW5kaW5nUHVicyEuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xyXG4gICAgICB0aGlzLl9wZW5kaW5nUHVicyA9IHVuZGVmaW5lZDtcclxuICAgICAgdGhpcy5faGFzQ2hhbmdlc0FjdGlvbiAmJiB0aGlzLl9oYXNDaGFuZ2VzQWN0aW9uKCk7XHJcbiAgICB9LCAoKSA9PiB7XHJcbiAgICAgIGNvcmUub2JqZWN0Rm9yRWFjaChqc29uLmVudGl0eUdyb3VwTWFwLCAoZW50aXR5VHlwZU5hbWUsIGpzb25Hcm91cCkgPT4ge1xyXG4gICAgICAgIGxldCBlbnRpdHlUeXBlID0gdGhpcy5tZXRhZGF0YVN0b3JlLl9nZXRTdHJ1Y3R1cmFsVHlwZShlbnRpdHlUeXBlTmFtZSwgZmFsc2UpIGFzIEVudGl0eVR5cGU7XHJcbiAgICAgICAgbGV0IHRhcmdldEVudGl0eUdyb3VwID0gZmluZE9yQ3JlYXRlRW50aXR5R3JvdXAodGhpcywgZW50aXR5VHlwZSk7XHJcbiAgICAgICAgbGV0IGVudGl0aWVzID0gaW1wb3J0RW50aXR5R3JvdXAodGFyZ2V0RW50aXR5R3JvdXAsIGpzb25Hcm91cCwgaW1wQ29uZmlnKTtcclxuICAgICAgICBpZiAoZW50aXRpZXMgJiYgZW50aXRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBlbnRpdGllc1RvTGluayA9IGVudGl0aWVzVG9MaW5rLmNvbmNhdChlbnRpdGllcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgZW50aXRpZXNUb0xpbmsuZm9yRWFjaCgoZW50aXR5KSA9PiB7XHJcbiAgICAgICAgaWYgKCFlbnRpdHkuZW50aXR5QXNwZWN0LmVudGl0eVN0YXRlLmlzRGVsZXRlZCgpKSB7XHJcbiAgICAgICAgICB0aGlzLl9saW5rUmVsYXRlZEVudGl0aWVzKGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZW50aXRpZXM6IGVudGl0aWVzVG9MaW5rLFxyXG4gICAgICB0ZW1wS2V5TWFwcGluZzogdGVtcEtleU1hcFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIENsZWFycyB0aGlzIEVudGl0eU1hbmFnZXIncyBjYWNoZSBidXQga2VlcHMgYWxsIG90aGVyIHNldHRpbmdzLiBOb3RlIHRoYXQgdGhpc1xyXG4gIG1ldGhvZCBpcyBub3QgYXMgZmFzdCBhcyBjcmVhdGluZyBhIG5ldyBFbnRpdHlNYW5hZ2VyIHZpYSAnbmV3IEVudGl0eU1hbmFnZXInLlxyXG4gIFRoaXMgaXMgYmVjYXVzZSBjbGVhciBhY3R1YWxseSBkZXRhY2hlcyBhbGwgb2YgdGhlIGVudGl0aWVzIGZyb20gdGhlIEVudGl0eU1hbmFnZXIuXHJcbiAgPiAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgZW0xLmNsZWFyKCk7XHJcbiAgPiAgICAgLy8gZW0xIGlzIHdpbGwgbm93IGNvbnRhaW4gbm8gZW50aXRpZXMsIGJ1dCBhbGwgb3RoZXIgc2V0dGluZyB3aWxsIGJlIG1haW50YWluZWQuXHJcbiAgKiovXHJcbiAgY2xlYXIoKSB7XHJcbiAgICBjb3JlLm9iamVjdE1hcCh0aGlzLl9lbnRpdHlHcm91cE1hcCwgZnVuY3Rpb24gKGtleTogc3RyaW5nLCBlbnRpdHlHcm91cDogRW50aXR5R3JvdXApIHtcclxuICAgICAgcmV0dXJuIGVudGl0eUdyb3VwLl9jaGVja09wZXJhdGlvbignY2xlYXInKTtcclxuICAgIH0pLmZvckVhY2goKGVudGl0eUdyb3VwOiBFbnRpdHlHcm91cCkgPT4ge1xyXG4gICAgICBlbnRpdHlHcm91cC5fY2xlYXIoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2VudGl0eUdyb3VwTWFwID0ge307XHJcbiAgICB0aGlzLl91bmF0dGFjaGVkQ2hpbGRyZW5NYXAgPSBuZXcgVW5hdHRhY2hlZENoaWxkcmVuTWFwKCk7XHJcbiAgICB0aGlzLmtleUdlbmVyYXRvciA9IG5ldyB0aGlzLmtleUdlbmVyYXRvckN0b3IoKTtcclxuICAgIHRoaXMuZW50aXR5Q2hhbmdlZC5wdWJsaXNoKHsgZW50aXR5QWN0aW9uOiBFbnRpdHlBY3Rpb24uQ2xlYXIgfSk7XHJcbiAgICB0aGlzLl9zZXRIYXNDaGFuZ2VzKGZhbHNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIENyZWF0ZXMgYW4gZW1wdHkgY29weSBvZiB0aGlzIEVudGl0eU1hbmFnZXIgYnV0IHdpdGggdGhlIHNhbWUgRGF0YVNlcnZpY2UsIE1ldGFkYXRhU3RvcmUsIFF1ZXJ5T3B0aW9ucywgU2F2ZU9wdGlvbnMsIFZhbGlkYXRpb25PcHRpb25zLCBldGMuIFxyXG4gID4gICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgIGxldCBlbTIgPSBlbTEuY3JlYXRlRW1wdHlDb3B5KCk7XHJcbiAgPiAgICAgLy8gZW0yIGlzIGEgbmV3IEVudGl0eU1hbmFnZXIgd2l0aCBhbGwgb2YgZW0xJ3Mgc2V0dGluZ3NcclxuICA+ICAgICAvLyBidXQgbm8gZW50aXRpZXMuXHJcbiAgQHJldHVybiBBIG5ldyBFbnRpdHlNYW5hZ2VyLlxyXG4gICoqL1xyXG4gIGNyZWF0ZUVtcHR5Q29weSgpIHtcclxuICAgIGxldCBjb3B5ID0gbmV3IEVudGl0eU1hbmFnZXIoY29yZS5leHRlbmQoe30sIHRoaXMsXHJcbiAgICAgIFtcImRhdGFTZXJ2aWNlXCIsIFwibWV0YWRhdGFTdG9yZVwiLCBcInF1ZXJ5T3B0aW9uc1wiLCBcInNhdmVPcHRpb25zXCIsIFwidmFsaWRhdGlvbk9wdGlvbnNcIiwgXCJrZXlHZW5lcmF0b3JDdG9yXCJdKSk7XHJcbiAgICByZXR1cm4gY29weTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIEF0dGFjaGVzIGFuIGVudGl0eSB0byB0aGlzIEVudGl0eU1hbmFnZXIgd2l0aCBhbiAgW1tFbnRpdHlTdGF0ZV1dIG9mICdBZGRlZCcuXHJcbiAgPiAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgbGV0IGN1c3RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkN1c3RvbWVyXCIpO1xyXG4gID4gICAgIGxldCBjdXN0MSA9IGN1c3RUeXBlLmNyZWF0ZUVudGl0eSgpO1xyXG4gID4gICAgIGVtMS5hZGRFbnRpdHkoY3VzdDEpO1xyXG5cclxuICBOb3RlIHRoYXQgdGhpcyBpcyB0aGUgc2FtZSBhcyB1c2luZyAnYXR0YWNoRW50aXR5JyB3aXRoIGFuIFtbRW50aXR5U3RhdGVdXSBvZiAnQWRkZWQnLlxyXG5cclxuICA+ICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXIgY29udGFpbmluZyBhIG51bWJlciBvZiBleGlzdGluZyBlbnRpdGllcy5cclxuICA+ICAgICBsZXQgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgPiAgICAgbGV0IGN1c3QxID0gY3VzdFR5cGUuY3JlYXRlRW50aXR5KCk7XHJcbiAgPiAgICAgZW0xLmF0dGFjaEVudGl0eShjdXN0MSwgRW50aXR5U3RhdGUuQWRkZWQpO1xyXG4gIEBwYXJhbSBlbnRpdHkgLSBUaGUgZW50aXR5IHRvIGFkZC5cclxuICBAcmV0dXJuIFRoZSBhZGRlZCBlbnRpdHkuXHJcbiAgKiovXHJcbiAgYWRkRW50aXR5KGVudGl0eTogRW50aXR5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRhY2hFbnRpdHkoZW50aXR5LCBFbnRpdHlTdGF0ZS5BZGRlZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBBdHRhY2hlcyBhbiBlbnRpdHkgdG8gdGhpcyBFbnRpdHlNYW5hZ2VyIHdpdGggYSBzcGVjaWZpZWQgW1tFbnRpdHlTdGF0ZV1dLlxyXG4gID4gICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICA+ICAgICBsZXQgY3VzdDEgPSBjdXN0VHlwZS5jcmVhdGVFbnRpdHkoKTtcclxuICA+ICAgICBlbTEuYXR0YWNoRW50aXR5KGN1c3QxLCBFbnRpdHlTdGF0ZS5BZGRlZCk7XHJcbiAgQHBhcmFtIGVudGl0eSAtIFRoZSBlbnRpdHkgdG8gYWRkLlxyXG4gIEBwYXJhbSBlbnRpdHlTdGF0ZSAtIChkZWZhdWx0PUVudGl0eVN0YXRlLlVuY2hhbmdlZCkgVGhlIEVudGl0eVN0YXRlIG9mIHRoZSBuZXdseSBhdHRhY2hlZCBlbnRpdHkuIElmIG9taXR0ZWQgdGhpcyBkZWZhdWx0cyB0byBFbnRpdHlTdGF0ZS5VbmNoYW5nZWQuXHJcbiAgQHBhcmFtIG1lcmdlU3RyYXRlZ3kgLSAoZGVmYXVsdCA9IE1lcmdlU3RyYXRlZ3kuRGlzYWxsb3dlZCkgSG93IHRoZSBzcGVjaWZpZWQgZW50aXR5IHNob3VsZCBiZSBtZXJnZWQgaW50byB0aGUgRW50aXR5TWFuYWdlciBpZiB0aGlzIEVudGl0eU1hbmFnZXIgYWxyZWFkeSBjb250YWlucyBhbiBlbnRpdHkgd2l0aCB0aGUgc2FtZSBrZXkuXHJcbiAgQHJldHVybiBUaGUgYXR0YWNoZWQgZW50aXR5LlxyXG4gICoqL1xyXG4gIGF0dGFjaEVudGl0eShlbnRpdHk6IEVudGl0eSwgZW50aXR5U3RhdGU/OiBFbnRpdHlTdGF0ZSwgbWVyZ2VTdHJhdGVneT86IE1lcmdlU3RyYXRlZ3kpIHtcclxuICAgIGFzc2VydFBhcmFtKGVudGl0eSwgXCJlbnRpdHlcIikuaXNSZXF1aXJlZCgpLmNoZWNrKCk7XHJcbiAgICB0aGlzLm1ldGFkYXRhU3RvcmUuX2NoZWNrRW50aXR5VHlwZShlbnRpdHkpO1xyXG4gICAgbGV0IGVzU3ltYm9sID0gYXNzZXJ0UGFyYW0oZW50aXR5U3RhdGUsIFwiZW50aXR5U3RhdGVcIikuaXNFbnVtT2YoRW50aXR5U3RhdGUpLmlzT3B0aW9uYWwoKS5jaGVjayhFbnRpdHlTdGF0ZS5VbmNoYW5nZWQpIGFzIEVudGl0eVN0YXRlO1xyXG4gICAgbGV0IG1zU3ltYm9sID0gYXNzZXJ0UGFyYW0obWVyZ2VTdHJhdGVneSwgXCJtZXJnZVN0cmF0ZWd5XCIpLmlzRW51bU9mKE1lcmdlU3RyYXRlZ3kpLmlzT3B0aW9uYWwoKS5jaGVjayhNZXJnZVN0cmF0ZWd5LkRpc2FsbG93ZWQpIGFzIE1lcmdlU3RyYXRlZ3k7XHJcblxyXG4gICAgaWYgKGVudGl0eS5lbnRpdHlUeXBlLm1ldGFkYXRhU3RvcmUgIT09IHRoaXMubWV0YWRhdGFTdG9yZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXR0YWNoIHRoaXMgZW50aXR5IGJlY2F1c2UgdGhlIEVudGl0eVR5cGUgKFwiICsgZW50aXR5LmVudGl0eVR5cGUubmFtZSArXHJcbiAgICAgICAgXCIpIGFuZCBNZXRhZGF0YVN0b3JlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGVudGl0eSBkb2VzIG5vdCBtYXRjaCB0aGlzIEVudGl0eU1hbmFnZXIncyBNZXRhZGF0YVN0b3JlLlwiKTtcclxuICAgIH1cclxuICAgIGxldCBhc3BlY3QgPSBlbnRpdHkuZW50aXR5QXNwZWN0O1xyXG4gICAgaWYgKGFzcGVjdCkge1xyXG4gICAgICAvLyB0byBhdm9pZCByZWF0dGFjaGluZyBhbiBlbnRpdHkgaW4gcHJvZ3Jlc3NcclxuICAgICAgaWYgKGFzcGVjdC5faW5Qcm9jZXNzRW50aXR5KSByZXR1cm4gYXNwZWN0Ll9pblByb2Nlc3NFbnRpdHk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB0aGlzIG9jY3VyJ3Mgd2hlbiBhdHRhY2hpbmcgYW4gZW50aXR5IGNyZWF0ZWQgdmlhIG5ldyBpbnN0ZWFkIG9mIHZpYSBjcmVhdGVFbnRpdHkuXHJcbiAgICAgIGFzcGVjdCA9IG5ldyBFbnRpdHlBc3BlY3QoZW50aXR5KTtcclxuICAgIH1cclxuICAgIGxldCBtYW5hZ2VyID0gYXNwZWN0LmVudGl0eU1hbmFnZXI7XHJcbiAgICBpZiAobWFuYWdlcikge1xyXG4gICAgICBpZiAobWFuYWdlciA9PT0gdGhpcykge1xyXG4gICAgICAgIHJldHVybiBlbnRpdHk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnRpdHkgYWxyZWFkeSBiZWxvbmdzIHRvIGFub3RoZXIgRW50aXR5TWFuYWdlclwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBhdHRhY2hlZEVudGl0eSA9IHt9IGFzIEVudGl0eTtcclxuICAgIGNvcmUudXNpbmcodGhpcywgXCJpc0xvYWRpbmdcIiwgdHJ1ZSwgKCkgPT4ge1xyXG4gICAgICBpZiAoZXNTeW1ib2wuaXNBZGRlZCgpKSB7XHJcbiAgICAgICAgY2hlY2tFbnRpdHlLZXkodGhpcywgZW50aXR5KTtcclxuICAgICAgfVxyXG4gICAgICAvLyBhdHRhY2hlZEVudGl0eSA9PT0gZW50aXR5IEVYQ0VQVCBpbiB0aGUgY2FzZSBvZiBhIG1lcmdlLlxyXG4gICAgICBhdHRhY2hlZEVudGl0eSA9IHRoaXMuX2F0dGFjaEVudGl0eUNvcmUoZW50aXR5LCBlc1N5bWJvbCwgbXNTeW1ib2wpO1xyXG4gICAgICBhc3BlY3QuX2luUHJvY2Vzc0VudGl0eSA9IGF0dGFjaGVkRW50aXR5O1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIGVudGl0eSAoIG5vdCBhdHRhY2hlZEVudGl0eSkgaXMgZGVsaWJlcmF0ZSBoZXJlLlxyXG4gICAgICAgIGF0dGFjaFJlbGF0ZWRFbnRpdGllcyh0aGlzLCBlbnRpdHksIGVzU3ltYm9sLCBtc1N5bWJvbCk7XHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgLy8gaW5zdXJlIHRoYXQgX2luUHJvY2Vzc0VudGl0eSBpcyBjbGVhcmVkLlxyXG4gICAgICAgIGFzcGVjdC5faW5Qcm9jZXNzRW50aXR5ID0gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIGlmICh0aGlzLnZhbGlkYXRpb25PcHRpb25zLnZhbGlkYXRlT25BdHRhY2gpIHtcclxuICAgICAgYXR0YWNoZWRFbnRpdHkuZW50aXR5QXNwZWN0LnZhbGlkYXRlRW50aXR5KCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWVzU3ltYm9sLmlzVW5jaGFuZ2VkKCkpIHtcclxuICAgICAgdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2UoYXR0YWNoZWRFbnRpdHksIHRydWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lbnRpdHlDaGFuZ2VkLnB1Ymxpc2goeyBlbnRpdHlBY3Rpb246IEVudGl0eUFjdGlvbi5BdHRhY2gsIGVudGl0eTogYXR0YWNoZWRFbnRpdHkgfSk7XHJcblxyXG4gICAgcmV0dXJuIGF0dGFjaGVkRW50aXR5O1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gIERldGFjaGVzIGFuIGVudGl0eSBmcm9tIHRoaXMgRW50aXR5TWFuYWdlci5cclxuICA+ICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXIgY29udGFpbmluZyBhIG51bWJlciBvZiBleGlzdGluZyBlbnRpdGllcy5cclxuICA+ICAgICAvLyBhc3N1bWUgY3VzdDEgaXMgYSBjdXN0b21lciBFbnRpdHkgcHJldmlvdXNseSBhdHRhY2hlZCB0byBlbTFcclxuICA+ICAgICBlbTEuZGV0YWNoRW50aXR5KGN1c3QxKTtcclxuICA+ICAgICAvLyBlbTEgd2lsbCBub3cgbm8gbG9uZ2VyIGNvbnRhaW4gY3VzdDEgYW5kIGN1c3QxIHdpbGwgaGF2ZSBhblxyXG4gID4gICAgIC8vIGVudGl0eUFzcGVjdC5lbnRpdHlTdGF0ZSBvZiBFbnRpdHlTdGF0ZS5EZXRhY2hlZFxyXG4gIEBwYXJhbSBlbnRpdHkgLSBUaGUgZW50aXR5IHRvIGRldGFjaC5cclxuICBAcmV0dXJuIFdoZXRoZXIgdGhlIGVudGl0eSBjb3VsZCBiZSBkZXRhY2hlZC4gVGhpcyB3aWxsIHJldHVybiBmYWxzZSBpZiB0aGUgZW50aXR5IGlzIGFscmVhZHkgZGV0YWNoZWQgb3Igd2FzIG5ldmVyIGF0dGFjaGVkLlxyXG4gICoqL1xyXG4gIGRldGFjaEVudGl0eShlbnRpdHk6IEVudGl0eSkge1xyXG4gICAgYXNzZXJ0UGFyYW0oZW50aXR5LCBcImVudGl0eVwiKS5pc0VudGl0eSgpLmNoZWNrKCk7XHJcbiAgICBsZXQgYXNwZWN0ID0gZW50aXR5LmVudGl0eUFzcGVjdDtcclxuICAgIGlmICghYXNwZWN0KSB7XHJcbiAgICAgIC8vIG5vIGFzcGVjdCBtZWFucyBpbiBjb3VsZG4ndCBhcHBlYXIgaW4gYW55IGdyb3VwXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYXNwZWN0LmVudGl0eU1hbmFnZXIgIT09IHRoaXMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnRpdHkgZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgRW50aXR5TWFuYWdlci5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXNwZWN0LnNldERldGFjaGVkKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBGZXRjaGVzIHRoZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIEVudGl0eU1hbmFnZXIncyBjdXJyZW50ICdzZXJ2aWNlTmFtZScuICBUaGlzIGNhbGxcclxuICBvY2N1cnMgaW50ZXJuYWxseSBiZWZvcmUgdGhlIGZpcnN0IHF1ZXJ5IHRvIGFueSBzZXJ2aWNlIGlmIHRoZSBtZXRhZGF0YSBoYXNuJ3QgYWxyZWFkeSBiZWVuXHJcbiAgbG9hZGVkLiBfX0FzeW5jX19cclxuXHJcbiAgVXN1YWxseSB5b3Ugd2lsbCBub3QgYWN0dWFsbHkgcHJvY2VzcyB0aGUgcmVzdWx0cyBvZiBhIGZldGNoTWV0YWRhdGEgY2FsbCBkaXJlY3RseSwgYnV0IHdpbGwgaW5zdGVhZFxyXG4gIGFzayBmb3IgdGhlIG1ldGFkYXRhIGZyb20gdGhlIEVudGl0eU1hbmFnZXIgYWZ0ZXIgdGhlIGZldGNoTWV0YWRhdGEgY2FsbCByZXR1cm5zLlxyXG4gID4gICAgIGxldCBlbTEgPSBuZXcgRW50aXR5TWFuYWdlciggXCJicmVlemUvTm9ydGh3aW5kSUJNb2RlbFwiKTtcclxuICA+ICAgICBlbTEuZmV0Y2hNZXRhZGF0YSgpXHJcbiAgPiAgICAgICAudGhlbihmdW5jdGlvbigpIHtcclxuICA+ICAgICAgICAgICBsZXQgbWV0YWRhdGFTdG9yZSA9IGVtMS5tZXRhZGF0YVN0b3JlO1xyXG4gID4gICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBtZXRhZGF0YVxyXG4gID4gICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXhjZXB0aW9uKSB7XHJcbiAgPiAgICAgICAgICAgLy8gaGFuZGxlIGV4Y2VwdGlvbiBoZXJlXHJcbiAgPiAgICAgICB9KTtcclxuICBcclxuICBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiBjYWxsZWQgb24gc3VjY2Vzcy5cclxuICBAcGFyYW0gZXJyb3JDYWxsYmFjayAtIEZ1bmN0aW9uIGNhbGxlZCBvbiBmYWlsdXJlLlxyXG4gIEByZXR1cm4ge1Byb21pc2V9XHJcbiAgICAtIHNjaGVtYSB7T2JqZWN0fSBUaGUgcmF3IFNjaGVtYSBvYmplY3QgZnJvbSBtZXRhZGF0YSBwcm92aWRlciAtIEJlY2F1c2UgdGhpcyBzY2hlbWEgd2lsbCBkaWZmZXIgZGVwZW5kaW5nIG9uIHRoZSBtZXRhZGF0YSBwcm92aWRlclxyXG4gICAgICAgIGl0IGlzIHVzdWFsbHkgYmV0dGVyIHRvIGFjY2VzcyBtZXRhZGF0YSB2aWEgdGhlICdtZXRhZGF0YVN0b3JlJyBwcm9wZXJ0eSBvZiB0aGUgRW50aXR5TWFuYWdlciBpbnN0ZWFkIG9mIHVzaW5nIHRoaXMgJ3JhdycgZGF0YS5cclxuICAqKi9cclxuICBmZXRjaE1ldGFkYXRhKGRhdGFTZXJ2aWNlPzogRGF0YVNlcnZpY2UsIGNhbGxiYWNrPzogQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s/OiBFcnJvckNhbGxiYWNrKSB7XHJcbiAgICBpZiAodHlwZW9mIChkYXRhU2VydmljZSkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAvLyBsZWdhY3kgc3VwcG9ydCBmb3Igd2hlbiBkYXRhU2VydmljZSB3YXMgbm90IGFuIGFyZy4gaS5lLiBmaXJzdCBhcmcgd2FzIGNhbGxiYWNrXHJcbiAgICAgIGVycm9yQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgY2FsbGJhY2sgPSBkYXRhU2VydmljZTtcclxuICAgICAgZGF0YVNlcnZpY2UgPSB1bmRlZmluZWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhc3NlcnRQYXJhbShkYXRhU2VydmljZSwgXCJkYXRhU2VydmljZVwiKS5pc0luc3RhbmNlT2YoRGF0YVNlcnZpY2UpLmlzT3B0aW9uYWwoKS5jaGVjaygpO1xyXG4gICAgICBhc3NlcnRQYXJhbShjYWxsYmFjaywgXCJjYWxsYmFja1wiKS5pc0Z1bmN0aW9uKCkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcbiAgICAgIGFzc2VydFBhcmFtKGVycm9yQ2FsbGJhY2ssIFwiZXJyb3JDYWxsYmFja1wiKS5pc0Z1bmN0aW9uKCkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHByb21pc2UgPSB0aGlzLm1ldGFkYXRhU3RvcmUuZmV0Y2hNZXRhZGF0YShkYXRhU2VydmljZSB8fCB0aGlzLmRhdGFTZXJ2aWNlKTtcclxuICAgIHJldHVybiBwcm9taXNlV2l0aENhbGxiYWNrcyhwcm9taXNlLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuXHJcbiAgZXhlY3V0ZVF1ZXJ5KHF1ZXJ5OiBzdHJpbmcsIGNhbGxiYWNrPzogUXVlcnlTdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s/OiBRdWVyeUVycm9yQ2FsbGJhY2spOiBQcm9taXNlPFF1ZXJ5UmVzdWx0PjtcclxuICBleGVjdXRlUXVlcnkocXVlcnk6IEVudGl0eVF1ZXJ5LCBjYWxsYmFjaz86IFF1ZXJ5U3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrPzogUXVlcnlFcnJvckNhbGxiYWNrKTogUHJvbWlzZTxRdWVyeVJlc3VsdD47XHJcbiAgLyoqXHJcbiAgRXhlY3V0ZXMgdGhlIHNwZWNpZmllZCBxdWVyeS4gX19Bc3luY19fIFxyXG4gIFxyXG4gID4gICAgIGxldCBlbSA9IG5ldyBFbnRpdHlNYW5hZ2VyKHNlcnZpY2VOYW1lKTtcclxuICA+ICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJPcmRlcnNcIik7XHJcbiAgPiAgICAgZW0uZXhlY3V0ZVF1ZXJ5KHF1ZXJ5KS50aGVuKCBmdW5jdGlvbihkYXRhKSB7XHJcbiAgPiAgICAgICAgIGxldCBvcmRlcnMgPSBkYXRhLnJlc3VsdHM7XHJcbiAgPiAgICAgICAgIC4uLiBxdWVyeSByZXN1bHRzIHByb2Nlc3NlZCBoZXJlXHJcbiAgPiAgICAgfSkuY2F0Y2goIGZ1bmN0aW9uKGVycikge1xyXG4gID4gICAgICAgICAuLi4gcXVlcnkgZmFpbHVyZSBwcm9jZXNzZWQgaGVyZVxyXG4gID4gICAgIH0pO1xyXG5cclxuICBvciB3aXRoIGNhbGxiYWNrc1xyXG4gID4gICAgIGxldCBlbSA9IG5ldyBFbnRpdHlNYW5hZ2VyKHNlcnZpY2VOYW1lKTtcclxuICA+ICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJPcmRlcnNcIik7XHJcbiAgPiAgICAgZW0uZXhlY3V0ZVF1ZXJ5KHF1ZXJ5LFxyXG4gID4gICAgICAgICBmdW5jdGlvbihkYXRhKSB7XHJcbiAgPiAgICAgICAgICAgICBsZXQgb3JkZXJzID0gZGF0YS5yZXN1bHRzO1xyXG4gID4gICAgICAgICAgICAgLi4uIHF1ZXJ5IHJlc3VsdHMgcHJvY2Vzc2VkIGhlcmVcclxuICA+ICAgICAgICAgfSxcclxuICA+ICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XHJcbiAgPiAgICAgICAgICAgICAuLi4gcXVlcnkgZmFpbHVyZSBwcm9jZXNzZWQgaGVyZVxyXG4gID4gICAgICAgICB9KTtcclxuXHJcbiAgRWl0aGVyIHdheSB0aGlzIG1ldGhvZCBpcyB0aGUgc2FtZSBhcyBjYWxsaW5nIHRoZSBUaGUgW1tFbnRpdHlRdWVyeV1dICdleGVjdXRlJyBtZXRob2QuXHJcbiAgPiAgICAgbGV0IGVtID0gbmV3IEVudGl0eU1hbmFnZXIoc2VydmljZU5hbWUpO1xyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIk9yZGVyc1wiKS51c2luZyhlbSk7XHJcbiAgPiAgICAgcXVlcnkuZXhlY3V0ZSgpLnRoZW4oIGZ1bmN0aW9uKGRhdGEpIHtcclxuICA+ICAgICAgICAgbGV0IG9yZGVycyA9IGRhdGEucmVzdWx0cztcclxuICA+ICAgICAgICAgLi4uIHF1ZXJ5IHJlc3VsdHMgcHJvY2Vzc2VkIGhlcmVcclxuICA+ICAgICB9KS5jYXRjaCggZnVuY3Rpb24oZXJyKSB7XHJcbiAgPiAgICAgICAgIC4uLiBxdWVyeSBmYWlsdXJlIHByb2Nlc3NlZCBoZXJlXHJcbiAgPiAgICAgfSk7XHJcbiAgQHBhcmFtIHF1ZXJ5IC0gVGhlIFtbRW50aXR5UXVlcnldXSBvciBPRGF0YSBxdWVyeSBzdHJpbmcgdG8gZXhlY3V0ZS5cclxuICBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiBjYWxsZWQgb24gc3VjY2Vzcy5cclxuICBAcGFyYW0gZXJyb3JDYWxsYmFjayAtIHtGdW5jdGlvbn0gRnVuY3Rpb24gY2FsbGVkIG9uIGZhaWx1cmUuXHJcbiAgQHJldHVybiBQcm9taXNlIG9mIFxyXG4gICAgLSByZXN1bHRzIC0gQW4gYXJyYXkgb2YgZW50aXRpZXNcclxuICAgIC0gcmV0cmlldmVkRW50aXRpZXMgLSBBIGFycmF5IG9mIGFsbCBvZiB0aGUgZW50aXRpZXMgcmV0dXJuZWQgYnkgdGhlIHF1ZXJ5LiAgRGlmZmVycyBmcm9tIHJlc3VsdHMgKGFib3ZlKSB3aGVuIC5leHBhbmQoKSBpcyB1c2VkLlxyXG4gICAgLSBxdWVyeSAtIFRoZSBvcmlnaW5hbCBbW0VudGl0eVF1ZXJ5XV0gb3IgcXVlcnkgc3RyaW5nXHJcbiAgICAtIGVudGl0eU1hbmFnZXIgLSAgVGhlIEVudGl0eU1hbmFnZXIuXHJcbiAgICAtIGh0dHBSZXNwb25zZSAtIFRoZSBbW0lIdHRwUmVzcG9uc2VdXSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAtIGlubGluZUNvdW50IC0gIE9ubHkgYXZhaWxhYmxlIGlmICdpbmxpbmVDb3VudCh0cnVlKScgd2FzIGFwcGxpZWQgdG8gdGhlIHF1ZXJ5LiAgUmV0dXJucyB0aGUgY291bnQgb2ZcclxuICAgIGl0ZW1zIHRoYXQgd291bGQgaGF2ZSBiZWVuIHJldHVybmVkIGJ5IHRoZSBxdWVyeSBiZWZvcmUgYXBwbHlpbmcgYW55IHNraXAgb3IgdGFrZSBvcGVyYXRvcnMsIGJ1dCBhZnRlciBhbnkgZmlsdGVyL3doZXJlIHByZWRpY2F0ZXNcclxuICAgIHdvdWxkIGhhdmUgYmVlbiBhcHBsaWVkLlxyXG4gICoqL1xyXG4gIGV4ZWN1dGVRdWVyeShxdWVyeTogRW50aXR5UXVlcnkgfCBzdHJpbmcsIGNhbGxiYWNrPzogUXVlcnlTdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s/OiBRdWVyeUVycm9yQ2FsbGJhY2spIHtcclxuICAgIGFzc2VydFBhcmFtKHF1ZXJ5LCBcInF1ZXJ5XCIpLmlzSW5zdGFuY2VPZihFbnRpdHlRdWVyeSkub3IoKS5pc1N0cmluZygpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShjYWxsYmFjaywgXCJjYWxsYmFja1wiKS5pc0Z1bmN0aW9uKCkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShlcnJvckNhbGxiYWNrLCBcImVycm9yQ2FsbGJhY2tcIikuaXNGdW5jdGlvbigpLmlzT3B0aW9uYWwoKS5jaGVjaygpO1xyXG4gICAgbGV0IHByb21pc2U6IFByb21pc2U8YW55PjtcclxuICAgIC8vICdyZXNvbHZlJyBtZXRob2RzIGNyZWF0ZSBhIG5ldyB0eXBlZCBvYmplY3Qgd2l0aCBhbGwgb2YgaXRzIHByb3BlcnRpZXMgZnVsbHkgcmVzb2x2ZWQgYWdhaW5zdCBhIGxpc3Qgb2Ygc291cmNlcy5cclxuICAgIC8vIFRob3VnaHQgYWJvdXQgY3JlYXRpbmcgYSAnbm9ybWFsaXplZCcgcXVlcnkgd2l0aCB0aGVzZSAncmVzb2x2ZWQnIG9iamVjdHNcclxuICAgIC8vIGJ1dCBkZWNpZGVkIG5vdCB0byBiZWNhdXNlIHRoZSAncXVlcnknIG1heSBub3QgYmUgYW4gRW50aXR5UXVlcnkgKGl0IGNhbiBiZSBhIHN0cmluZykgYW5kIGhlbmNlIG1pZ2h0IG5vdCBoYXZlIGEgcXVlcnlPcHRpb25zIG9yIGRhdGFTZXJ2aWNlcyBwcm9wZXJ0eSBvbiBpdC5cclxuICAgIGxldCBxdWVyeU9wdGlvbnMgPSBRdWVyeU9wdGlvbnMucmVzb2x2ZShbKHF1ZXJ5IGFzIGFueSkucXVlcnlPcHRpb25zLCB0aGlzLnF1ZXJ5T3B0aW9ucywgUXVlcnlPcHRpb25zLmRlZmF1bHRJbnN0YW5jZV0pO1xyXG4gICAgbGV0IGRhdGFTZXJ2aWNlID0gRGF0YVNlcnZpY2UucmVzb2x2ZShbKHF1ZXJ5IGFzIGFueSkuZGF0YVNlcnZpY2UhLCB0aGlzLmRhdGFTZXJ2aWNlXSk7XHJcblxyXG4gICAgaWYgKCghZGF0YVNlcnZpY2UuaGFzU2VydmVyTWV0YWRhdGEpIHx8IHRoaXMubWV0YWRhdGFTdG9yZS5oYXNNZXRhZGF0YUZvcihkYXRhU2VydmljZS5zZXJ2aWNlTmFtZSkpIHtcclxuICAgICAgcHJvbWlzZSA9IGV4ZWN1dGVRdWVyeUNvcmUodGhpcywgcXVlcnksIHF1ZXJ5T3B0aW9ucywgZGF0YVNlcnZpY2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcHJvbWlzZSA9IHRoaXMuZmV0Y2hNZXRhZGF0YShkYXRhU2VydmljZSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGVRdWVyeUNvcmUodGhpcywgcXVlcnksIHF1ZXJ5T3B0aW9ucywgZGF0YVNlcnZpY2UpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcHJvbWlzZVdpdGhDYWxsYmFja3MocHJvbWlzZSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2sgYXMgRXJyb3JDYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBFeGVjdXRlcyB0aGUgc3BlY2lmaWVkIHF1ZXJ5IGFnYWluc3QgdGhpcyBFbnRpdHlNYW5hZ2VyJ3MgbG9jYWwgY2FjaGUuXHJcblxyXG4gIEJlY2F1c2UgdGhpcyBtZXRob2QgaXMgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgdGhlcmUgaXMgbm8gbmVlZCBmb3IgYSBwcm9taXNlIG9yIGEgY2FsbGJhY2tcclxuICA+ICAgICBsZXQgZW0gPSBuZXcgRW50aXR5TWFuYWdlcihzZXJ2aWNlTmFtZSk7XHJcbiAgPiAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiT3JkZXJzXCIpO1xyXG4gID4gICAgIGxldCBvcmRlcnMgPSBlbS5leGVjdXRlUXVlcnlMb2NhbGx5KHF1ZXJ5KTtcclxuXHJcbiAgTm90ZSB0aGF0IHRoaXMgY2FuIGFsc28gYmUgYWNjb21wbGlzaGVkIHVzaW5nIHRoZSAnZXhlY3V0ZVF1ZXJ5JyBtZXRob2Qgd2l0aFxyXG4gIGEgRmV0Y2hTdHJhdGVneSBvZiBGcm9tTG9jYWxDYWNoZSBhbmQgbWFraW5nIHVzZSBvZiB0aGUgUHJvbWlzZSBvciBjYWxsYmFja1xyXG4gID4gICAgIGxldCBlbSA9IG5ldyBFbnRpdHlNYW5hZ2VyKHNlcnZpY2VOYW1lKTtcclxuICA+ICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJPcmRlcnNcIikudXNpbmcoRmV0Y2hTdHJhdGVneS5Gcm9tTG9jYWxDYWNoZSk7XHJcbiAgPiAgICAgZW0uZXhlY3V0ZVF1ZXJ5KHF1ZXJ5KS50aGVuKCBmdW5jdGlvbihkYXRhKSB7XHJcbiAgPiAgICAgICAgIGxldCBvcmRlcnMgPSBkYXRhLnJlc3VsdHM7XHJcbiAgPiAgICAgICAgIC4uLiBxdWVyeSByZXN1bHRzIHByb2Nlc3NlZCBoZXJlXHJcbiAgPiAgICAgfSkuY2F0Y2goIGZ1bmN0aW9uKGVycikge1xyXG4gID4gICAgICAgICAuLi4gcXVlcnkgZmFpbHVyZSBwcm9jZXNzZWQgaGVyZVxyXG4gID4gICAgIH0pO1xyXG4gIEBwYXJhbSBxdWVyeSAtIFRoZSBbW0VudGl0eVF1ZXJ5XV0gdG8gZXhlY3V0ZS5cclxuICBAcmV0dXJuICB7QXJyYXkgb2YgRW50aXR5fSAgQXJyYXkgb2YgZW50aXRpZXMgZnJvbSBjYWNoZSB0aGF0IHNhdGlzZnkgdGhlIHF1ZXJ5XHJcbiAgKiovXHJcbiAgZXhlY3V0ZVF1ZXJ5TG9jYWxseShxdWVyeTogRW50aXR5UXVlcnkpIHtcclxuICAgIHJldHVybiBleGVjdXRlUXVlcnlMb2NhbGx5Q29yZSh0aGlzLCBxdWVyeSkucmVzdWx0cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFNhdmVzIGVpdGhlciBhIGxpc3Qgb2Ygc3BlY2lmaWVkIGVudGl0aWVzIG9yIGFsbCBjaGFuZ2VkIGVudGl0aWVzIHdpdGhpbiB0aGlzIEVudGl0eU1hbmFnZXIuIElmIHRoZXJlIGFyZSBubyBjaGFuZ2VzIHRvIGFueSBvZiB0aGUgZW50aXRpZXNcclxuICBzcGVjaWZpZWQgdGhlbiB0aGVyZSB3aWxsIGJlIG5vIHNlcnZlciBzaWRlIGNhbGwgbWFkZSBidXQgYSB2YWxpZCAnZW1wdHknIHNhdmVSZXN1bHQgd2lsbCBzdGlsbCBiZSByZXR1cm5lZC4gX19Bc3luY19fXHJcblxyXG4gIE9mdGVuIHdlIHdpbGwgYmUgc2F2aW5nIGFsbCBvZiB0aGUgZW50aXRpZXMgd2l0aGluIGFuIEVudGl0eU1hbmFnZXIgdGhhdCBhcmUgZWl0aGVyIGFkZGVkLCBtb2RpZmllZCBvciBkZWxldGVkXHJcbiAgYW5kIHdlIHdpbGwgbGV0IHRoZSAnc2F2ZUNoYW5nZXMnIGNhbGwgZGV0ZXJtaW5lIHdoaWNoIGVudGl0aWVzIHRoZXNlIGFyZS5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcHJlZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIC8vIFRoaXMgY291bGQgaW5jbHVkZSBhZGRlZCwgbW9kaWZpZWQgYW5kIGRlbGV0ZWQgZW50aXRpZXMuXHJcbiAgPiAgICAgIGVtLnNhdmVDaGFuZ2VzKCkudGhlbihmdW5jdGlvbihzYXZlUmVzdWx0KSB7XHJcbiAgPiAgICAgICAgICBsZXQgc2F2ZWRFbnRpdGllcyA9IHNhdmVSZXN1bHQuZW50aXRpZXM7XHJcbiAgPiAgICAgICAgICBsZXQga2V5TWFwcGluZ3MgPSBzYXZlUmVzdWx0LmtleU1hcHBpbmdzO1xyXG4gID4gICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xyXG4gID4gICAgICAgICAgLy8gZSBpcyBhbnkgZXhjZXB0aW9uIHRoYXQgd2FzIHRocm93bi5cclxuICA+ICAgICAgfSk7XHJcblxyXG4gIEJ1dCB3ZSBjYW4gYWxzbyBjb250cm9sIGV4YWN0bHkgd2hpY2ggZW50aXRpZXMgdG8gc2F2ZSBhbmQgY2FuIHNwZWNpZnkgc3BlY2lmaWMgU2F2ZU9wdGlvbnNcclxuXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbnRpdGllc1RvU2F2ZSBpcyBhbiBhcnJheSBvZiBlbnRpdGllcyB0byBzYXZlLlxyXG4gID4gICAgICBsZXQgc2F2ZU9wdGlvbnMgPSBuZXcgU2F2ZU9wdGlvbnMoeyBhbGxvd0NvbmN1cnJlbnRTYXZlczogdHJ1ZSB9KTtcclxuICA+ICAgICAgZW0uc2F2ZUNoYW5nZXMoZW50aXRpZXNUb1NhdmUsIHNhdmVPcHRpb25zKS50aGVuKGZ1bmN0aW9uKHNhdmVSZXN1bHQpIHtcclxuICA+ICAgICAgICAgIGxldCBzYXZlZEVudGl0aWVzID0gc2F2ZVJlc3VsdC5lbnRpdGllcztcclxuICA+ICAgICAgICAgIGxldCBrZXlNYXBwaW5ncyA9IHNhdmVSZXN1bHQua2V5TWFwcGluZ3M7XHJcbiAgPiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgPiAgICAgICAgICAvLyBlIGlzIGFueSBleGNlcHRpb24gdGhhdCB3YXMgdGhyb3duLlxyXG4gID4gICAgICB9KTtcclxuXHJcbiAgQ2FsbGJhY2sgbWV0aG9kcyBjYW4gYWxzbyBiZSB1c2VkXHJcbiAgPiAgICAgIGVtLnNhdmVDaGFuZ2VzKGVudGl0aWVzVG9TYXZlLCBudWxsLFxyXG4gID4gICAgICAgICAgZnVuY3Rpb24oc2F2ZVJlc3VsdCkge1xyXG4gID4gICAgICAgICAgICAgIGxldCBzYXZlZEVudGl0aWVzID0gc2F2ZVJlc3VsdC5lbnRpdGllcztcclxuICA+ICAgICAgICAgICAgICBsZXQga2V5TWFwcGluZ3MgPSBzYXZlUmVzdWx0LmtleU1hcHBpbmdzO1xyXG4gID4gICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICA+ICAgICAgICAgICAgICAvLyBlIGlzIGFueSBleGNlcHRpb24gdGhhdCB3YXMgdGhyb3duLlxyXG4gID4gICAgICAgICAgfVxyXG4gID4gICAgICApO1xyXG5cclxuICBAcGFyYW0gZW50aXRpZXMgLSBUaGUgbGlzdCBvZiBlbnRpdGllcyB0byBzYXZlLlxyXG4gIEV2ZXJ5IGVudGl0eSBpbiB0aGF0IGxpc3Qgd2lsbCBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIsIHdoZXRoZXIgY2hhbmdlZCBvciB1bmNoYW5nZWQsXHJcbiAgYXMgbG9uZyBhcyBpdCBpcyBhdHRhY2hlZCB0byB0aGlzIEVudGl0eU1hbmFnZXIuXHJcbiAgSWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgbnVsbCBvciBlbXB0eSAodGhlIHVzdWFsIGNhc2UpLFxyXG4gIGV2ZXJ5IGVudGl0eSB3aXRoIHBlbmRpbmcgY2hhbmdlcyBpbiB0aGlzIEVudGl0eU1hbmFnZXIgd2lsbCBiZSBzYXZlZC5cclxuICBAcGFyYW0gc2F2ZU9wdGlvbnMgLSBbW1NhdmVPcHRpb25zXV0gZm9yIHRoZSBzYXZlIC0gd2lsbCBkZWZhdWx0IHRvXHJcbiAgW1tFbnRpdHlNYW5hZ2VyLnNhdmVPcHRpb25zXV0gaWYgbnVsbC5cclxuICBAcGFyYW0gY2FsbGJhY2sgLSAgRnVuY3Rpb24gY2FsbGVkIG9uIHN1Y2Nlc3MuXHJcbiAgQHBhcmFtIGVycm9yQ2FsbGJhY2sgLSBGdW5jdGlvbiBjYWxsZWQgb24gZmFpbHVyZS5cclxuICBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlXHJcbiAgKiovXHJcbiAgc2F2ZUNoYW5nZXMoZW50aXRpZXM/OiBFbnRpdHlbXSB8IG51bGwsIHNhdmVPcHRpb25zPzogU2F2ZU9wdGlvbnMsIGNhbGxiYWNrPzogRnVuY3Rpb24sIGVycm9yQ2FsbGJhY2s/OiBGdW5jdGlvbikge1xyXG4gICAgYXNzZXJ0UGFyYW0oZW50aXRpZXMsIFwiZW50aXRpZXNcIikuaXNPcHRpb25hbCgpLmlzQXJyYXkoKS5pc0VudGl0eSgpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShzYXZlT3B0aW9ucywgXCJzYXZlT3B0aW9uc1wiKS5pc0luc3RhbmNlT2YoU2F2ZU9wdGlvbnMpLmlzT3B0aW9uYWwoKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0oY2FsbGJhY2ssIFwiY2FsbGJhY2tcIikuaXNGdW5jdGlvbigpLmlzT3B0aW9uYWwoKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0oZXJyb3JDYWxsYmFjaywgXCJlcnJvckNhbGxiYWNrXCIpLmlzRnVuY3Rpb24oKS5pc09wdGlvbmFsKCkuY2hlY2soKTtcclxuXHJcbiAgICBzYXZlT3B0aW9ucyA9IHNhdmVPcHRpb25zIHx8IHRoaXMuc2F2ZU9wdGlvbnMgfHwgU2F2ZU9wdGlvbnMuZGVmYXVsdEluc3RhbmNlO1xyXG5cclxuICAgIGxldCBlbnRpdGllc1RvU2F2ZSA9IGdldEVudGl0aWVzVG9TYXZlKHRoaXMsIGVudGl0aWVzID8gZW50aXRpZXMgOiB1bmRlZmluZWQpO1xyXG5cclxuICAgIGlmIChlbnRpdGllc1RvU2F2ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgbGV0IHJlc3VsdCA9IHsgZW50aXRpZXM6IFtdLCBrZXlNYXBwaW5nczogW10gfSBhcyBTYXZlUmVzdWx0O1xyXG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHJlc3VsdCk7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNhdmVPcHRpb25zLmFsbG93Q29uY3VycmVudFNhdmVzKSB7XHJcbiAgICAgIGxldCBhbnlQZW5kaW5nU2F2ZXMgPSBlbnRpdGllc1RvU2F2ZS5zb21lKGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICByZXR1cm4gZW50aXR5LmVudGl0eUFzcGVjdC5pc0JlaW5nU2F2ZWQ7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoYW55UGVuZGluZ1NhdmVzKSB7XHJcbiAgICAgICAgbGV0IGVyciA9IG5ldyBFcnJvcihcIkNvbmN1cnJlbnQgc2F2ZXMgbm90IGFsbG93ZWQgLSBTYXZlT3B0aW9ucy5hbGxvd0NvbmN1cnJlbnRTYXZlcyBpcyBmYWxzZVwiKTtcclxuICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykgZXJyb3JDYWxsYmFjayhlcnIpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY2xlYXJTZXJ2ZXJFcnJvcnMoZW50aXRpZXNUb1NhdmUpO1xyXG5cclxuICAgIGxldCB2YWxFcnJvciA9IHRoaXMuc2F2ZUNoYW5nZXNWYWxpZGF0ZU9uQ2xpZW50KGVudGl0aWVzVG9TYXZlKTtcclxuICAgIGlmICh2YWxFcnJvcikge1xyXG4gICAgICBpZiAoZXJyb3JDYWxsYmFjaykgZXJyb3JDYWxsYmFjayh2YWxFcnJvcik7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2YWxFcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRhdGFTZXJ2aWNlID0gRGF0YVNlcnZpY2UucmVzb2x2ZShbc2F2ZU9wdGlvbnMuZGF0YVNlcnZpY2UsIHRoaXMuZGF0YVNlcnZpY2VdKTtcclxuICAgIGxldCBzYXZlQ29udGV4dDogU2F2ZUNvbnRleHQgPSB7XHJcbiAgICAgIGVudGl0eU1hbmFnZXI6IHRoaXMsXHJcbiAgICAgIGRhdGFTZXJ2aWNlOiBkYXRhU2VydmljZSxcclxuICAgICAgcHJvY2Vzc1NhdmVkRW50aXRpZXM6IHByb2Nlc3NTYXZlZEVudGl0aWVzLFxyXG4gICAgICByZXNvdXJjZU5hbWU6IHNhdmVPcHRpb25zLnJlc291cmNlTmFtZSB8fCB0aGlzLnNhdmVPcHRpb25zLnJlc291cmNlTmFtZSB8fCBcIlNhdmVDaGFuZ2VzXCJcclxuICAgIH07XHJcblxyXG4gICAgLy8gVE9ETzogbmVlZCB0byBjaGVjayB0aGF0IGlmIHdlIGFyZSBkb2luZyBhIHBhcnRpYWwgc2F2ZSB0aGF0IGFsbCBlbnRpdGllcyB3aG9zZSB0ZW1wIGtleXNcclxuICAgIC8vIGFyZSByZWZlcmVuY2VkIGFyZSBhbHNvIGluIHRoZSBwYXJ0aWFsIHNhdmUgZ3JvdXBcclxuXHJcbiAgICBsZXQgc2F2ZUJ1bmRsZSA9IHsgZW50aXRpZXM6IGVudGl0aWVzVG9TYXZlLCBzYXZlT3B0aW9uczogc2F2ZU9wdGlvbnMgfTtcclxuXHJcblxyXG4gICAgdHJ5IHsgLy8gR3VhcmQgYWdhaW5zdCBleGNlcHRpb24gdGhyb3duIGluIGRhdGFzZXJ2aWNlIGFkYXB0ZXIgYmVmb3JlIGl0IGdvZXMgYXN5bmNcclxuICAgICAgdXBkYXRlQ29uY3VycmVuY3lQcm9wZXJ0aWVzKGVudGl0aWVzVG9TYXZlKTtcclxuICAgICAgcmV0dXJuIGRhdGFTZXJ2aWNlLmFkYXB0ZXJJbnN0YW5jZSEuc2F2ZUNoYW5nZXMoc2F2ZUNvbnRleHQsIHNhdmVCdW5kbGUpXHJcbiAgICAgICAgLnRoZW4oc2F2ZVN1Y2Nlc3MpLnRoZW4oKHIpID0+IHIsIHNhdmVGYWlsKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAvLyB1bmRvIHRoZSBtYXJraW5nIGJ5IHVwZGF0ZUNvbmN1cnJlbmN5UHJvcGVydGllc1xyXG4gICAgICBtYXJrSXNCZWluZ1NhdmVkKGVudGl0aWVzVG9TYXZlLCBmYWxzZSk7XHJcbiAgICAgIGlmIChlcnJvckNhbGxiYWNrKSBlcnJvckNhbGxiYWNrKGVycik7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNhdmVTdWNjZXNzKHNhdmVSZXN1bHQ6IFNhdmVSZXN1bHQpIHtcclxuICAgICAgbGV0IGVtID0gc2F2ZUNvbnRleHQuZW50aXR5TWFuYWdlcjtcclxuICAgICAgbWFya0lzQmVpbmdTYXZlZChlbnRpdGllc1RvU2F2ZSwgZmFsc2UpO1xyXG4gICAgICBsZXQgc2F2ZWRFbnRpdGllcyA9IHNhdmVDb250ZXh0LnByb2Nlc3NTYXZlZEVudGl0aWVzKHNhdmVSZXN1bHQpO1xyXG4gICAgICBzYXZlUmVzdWx0LmVudGl0aWVzID0gc2F2ZWRFbnRpdGllcztcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSBfaGFzQ2hhbmdlcyBhZnRlciBzYXZlLlxyXG4gICAgICBlbS5fc2V0SGFzQ2hhbmdlcygpO1xyXG5cclxuICAgICAgLy8gY2FuJ3QgZG8gdGhpcyBhbnltb3JlIGJlY2F1c2Ugb3RoZXIgY2hhbmdlcyBtaWdodCBoYXZlIGJlZW4gbWFkZSB3aGlsZSBzYXZlZCBlbnRpdGllcyBpbiBmbGlnaHQuXHJcbiAgICAgIC8vICAgICAgbGV0IGhhc0NoYW5nZXMgPSAoaXNGdWxsU2F2ZSAmJiBoYXZlU2FtZUNvbnRlbnRzKGVudGl0aWVzVG9TYXZlLCBzYXZlZEVudGl0aWVzKSkgPyBmYWxzZSA6IG51bGw7XHJcbiAgICAgIC8vICAgICAgZW0uX3NldEhhc0NoYW5nZXMoaGFzQ2hhbmdlcyk7XHJcblxyXG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHNhdmVSZXN1bHQpO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNhdmVSZXN1bHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTYXZlZEVudGl0aWVzKHNhdmVSZXN1bHQ6IFNhdmVSZXN1bHQpIHtcclxuICAgICAgbGV0IHNhdmVkRW50aXRpZXMgPSBzYXZlUmVzdWx0LmVudGl0aWVzO1xyXG4gICAgICBsZXQgZGVsZXRlZEtleXMgPSBzYXZlUmVzdWx0LmRlbGV0ZWRLZXlzIHx8IFtdO1xyXG4gICAgICBpZiAoc2F2ZWRFbnRpdGllcy5sZW5ndGggPT09IDAgJiYgZGVsZXRlZEtleXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBrZXlNYXBwaW5ncyA9IHNhdmVSZXN1bHQua2V5TWFwcGluZ3M7XHJcbiAgICAgIGxldCBlbSA9IHNhdmVDb250ZXh0LmVudGl0eU1hbmFnZXI7XHJcblxyXG4gICAgICAvLyBtdXN0IG9jY3VyIG91dHNpZGUgb2YgaXNMb2FkaW5nIGJsb2NrXHJcbiAgICAgIGZpeHVwS2V5cyhlbSwga2V5TWFwcGluZ3MpO1xyXG5cclxuICAgICAgY29yZS51c2luZyhlbSwgXCJpc0xvYWRpbmdcIiwgdHJ1ZSwgKCkgPT4ge1xyXG5cclxuICAgICAgICBsZXQgbWFwcGluZ0NvbnRleHQgPSBuZXcgTWFwcGluZ0NvbnRleHQoe1xyXG4gICAgICAgICAgcXVlcnk6IHVuZGVmaW5lZCwgLy8gdGVsbHMgdmlzaXRBbmRNZXJnZSB0aGlzIGlzIGEgc2F2ZSBpbnN0ZWFkIG9mIGEgcXVlcnlcclxuICAgICAgICAgIGVudGl0eU1hbmFnZXI6IGVtLFxyXG4gICAgICAgICAgbWVyZ2VPcHRpb25zOiB7IG1lcmdlU3RyYXRlZ3k6IE1lcmdlU3RyYXRlZ3kuT3ZlcndyaXRlQ2hhbmdlcyB9LFxyXG4gICAgICAgICAgZGF0YVNlcnZpY2U6IGRhdGFTZXJ2aWNlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFRoZSB2aXNpdEFuZE1lcmdlIG9wZXJhdGlvbiBoYXMgYmVlbiBvcHRpbWl6ZWQgc28gdGhhdCB3ZSBkbyBub3QgYWN0dWFsbHkgcGVyZm9ybSBhIG1lcmdlIGlmIHRoZVxyXG4gICAgICAgIC8vIHRoZSBzYXZlIG9wZXJhdGlvbiBkaWQgbm90IGFjdHVhbGx5IHJldHVybiB0aGUgZW50aXR5IC0gaS5lLiBkdXJpbmcgT0RhdGEgYW5kIE1vbmdvIHVwZGF0ZXMgYW5kIGRlbGV0ZXMuXHJcbiAgICAgICAgc2F2ZWRFbnRpdGllcyA9IG1hcHBpbmdDb250ZXh0LnZpc2l0QW5kTWVyZ2Uoc2F2ZWRFbnRpdGllcywgeyBub2RlVHlwZTogXCJyb290XCIgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gZGV0YWNoIGFueSBlbnRpdGllcyBmb3VuZCBpbiB0aGUgZW0gdGhhdCBhcHBlYXIgaW4gdGhlIGRlbGV0ZWRLZXlzIGxpc3QuIFxyXG4gICAgICBkZWxldGVkS2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgbGV0IGVudGl0eVR5cGUgPSBlbS5tZXRhZGF0YVN0b3JlLl9nZXRTdHJ1Y3R1cmFsVHlwZShrZXkuZW50aXR5VHlwZU5hbWUpIGFzIEVudGl0eVR5cGU7XHJcbiAgICAgICAgbGV0IGVrZXkgPSBuZXcgRW50aXR5S2V5KGVudGl0eVR5cGUsIGtleS5rZXlWYWx1ZXMpO1xyXG4gICAgICAgIGxldCBlbnRpdHkgPSBlbS5maW5kRW50aXR5QnlLZXkoZWtleSk7XHJcbiAgICAgICAgaWYgKGVudGl0eSkge1xyXG4gICAgICAgICAgZW50aXR5LmVudGl0eUFzcGVjdC5zZXREZXRhY2hlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gc2F2ZWRFbnRpdGllcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzYXZlRmFpbChzZXJ2ZXJFcnJvcjogU2F2ZUVycm9yRnJvbVNlcnZlcikge1xyXG4gICAgICBtYXJrSXNCZWluZ1NhdmVkKGVudGl0aWVzVG9TYXZlLCBmYWxzZSk7XHJcbiAgICAgIGxldCBjbGllbnRFcnJvciA9IHByb2Nlc3NTZXJ2ZXJFcnJvcnMoc2F2ZUNvbnRleHQsIHNlcnZlckVycm9yKTtcclxuICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIGVycm9yQ2FsbGJhY2soY2xpZW50RXJyb3IpO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY2xpZW50RXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUnVuIHRoZSBcInNhdmVDaGFuZ2VzXCIgcHJlLXNhdmUgY2xpZW50IHZhbGlkYXRpb24gbG9naWMuXHJcbiAgXHJcbiAgVGhpcyBpcyBOT1QgYSBnZW5lcmFsIHB1cnBvc2UgdmFsaWRhdGlvbiBtZXRob2QuXHJcbiAgSXQgaXMgaW50ZW5kZWQgZm9yIHV0aWxpdGllcyB0aGF0IG11c3Qga25vdyBpZiBzYXZlQ2hhbmdlc1xyXG4gIHdvdWxkIHJlamVjdCB0aGUgc2F2ZSBkdWUgdG8gY2xpZW50IHZhbGlkYXRpb24gZXJyb3JzLlxyXG4gIFxyXG4gIEl0IG9ubHkgdmFsaWRhdGVzIGVudGl0aWVzIGlmIHRoZSBFbnRpdHlNYW5hZ2VyJ3NcclxuICBbW1ZhbGlkYXRpb25PcHRpb25zXV0udmFsaWRhdGVPblNhdmUgaXMgdHJ1ZS5cclxuICBcclxuICBAcGFyYW0gZW50aXRpZXNUb1NhdmUge0FycmF5IG9mIEVudGl0eX0gVGhlIGxpc3Qgb2YgZW50aXRpZXMgdG8gc2F2ZSAodG8gdmFsaWRhdGUpLlxyXG4gIEByZXR1cm4ge0Vycm9yfSBWYWxpZGF0aW9uIGVycm9yIG9yIG51bGwgaWYgbm8gZXJyb3JcclxuICAqKi9cclxuICBzYXZlQ2hhbmdlc1ZhbGlkYXRlT25DbGllbnQoZW50aXRpZXNUb1NhdmU6IEVudGl0eVtdKSB7XHJcblxyXG4gICAgaWYgKHRoaXMudmFsaWRhdGlvbk9wdGlvbnMudmFsaWRhdGVPblNhdmUpIHtcclxuICAgICAgbGV0IGZhaWxlZEVudGl0aWVzID0gZW50aXRpZXNUb1NhdmUuZmlsdGVyKGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICBsZXQgYXNwZWN0ID0gZW50aXR5LmVudGl0eUFzcGVjdDtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IGFzcGVjdC5lbnRpdHlTdGF0ZS5pc0RlbGV0ZWQoKSB8fCBhc3BlY3QudmFsaWRhdGVFbnRpdHkoKTtcclxuICAgICAgICByZXR1cm4gIWlzVmFsaWQ7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAoZmFpbGVkRW50aXRpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGxldCB2YWxFcnJvciA9IG5ldyBFcnJvcihcIkNsaWVudCBzaWRlIHZhbGlkYXRpb24gZXJyb3JzIGVuY291bnRlcmVkIC0gc2VlIHRoZSBlbnRpdHlFcnJvcnMgY29sbGVjdGlvbiBvbiB0aGlzIG9iamVjdCBmb3IgbW9yZSBkZXRhaWxcIik7XHJcbiAgICAgICAgKHZhbEVycm9yIGFzIGFueSkuZW50aXR5RXJyb3JzID0gY3JlYXRlRW50aXR5RXJyb3JzKGZhaWxlZEVudGl0aWVzKTtcclxuICAgICAgICByZXR1cm4gdmFsRXJyb3I7IC8vIFRPRE86IHR5cGUgdGhpcy5cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfZmluZEVudGl0eUdyb3VwKGVudGl0eVR5cGU6IEVudGl0eVR5cGUpIHtcclxuICAgIHJldHVybiB0aGlzLl9lbnRpdHlHcm91cE1hcFtlbnRpdHlUeXBlLm5hbWVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIHByZWV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgZW1wbG95ZWVUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkVtcGxveWVlXCIpO1xyXG4gID4gICAgICBsZXQgZW1wbG95ZWVLZXkgPSBuZXcgRW50aXR5S2V5KGVtcGxveWVlVHlwZSwgMSk7XHJcbiAgPiAgICAgIGxldCBlbXBsb3llZSA9IGVtMS5nZXRFbnRpdHlCeUtleShlbXBsb3llZUtleSk7XHJcbiAgPiAgICAgIC8vIGVtcGxveWVlIHdpbGwgZWl0aGVyIGJlIGFuIGVudGl0eSBvciBudWxsLlxyXG4gICoqL1xyXG4gIGdldEVudGl0eUJ5S2V5KGVudGl0eUtleTogRW50aXR5S2V5KTogRW50aXR5IHwgbnVsbDtcclxuXHJcbiAgLyoqICBcclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcHJlZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBlbXBsb3llZSA9IGVtMS5nZXRFbnRpdHlCeUtleShcIkVtcGxveWVlXCIsIDEpO1xyXG4gID4gICAgICAvLyBlbXBsb3llZSB3aWxsIGVpdGhlciBiZSBhbiBlbnRpdHkgb3IgbnVsbC5cclxuICAqKi9cclxuICBnZXRFbnRpdHlCeUtleSh0eXBlTmFtZTogc3RyaW5nLCBrZXlWYWx1ZXM6IGFueSB8IGFueVtdKTogRW50aXR5IHwgbnVsbDtcclxuXHJcbiAgLyoqICBcclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcHJlZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBlbXBsb3llZVR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiRW1wbG95ZWVcIik7XHJcbiAgPiAgICAgIGxldCBlbXBsb3llZSA9IGVtMS5nZXRFbnRpdHlCeUtleShlbXBsb3llZVR5cGUsIDEpO1xyXG4gID4gICAgICAvLyBlbXBsb3llZSB3aWxsIGVpdGhlciBiZSBhbiBlbnRpdHkgb3IgbnVsbC5cclxuICAqKi9cclxuICBnZXRFbnRpdHlCeUtleSh0eXBlOiBFbnRpdHlUeXBlLCBrZXlWYWx1ZXM6IGFueSB8IGFueVtdKTogRW50aXR5IHwgbnVsbDtcclxuXHJcbiAgLyoqICBcclxuICBBdHRlbXB0cyB0byBsb2NhdGUgYW4gZW50aXR5IHdpdGhpbiB0aGlzIEVudGl0eU1hbmFnZXIgYnkgaXRzIFtFbnRpdHlLZXldLlxyXG4gIEBwYXJhbSBlbnRpdHlLZXkgLSBUaGUgW1tFbnRpdHlLZXldXSBvZiB0aGUgRW50aXR5IHRvIGJlIGxvY2F0ZWQuXHJcbiAgQHBhcmFtIHR5cGUgLSBUaGUgW1tFbnRpdHlUeXBlXV0gZm9yIHRoaXMga2V5LlxyXG4gIEBwYXJhbSB0eXBlTmFtZSAtIFRoZSBFbnRpdHlUeXBlIG5hbWUgZm9yIHRoaXMga2V5LlxyXG4gIEBwYXJhbSBrZXlWYWx1ZXMgLSBUaGUgdmFsdWVzIGZvciB0aGlzIGtleSAtIHdpbGwgdXN1YWxseSBqdXN0IGJlIGEgc2luZ2xlIHZhbHVlOyBhbiBhcnJheSBpcyBvbmx5IG5lZWRlZCBmb3IgbXVsdGlwYXJ0IGtleXMuICBcclxuICBAcmV0dXJuIEFuIEVudGl0eSBvciBudWxsO1xyXG4gICoqL1xyXG4gIGdldEVudGl0eUJ5S2V5KC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBsZXQgZW50aXR5S2V5ID0gY3JlYXRlRW50aXR5S2V5KHRoaXMsIGFyZ3MpLmVudGl0eUtleTtcclxuICAgIGxldCBlbnRpdHlUeXBlcyA9IGVudGl0eUtleS5fc3VidHlwZXMgfHwgW2VudGl0eUtleS5lbnRpdHlUeXBlXTtcclxuICAgIGxldCBlOiBFbnRpdHkgfCB1bmRlZmluZWQ7XHJcbiAgICAvLyBoYWNrIHVzZSBvZiBzb21lIHRvIHNpbXVsYXRlIG1hcEZpcnN0IGxvZ2ljLlxyXG4gICAgZW50aXR5VHlwZXMuc29tZSgoZXQpID0+IHtcclxuICAgICAgbGV0IGdyb3VwID0gdGhpcy5fZmluZEVudGl0eUdyb3VwKGV0KTtcclxuICAgICAgLy8gZ3JvdXAgdmVyc2lvbiBvZiBmaW5kRW50aXR5QnlLZXkgZG9lc24ndCBjYXJlIGFib3V0IGVudGl0eVR5cGVcclxuICAgICAgZSA9IGdyb3VwICYmIGdyb3VwLmZpbmRFbnRpdHlCeUtleShlbnRpdHlLZXkpO1xyXG4gICAgICByZXR1cm4gZSAhPSBudWxsO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgZmV0Y2hFbnRpdHlCeUtleSh0eXBlTmFtZTogc3RyaW5nLCBrZXlWYWx1ZXM6IGFueSB8IGFueVtdLCBjaGVja0xvY2FsQ2FjaGVGaXJzdD86IGJvb2xlYW4pOiBQcm9taXNlPElFbnRpdHlCeUtleVJlc3VsdD47XHJcbiAgZmV0Y2hFbnRpdHlCeUtleShlbnRpdHlUeXBlOiBFbnRpdHlUeXBlLCBrZXlWYWx1ZXM6IGFueSB8IGFueVtdLCBjaGVja0xvY2FsQ2FjaGVGaXJzdD86IGJvb2xlYW4pOiBQcm9taXNlPElFbnRpdHlCeUtleVJlc3VsdD47XHJcbiAgZmV0Y2hFbnRpdHlCeUtleShlbnRpdHlLZXk6IEVudGl0eUtleSwgY2hlY2tMb2NhbENhY2hlRmlyc3Q/OiBib29sZWFuKTogUHJvbWlzZTxJRW50aXR5QnlLZXlSZXN1bHQ+O1xyXG4gIC8qKlxyXG4gIEF0dGVtcHRzIHRvIGZldGNoIGFuIGVudGl0eSBmcm9tIHRoZSBzZXJ2ZXIgYnkgaXRzIFtbRW50aXR5S2V5XV0gd2l0aFxyXG4gIGFuIG9wdGlvbiB0byBjaGVjayB0aGUgbG9jYWwgY2FjaGUgZmlyc3QuIE5vdGUgdGhlIHRoaXMgRW50aXR5TWFuYWdlcidzIHF1ZXJ5T3B0aW9ucy5tZXJnZVN0cmF0ZWd5XHJcbiAgd2lsbCBiZSB1c2VkIHRvIG1lcmdlIGFueSBzZXJ2ZXIgc2lkZSBlbnRpdHkgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QuXHJcbiAgPiAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcHJlZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgbGV0IGVtcGxveWVlVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJFbXBsb3llZVwiKTtcclxuICA+ICAgICBsZXQgZW1wbG95ZWVLZXkgPSBuZXcgRW50aXR5S2V5KGVtcGxveWVlVHlwZSwgMSk7XHJcbiAgPiAgICAgZW0xLmZldGNoRW50aXR5QnlLZXkoZW1wbG95ZWVLZXkpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgPiAgICAgICBsZXQgZW1wbG95ZWUgPSByZXN1bHQuZW50aXR5O1xyXG4gID4gICAgICAgbGV0IGVudGl0eUtleSA9IHJlc3VsdC5lbnRpdHlLZXk7XHJcbiAgPiAgICAgICBsZXQgZnJvbUNhY2hlID0gcmVzdWx0LmZyb21DYWNoZTtcclxuICA+ICAgICB9KTtcclxuICBAcGFyYW0gdHlwZU5hbWUgIC0gVGhlIEVudGl0eVR5cGUgbmFtZSBmb3IgdGhpcyBrZXkuXHJcbiAgQHBhcmFtIGVudGl0eVR5cGUgIC0gVGhlIEVudGl0eVR5cGUgZm9yIHRoaXMga2V5LlxyXG4gIEBwYXJhbSBrZXlWYWx1ZXMgLSBUaGUgdmFsdWVzIGZvciB0aGlzIGtleSAtIHdpbGwgdXN1YWxseSBqdXN0IGJlIGEgc2luZ2xlIHZhbHVlOyBhbiBhcnJheSBpcyBvbmx5IG5lZWRlZCBmb3IgbXVsdGlwYXJ0IGtleXMuXHJcbiAgQHBhcmFtIGVudGl0eUtleSAtIFRoZSBbW0VudGl0eUtleV1dIG9mIHRoZSBFbnRpdHkgdG8gYmUgbG9jYXRlZC5cclxuICBAcGFyYW0gY2hlY2tMb2NhbENhY2hlRmlyc3QgLSAoZGVmYXVsdCA9IGZhbHNlKSAtIFdoZXRoZXIgdG8gY2hlY2sgdGhpcyBFbnRpdHlNYW5hZ2VyIGZpcnN0IGJlZm9yZSBnb2luZyB0byB0aGUgc2VydmVyLiBCeSBkZWZhdWx0LCB0aGUgcXVlcnkgd2lsbCBOT1QgZG8gdGhpcy5cclxuICBAcmV0dXJuIHtQcm9taXNlfVxyXG4gICAgLSBQcm9wZXJ0aWVzIG9uIHRoZSBwcm9taXNlIHN1Y2Nlc3MgcmVzdWx0XHJcbiAgICAgIC0gZW50aXR5IHtPYmplY3R9IFRoZSBlbnRpdHkgcmV0dXJuZWQgb3IgbnVsbFxyXG4gICAgICAtIGVudGl0eUtleSB7RW50aXR5S2V5fSBUaGUgZW50aXR5S2V5IG9mIHRoZSBlbnRpdHkgdG8gZmV0Y2guXHJcbiAgICAgIC0gZnJvbUNhY2hlIHtCb29sZWFufSBXaGV0aGVyIHRoaXMgZW50aXR5IHdhcyBmZXRjaGVkIGZyb20gdGhlIHNlcnZlciBvciB3YXMgZm91bmQgaW4gdGhlIGxvY2FsIGNhY2hlLlxyXG4gICoqL1xyXG4gIGZldGNoRW50aXR5QnlLZXkoLi4uYXJnczogYW55W10pIHtcclxuICAgIGxldCBkYXRhU2VydmljZSA9IERhdGFTZXJ2aWNlLnJlc29sdmUoW3RoaXMuZGF0YVNlcnZpY2VdKTtcclxuICAgIGlmICgoIWRhdGFTZXJ2aWNlLmhhc1NlcnZlck1ldGFkYXRhKSB8fCB0aGlzLm1ldGFkYXRhU3RvcmUuaGFzTWV0YWRhdGFGb3IoZGF0YVNlcnZpY2Uuc2VydmljZU5hbWUpKSB7XHJcbiAgICAgIHJldHVybiBmZXRjaEVudGl0eUJ5S2V5Q29yZSh0aGlzLCBhcmdzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZldGNoTWV0YWRhdGEoZGF0YVNlcnZpY2UpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBmZXRjaEVudGl0eUJ5S2V5Q29yZSh0aGlzLCBhcmdzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBbRGVwcmVjYXRlZF0gLSBBdHRlbXB0cyB0byBsb2NhdGUgYW4gZW50aXR5IHdpdGhpbiB0aGlzIEVudGl0eU1hbmFnZXIgYnkgaXRzICBbW0VudGl0eUtleV1dLlxyXG4gID4gICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIHByZWV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgIGxldCBlbXBsb3llZVR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiRW1wbG95ZWVcIik7XHJcbiAgPiAgICAgbGV0IGVtcGxveWVlS2V5ID0gbmV3IEVudGl0eUtleShlbXBsb3llZVR5cGUsIDEpO1xyXG4gID4gICAgIGxldCBlbXBsb3llZSA9IGVtMS5maW5kRW50aXR5QnlLZXkoZW1wbG95ZWVLZXkpO1xyXG4gID4gICAgIC8vIGVtcGxveWVlIHdpbGwgZWl0aGVyIGJlIGFuIGVudGl0eSBvciBudWxsLlxyXG4gIEBkZXByZWNhdGVkICAgIFVzZSBnZXRFbnRpdHlCeUtleSBpbnN0ZWFkXHJcbiAgQHBhcmFtIGVudGl0eUtleSAtIFRoZSAgW1tFbnRpdHlLZXldXSBvZiB0aGUgRW50aXR5IHRvIGJlIGxvY2F0ZWQuXHJcbiAgQHJldHVybiBBbiBFbnRpdHkgb3IgbnVsbDtcclxuICAqKi9cclxuICBmaW5kRW50aXR5QnlLZXkoZW50aXR5S2V5OiBFbnRpdHlLZXkpIHtcclxuICAgIHJldHVybiB0aGlzLmdldEVudGl0eUJ5S2V5KGVudGl0eUtleSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBHZW5lcmF0ZXMgYSB0ZW1wb3Jhcnkga2V5IGZvciB0aGUgc3BlY2lmaWVkIGVudGl0eS4gIFRoaXMgaXMgdXNlZCB0byBpbnN1cmUgdGhhdCBuZXdseVxyXG4gIGNyZWF0ZWQgZW50aXRpZXMgaGF2ZSB1bmlxdWUga2V5cyBhbmQgdG8gcmVnaXN0ZXIgdGhhdCB0aGVzZSBrZXlzIGFyZSB0ZW1wb3JhcnkgYW5kXHJcbiAgbmVlZCB0byBiZSBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIHdpdGggJ3JlYWwnIGtleSB2YWx1ZXMgb25jZSB0aGVzZSBlbnRpdGllcyBhcmUgc2F2ZWQuXHJcbiAgXHJcbiAgVGhlIFtbRW50aXR5TWFuYWdlci5rZXlHZW5lcmF0b3JDdG9yXV0gcHJvcGVydHkgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoaXMgbWV0aG9kIHRvIGFjdHVhbGx5IGdlbmVyYXRlXHJcbiAgdGhlIGtleXMgLSBTZWUgdGhlICBLZXlHZW5lcmF0b3IgaW50ZXJmYWNlIGludGVyZmFjZSBkZXNjcmlwdGlvbiB0byBzZWVcclxuICBob3cgYSBjdXN0b20ga2V5IGdlbmVyYXRvciBjYW4gYmUgcGx1Z2dlZCBpbi5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcHJlZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICA+ICAgICAgbGV0IGN1c3RvbWVyID0gY3VzdFR5cGUuY3JlYXRlRW50aXR5KCk7XHJcbiAgPiAgICAgIGxldCBjdXN0b21lcklkID0gZW0uZ2VuZXJhdGVUZW1wS2V5VmFsdWUoY3VzdG9tZXIpO1xyXG4gID4gICAgICAvLyBUaGUgJ2N1c3RvbWVyJyBlbnRpdHkgJ0N1c3RvbWVySUQnIHByb3BlcnR5IGlzIG5vdyBzZXQgdG8gYSBuZXdseSBnZW5lcmF0ZWQgdW5pcXVlIGlkIHZhbHVlXHJcbiAgPiAgICAgIC8vIFRoaXMgcHJvcGVydHkgd2lsbCBjaGFuZ2UgYWdhaW4gYWZ0ZXIgYSBzdWNjZXNzZnVsIHNhdmUgb2YgdGhlICdjdXN0b21lcicgZW50aXR5LlxyXG4gID4gIFxyXG4gID4gICAgICBlbTEuc2F2ZUNoYW5nZXMoKS50aGVuKCBmdW5jdGlvbiggZGF0YSkge1xyXG4gID4gICAgICAgICAgbGV0IHNhbWVDdXN0MSA9IGRhdGEucmVzdWx0c1swXTtcclxuICA+ICAgICAgICAgIC8vIGN1c3QxID09PSBzYW1lQ3VzdDE7XHJcbiAgPiAgICAgICAgICAvLyBidXQgY3VzdDEuZ2V0UHJvcGVydHkoXCJDdXN0b21lcklkXCIpICE9IGN1c3RvbWVySWRcclxuICA+ICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHNlcnZlciB3aWxsIGhhdmUgZ2VuZXJhdGVkIGEgbmV3IGlkXHJcbiAgPiAgICAgICAgICAvLyBhbmQgdGhlIGNsaWVudCB3aWxsIGhhdmUgYmVlbiB1cGRhdGVkIHdpdGggdGhpc1xyXG4gID4gICAgICAgICAgLy8gbmV3IGlkLlxyXG4gID4gICAgICB9KVxyXG4gIEBwYXJhbSBlbnRpdHkgLSBUaGUgRW50aXR5IHRvIGdlbmVyYXRlIGEga2V5IGZvci5cclxuICBAcmV0dXJuIFRoZSBuZXcga2V5IHZhbHVlXHJcbiAgKiovXHJcbiAgZ2VuZXJhdGVUZW1wS2V5VmFsdWUoZW50aXR5OiBFbnRpdHkpIHtcclxuICAgIC8vIFRPRE8gLSBjaGVjayBpZiB0aGlzIGVudGl0eSBpcyBhdHRhY2hlZCB0byB0aGlzIEVudGl0eU1hbmFnZXIuXHJcbiAgICBhc3NlcnRQYXJhbShlbnRpdHksIFwiZW50aXR5XCIpLmlzRW50aXR5KCkuY2hlY2soKTtcclxuICAgIGxldCBlbnRpdHlUeXBlID0gZW50aXR5LmVudGl0eVR5cGU7XHJcbiAgICBsZXQgbmV4dEtleVZhbHVlID0gdGhpcy5rZXlHZW5lcmF0b3IuZ2VuZXJhdGVUZW1wS2V5VmFsdWUoZW50aXR5VHlwZSk7XHJcbiAgICBsZXQga2V5UHJvcCA9IGVudGl0eVR5cGUua2V5UHJvcGVydGllc1swXTtcclxuICAgIGVudGl0eS5zZXRQcm9wZXJ0eShrZXlQcm9wLm5hbWUsIG5leHRLZXlWYWx1ZSk7XHJcbiAgICBlbnRpdHkuZW50aXR5QXNwZWN0Lmhhc1RlbXBLZXkgPSB0cnVlO1xyXG4gICAgcmV0dXJuIG5leHRLZXlWYWx1ZTtcclxuICB9XHJcblxyXG4gIGhhc0NoYW5nZXMoKTogYm9vbGVhbjtcclxuICBoYXNDaGFuZ2VzKGVudGl0eVR5cGVOYW1lczogc3RyaW5nIHwgc3RyaW5nW10pOiBib29sZWFuO1xyXG4gIGhhc0NoYW5nZXMoZW50aXR5VHlwZXM6IEVudGl0eVR5cGUgfCBFbnRpdHlUeXBlW10pOiBib29sZWFuO1xyXG4gIC8qKlxyXG4gIFJldHVybnMgd2hldGhlciB0aGVyZSBhcmUgYW55IGNoYW5nZWQgZW50aXRpZXMgb2YgdGhlIHNwZWNpZmllZCBbW0VudGl0eVR5cGVdXXMuIEEgJ2NoYW5nZWQnIEVudGl0eSBoYXNcclxuICBoYXMgYW4gW1tFbnRpdHlTdGF0ZV1dIG9mIGVpdGhlciBBZGRlZCwgTW9kaWZpZWQgb3IgRGVsZXRlZC5cclxuXHJcbiAgVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGFuIEVudGl0eU1hbmFnZXIgaGFzIGFueSBjaGFuZ2VzXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIHByZWV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBpZiAoIGVtMS5oYXNDaGFuZ2VzKCkge1xyXG4gID4gICAgICAgICAgLy8gZG8gc29tZXRoaW5nIGludGVyZXN0aW5nXHJcbiAgPiAgICAgIH1cclxuXHJcbiAgb3IgaWYgaXQgaGFzIGFueSBjaGFuZ2VzIG9uIHRvIGEgc3BlY2lmaWMgW1tFbnRpdHlUeXBlXV0uXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIHByZWV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgPiAgICAgIGlmICggZW0xLmhhc0NoYW5nZXMoY3VzdFR5cGUpIHtcclxuICA+ICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyBpbnRlcmVzdGluZ1xyXG4gID4gICAgICB9XHJcblxyXG4gIG9yIHRvIGEgY29sbGVjdGlvbiBvZiBbW0VudGl0eVR5cGVdXXNcclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcHJlZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICA+ICAgICAgbGV0IG9yZGVyVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJPcmRlclwiKTtcclxuICA+ICAgICAgaWYgKCBlbTEuaGFzQ2hhbmdlcyggW2N1c3RUeXBlLCBvcmRlclR5cGVdKSB7XHJcbiAgPiAgICAgICAgICAvLyBkbyBzb21ldGhpbmcgaW50ZXJlc3RpbmdcclxuICA+ICAgICAgfVxyXG4gIEBwYXJhbSBlbnRpdHlUeXBlcyAtIFRoZSBbW0VudGl0eVR5cGVdXSBvciBFbnRpdHlUeXBlcyBmb3Igd2hpY2ggJ2NoYW5nZWQnIGVudGl0aWVzIHdpbGwgYmUgZm91bmQuXHJcbiAgQHBhcmFtIGVudGl0eVR5cGVOYW1lcyAtIFRoZSBbW0VudGl0eVR5cGVdXSBuYW1lIG9yIG5hbWVzIGZvciB3aGljaCAnY2hhbmdlZCcgZW50aXRpZXMgd2lsbCBiZSBmb3VuZC5cclxuICBAcmV0dXJuIFdoZXRoZXIgdGhlcmUgYXJlIGFueSBjaGFuZ2VkIGVudGl0aWVzIHRoYXQgbWF0Y2ggdGhlIHR5cGVzIHNwZWNpZmllZC4uXHJcbiAgKiovXHJcbiAgaGFzQ2hhbmdlcyhlbnRpdHlUeXBlcz86IEVudGl0eVR5cGUgfCBFbnRpdHlUeXBlW10gfCBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG4gICAgaWYgKCF0aGlzLl9oYXNDaGFuZ2VzKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoZW50aXR5VHlwZXMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX2hhc0NoYW5nZXM7XHJcbiAgICByZXR1cm4gdGhpcy5faGFzQ2hhbmdlc0NvcmUoZW50aXR5VHlwZXMpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIC8vIGJhY2tkb29yIHRvIFwicmVhbGx5XCIgY2hlY2sgZm9yIGNoYW5nZXMuXHJcbiAgX2hhc0NoYW5nZXNDb3JlKGVudGl0eVR5cGVzPzogRW50aXR5VHlwZSB8IEVudGl0eVR5cGVbXSB8IHN0cmluZyB8IHN0cmluZ1tdKSB7XHJcbiAgICBsZXQgZXRzID0gY2hlY2tFbnRpdHlUeXBlcyh0aGlzLCBlbnRpdHlUeXBlcyk7XHJcbiAgICBsZXQgZW50aXR5R3JvdXBzID0gZ2V0RW50aXR5R3JvdXBzKHRoaXMsIGV0cyk7XHJcbiAgICByZXR1cm4gZW50aXR5R3JvdXBzLnNvbWUoZnVuY3Rpb24gKGVnKSB7XHJcbiAgICAgIHJldHVybiBlZyAmJiBlZy5oYXNDaGFuZ2VzKCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGdldENoYW5nZXMoKTogRW50aXR5W107XHJcbiAgZ2V0Q2hhbmdlcyhlbnRpdHlUeXBlTmFtZXM6IHN0cmluZyB8IHN0cmluZ1tdKTogRW50aXR5W107XHJcbiAgZ2V0Q2hhbmdlcyhlbnRpdHlUeXBlczogRW50aXR5VHlwZSB8IEVudGl0eVR5cGVbXSk6IEVudGl0eVtdO1xyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBhcnJheSBvZiBhbGwgY2hhbmdlZCBlbnRpdGllcyBvZiB0aGUgc3BlY2lmaWVkIFtbRW50aXR5VHlwZV1dcy4gQSAnY2hhbmdlZCcgRW50aXR5IGhhc1xyXG4gIGhhcyBhbiBbW0VudGl0eVN0YXRlXV0gb2YgZWl0aGVyIEFkZGVkLCBNb2RpZmllZCBvciBEZWxldGVkLlxyXG4gIFxyXG4gIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGdldCBhbGwgb2YgdGhlIGNoYW5nZWQgZW50aXRpZXMgd2l0aGluIGFuIEVudGl0eU1hbmFnZXJcclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcHJlZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBjaGFuZ2VkRW50aXRpZXMgPSBlbTEuZ2V0Q2hhbmdlcygpO1xyXG5cclxuICBvciB5b3UgY2FuIHNwZWNpZnkgdGhhdCB5b3Ugb25seSB3YW50IHRoZSBjaGFuZ2VzIG9uIGEgc3BlY2lmaWMgW1tFbnRpdHlUeXBlXV1cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcHJlZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICA+ICAgICAgbGV0IGNoYW5nZWRDdXN0b21lcnMgPSBlbTEuZ2V0Q2hhbmdlcyhjdXN0VHlwZSk7XHJcblxyXG4gIG9yIHRvIGEgY29sbGVjdGlvbiBvZiBbW0VudGl0eVR5cGVdXXNcclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcHJlZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICA+ICAgICAgbGV0IG9yZGVyVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJPcmRlclwiKTtcclxuICA+ICAgICAgbGV0IGNoYW5nZWRDdXN0b21lcnNBbmRPcmRlcnMgPSBlbTEuZ2V0Q2hhbmdlcyhbY3VzdFR5cGUsIG9yZGVyVHlwZV0pO1xyXG4gIEBwYXJhbSBlbnRpdHlUeXBlcyAtIFRoZSBbW0VudGl0eVR5cGVdXSBvciBFbnRpdHlUeXBlcyBmb3Igd2hpY2ggJ2NoYW5nZWQnIGVudGl0aWVzIHdpbGwgYmUgZm91bmQuXHJcbiAgQHBhcmFtIGVudGl0eVR5cGVOYW1lcyAtIFRoZSBbW0VudGl0eVR5cGVdXSBuYW1lIG9yIG5hbWVzIGZvciB3aGljaCAnY2hhbmdlZCcgZW50aXRpZXMgd2lsbCBiZSBmb3VuZC5cclxuICBAcmV0dXJuIEFuIGFycmF5IG9mIEVudGl0aWVzXHJcbiAgKiovXHJcbiAgZ2V0Q2hhbmdlcyhlbnRpdHlUeXBlcz86IEVudGl0eVR5cGUgfCBFbnRpdHlUeXBlW10gfCBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG4gICAgbGV0IGV0cyA9IGNoZWNrRW50aXR5VHlwZXModGhpcywgZW50aXR5VHlwZXMpO1xyXG4gICAgcmV0dXJuIGdldENoYW5nZXNDb3JlKHRoaXMsIGV0cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZWplY3RzIChyZXZlcnNlcyB0aGUgZWZmZWN0cykgYWxsIG9mIHRoZSBhZGRpdGlvbnMsIG1vZGlmaWNhdGlvbnMgYW5kIGRlbGV0ZXMgZnJvbSB0aGlzIEVudGl0eU1hbmFnZXIuXHJcbiAgQ2FsbHMgW1tFbnRpdHlBc3BlY3QucmVqZWN0Q2hhbmdlc11dIG9uIGV2ZXJ5IGNoYW5nZWQgZW50aXR5IGluIHRoaXMgRW50aXR5TWFuYWdlci5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcHJlZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBlbnRpdGllcyA9IGVtMS5yZWplY3RDaGFuZ2VzKCk7XHJcbiAgQHJldHVybiBUaGUgZW50aXRpZXMgd2hvc2UgY2hhbmdlcyB3ZXJlIHJlamVjdGVkLiBUaGVzZSBlbnRpdGllcyB3aWxsIGFsbCBoYXZlIEVudGl0eVN0YXRlcyBvZlxyXG4gIGVpdGhlciAnVW5jaGFuZ2VkJyBvciAnRGV0YWNoZWQnXHJcbiAgKiovXHJcbiAgcmVqZWN0Q2hhbmdlcygpIHtcclxuICAgIGlmICghdGhpcy5faGFzQ2hhbmdlcykgcmV0dXJuIFtdO1xyXG4gICAgbGV0IGNoYW5nZXMgPSBnZXRDaGFuZ2VzQ29yZSh0aGlzKTtcclxuICAgIC8vIG5leHQgbGluZSBzdG9wcyBpbmRpdmlkdWFsIHJlamVjdCBjaGFuZ2VzIGZyb20gZWFjaCBjYWxsaW5nIF9oYXNDaGFuZ2VzQ29yZVxyXG4gICAgbGV0IGFzcGVjdHMgPSBjaGFuZ2VzLm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgICByZXR1cm4gZS5lbnRpdHlBc3BlY3QuX2NoZWNrT3BlcmF0aW9uKFwicmVqZWN0Q2hhbmdlc1wiKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5faGFzQ2hhbmdlcyA9IGZhbHNlO1xyXG4gICAgYXNwZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3BlY3QpIHtcclxuICAgICAgYXNwZWN0LnJlamVjdENoYW5nZXMoKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5oYXNDaGFuZ2VzQ2hhbmdlZC5wdWJsaXNoKHsgZW50aXR5TWFuYWdlcjogdGhpcywgaGFzQ2hhbmdlczogZmFsc2UgfSk7XHJcbiAgICByZXR1cm4gY2hhbmdlcztcclxuICB9XHJcblxyXG4gIGdldEVudGl0aWVzKGVudGl0eVR5cGVOYW1lcz86IHN0cmluZyB8IHN0cmluZ1tdLCBlbnRpdHlTdGF0ZXM/OiBFbnRpdHlTdGF0ZSB8IEVudGl0eVN0YXRlW10pOiBFbnRpdHlbXTtcclxuICBnZXRFbnRpdGllcyhlbnRpdHlUeXBlcz86IEVudGl0eVR5cGUgfCBFbnRpdHlUeXBlW10sIGVudGl0eVN0YXRlcz86IEVudGl0eVN0YXRlIHwgRW50aXR5U3RhdGVbXSk6IEVudGl0eVtdO1xyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBhcnJheSBvZiBhbGwgZW50aXRpZXMgb2YgdGhlIHNwZWNpZmllZCBbW0VudGl0eVR5cGVdXXMgd2l0aCB0aGUgc3BlY2lmaWVkIFtbRW50aXR5U3RhdGVdXXMuXHJcblxyXG4gIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGdldCBhbGwgb2YgdGhlIGVudGl0aWVzIHdpdGhpbiBhbiBFbnRpdHlNYW5hZ2VyXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIHByZWV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgZW50aXRpZXMgPSBlbTEuZ2V0RW50aXRpZXMoKTtcclxuXHJcbiAgb3IgeW91IGNhbiBzcGVjaWZ5IHRoYXQgeW91IG9ubHkgd2FudCB0aGUgY2hhbmdlcyBvbiBhIHNwZWNpZmljIFtbRW50aXR5VHlwZV1dXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIHByZWV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgPiAgICAgIGxldCBjdXN0b21lcnMgPSBlbTEuZ2V0RW50aXRpZXMoY3VzdFR5cGUpO1xyXG5cclxuICBvciB0byBhIGNvbGxlY3Rpb24gb2YgW1tFbnRpdHlUeXBlXV1zXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIHByZWV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgPiAgICAgIGxldCBvcmRlclR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiT3JkZXJcIik7XHJcbiAgPiAgICAgIGxldCBjdXN0b21lcnNBbmRPcmRlcnMgPSBlbTEuZ2V0Q2hhbmdlcyhbY3VzdFR5cGUsIG9yZGVyVHlwZV0pO1xyXG5cclxuICBZb3UgY2FuIGFsc28gYXNrIGZvciBlbnRpdGllcyB3aXRoIGEgcGFydGljdWxhciBbW0VudGl0eVN0YXRlXV0gb3IgRW50aXR5U3RhdGVzLlxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXIgY29udGFpbmluZyBhIG51bWJlciBvZiBwcmVleGlzdGluZyBlbnRpdGllcy5cclxuICA+ICAgICAgbGV0IGN1c3RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkN1c3RvbWVyXCIpO1xyXG4gID4gICAgICBsZXQgb3JkZXJUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIk9yZGVyXCIpO1xyXG4gID4gICAgICBsZXQgYWRkZWRDdXN0b21lcnNBbmRPcmRlcnMgPSBlbTEuZ2V0RW50aXRpZXMoW2N1c3RUeXBlLCBvcmRlclR5cGVdLCBFbnRpdHlTdGF0ZS5BZGRlZCk7XHJcbiBcclxuICBAcGFyYW0gZW50aXR5VHlwZU5hbWUgLSBUaGUgW1tFbnRpdHlUeXBlXV0gbmFtZSBvciBuYW1lcyBmb3Igd2hpY2ggZW50aXRpZXMgd2lsbCBiZSBmb3VuZC5cclxuICBJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCBhbGwgRW50aXR5VHlwZXMgYXJlIHNlYXJjaGVkLiAgXHJcbiAgQHBhcmFtIGVudGl0eVR5cGVzIC0gVGhlIFtbRW50aXR5VHlwZV1dIG9yIEVudGl0eVR5cGVzIGZvciB3aGljaCBlbnRpdGllcyB3aWxsIGJlIGZvdW5kLlxyXG4gIElmIHRoaXMgcGFyYW1ldGVyIGlzIG9taXR0ZWQsIGFsbCBFbnRpdHlUeXBlcyBhcmUgc2VhcmNoZWQuIFxyXG4gIEBwYXJhbSBlbnRpdHlTdGF0ZXMgLSBUaGUgW1tFbnRpdHlTdGF0ZV1dcyBmb3Igd2hpY2ggZW50aXRpZXMgd2lsbCBiZSBmb3VuZC5cclxuICBJZiB0aGlzIHBhcmFtZXRlciBpcyBvbWl0dGVkLCBlbnRpdGllcyBvZiBhbGwgRW50aXR5U3RhdGVzIGFyZSByZXR1cm5lZC5cclxuICBAcmV0dXJuIEFuIGFycmF5IG9mIEVudGl0aWVzXHJcbiAgKiovXHJcbiAgZ2V0RW50aXRpZXMoZW50aXR5VHlwZXM/OiBFbnRpdHlUeXBlIHwgRW50aXR5VHlwZVtdIHwgc3RyaW5nIHwgc3RyaW5nW10sIGVudGl0eVN0YXRlcz86IEVudGl0eVN0YXRlIHwgRW50aXR5U3RhdGVbXSkge1xyXG4gICAgbGV0IGVudFR5cGVzID0gY2hlY2tFbnRpdHlUeXBlcyh0aGlzLCBlbnRpdHlUeXBlcyk7XHJcbiAgICBhc3NlcnRQYXJhbShlbnRpdHlTdGF0ZXMsIFwiZW50aXR5U3RhdGVzXCIpLmlzT3B0aW9uYWwoKS5pc0VudW1PZihFbnRpdHlTdGF0ZSkub3IoKS5pc05vbkVtcHR5QXJyYXkoKS5pc0VudW1PZihFbnRpdHlTdGF0ZSkuY2hlY2soKTtcclxuXHJcbiAgICBsZXQgc3RhdGVzID0gdmFsaWRhdGVFbnRpdHlTdGF0ZXModGhpcywgZW50aXR5U3RhdGVzKTtcclxuICAgIHJldHVybiBnZXRFbnRpdGllc0NvcmUodGhpcywgZW50VHlwZXMsIHN0YXRlcyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gcHJvdGVjdGVkIG1ldGhvZHNcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfbm90aWZ5U3RhdGVDaGFuZ2UoZW50aXR5OiBFbnRpdHksIG5lZWRzU2F2ZTogYm9vbGVhbikge1xyXG4gICAgbGV0IGVjQXJncyA9IHsgZW50aXR5QWN0aW9uOiBFbnRpdHlBY3Rpb24uRW50aXR5U3RhdGVDaGFuZ2UsIGVudGl0eTogZW50aXR5IH07XHJcblxyXG4gICAgaWYgKG5lZWRzU2F2ZSkge1xyXG4gICAgICBpZiAoIXRoaXMuX2hhc0NoYW5nZXMpIHRoaXMuX3NldEhhc0NoYW5nZXModHJ1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBjYWxsZWQgd2hlbiByZWplY3RpbmcgYSBjaGFuZ2Ugb3IgbWVyZ2luZyBhbiB1bmNoYW5nZWQgcmVjb3JkLlxyXG4gICAgICAvLyBOT1RFOiB0aGlzIGNhbiBiZSBzbG93IHdpdGggbG90cyBvZiBlbnRpdGllcyBpbiB0aGUgY2FjaGUuXHJcbiAgICAgIC8vIHNvIGRlZmVyIGl0IGR1cmluZyBhIHF1ZXJ5L2ltcG9ydCBvciBzYXZlIGFuZCBjYWxsIGl0IG9uY2Ugd2hlbiBjb21wbGV0ZSAoIGlmIG5lZWRlZCkuXHJcbiAgICAgIGlmICh0aGlzLl9oYXNDaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICB0aGlzLl9oYXNDaGFuZ2VzQWN0aW9uID0gdGhpcy5faGFzQ2hhbmdlc0FjdGlvbiB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEhhc0NoYW5nZXMobnVsbCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW50aXR5Q2hhbmdlZC5wdWJsaXNoKGVjQXJncyk7XHJcbiAgICAgICAgICB9LmJpbmQodGhpcyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX3NldEhhc0NoYW5nZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuZW50aXR5Q2hhbmdlZC5wdWJsaXNoKGVjQXJncyk7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfc2V0SGFzQ2hhbmdlcyhoYXNDaGFuZ2VzPzogYm9vbGVhbikge1xyXG4gICAgaWYgKGhhc0NoYW5nZXMgPT0gbnVsbCkgaGFzQ2hhbmdlcyA9IHRoaXMuX2hhc0NoYW5nZXNDb3JlKCk7XHJcbiAgICBsZXQgaGFkQ2hhbmdlcyA9IHRoaXMuX2hhc0NoYW5nZXM7XHJcbiAgICB0aGlzLl9oYXNDaGFuZ2VzID0gaGFzQ2hhbmdlcztcclxuICAgIGlmIChoYXNDaGFuZ2VzICE9PSBoYWRDaGFuZ2VzKSB7XHJcbiAgICAgIHRoaXMuaGFzQ2hhbmdlc0NoYW5nZWQucHVibGlzaCh7IGVudGl0eU1hbmFnZXI6IHRoaXMsIGhhc0NoYW5nZXM6IGhhc0NoYW5nZXMgfSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9oYXNDaGFuZ2VzQWN0aW9uID0gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2xpbmtSZWxhdGVkRW50aXRpZXMoZW50aXR5OiBFbnRpdHkpIHtcclxuICAgIGxldCBlbSA9IHRoaXM7XHJcbiAgICBsZXQgZW50aXR5QXNwZWN0ID0gZW50aXR5LmVudGl0eUFzcGVjdDtcclxuICAgIC8vIHdlIGRvIG5vdCB3YW50IGVudGl0eVN0YXRlIHRvIGNoYW5nZSBhcyBhIHJlc3VsdCBvZiBsaW5rYWdlLlxyXG4gICAgY29yZS51c2luZyhlbSwgXCJpc0xvYWRpbmdcIiwgdHJ1ZSwgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgbGV0IHVuYXR0YWNoZWRNYXAgPSBlbS5fdW5hdHRhY2hlZENoaWxkcmVuTWFwO1xyXG4gICAgICBsZXQgZW50aXR5S2V5ID0gZW50aXR5QXNwZWN0LmdldEtleSgpO1xyXG4gICAgICBsZXQgZW50aXR5VHlwZSA9IGVudGl0eUtleS5lbnRpdHlUeXBlO1xyXG5cclxuICAgICAgd2hpbGUgKGVudGl0eVR5cGUpIHtcclxuICAgICAgICBsZXQga2V5c3RyaW5nID0gZW50aXR5S2V5LnRvU3RyaW5nKGVudGl0eVR5cGUpO1xyXG5cclxuICAgICAgICAvLyBhdHRhY2ggYW55IHVuYXR0YWNoZWRDaGlsZHJlblxyXG4gICAgICAgIGxldCB0dXBsZXMgPSB1bmF0dGFjaGVkTWFwLmdldFR1cGxlc0J5U3RyaW5nKGtleXN0cmluZyk7XHJcbiAgICAgICAgaWYgKHR1cGxlcykge1xyXG4gICAgICAgICAgdHVwbGVzLnNsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKHRwbCkge1xyXG5cclxuICAgICAgICAgICAgbGV0IHVuYXR0YWNoZWRDaGlsZHJlbiA9IHRwbC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZS5lbnRpdHlBc3BlY3QuZW50aXR5U3RhdGUgIT09IEVudGl0eVN0YXRlLkRldGFjaGVkO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGxldCBjaGlsZFRvUGFyZW50TnA6IE5hdmlnYXRpb25Qcm9wZXJ0eTtcclxuICAgICAgICAgICAgbGV0IHBhcmVudFRvQ2hpbGROcDogTmF2aWdhdGlvblByb3BlcnR5O1xyXG5cclxuICAgICAgICAgICAgLy8gbnAgaXMgdXN1YWxseSBjaGlsZFRvUGFyZW50TnBcclxuICAgICAgICAgICAgLy8gZXhjZXB0IHdpdGggdW5pZGlyZWN0aW9uYWwgMS1uIHdoZXJlIGl0IGlzIHBhcmVudFRvQ2hpbGROcDtcclxuICAgICAgICAgICAgbGV0IG5wID0gdHBsLm5hdmlnYXRpb25Qcm9wZXJ0eTtcclxuXHJcbiAgICAgICAgICAgIGxldCBpbnZlcnNlTnAgPSBucC5pbnZlcnNlO1xyXG4gICAgICAgICAgICBpZiAoaW52ZXJzZU5wKSB7XHJcbiAgICAgICAgICAgICAgLy8gYmlkaXJlY3Rpb25hbFxyXG4gICAgICAgICAgICAgIGNoaWxkVG9QYXJlbnROcCA9IG5wO1xyXG4gICAgICAgICAgICAgIHBhcmVudFRvQ2hpbGROcCA9IGludmVyc2VOcDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHBhcmVudFRvQ2hpbGROcC5pc1NjYWxhcikge1xyXG4gICAgICAgICAgICAgICAgbGV0IG9ubHlDaGlsZCA9IHVuYXR0YWNoZWRDaGlsZHJlblswXTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5zZXRQcm9wZXJ0eShwYXJlbnRUb0NoaWxkTnAubmFtZSwgb25seUNoaWxkKTtcclxuICAgICAgICAgICAgICAgIG9ubHlDaGlsZC5zZXRQcm9wZXJ0eShjaGlsZFRvUGFyZW50TnAubmFtZSwgZW50aXR5KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDaGlsZHJlbiA9IGVudGl0eS5nZXRQcm9wZXJ0eShwYXJlbnRUb0NoaWxkTnAubmFtZSk7XHJcbiAgICAgICAgICAgICAgICB1bmF0dGFjaGVkQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgY3VycmVudENoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICBjaGlsZC5zZXRQcm9wZXJ0eShjaGlsZFRvUGFyZW50TnAubmFtZSwgZW50aXR5KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB1bmF0dGFjaGVkTWFwLnJlbW92ZUNoaWxkcmVuKGtleXN0cmluZywgY2hpbGRUb1BhcmVudE5wKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyB1bmlkaXJlY3Rpb25hbFxyXG4gICAgICAgICAgICAgIC8vIGlmIChucC5pc1NjYWxhciB8fCBucC5wYXJlbnRUeXBlICE9PSBlbnRpdHkuZW50aXR5VHlwZSkge1xyXG4gICAgICAgICAgICAgIGlmIChucC5pc1NjYWxhcikge1xyXG4gICAgICAgICAgICAgICAgLy8gbiAtPiAxICBlZzogY2hpbGQ6IE9yZGVyRGV0YWlsIHBhcmVudDogUHJvZHVjdFxyXG4gICAgICAgICAgICAgICAgLy8gMSAtPiAxIGVnIGNoaWxkOiBFbXBsb3llZSBwYXJlbnQ6IEVtcGxveWVlICggb25seSBNYW5hZ2VyLCBubyBEaXJlY3RSZXBvcnRzIHByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgY2hpbGRUb1BhcmVudE5wID0gbnA7XHJcbiAgICAgICAgICAgICAgICB1bmF0dGFjaGVkQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0UHJvcGVydHkoY2hpbGRUb1BhcmVudE5wLm5hbWUsIGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHVuYXR0YWNoZWRNYXAucmVtb3ZlQ2hpbGRyZW4oa2V5c3RyaW5nLCBjaGlsZFRvUGFyZW50TnApO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyAxIC0+IG4gIGVnOiBwYXJlbnQ6IFJlZ2lvbiBjaGlsZDogVGVyclxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogbmVlZCB0byByZW1vdmUgdW5hdHRhY2hlZCBjaGlsZHJlbiBmcm9tIHRoZSBtYXAgYWZ0ZXIgdGhpczsgb25seSBhIHBlcmYgaXNzdWUuXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRUb0NoaWxkTnAgPSBucDtcclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q2hpbGRyZW4gPSBlbnRpdHkuZ2V0UHJvcGVydHkocGFyZW50VG9DaGlsZE5wLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdW5hdHRhY2hlZENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgaWYgY2FuJ3QgYWxyZWFkeSBiZSB0aGVyZS5cclxuICAgICAgICAgICAgICAgICAgY3VycmVudENoaWxkcmVuLl9wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVudGl0eVR5cGUgPSBlbnRpdHlUeXBlLmJhc2VFbnRpdHlUeXBlOyAvLyBsb29rIGZvciByZWxhdGlvbnNoaXBzIHVwIHRoZSBoaWVyYXJjaHlcclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIC8vIG5vdyBhZGQgdG8gdW5hdHRhY2hlZE1hcCBpZiBuZWVkZWQuXHJcbiAgICAgIGVudGl0eS5lbnRpdHlUeXBlLm5hdmlnYXRpb25Qcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKG5wKSB7XHJcbiAgICAgICAgaWYgKG5wLmlzU2NhbGFyKSB7XHJcbiAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRpdHkuZ2V0UHJvcGVydHkobnAubmFtZSk7XHJcbiAgICAgICAgICAvLyBwcm9wZXJ0eSBpcyBhbHJlYWR5IGxpbmtlZCB1cFxyXG4gICAgICAgICAgaWYgKHZhbHVlKSByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaXJzdCBkZXRlcm1pbmUgaWYgbnAgY29udGFpbnMgYSBwYXJlbnQgb3IgY2hpbGRcclxuICAgICAgICAvLyBoYXZpbmcgYSBwYXJlbnRLZXkgbWVhbnMgdGhhdCB0aGlzIGlzIGEgY2hpbGRcclxuICAgICAgICAvLyBpZiBhIHBhcmVudCB0aGVuIG5vIG5lZWQgZm9yIG1vcmUgd29yayBiZWNhdXNlIGNoaWxkcmVuIHdpbGwgYXR0YWNoIHRvIGl0LlxyXG4gICAgICAgIGxldCBwYXJlbnRLZXkgPSBlbnRpdHlBc3BlY3QuZ2V0UGFyZW50S2V5KG5wKTtcclxuICAgICAgICBpZiAocGFyZW50S2V5KSB7XHJcbiAgICAgICAgICAvLyBjaGVjayBmb3IgZW1wdHkga2V5cyAtIG1lYW5pbmcgdGhhdCBwYXJlbnQgaWQncyBhcmUgbm90IHlldCBzZXQuXHJcbiAgICAgICAgICBpZiAocGFyZW50S2V5Ll9pc0VtcHR5KCkpIHJldHVybjtcclxuICAgICAgICAgIC8vIGlmIGEgY2hpbGQgLSBsb29rIGZvciBwYXJlbnQgaW4gdGhlIGVtIGNhY2hlXHJcbiAgICAgICAgICBsZXQgcGFyZW50ID0gZW0uZmluZEVudGl0eUJ5S2V5KHBhcmVudEtleSk7XHJcbiAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGZvdW5kIGhvb2sgaXQgdXBcclxuICAgICAgICAgICAgZW50aXR5LnNldFByb3BlcnR5KG5wLm5hbWUsIHBhcmVudCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBlbHNlIGFkZCBwYXJlbnQgdG8gdW5yZXNvbHZlZFBhcmVudE1hcDtcclxuICAgICAgICAgICAgdW5hdHRhY2hlZE1hcC5hZGRDaGlsZChwYXJlbnRLZXksIG5wLCBlbnRpdHkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBoYW5kbGUgdW5pZGlyZWN0aW9uYWwgMS14IHdoZXJlIHdlIHNldCB4LmZrXHJcbiAgICAgIGVudGl0eS5lbnRpdHlUeXBlLmZvcmVpZ25LZXlQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKGZrUHJvcCkge1xyXG4gICAgICAgIGxldCBpbnZOcCA9IGZrUHJvcC5pbnZlcnNlTmF2aWdhdGlvblByb3BlcnR5O1xyXG4gICAgICAgIGlmICghaW52TnApIHJldHVybjtcclxuICAgICAgICAvLyB1bmlkaXJlY3Rpb25hbCBmayBwcm9wcyBvbmx5XHJcbiAgICAgICAgbGV0IGZrVmFsdWUgPSBlbnRpdHkuZ2V0UHJvcGVydHkoZmtQcm9wLm5hbWUpO1xyXG4gICAgICAgIGxldCBwYXJlbnRLZXkgPSBuZXcgRW50aXR5S2V5KGludk5wLnBhcmVudFR5cGUsIFtma1ZhbHVlXSk7XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IGVtLmZpbmRFbnRpdHlCeUtleShwYXJlbnRLZXkpO1xyXG5cclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICBpZiAoaW52TnAuaXNTY2FsYXIpIHtcclxuICAgICAgICAgICAgcGFyZW50LnNldFByb3BlcnR5KGludk5wLm5hbWUsIGVudGl0eSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZW0uaXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgICAgcGFyZW50LmdldFByb3BlcnR5KGludk5wLm5hbWUpLl9wdXNoKGVudGl0eSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcGFyZW50LmdldFByb3BlcnR5KGludk5wLm5hbWUpLnB1c2goZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBlbHNlIGFkZCBwYXJlbnQgdG8gdW5yZXNvbHZlZFBhcmVudE1hcDtcclxuICAgICAgICAgIHVuYXR0YWNoZWRNYXAuYWRkQ2hpbGQocGFyZW50S2V5LCBpbnZOcCwgZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2F0dGFjaEVudGl0eUNvcmUoZW50aXR5OiBFbnRpdHksIGVudGl0eVN0YXRlOiBFbnRpdHlTdGF0ZSwgbWVyZ2VTdHJhdGVneTogTWVyZ2VTdHJhdGVneSkge1xyXG4gICAgbGV0IGdyb3VwID0gZmluZE9yQ3JlYXRlRW50aXR5R3JvdXAodGhpcywgZW50aXR5LmVudGl0eVR5cGUpO1xyXG4gICAgbGV0IGF0dGFjaGVkRW50aXR5ID0gZ3JvdXAuYXR0YWNoRW50aXR5KGVudGl0eSwgZW50aXR5U3RhdGUsIG1lcmdlU3RyYXRlZ3kpO1xyXG4gICAgdGhpcy5fbGlua1JlbGF0ZWRFbnRpdGllcyhhdHRhY2hlZEVudGl0eSk7XHJcbiAgICByZXR1cm4gYXR0YWNoZWRFbnRpdHk7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfdXBkYXRlRmtWYWwoZmtQcm9wOiBEYXRhUHJvcGVydHksIG9sZFZhbHVlOiBhbnksIG5ld1ZhbHVlOiBhbnkpIHtcclxuICAgIGxldCBncm91cCA9IHRoaXMuX2VudGl0eUdyb3VwTWFwW2ZrUHJvcC5wYXJlbnRUeXBlLm5hbWVdO1xyXG4gICAgaWYgKCFncm91cCkgcmV0dXJuO1xyXG4gICAgZ3JvdXAuX3VwZGF0ZUZrVmFsKGZrUHJvcCwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbkVudGl0eU1hbmFnZXIucHJvdG90eXBlLl8kdHlwZU5hbWUgPSBcIkVudGl0eU1hbmFnZXJcIjtcclxuXHJcbkJyZWV6ZUV2ZW50LmJ1YmJsZUV2ZW50KEVudGl0eU1hbmFnZXIucHJvdG90eXBlKTtcclxuXHJcbmZ1bmN0aW9uIGNsZWFyU2VydmVyRXJyb3JzKGVudGl0aWVzOiBFbnRpdHlbXSkge1xyXG4gIGVudGl0aWVzLmZvckVhY2goZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgbGV0IHNlcnZlcktleXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBsZXQgYXNwZWN0ID0gZW50aXR5LmVudGl0eUFzcGVjdDtcclxuICAgIGNvcmUub2JqZWN0Rm9yRWFjaChhc3BlY3QuX3ZhbGlkYXRpb25FcnJvcnMsIGZ1bmN0aW9uIChrZXksIHZlKSB7XHJcbiAgICAgIGlmICh2ZS5pc1NlcnZlckVycm9yKSBzZXJ2ZXJLZXlzLnB1c2goa2V5KTtcclxuICAgIH0pO1xyXG4gICAgaWYgKHNlcnZlcktleXMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcbiAgICBhc3BlY3QuX3Byb2Nlc3NWYWxpZGF0aW9uT3BBbmRQdWJsaXNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgc2VydmVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBhc3BlY3QuX3JlbW92ZVZhbGlkYXRpb25FcnJvcihrZXkpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFbnRpdHlFcnJvcnMoZW50aXRpZXM6IEVudGl0eVtdKSB7XHJcbiAgbGV0IGVudGl0eUVycm9yczogRW50aXR5RXJyb3JbXSA9IFtdO1xyXG4gIGVudGl0aWVzLmZvckVhY2goKGVudGl0eSkgPT4ge1xyXG4gICAgY29yZS5vYmplY3RGb3JFYWNoKGVudGl0eS5lbnRpdHlBc3BlY3QuX3ZhbGlkYXRpb25FcnJvcnMsIGZ1bmN0aW9uIChrZXksIHZlKSB7XHJcbiAgICAgIGxldCBjZmcgPSBjb3JlLmV4dGVuZCh7XHJcbiAgICAgICAgZW50aXR5OiBlbnRpdHksXHJcbiAgICAgICAgZXJyb3JOYW1lOiB2ZS52YWxpZGF0b3IubmFtZVxyXG4gICAgICB9LCB2ZSwgW1wiZXJyb3JNZXNzYWdlXCIsIFwicHJvcGVydHlOYW1lXCIsIFwiaXNTZXJ2ZXJFcnJvclwiXSkgYXMgRW50aXR5RXJyb3I7XHJcbiAgICAgIGVudGl0eUVycm9ycy5wdXNoKGNmZyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gZW50aXR5RXJyb3JzO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1NlcnZlckVycm9ycyhzYXZlQ29udGV4dDogU2F2ZUNvbnRleHQsIHNhdmVFcnJvcjogU2F2ZUVycm9yRnJvbVNlcnZlcikge1xyXG4gIC8vIGNvbnZlcnRpbmcgSVNhdmVFcnJvckZyb21TZXJ2ZXIgLT4gSVNhdmVFcnJvclxyXG4gIGxldCBzZXJ2ZXJFcnJvcnMgPSBzYXZlRXJyb3IuZW50aXR5RXJyb3JzO1xyXG4gIGlmICghc2VydmVyRXJyb3JzKSByZXR1cm4gPFNhdmVFcnJvcj4gPGFueT4gc2F2ZUVycm9yO1xyXG4gIGxldCBlbnRpdHlNYW5hZ2VyID0gc2F2ZUNvbnRleHQuZW50aXR5TWFuYWdlcjtcclxuICBsZXQgbWV0YWRhdGFTdG9yZSA9IGVudGl0eU1hbmFnZXIubWV0YWRhdGFTdG9yZTtcclxuICBsZXQgZW50aXR5RXJyb3JzID0gc2VydmVyRXJyb3JzLm1hcCgoc2VycikgPT4ge1xyXG4gICAgbGV0IGVudGl0eTogRW50aXR5IHwgbnVsbCA9IG51bGw7XHJcbiAgICBsZXQgZW50aXR5VHlwZTogRW50aXR5VHlwZSB8IHVuZGVmaW5lZDtcclxuICAgIGlmIChzZXJyLmtleVZhbHVlcykge1xyXG4gICAgICBlbnRpdHlUeXBlID0gbWV0YWRhdGFTdG9yZS5fZ2V0U3RydWN0dXJhbFR5cGUoc2Vyci5lbnRpdHlUeXBlTmFtZSkgYXMgRW50aXR5VHlwZTtcclxuICAgICAgbGV0IGVrZXkgPSBuZXcgRW50aXR5S2V5KGVudGl0eVR5cGUsIHNlcnIua2V5VmFsdWVzKTtcclxuICAgICAgZW50aXR5ID0gZW50aXR5TWFuYWdlci5maW5kRW50aXR5QnlLZXkoZWtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVudGl0eVR5cGUgJiYgZW50aXR5KSB7XHJcbiAgICAgIGxldCBjb250ZXh0ID0gc2Vyci5wcm9wZXJ0eU5hbWUgP1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIHByb3BlcnR5TmFtZTogc2Vyci5wcm9wZXJ0eU5hbWUsXHJcbiAgICAgICAgICBwcm9wZXJ0eTogZW50aXR5VHlwZS5nZXRQcm9wZXJ0eShzZXJyLnByb3BlcnR5TmFtZSlcclxuICAgICAgICB9IDoge1xyXG4gICAgICAgIH07XHJcbiAgICAgIGxldCBrZXkgPSBWYWxpZGF0aW9uRXJyb3IuZ2V0S2V5KHNlcnIuZXJyb3JOYW1lIHx8IHNlcnIuZXJyb3JNZXNzYWdlLCBzZXJyLnByb3BlcnR5TmFtZSk7XHJcblxyXG4gICAgICBsZXQgdmUgPSBuZXcgVmFsaWRhdGlvbkVycm9yKG51bGwsIGNvbnRleHQsIHNlcnIuZXJyb3JNZXNzYWdlLCBrZXkpO1xyXG4gICAgICB2ZS5pc1NlcnZlckVycm9yID0gdHJ1ZTtcclxuICAgICAgZW50aXR5LmVudGl0eUFzcGVjdC5hZGRWYWxpZGF0aW9uRXJyb3IodmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBlbnRpdHlFcnJvciA9IGNvcmUuZXh0ZW5kKHtcclxuICAgICAgZW50aXR5OiBlbnRpdHksXHJcbiAgICAgIGlzU2VydmVyRXJyb3I6IHRydWVcclxuICAgIH0sIHNlcnIsIFtcImVycm9yTmFtZVwiLCBcImVycm9yTWVzc2FnZVwiLCBcInByb3BlcnR5TmFtZVwiXSkgYXMgRW50aXR5RXJyb3I7XHJcbiAgICByZXR1cm4gZW50aXR5RXJyb3I7XHJcbiAgfSk7XHJcbiAgLy8gY29udmVydGluZyBJU2F2ZUVycm9yRnJvbVNlcnZlciAtPiBJU2F2ZUVycm9yIFxyXG4gIHNhdmVFcnJvci5lbnRpdHlFcnJvcnMgPSBlbnRpdHlFcnJvcnMgYXMgYW55O1xyXG4gIHJldHVybiA8U2F2ZUVycm9yPiA8YW55PiBzYXZlRXJyb3I7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUVudGl0eUJ5S2V5UmVzdWx0IHtcclxuICBlbnRpdHk/OiBFbnRpdHk7XHJcbiAgZW50aXR5S2V5OiBFbnRpdHlLZXk7XHJcbiAgZnJvbUNhY2hlOiBib29sZWFuO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmZXRjaEVudGl0eUJ5S2V5Q29yZShlbTogRW50aXR5TWFuYWdlciwgYXJnczogYW55W10pOiBQcm9taXNlPElFbnRpdHlCeUtleVJlc3VsdD4ge1xyXG4gIGxldCB0cGwgPSBjcmVhdGVFbnRpdHlLZXkoZW0sIGFyZ3MpO1xyXG4gIGxldCBlbnRpdHlLZXkgPSB0cGwuZW50aXR5S2V5O1xyXG5cclxuICBsZXQgY2hlY2tMb2NhbENhY2hlRmlyc3QgPSB0cGwucmVtYWluaW5nQXJncy5sZW5ndGggPT09IDAgPyBmYWxzZSA6ICEhdHBsLnJlbWFpbmluZ0FyZ3NbMF07XHJcbiAgbGV0IGVudGl0eTogRW50aXR5IHwgbnVsbCA9IG51bGw7XHJcbiAgbGV0IGZvdW5kSXQgPSBmYWxzZTtcclxuICBpZiAoY2hlY2tMb2NhbENhY2hlRmlyc3QpIHtcclxuICAgIGVudGl0eSA9IGVtLmdldEVudGl0eUJ5S2V5KGVudGl0eUtleSk7XHJcbiAgICBmb3VuZEl0ID0gZW50aXR5ICE9IG51bGw7XHJcbiAgICBpZiAoZW50aXR5ICE9IG51bGwgJiZcclxuICAgICAgLy8gbnVsbCB0aGUgZW50aXR5IGlmIGl0IGlzIGRlbGV0ZWQgYW5kIHdlIHNob3VsZCBleGNsdWRlIGRlbGV0ZWQgZW50aXRpZXNcclxuICAgICAgIWVtLnF1ZXJ5T3B0aW9ucy5pbmNsdWRlRGVsZXRlZCAmJiBlbnRpdHkuZW50aXR5QXNwZWN0LmVudGl0eVN0YXRlLmlzRGVsZXRlZCgpKSB7XHJcbiAgICAgIGVudGl0eSA9IG51bGw7XHJcbiAgICAgIC8vIGJ1dCByZXN1bWUgbG9va2luZyBpZiB3ZSdkIG92ZXJ3cml0ZSBkZWxldGVkIGVudGl0eSB3aXRoIGEgcmVtb3RlIGVudGl0eVxyXG4gICAgICAvLyBub3RlOiBlbS5xdWVyeU9wdGlvbnMgaXMgYWx3YXlzIGZ1bGx5IHJlc29sdmVkIGJ5IG5vd1xyXG4gICAgICBmb3VuZEl0ID0gZW0ucXVlcnlPcHRpb25zLm1lcmdlU3RyYXRlZ3kgIT09IE1lcmdlU3RyYXRlZ3kuT3ZlcndyaXRlQ2hhbmdlcztcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGZvdW5kSXQpIHtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBlbnRpdHk6IGVudGl0eSB8fCB1bmRlZmluZWQsIGVudGl0eUtleTogZW50aXR5S2V5LCBmcm9tQ2FjaGU6IHRydWUgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBFbnRpdHlRdWVyeS5mcm9tRW50aXR5S2V5KGVudGl0eUtleSkudXNpbmcoZW0pLmV4ZWN1dGUoKS50aGVuKGZ1bmN0aW9uIChkYXRhOiBhbnkpIHtcclxuICAgICAgZW50aXR5ID0gKGRhdGEucmVzdWx0cy5sZW5ndGggPT09IDApID8gbnVsbCA6IGRhdGEucmVzdWx0c1swXTtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGVudGl0eTogZW50aXR5IHx8IHVuZGVmaW5lZCwgZW50aXR5S2V5OiBlbnRpdHlLZXksIGZyb21DYWNoZTogZmFsc2UgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcblxyXG4vLyBwcml2YXRlIGZuc1xyXG5cclxuLy8gdGFrZXMgaW4gZW50aXR5VHlwZXMgYXMgZWl0aGVyIHN0cmluZ3Mgb3IgZW50aXR5VHlwZXMgb3IgYXJyYXlzIG9mIGVpdGhlclxyXG4vLyBhbmQgcmV0dXJucyBlaXRoZXIgYW4gZW50aXR5VHlwZSBvciBhbiBhcnJheSBvZiBlbnRpdHlUeXBlcyBvciB0aHJvd3MgYW4gZXJyb3JcclxuZnVuY3Rpb24gY2hlY2tFbnRpdHlUeXBlcyhlbTogRW50aXR5TWFuYWdlciwgZW50aXR5VHlwZXM/OiBFbnRpdHlUeXBlIHwgRW50aXR5VHlwZVtdIHwgc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuICBhc3NlcnRQYXJhbShlbnRpdHlUeXBlcywgXCJlbnRpdHlUeXBlc1wiKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKS5vcigpLmlzTm9uRW1wdHlBcnJheSgpLmlzU3RyaW5nKClcclxuICAgIC5vcigpLmlzSW5zdGFuY2VPZihFbnRpdHlUeXBlKS5vcigpLmlzTm9uRW1wdHlBcnJheSgpLmlzSW5zdGFuY2VPZihFbnRpdHlUeXBlKS5jaGVjaygpO1xyXG4gIGxldCByZXN1bHRUeXBlczogRW50aXR5VHlwZSB8IEVudGl0eVR5cGVbXSB8IHVuZGVmaW5lZDtcclxuICBpZiAodHlwZW9mIGVudGl0eVR5cGVzID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICByZXN1bHRUeXBlcyA9IGVtLm1ldGFkYXRhU3RvcmUuX2dldFN0cnVjdHVyYWxUeXBlKGVudGl0eVR5cGVzLCBmYWxzZSkgYXMgKEVudGl0eVR5cGUgfCBFbnRpdHlUeXBlW10pO1xyXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbnRpdHlUeXBlcykgJiYgdHlwZW9mIGVudGl0eVR5cGVzWzBdID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICByZXN1bHRUeXBlcyA9IChlbnRpdHlUeXBlcyBhcyBzdHJpbmdbXSkubWFwKGZ1bmN0aW9uIChldE5hbWUpIHtcclxuICAgICAgcmV0dXJuIGVtLm1ldGFkYXRhU3RvcmUuX2dldFN0cnVjdHVyYWxUeXBlKGV0TmFtZSwgZmFsc2UpIGFzIEVudGl0eVR5cGU7XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVzdWx0VHlwZXMgPSBlbnRpdHlUeXBlcyBhcyAoRW50aXR5VHlwZSB8IEVudGl0eVR5cGVbXSB8IHVuZGVmaW5lZCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0VHlwZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldENoYW5nZXNDb3JlKGVtOiBFbnRpdHlNYW5hZ2VyLCBlbnRpdHlUeXBlcz86IEVudGl0eVR5cGUgfCBFbnRpdHlUeXBlW10pIHtcclxuICBsZXQgZW50aXR5R3JvdXBzID0gZ2V0RW50aXR5R3JvdXBzKGVtLCBlbnRpdHlUeXBlcyk7XHJcblxyXG4gIC8vIFRPRE86IHRoaW5rIGFib3V0IHdyaXRpbmcgYSBjb3JlLm1hcE1hbnkgbWV0aG9kIGlmIHdlIHNlZSBtb3JlIG9mIHRoZXNlLlxyXG4gIGxldCBzZWxlY3RlZDogRW50aXR5W10gPSBbXTtcclxuICBlbnRpdHlHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZWcpIHtcclxuICAgIC8vIGVnIG1heSBiZSB1bmRlZmluZWQgb3IgbnVsbFxyXG4gICAgaWYgKCFlZykgcmV0dXJuO1xyXG4gICAgbGV0IGVudGl0aWVzID0gZWcuZ2V0Q2hhbmdlcygpO1xyXG4gICAgaWYgKHNlbGVjdGVkICYmIHNlbGVjdGVkLmxlbmd0aCkge1xyXG4gICAgICBzZWxlY3RlZCA9IHNlbGVjdGVkLmNvbmNhdChlbnRpdGllcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZWxlY3RlZCA9IGVudGl0aWVzO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBzZWxlY3RlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RW50aXRpZXNDb3JlKGVtOiBFbnRpdHlNYW5hZ2VyLCBlbnRpdHlUeXBlczogRW50aXR5VHlwZSB8IEVudGl0eVR5cGVbXSB8IHVuZGVmaW5lZCwgZW50aXR5U3RhdGVzOiBFbnRpdHlTdGF0ZVtdKSB7XHJcbiAgbGV0IGVudGl0eUdyb3VwcyA9IGdldEVudGl0eUdyb3VwcyhlbSwgZW50aXR5VHlwZXMpO1xyXG5cclxuICAvLyBUT0RPOiB0aGluayBhYm91dCB3cml0aW5nIGEgY29yZS5tYXBNYW55IG1ldGhvZCBpZiB3ZSBzZWUgbW9yZSBvZiB0aGVzZS5cclxuICBsZXQgc2VsZWN0ZWQ6IEVudGl0eVtdID0gW107XHJcbiAgZW50aXR5R3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGVnKSB7XHJcbiAgICAvLyBlZyBtYXkgYmUgdW5kZWZpbmVkIG9yIG51bGxcclxuICAgIGlmICghZWcpIHJldHVybjtcclxuICAgIGxldCBlbnRpdGllcyA9IGVnLmdldEVudGl0aWVzKGVudGl0eVN0YXRlcyk7XHJcbiAgICBpZiAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQubGVuZ3RoKSB7XHJcbiAgICAgIHNlbGVjdGVkID0gc2VsZWN0ZWQuY29uY2F0KGVudGl0aWVzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNlbGVjdGVkID0gZW50aXRpZXM7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHNlbGVjdGVkO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRW50aXR5S2V5KGVtOiBFbnRpdHlNYW5hZ2VyLCBhcmdzOiBhbnlbXSkge1xyXG4gIHRyeSB7XHJcbiAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIEVudGl0eUtleSkge1xyXG4gICAgICByZXR1cm4geyBlbnRpdHlLZXk6IGFyZ3NbMF0gYXMgRW50aXR5S2V5LCByZW1haW5pbmdBcmdzOiBjb3JlLmFycmF5U2xpY2UoYXJncywgMSkgfTtcclxuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPj0gMikge1xyXG4gICAgICBsZXQgZW50aXR5VHlwZSA9ICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycpID8gZW0ubWV0YWRhdGFTdG9yZS5fZ2V0U3RydWN0dXJhbFR5cGUoYXJnc1swXSwgZmFsc2UpIDogYXJnc1swXTtcclxuICAgICAgcmV0dXJuIHsgZW50aXR5S2V5OiBuZXcgRW50aXR5S2V5KGVudGl0eVR5cGUsIGFyZ3NbMV0pLCByZW1haW5pbmdBcmdzOiBjb3JlLmFycmF5U2xpY2UoYXJncywgMikgfTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlKSB7LyogdGhyb3cgYmVsb3cgKi9cclxuICAgIC8vIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3VwcGx5IGFuIEVudGl0eUtleSBPUiBhbiBFbnRpdHlUeXBlIG5hbWUgb3IgRW50aXR5VHlwZSBmb2xsb3dlZCBieSBhIGtleSB2YWx1ZSBvciBhbiBhcnJheSBvZiBrZXkgdmFsdWVzLlwiKTtcclxuICB9XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzdXBwbHkgYW4gRW50aXR5S2V5IE9SIGFuIEVudGl0eVR5cGUgbmFtZSBvciBFbnRpdHlUeXBlIGZvbGxvd2VkIGJ5IGEga2V5IHZhbHVlIG9yIGFuIGFycmF5IG9mIGtleSB2YWx1ZXMuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXJrSXNCZWluZ1NhdmVkKGVudGl0aWVzOiBFbnRpdHlbXSwgZmxhZzogYm9vbGVhbikge1xyXG4gIGVudGl0aWVzLmZvckVhY2goZnVuY3Rpb24gKGVudGl0eSkge1xyXG4gICAgZW50aXR5LmVudGl0eUFzcGVjdC5pc0JlaW5nU2F2ZWQgPSBmbGFnO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHBvcnRFbnRpdHlHcm91cHMoZW06IEVudGl0eU1hbmFnZXIsIGVudGl0aWVzT3JFbnRpdHlUeXBlczogRW50aXR5W10gfCBFbnRpdHlUeXBlW10gfCBzdHJpbmdbXSkge1xyXG4gIGxldCBlbnRpdHlHcm91cE1hcDogeyBbaW5kZXg6IHN0cmluZ106IEVudGl0eUdyb3VwIH07XHJcbiAgbGV0IGZpcnN0ID0gZW50aXRpZXNPckVudGl0eVR5cGVzICYmIGVudGl0aWVzT3JFbnRpdHlUeXBlc1swXTtcclxuICAvLyBjaGVjayBpZiBhcnJheVxyXG4gIGlmIChmaXJzdCkge1xyXG4gICAgLy8gZ3JvdXAgZW50aXRpZXMgYnkgZW50aXR5VHlwZSBhbmRcclxuICAgIC8vIGNyZWF0ZSAnZ3JvdXBzJyB0aGF0IGxvb2sgbGlrZSBlbnRpdHlHcm91cHMuXHJcbiAgICBlbnRpdHlHcm91cE1hcCA9IHt9O1xyXG4gICAgaWYgKChmaXJzdCBhcyBhbnkpLmVudGl0eVR5cGUpIHtcclxuICAgICAgbGV0IGVudGl0aWVzID0gZW50aXRpZXNPckVudGl0eVR5cGVzIGFzIEVudGl0eVtdO1xyXG4gICAgICAvLyBhc3N1bWUgXCJlbnRpdGllc1wiIGlzIGFuIGFycmF5IG9mIGVudGl0aWVzO1xyXG4gICAgICBlbnRpdGllcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUuZW50aXR5QXNwZWN0LmVudGl0eVN0YXRlID09PSBFbnRpdHlTdGF0ZS5EZXRhY2hlZCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGV4cG9ydCBhbiBlbnRpdHkgd2l0aCBhbiBFbnRpdHlTdGF0ZSBvZiAnRGV0YWNoZWQnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZ3JvdXAgPSBlbnRpdHlHcm91cE1hcFtlLmVudGl0eVR5cGUubmFtZV07XHJcbiAgICAgICAgaWYgKCFncm91cCkge1xyXG4gICAgICAgICAgZ3JvdXAgPSB7fSBhcyBFbnRpdHlHcm91cDtcclxuICAgICAgICAgIGdyb3VwLmVudGl0eVR5cGUgPSBlLmVudGl0eVR5cGU7XHJcbiAgICAgICAgICBncm91cC5fZW50aXRpZXMgPSBbXTtcclxuICAgICAgICAgIGVudGl0eUdyb3VwTWFwW2UuZW50aXR5VHlwZS5uYW1lXSA9IGdyb3VwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBncm91cC5fZW50aXRpZXMucHVzaChlKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBhc3N1bWUgXCJlbnRpdGllc1wiIGlzIGFuIGFycmF5IG9mIEVudGl0eVR5cGVzIChvciBuYW1lcylcclxuICAgICAgbGV0IGVudGl0eVR5cGVzID0gY2hlY2tFbnRpdHlUeXBlcyhlbSwgZW50aXRpZXNPckVudGl0eVR5cGVzIGFzIEVudGl0eVR5cGVbXSB8IHN0cmluZ1tdKSBhcyBFbnRpdHlUeXBlW107XHJcbiAgICAgIGlmIChlbnRpdHlUeXBlcyAhPSBudWxsKSB7XHJcbiAgICAgICAgZW50aXR5VHlwZXMuZm9yRWFjaCgoZXQpID0+IHtcclxuICAgICAgICAgIGxldCBncm91cCA9IGVtLl9lbnRpdHlHcm91cE1hcFtldC5uYW1lXTtcclxuICAgICAgICAgIGlmIChncm91cCAmJiBncm91cC5fZW50aXRpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGVudGl0eUdyb3VwTWFwW2V0Lm5hbWVdID0gZ3JvdXA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGVudGl0aWVzT3JFbnRpdHlUeXBlcyAmJiBlbnRpdGllc09yRW50aXR5VHlwZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAvLyBlbXB0eSBhcnJheSA9IGV4cG9ydCBub3RoaW5nXHJcbiAgICBlbnRpdHlHcm91cE1hcCA9IHt9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBlbnRpdHlHcm91cE1hcCA9IGVtLl9lbnRpdHlHcm91cE1hcDtcclxuICB9XHJcblxyXG4gIGxldCB0ZW1wS2V5czogSVRlbXBLZXlbXSA9IFtdO1xyXG4gIGxldCBuZXdHcm91cE1hcCA9IHt9O1xyXG4gIGNvcmUub2JqZWN0Rm9yRWFjaChlbnRpdHlHcm91cE1hcCwgKGVudGl0eVR5cGVOYW1lLCBlbnRpdHlHcm91cCkgPT4ge1xyXG4gICAgbmV3R3JvdXBNYXBbZW50aXR5VHlwZU5hbWVdID0gZXhwb3J0RW50aXR5R3JvdXAoZW50aXR5R3JvdXAsIHRlbXBLZXlzKTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHsgZW50aXR5R3JvdXBNYXA6IG5ld0dyb3VwTWFwLCB0ZW1wS2V5czogdGVtcEtleXMgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXhwb3J0RW50aXR5R3JvdXAoZW50aXR5R3JvdXA6IEVudGl0eUdyb3VwLCB0ZW1wS2V5czogSVRlbXBLZXlbXSkge1xyXG4gIGxldCByZXN1bHRHcm91cCA9IHt9IGFzIHsgZW50aXRpZXM6IGFueVtdIH07XHJcbiAgbGV0IGVudGl0eVR5cGUgPSBlbnRpdHlHcm91cC5lbnRpdHlUeXBlO1xyXG4gIGxldCBkcHMgPSBlbnRpdHlUeXBlLmRhdGFQcm9wZXJ0aWVzO1xyXG4gIGxldCBzZXJpYWxpemVyRm4gPSBnZXRTZXJpYWxpemVyRm4oZW50aXR5VHlwZSk7XHJcbiAgbGV0IHJhd0VudGl0aWVzOiBhbnlbXSA9IFtdO1xyXG4gIGVudGl0eUdyb3VwLl9lbnRpdGllcy5mb3JFYWNoKChlbnRpdHkpID0+IHtcclxuICAgIGlmIChlbnRpdHkpIHtcclxuICAgICAgbGV0IHJhd0VudGl0eSA9IHN0cnVjdHVyYWxPYmplY3RUb0pzb24oZW50aXR5LCBkcHMsIHNlcmlhbGl6ZXJGbiwgdGVtcEtleXMpO1xyXG4gICAgICByYXdFbnRpdGllcy5wdXNoKHJhd0VudGl0eSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmVzdWx0R3JvdXAuZW50aXRpZXMgPSByYXdFbnRpdGllcztcclxuICByZXR1cm4gcmVzdWx0R3JvdXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cnVjdHVyYWxPYmplY3RUb0pzb24oc286IFN0cnVjdHVyYWxPYmplY3QsIGRwczogRGF0YVByb3BlcnR5W10sIHNlcmlhbGl6ZXJGbj86IChkcDogRGF0YVByb3BlcnR5LCB2YWx1ZTogYW55KSA9PiBhbnksIHRlbXBLZXlzPzogSVRlbXBLZXlbXSkge1xyXG5cclxuICBsZXQgcmVzdWx0ID0ge307XHJcbiAgZHBzLmZvckVhY2goZnVuY3Rpb24gKGRwKSB7XHJcbiAgICBsZXQgZHBOYW1lID0gZHAubmFtZTtcclxuICAgIGxldCB2YWx1ZSA9IHNvLmdldFByb3BlcnR5KGRwTmFtZSk7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCAmJiBkcC5kZWZhdWx0VmFsdWUgPT0gbnVsbCkgcmV0dXJuO1xyXG5cclxuICAgIGlmICh2YWx1ZSAmJiBkcC5pc0NvbXBsZXhQcm9wZXJ0eSkge1xyXG4gICAgICBsZXQgY29EcHMgPSAoZHAuZGF0YVR5cGUgYXMgQ29tcGxleFR5cGUpLmRhdGFQcm9wZXJ0aWVzO1xyXG4gICAgICB2YWx1ZSA9IGNvcmUubWFwKHZhbHVlLCBmdW5jdGlvbiAodjogQ29tcGxleE9iamVjdCkge1xyXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmFsT2JqZWN0VG9Kc29uKHYsIGNvRHBzLCBzZXJpYWxpemVyRm4pO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbHVlID0gc2VyaWFsaXplckZuID8gc2VyaWFsaXplckZuKGRwLCB2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgaWYgKGRwLmlzVW5tYXBwZWQpIHtcclxuICAgICAgICB2YWx1ZSA9IGNvcmUudG9KU09OU2FmZSh2YWx1ZSwgY29yZS50b0pTT05TYWZlUmVwbGFjZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG4gICAgcmVzdWx0W2RwTmFtZV0gPSB2YWx1ZTtcclxuICB9KTtcclxuXHJcbiAgLy8gaWYgKHNvLmVudGl0eUFzcGVjdCkge1xyXG4gIGlmIChFbnRpdHlBc3BlY3QuaXNFbnRpdHkoc28pKSB7XHJcbiAgICBsZXQgYXNwZWN0ID0gc28uZW50aXR5QXNwZWN0O1xyXG4gICAgbGV0IGVudGl0eVN0YXRlID0gYXNwZWN0LmVudGl0eVN0YXRlO1xyXG4gICAgbGV0IG5ld0FzcGVjdCA9IHtcclxuICAgICAgdGVtcE5hdlByb3BOYW1lczogZXhwb3J0VGVtcEtleUluZm8oYXNwZWN0LCB0ZW1wS2V5cyB8fCBbXSksXHJcbiAgICAgIGVudGl0eVN0YXRlOiBlbnRpdHlTdGF0ZS5uYW1lXHJcbiAgICB9IGFzIGFueTtcclxuICAgIGlmIChhc3BlY3QuZXh0cmFNZXRhZGF0YSkge1xyXG4gICAgICBuZXdBc3BlY3QuZXh0cmFNZXRhZGF0YSA9IGFzcGVjdC5leHRyYU1ldGFkYXRhO1xyXG4gICAgfVxyXG4gICAgaWYgKGVudGl0eVN0YXRlLmlzTW9kaWZpZWQoKSB8fCBlbnRpdHlTdGF0ZS5pc0RlbGV0ZWQoKSkge1xyXG4gICAgICBuZXdBc3BlY3Qub3JpZ2luYWxWYWx1ZXNNYXAgPSBhc3BlY3Qub3JpZ2luYWxWYWx1ZXM7XHJcbiAgICB9XHJcbiAgICAocmVzdWx0IGFzIGFueSkuZW50aXR5QXNwZWN0ID0gbmV3QXNwZWN0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgYXNwZWN0ID0gc28uY29tcGxleEFzcGVjdDtcclxuICAgIGxldCBuZXdBc3BlY3QgPSB7fSBhcyBhbnk7XHJcbiAgICBpZiAoYXNwZWN0Lm9yaWdpbmFsVmFsdWVzICYmICFjb3JlLmlzRW1wdHkoYXNwZWN0Lm9yaWdpbmFsVmFsdWVzKSkge1xyXG4gICAgICBuZXdBc3BlY3Qub3JpZ2luYWxWYWx1ZXNNYXAgPSBhc3BlY3Qub3JpZ2luYWxWYWx1ZXM7XHJcbiAgICB9XHJcblxyXG4gICAgKHJlc3VsdCBhcyBhbnkpLmNvbXBsZXhBc3BlY3QgPSBuZXdBc3BlY3Q7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgSVRlbXBLZXkge1xyXG4gIGVudGl0eVR5cGU6IHN0cmluZztcclxuICB2YWx1ZXM6IGFueVtdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHBvcnRUZW1wS2V5SW5mbyhlbnRpdHlBc3BlY3Q6IEVudGl0eUFzcGVjdCwgdGVtcEtleXM6IElUZW1wS2V5W10pIHtcclxuICBsZXQgZW50aXR5ID0gZW50aXR5QXNwZWN0LmVudGl0eSBhcyBFbnRpdHk7XHJcbiAgaWYgKGVudGl0eUFzcGVjdC5oYXNUZW1wS2V5KSB7XHJcbiAgICB0ZW1wS2V5cy5wdXNoKGVudGl0eUFzcGVjdC5nZXRLZXkoKS50b0pTT04oKSk7XHJcbiAgfVxyXG4gIC8vIGNyZWF0ZSBtYXAgZm9yIHRoaXMgZW50aXR5IHdpdGggZm9yZWlnbktleXMgdGhhdCBhcmUgJ3RlbXBvcmFyeSdcclxuICAvLyBtYXAgLT4ga2V5OiB0ZW1wS2V5LCB2YWx1ZTogZmtQcm9wTmFtZVxyXG4gIGxldCB0ZW1wTmF2UHJvcE5hbWVzOiBzdHJpbmdbXSA9IFtdO1xyXG4gIGVudGl0eS5lbnRpdHlUeXBlLm5hdmlnYXRpb25Qcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKG5wKSB7XHJcbiAgICBpZiAobnAucmVsYXRlZERhdGFQcm9wZXJ0aWVzKSB7XHJcbiAgICAgIGxldCByZWxhdGVkVmFsdWUgPSBlbnRpdHkuZ2V0UHJvcGVydHkobnAubmFtZSk7XHJcbiAgICAgIGlmIChyZWxhdGVkVmFsdWUgJiYgcmVsYXRlZFZhbHVlLmVudGl0eUFzcGVjdC5oYXNUZW1wS2V5KSB7XHJcbiAgICAgICAgdGVtcE5hdlByb3BOYW1lcy5wdXNoKG5wLm5hbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHRlbXBOYXZQcm9wTmFtZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGltcG9ydEVudGl0eUdyb3VwKGVudGl0eUdyb3VwOiBFbnRpdHlHcm91cCwganNvbkdyb3VwOiB7IGVudGl0aWVzOiBhbnlbXSB9LCBpbXBvcnRDb25maWc6IEltcG9ydENvbmZpZ0V4dCkge1xyXG5cclxuICBsZXQgdGVtcEtleU1hcCA9IGltcG9ydENvbmZpZy50ZW1wS2V5TWFwO1xyXG4gIGxldCBtZXJnZUFkZHMgPSAhIWltcG9ydENvbmZpZy5tZXJnZUFkZHM7XHJcblxyXG4gIGxldCBlbnRpdHlUeXBlID0gZW50aXR5R3JvdXAuZW50aXR5VHlwZTtcclxuICBsZXQgbWVyZ2VTdHJhdGVneSA9IGltcG9ydENvbmZpZy5tZXJnZVN0cmF0ZWd5O1xyXG5cclxuICBsZXQgdGFyZ2V0RW50aXR5OiBFbnRpdHkgfCB1bmRlZmluZWQ7XHJcblxyXG4gIGxldCBlbSA9IGVudGl0eUdyb3VwLmVudGl0eU1hbmFnZXI7XHJcbiAgbGV0IGVudGl0eUNoYW5nZWQgPSBlbS5lbnRpdHlDaGFuZ2VkO1xyXG4gIGxldCBlbnRpdGllc1RvTGluazogRW50aXR5W10gPSBbXTtcclxuICBsZXQgcmF3VmFsdWVGbiA9IERhdGFQcm9wZXJ0eS5nZXRSYXdWYWx1ZUZyb21DbGllbnQ7XHJcbiAganNvbkdyb3VwLmVudGl0aWVzLmZvckVhY2goZnVuY3Rpb24gKHJhd0VudGl0eTogYW55KSB7XHJcbiAgICBsZXQgbmV3QXNwZWN0ID0gcmF3RW50aXR5LmVudGl0eUFzcGVjdDtcclxuXHJcbiAgICBsZXQgZW50aXR5S2V5ID0gZW50aXR5VHlwZS5nZXRFbnRpdHlLZXlGcm9tUmF3RW50aXR5KHJhd0VudGl0eSwgcmF3VmFsdWVGbik7XHJcbiAgICBsZXQgZW50aXR5U3RhdGUgPSBFbnRpdHlTdGF0ZS5mcm9tTmFtZShuZXdBc3BlY3QuZW50aXR5U3RhdGUpIGFzIEVudGl0eVN0YXRlO1xyXG4gICAgaWYgKCFlbnRpdHlTdGF0ZSB8fCBlbnRpdHlTdGF0ZSA9PT0gRW50aXR5U3RhdGUuRGV0YWNoZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBlbnRpdGllcyB3aXRoIGEgbm9uIGRldGFjaGVkIGVudGl0eSBzdGF0ZSBtYXkgYmUgaW1wb3J0ZWQuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1lcmdlIGlmIHJhdyBlbnRpdHkgaXMgaW4gY2FjaGUgVU5MRVNTIHRoaXMgaXMgYSBuZXcgZW50aXR5IHcvIGEgdGVtcCBrZXlcclxuICAgIC8vIENhbm5vdCBzYWZlbHkgbWVyZ2Ugc3VjaCBlbnRpdGllcyBldmVuIGlmIGNvdWxkIG1hdGNoIHRlbXAga2V5IHRvIGFuIGVudGl0eSBpbiBjYWNoZS5cclxuICAgIC8vIENhbiBlbmFibGUgbWVyZ2Ugb2YgZW50aXRpZXMgdy90ZW1wIGtleSB1c2luZyBcIm1lcmdlQWRkc1wiIC0gdXNlIGF0IHlvdXIgb3duIHJpc2shXHJcbiAgICBsZXQgbmV3VGVtcEtleSA9ICFtZXJnZUFkZHMgJiYgZW50aXR5U3RhdGUuaXNBZGRlZCgpICYmIGdldE1hcHBlZEtleSh0ZW1wS2V5TWFwISwgZW50aXR5S2V5KTtcclxuICAgIHRhcmdldEVudGl0eSA9IG5ld1RlbXBLZXkgPyB1bmRlZmluZWQgOiBlbnRpdHlHcm91cC5maW5kRW50aXR5QnlLZXkoZW50aXR5S2V5KTtcclxuXHJcbiAgICBpZiAodGFyZ2V0RW50aXR5KSB7XHJcbiAgICAgIGlmIChtZXJnZVN0cmF0ZWd5ID09PSBNZXJnZVN0cmF0ZWd5LlNraXBNZXJnZSkge1xyXG4gICAgICAgIC8vIGRlbGliZXJhdGUgZmFsbCB0aHJ1XHJcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VTdHJhdGVneSA9PT0gTWVyZ2VTdHJhdGVneS5EaXNhbGxvd2VkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBNZXJnZVN0cmF0ZWd5IG9mICdEaXNhbGxvd2VkJyBwcmV2ZW50cyBcIiArIGVudGl0eUtleS50b1N0cmluZygpICsgXCIgZnJvbSBiZWluZyBtZXJnZWRcIik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IHRhcmdldEVudGl0eVN0YXRlID0gdGFyZ2V0RW50aXR5LmVudGl0eUFzcGVjdC5lbnRpdHlTdGF0ZTtcclxuICAgICAgICBsZXQgd2FzVW5jaGFuZ2VkID0gdGFyZ2V0RW50aXR5U3RhdGUuaXNVbmNoYW5nZWQoKTtcclxuICAgICAgICBpZiAobWVyZ2VTdHJhdGVneSA9PT0gTWVyZ2VTdHJhdGVneS5PdmVyd3JpdGVDaGFuZ2VzIHx8IHdhc1VuY2hhbmdlZCkge1xyXG4gICAgICAgICAgZW50aXR5VHlwZS5fdXBkYXRlVGFyZ2V0RnJvbVJhdyh0YXJnZXRFbnRpdHksIHJhd0VudGl0eSwgcmF3VmFsdWVGbik7XHJcbiAgICAgICAgICB0YXJnZXRFbnRpdHkuZW50aXR5QXNwZWN0LnNldEVudGl0eVN0YXRlKGVudGl0eVN0YXRlKTtcclxuICAgICAgICAgIGVudGl0eUNoYW5nZWQucHVibGlzaCh7IGVudGl0eUFjdGlvbjogRW50aXR5QWN0aW9uLk1lcmdlT25JbXBvcnQsIGVudGl0eTogdGFyZ2V0RW50aXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGFyZ2V0RW50aXR5ID0gZW50aXR5VHlwZS5fY3JlYXRlSW5zdGFuY2VDb3JlKCkgYXMgRW50aXR5O1xyXG4gICAgICBlbnRpdHlUeXBlLl91cGRhdGVUYXJnZXRGcm9tUmF3KHRhcmdldEVudGl0eSwgcmF3RW50aXR5LCByYXdWYWx1ZUZuKTtcclxuICAgICAgaWYgKG5ld1RlbXBLZXkpIHtcclxuICAgICAgICB0YXJnZXRFbnRpdHkuZW50aXR5QXNwZWN0Lmhhc1RlbXBLZXkgPSB0cnVlO1xyXG4gICAgICAgIC8vIGZpeHVwIHBrXHJcbiAgICAgICAgdGFyZ2V0RW50aXR5LnNldFByb3BlcnR5KGVudGl0eVR5cGUua2V5UHJvcGVydGllc1swXS5uYW1lLCBuZXdUZW1wS2V5LnZhbHVlc1swXSk7XHJcblxyXG4gICAgICAgIC8vIGZpeHVwIGZvcmVpZ24ga2V5c1xyXG4gICAgICAgIC8vIFRoaXMgaXMgc2FmZSBiZWNhdXNlIHRoZSBlbnRpdHkgaXMgZGV0YWNoZWQgaGVyZSBhbmQgdGhlcmVmb3JlIG9yaWdpbmFsVmFsdWVzIHdpbGwgbm90IGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgaWYgKG5ld0FzcGVjdC50ZW1wTmF2UHJvcE5hbWVzKSB7XHJcbiAgICAgICAgICBuZXdBc3BlY3QudGVtcE5hdlByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChucE5hbWU6IHN0cmluZykge1xyXG4gICAgICAgICAgICBsZXQgbnAgPSBlbnRpdHlUeXBlLmdldE5hdmlnYXRpb25Qcm9wZXJ0eShucE5hbWUpO1xyXG4gICAgICAgICAgICBsZXQgZmtQcm9wTmFtZSA9IG5wIS5yZWxhdGVkRGF0YVByb3BlcnRpZXNbMF0ubmFtZTtcclxuICAgICAgICAgICAgbGV0IG9sZEZrVmFsdWUgPSB0YXJnZXRFbnRpdHkhLmdldFByb3BlcnR5KGZrUHJvcE5hbWUpO1xyXG4gICAgICAgICAgICBsZXQgZmsgPSBuZXcgRW50aXR5S2V5KG5wIS5lbnRpdHlUeXBlLCBbb2xkRmtWYWx1ZV0pO1xyXG4gICAgICAgICAgICBsZXQgbmV3RmsgPSBnZXRNYXBwZWRLZXkodGVtcEtleU1hcCEsIGZrKTtcclxuICAgICAgICAgICAgdGFyZ2V0RW50aXR5IS5zZXRQcm9wZXJ0eShma1Byb3BOYW1lLCBuZXdGayEudmFsdWVzWzBdKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBOb3cgcGVyZm9ybWVkIGluIGF0dGFjaEVudGl0eVxyXG4gICAgICB0YXJnZXRFbnRpdHkgPSBlbnRpdHlHcm91cC5hdHRhY2hFbnRpdHkodGFyZ2V0RW50aXR5LCBlbnRpdHlTdGF0ZSk7XHJcbiAgICAgIGVudGl0eUNoYW5nZWQucHVibGlzaCh7IGVudGl0eUFjdGlvbjogRW50aXR5QWN0aW9uLkF0dGFjaE9uSW1wb3J0LCBlbnRpdHk6IHRhcmdldEVudGl0eSB9KTtcclxuICAgICAgaWYgKCFlbnRpdHlTdGF0ZS5pc1VuY2hhbmdlZCgpKSB7XHJcbiAgICAgICAgZW0uX25vdGlmeVN0YXRlQ2hhbmdlKHRhcmdldEVudGl0eSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBlbnRpdGllc1RvTGluay5wdXNoKHRhcmdldEVudGl0eSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGVudGl0aWVzVG9MaW5rO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRNYXBwZWRLZXkodGVtcEtleU1hcDogSVRlbXBLZXlNYXAsIGVudGl0eUtleTogRW50aXR5S2V5KSB7XHJcbiAgbGV0IG5ld0tleSA9IHRlbXBLZXlNYXBbZW50aXR5S2V5LnRvU3RyaW5nKCldO1xyXG4gIGlmIChuZXdLZXkpIHJldHVybiBuZXdLZXk7XHJcbiAgbGV0IHN1YnR5cGVzID0gZW50aXR5S2V5Ll9zdWJ0eXBlcztcclxuICBpZiAoIXN1YnR5cGVzKSByZXR1cm4gbnVsbDtcclxuICBmb3IgKGxldCBpID0gMCwgaiA9IHN1YnR5cGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG4gICAgbmV3S2V5ID0gdGVtcEtleU1hcFtlbnRpdHlLZXkudG9TdHJpbmcoc3VidHlwZXNbaV0pXTtcclxuICAgIGlmIChuZXdLZXkpIHJldHVybiBuZXdLZXk7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9taXNlV2l0aENhbGxiYWNrczxUPihwcm9taXNlOiBQcm9taXNlPFQ+LCBjYWxsYmFjaz86IENhbGxiYWNrLCBlcnJvckNhbGxiYWNrPzogRXJyb3JDYWxsYmFjaykge1xyXG4gIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZGF0YSk7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xyXG4gIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgaWYgKGVycm9yQ2FsbGJhY2spIGVycm9yQ2FsbGJhY2soZXJyb3IpO1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICB9KTtcclxuICByZXR1cm4gcHJvbWlzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RW50aXRpZXNUb1NhdmUoZW06IEVudGl0eU1hbmFnZXIsIGVudGl0aWVzPzogRW50aXR5W10pIHtcclxuICBsZXQgZW50aXRpZXNUb1NhdmU6IEVudGl0eVtdO1xyXG4gIGlmIChlbnRpdGllcykge1xyXG4gICAgZW50aXRpZXNUb1NhdmUgPSBlbnRpdGllcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgaWYgKGUuZW50aXR5QXNwZWN0LmVudGl0eU1hbmFnZXIgIT09IGVtKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBlbnRpdGllcyBpbiB0aGlzIGVudGl0eU1hbmFnZXIgbWF5IGJlIHNhdmVkXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAhZS5lbnRpdHlBc3BlY3QuZW50aXR5U3RhdGUuaXNEZXRhY2hlZCgpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGVudGl0aWVzVG9TYXZlID0gZW0uZ2V0Q2hhbmdlcygpO1xyXG4gIH1cclxuICByZXR1cm4gZW50aXRpZXNUb1NhdmU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpeHVwS2V5cyhlbTogRW50aXR5TWFuYWdlciwga2V5TWFwcGluZ3M6IEtleU1hcHBpbmdbXSkge1xyXG4gIGVtLl9pbktleUZpeHVwID0gdHJ1ZTtcclxuICBrZXlNYXBwaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChrbSkge1xyXG4gICAgbGV0IGdyb3VwID0gZW0uX2VudGl0eUdyb3VwTWFwW2ttLmVudGl0eVR5cGVOYW1lXTtcclxuICAgIGlmICghZ3JvdXApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvY2F0ZSB0aGUgZm9sbG93aW5nIGZ1bGx5IHF1YWxpZmllZCBFbnRpdHlUeXBlIG5hbWU6IFwiICsga20uZW50aXR5VHlwZU5hbWUpO1xyXG4gICAgfVxyXG4gICAgZ3JvdXAuX2ZpeHVwS2V5KGttLnRlbXBWYWx1ZSwga20ucmVhbFZhbHVlKTtcclxuICB9KTtcclxuICBlbS5faW5LZXlGaXh1cCA9IGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFbnRpdHlHcm91cHMoZW06IEVudGl0eU1hbmFnZXIsIGVudGl0eVR5cGVzPzogRW50aXR5VHlwZSB8IEVudGl0eVR5cGVbXSkge1xyXG4gIGxldCBncm91cE1hcCA9IGVtLl9lbnRpdHlHcm91cE1hcDtcclxuICBpZiAoZW50aXR5VHlwZXMpIHtcclxuICAgIHJldHVybiBjb3JlLnRvQXJyYXkoZW50aXR5VHlwZXMpLm1hcChmdW5jdGlvbiAoZXQ6IEVudGl0eVR5cGUpIHtcclxuICAgICAgaWYgKGV0IGluc3RhbmNlb2YgRW50aXR5VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBncm91cE1hcFtldC5uYW1lXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgRW50aXR5TWFuYWdlci5nZXRDaGFuZ2VzKCkgJ2VudGl0eVR5cGVzJyBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYW4gZW50aXR5VHlwZSBvciBhbiBhcnJheSBvZiBlbnRpdHlUeXBlcyBvciBudWxsXCIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGNvcmUuZ2V0T3duUHJvcGVydHlWYWx1ZXMoZ3JvdXBNYXApIGFzIEVudGl0eUdyb3VwW107XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja0VudGl0eUtleShlbTogRW50aXR5TWFuYWdlciwgZW50aXR5OiBFbnRpdHkpIHtcclxuICBsZXQgZWsgPSBlbnRpdHkuZW50aXR5QXNwZWN0LmdldEtleSgpO1xyXG4gIC8vIHJldHVybiBwcm9wZXJ0aWVzIHRoYXQgYXJlID0gdG8gZGVmYXVsdFZhbHVlc1xyXG4gIGxldCBrZXlQcm9wc1dpdGhEZWZhdWx0VmFsdWVzID0gY29yZS5hcnJheVppcChlbnRpdHkuZW50aXR5VHlwZS5rZXlQcm9wZXJ0aWVzLCBlay52YWx1ZXMsIGZ1bmN0aW9uIChrcCwga3YpIHtcclxuICAgIHJldHVybiAoa3AuZGVmYXVsdFZhbHVlID09PSBrdikgPyBrcCA6IG51bGw7XHJcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChrcCkge1xyXG4gICAgcmV0dXJuIGtwICE9PSBudWxsO1xyXG4gIH0pO1xyXG4gIGlmIChrZXlQcm9wc1dpdGhEZWZhdWx0VmFsdWVzLmxlbmd0aCkge1xyXG4gICAgaWYgKGVudGl0eS5lbnRpdHlUeXBlLmF1dG9HZW5lcmF0ZWRLZXlUeXBlICE9PSBBdXRvR2VuZXJhdGVkS2V5VHlwZS5Ob25lKSB7XHJcbiAgICAgIGVtLmdlbmVyYXRlVGVtcEtleVZhbHVlKGVudGl0eSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyB3ZSB3aWxsIGFsbG93IGF0dGFjaGVzIG9mIGVudGl0aWVzIHdoZXJlIG9ubHkgcGFydCBvZiB0aGUga2V5IGlzIHNldC5cclxuICAgICAgaWYgKGtleVByb3BzV2l0aERlZmF1bHRWYWx1ZXMubGVuZ3RoID09PSBlay52YWx1ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGF0dGFjaCBhbiBvYmplY3Qgb2YgdHlwZSAgKFwiICsgZW50aXR5LmVudGl0eVR5cGUubmFtZSArIFwiKSB0byBhbiBFbnRpdHlNYW5hZ2VyIHdpdGhvdXQgZmlyc3Qgc2V0dGluZyBpdHMga2V5IG9yIHNldHRpbmcgaXRzIGVudGl0eVR5cGUgJ0F1dG9HZW5lcmF0ZWRLZXlUeXBlJyBwcm9wZXJ0eSB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiAnTm9uZSdcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRW50aXR5U3RhdGVzKGVtOiBFbnRpdHlNYW5hZ2VyLCBlbnRpdHlTdGF0ZXM/OiBFbnRpdHlTdGF0ZSB8IEVudGl0eVN0YXRlW10pIHtcclxuICBpZiAoIWVudGl0eVN0YXRlcykgcmV0dXJuIFtdIGFzIEVudGl0eVN0YXRlW107XHJcbiAgbGV0IGVudFN0YXRlcyA9IGNvcmUudG9BcnJheShlbnRpdHlTdGF0ZXMpIGFzIEVudGl0eVN0YXRlW107XHJcbiAgZW50U3RhdGVzLmZvckVhY2goKGVzKSA9PiB7XHJcbiAgICBpZiAoIShlcyBpbnN0YW5jZW9mIEVudGl0eVN0YXRlKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgRW50aXR5TWFuYWdlci5nZXRDaGFuZ2VzKCkgJ2VudGl0eVN0YXRlcycgcGFyYW1ldGVyIG11c3QgZWl0aGVyIGJlIG51bGwsIGFuIGVudGl0eVN0YXRlIG9yIGFuIGFycmF5IG9mIGVudGl0eVN0YXRlc1wiKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gZW50U3RhdGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhdHRhY2hSZWxhdGVkRW50aXRpZXMoZW06IEVudGl0eU1hbmFnZXIsIGVudGl0eTogRW50aXR5LCBlbnRpdHlTdGF0ZTogRW50aXR5U3RhdGUsIG1lcmdlU3RyYXRlZ3k6IE1lcmdlU3RyYXRlZ3kpIHtcclxuICBsZXQgbmF2UHJvcHMgPSBlbnRpdHkuZW50aXR5VHlwZS5uYXZpZ2F0aW9uUHJvcGVydGllcztcclxuICBuYXZQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChucCkge1xyXG4gICAgbGV0IHJlbGF0ZWQgPSBlbnRpdHkuZ2V0UHJvcGVydHkobnAubmFtZSk7XHJcbiAgICBpZiAobnAuaXNTY2FsYXIpIHtcclxuICAgICAgaWYgKCFyZWxhdGVkKSByZXR1cm47XHJcbiAgICAgIGVtLmF0dGFjaEVudGl0eShyZWxhdGVkLCBlbnRpdHlTdGF0ZSwgbWVyZ2VTdHJhdGVneSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZWxhdGVkLmZvckVhY2goZnVuY3Rpb24gKGU6IEVudGl0eSkge1xyXG4gICAgICAgIGVtLmF0dGFjaEVudGl0eShlLCBlbnRpdHlTdGF0ZSwgbWVyZ2VTdHJhdGVneSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm5zIGEgcHJvbWlzZVxyXG5mdW5jdGlvbiBleGVjdXRlUXVlcnlDb3JlKGVtOiBFbnRpdHlNYW5hZ2VyLCBxdWVyeTogRW50aXR5UXVlcnkgfCBzdHJpbmcsIHF1ZXJ5T3B0aW9uczogUXVlcnlPcHRpb25zLCBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UpOiBQcm9taXNlPFF1ZXJ5UmVzdWx0PiB7XHJcbiAgdHJ5IHtcclxuICAgIGxldCByZXN1bHRzOiBhbnlbXTtcclxuICAgIGxldCBtZXRhZGF0YVN0b3JlID0gZW0ubWV0YWRhdGFTdG9yZTtcclxuXHJcbiAgICBpZiAobWV0YWRhdGFTdG9yZS5pc0VtcHR5KCkgJiYgZGF0YVNlcnZpY2UuaGFzU2VydmVyTWV0YWRhdGEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGV4ZWN1dGUgX2V4ZWN1dGVRdWVyeUNvcmUgdW50aWwgbWV0YWRhdGFTdG9yZSBpcyBwb3B1bGF0ZWQuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChxdWVyeU9wdGlvbnMuZmV0Y2hTdHJhdGVneSA9PT0gRmV0Y2hTdHJhdGVneS5Gcm9tTG9jYWxDYWNoZSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZXhlY3V0ZSAnc3RyaW5nJyBFbnRpdHlRdWVyeSBsb2NhbGx5LlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHFyID0gZXhlY3V0ZVF1ZXJ5TG9jYWxseUNvcmUoZW0sIHF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgcmVzdWx0czogcXIucmVzdWx0cywgZW50aXR5TWFuYWdlcjogZW0sIGlubGluZUNvdW50OiBxci5pbmxpbmVDb3VudCwgcXVlcnk6IHF1ZXJ5IH0pO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG1hcHBpbmdDb250ZXh0OiBNYXBwaW5nQ29udGV4dCB8IHVuZGVmaW5lZCA9IG5ldyBNYXBwaW5nQ29udGV4dCh7XHJcbiAgICAgIHF1ZXJ5OiBxdWVyeSxcclxuICAgICAgZW50aXR5TWFuYWdlcjogZW0sXHJcbiAgICAgIGRhdGFTZXJ2aWNlOiBkYXRhU2VydmljZSxcclxuICAgICAgbWVyZ2VPcHRpb25zOiB7XHJcbiAgICAgICAgbWVyZ2VTdHJhdGVneTogcXVlcnlPcHRpb25zLm1lcmdlU3RyYXRlZ3ksXHJcbiAgICAgICAgbm9UcmFja2luZzogISEocXVlcnkgYXMgYW55KS5ub1RyYWNraW5nRW5hYmxlZCxcclxuICAgICAgICBpbmNsdWRlRGVsZXRlZDogcXVlcnlPcHRpb25zLmluY2x1ZGVEZWxldGVkXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGxldCB2YWxpZGF0ZU9uUXVlcnkgPSBlbS52YWxpZGF0aW9uT3B0aW9ucy52YWxpZGF0ZU9uUXVlcnk7XHJcblxyXG4gICAgcmV0dXJuIGRhdGFTZXJ2aWNlLmFkYXB0ZXJJbnN0YW5jZSEuZXhlY3V0ZVF1ZXJ5KG1hcHBpbmdDb250ZXh0KS50aGVuKGZ1bmN0aW9uIChkYXRhOiBhbnkpIHtcclxuICAgICAgbGV0IHJlc3VsdCA9IGNvcmUud3JhcEV4ZWN1dGlvbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IHN0YXRlID0geyBpc0xvYWRpbmc6IGVtLmlzTG9hZGluZyB9O1xyXG4gICAgICAgIGVtLmlzTG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgZW0uX3BlbmRpbmdQdWJzID0gW107XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICB9LCBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICAvLyBjbGVhbnVwXHJcbiAgICAgICAgZW0uaXNMb2FkaW5nID0gc3RhdGUuaXNMb2FkaW5nO1xyXG4gICAgICAgIGVtLl9wZW5kaW5nUHVicyEuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZW0uX3BlbmRpbmdQdWJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGVtLl9oYXNDaGFuZ2VzQWN0aW9uICYmIGVtLl9oYXNDaGFuZ2VzQWN0aW9uKCk7XHJcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlZCAtIG5vdCBzdXJlIHdoeSBuZWVkZWQgaW4gZmlyc3QgcGxhY2UuLi5cclxuICAgICAgICAvLyAvLyBIQUNLIGZvciBHQ1xyXG4gICAgICAgIC8vIHF1ZXJ5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIG1hcHBpbmdDb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8vIEhBQ0s6IHNvbWUgZXJyb3JzIHRocm93biBpbiBuZXh0IGZ1bmN0aW9uIGRvIG5vdCBwcm9wb2dhdGUgcHJvcGVybHkgLSB0aGlzIGNhdGNoZXMgdGhlbS5cclxuXHJcbiAgICAgICAgaWYgKHN0YXRlLmVycm9yKSB7XHJcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qoc3RhdGUuZXJyb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsZXQgbm9kZXMgPSBkYXRhU2VydmljZS5qc29uUmVzdWx0c0FkYXB0ZXIuZXh0cmFjdFJlc3VsdHMoZGF0YSk7XHJcbiAgICAgICAgbm9kZXMgPSBjb3JlLnRvQXJyYXkobm9kZXMpO1xyXG5cclxuICAgICAgICByZXN1bHRzID0gbWFwcGluZ0NvbnRleHQhLnZpc2l0QW5kTWVyZ2Uobm9kZXMsIHsgbm9kZVR5cGU6IFwicm9vdFwiIH0pO1xyXG4gICAgICAgIGlmICh2YWxpZGF0ZU9uUXVlcnkpIHtcclxuICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocjogYW55KSB7XHJcbiAgICAgICAgICAgIC8vIGFub24gdHlwZXMgYW5kIHNpbXBsZSB0eXBlcyB3aWxsIG5vdCBoYXZlIGFuIGVudGl0eUFzcGVjdC5cclxuICAgICAgICAgICAgci5lbnRpdHlBc3BlY3QgJiYgci5lbnRpdHlBc3BlY3QudmFsaWRhdGVFbnRpdHkoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXBwaW5nQ29udGV4dCEucHJvY2Vzc0RlZmVycmVkKCk7XHJcbiAgICAgICAgLy8gaWYgcXVlcnkgaGFzIGV4cGFuZCBjbGF1c2VzIHdhbGsgZWFjaCBvZiB0aGUgJ3Jlc3VsdHMnIGFuZCBtYXJrIHRoZSBleHBhbmRlZCBwcm9wcyBhcyBsb2FkZWQuXHJcbiAgICAgICAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgRW50aXR5UXVlcnkpIHtcclxuICAgICAgICAgIG1hcmtMb2FkZWROYXZQcm9wcyhyZXN1bHRzLCBxdWVyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXRyaWV2ZWRFbnRpdGllcyA9IGNvcmUub2JqZWN0TWFwKG1hcHBpbmdDb250ZXh0IS5yZWZNYXApO1xyXG4gICAgICAgIHJldHVybiB7IHJlc3VsdHM6IHJlc3VsdHMsIHF1ZXJ5OiBxdWVyeSwgZW50aXR5TWFuYWdlcjogZW0sIGh0dHBSZXNwb25zZTogZGF0YS5odHRwUmVzcG9uc2UsIGlubGluZUNvdW50OiBkYXRhLmlubGluZUNvdW50LCByZXRyaWV2ZWRFbnRpdGllczogcmV0cmlldmVkRW50aXRpZXMgfTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcclxuICAgIH0sIGZ1bmN0aW9uIChlOiBhbnkpIHtcclxuICAgICAgaWYgKGUpIHtcclxuICAgICAgICBlLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICAgICAgZS5lbnRpdHlNYW5hZ2VyID0gZW07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xyXG4gICAgfSk7XHJcblxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlmIChlKSB7XHJcbiAgICAgIGUucXVlcnkgPSBxdWVyeTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtMb2FkZWROYXZQcm9wcyhlbnRpdGllczogRW50aXR5W10sIHF1ZXJ5OiBFbnRpdHlRdWVyeSkge1xyXG4gIGlmIChxdWVyeS5ub1RyYWNraW5nRW5hYmxlZCkgcmV0dXJuO1xyXG4gIGxldCBleHBhbmRDbGF1c2UgPSBxdWVyeS5leHBhbmRDbGF1c2U7XHJcbiAgaWYgKGV4cGFuZENsYXVzZSA9PSBudWxsKSByZXR1cm47XHJcbiAgZXhwYW5kQ2xhdXNlLnByb3BlcnR5UGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHlQYXRoKSB7XHJcbiAgICBsZXQgcHJvcE5hbWVzID0gcHJvcGVydHlQYXRoLnNwbGl0KCcuJyk7XHJcbiAgICBtYXJrTG9hZGVkTmF2UGF0aChlbnRpdGllcywgcHJvcE5hbWVzKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWFya0xvYWRlZE5hdlBhdGgoZW50aXRpZXM6IEVudGl0eVtdLCBwcm9wTmFtZXM6IHN0cmluZ1tdKSB7XHJcbiAgbGV0IHByb3BOYW1lID0gcHJvcE5hbWVzWzBdO1xyXG4gIGVudGl0aWVzLmZvckVhY2goKGVudGl0eSkgPT4ge1xyXG4gICAgbGV0IGVhID0gZW50aXR5LmVudGl0eUFzcGVjdDtcclxuICAgIGlmICghZWEpIHJldHVybjsgLy8gZW50aXR5IG1heSBub3QgYmUgYSAncmVhbCcgZW50aXR5IGluIHRoZSBjYXNlIG9mIGEgcHJvamVjdGlvbi5cclxuICAgIGVhLl9tYXJrQXNMb2FkZWQocHJvcE5hbWUpO1xyXG4gICAgaWYgKHByb3BOYW1lcy5sZW5ndGggPT09IDEpIHJldHVybjtcclxuICAgIGxldCBuZXh0ID0gZW50aXR5LmdldFByb3BlcnR5KHByb3BOYW1lKTtcclxuICAgIGlmICghbmV4dCkgcmV0dXJuOyAvLyBubyBjaGlsZHJlbiB0byBwcm9jZXNzLlxyXG4gICAgLy8gc3RyYW5nZSBsb2dpYyBiZWNhdXNlIG5vbnNjYWxhciBuYXYgdmFsdWVzIGFyZSBOT1QgcmVhbGx5IGFycmF5c1xyXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGNvdWxkIHVzZSBBcnJheS5pc0FycmF5XHJcbiAgICBpZiAoIW5leHQuYXJyYXlDaGFuZ2VkKSBuZXh0ID0gW25leHRdO1xyXG4gICAgbWFya0xvYWRlZE5hdlBhdGgobmV4dCwgcHJvcE5hbWVzLnNsaWNlKDEpKTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlQ29uY3VycmVuY3lQcm9wZXJ0aWVzKGVudGl0aWVzOiBFbnRpdHlbXSkge1xyXG4gIGxldCBjYW5kaWRhdGVzID0gZW50aXRpZXMuZmlsdGVyKChlKSA9PiB7XHJcbiAgICBlLmVudGl0eUFzcGVjdC5pc0JlaW5nU2F2ZWQgPSB0cnVlO1xyXG4gICAgcmV0dXJuIGUuZW50aXR5QXNwZWN0LmVudGl0eVN0YXRlLmlzTW9kaWZpZWQoKVxyXG4gICAgICAmJiBlLmVudGl0eVR5cGUuY29uY3VycmVuY3lQcm9wZXJ0aWVzLmxlbmd0aCA+IDA7XHJcblxyXG4gIH0pO1xyXG4gIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xyXG4gICAgYy5lbnRpdHlUeXBlLmNvbmN1cnJlbmN5UHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChjcCkge1xyXG4gICAgICB1cGRhdGVDb25jdXJyZW5jeVByb3BlcnR5KGMsIGNwKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDb25jdXJyZW5jeVByb3BlcnR5KGVudGl0eTogRW50aXR5LCBwcm9wZXJ0eTogRGF0YVByb3BlcnR5KSB7XHJcbiAgLy8gY2hlY2sgaWYgcHJvcGVydHkgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXHJcbiAgaWYgKGVudGl0eS5lbnRpdHlBc3BlY3Qub3JpZ2luYWxWYWx1ZXNbcHJvcGVydHkubmFtZV0pIHJldHVybjtcclxuICBsZXQgdmFsdWUgPSBlbnRpdHkuZ2V0UHJvcGVydHkocHJvcGVydHkubmFtZSk7XHJcbiAgbGV0IGRhdGFUeXBlID0gcHJvcGVydHkuZGF0YVR5cGUgYXMgRGF0YVR5cGU7XHJcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSBkYXRhVHlwZS5kZWZhdWx0VmFsdWU7XHJcbiAgaWYgKGRhdGFUeXBlLmlzTnVtZXJpYykge1xyXG4gICAgZW50aXR5LnNldFByb3BlcnR5KHByb3BlcnR5Lm5hbWUsIHZhbHVlICsgMSk7XHJcbiAgfSBlbHNlIGlmIChkYXRhVHlwZS5nZXRDb25jdXJyZW5jeVZhbHVlKSB7XHJcbiAgICAvLyBEYXRhVHlwZSBoYXMgaXRzIG93biBpbXBsZW1lbnRhdGlvblxyXG4gICAgbGV0IG5leHRWYWx1ZSA9IGRhdGFUeXBlLmdldENvbmN1cnJlbmN5VmFsdWUodmFsdWUpO1xyXG4gICAgZW50aXR5LnNldFByb3BlcnR5KHByb3BlcnR5Lm5hbWUsIG5leHRWYWx1ZSk7XHJcbiAgfSBlbHNlIGlmIChkYXRhVHlwZSA9PT0gRGF0YVR5cGUuQmluYXJ5KSB7XHJcbiAgICAvLyBiZXN0IGd1ZXNzIC0gdGhhdCB0aGlzIGlzIGEgdGltZXN0YW1wIGNvbHVtbiBhbmQgaXMgY29tcHV0ZWQgb24gdGhlIHNlcnZlciBkdXJpbmcgc2F2ZVxyXG4gICAgLy8gLSBzbyBubyBuZWVkIHRvIHNldCBpdCBoZXJlLlxyXG4gICAgcmV0dXJuO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyB0aGlzIGp1c3QgbGVhdmVzIERhdGFUeXBlcyBvZiBCb29sZWFuLCBTdHJpbmcgYW5kIEJ5dGUgLSBub25lIG9mIHdoaWNoIHNob3VsZCBiZSB0aGVcclxuICAgIC8vIHR5cGUgZm9yIGEgY29uY3VycmVuY3kgY29sdW1uLlxyXG4gICAgLy8gTk9URTogdGhvdWdodCBhYm91dCBqdXN0IHJldHVybmluZyBoZXJlIGJ1dCB3b3VsZCByYXRoZXIgYmUgc2FmZSBmb3Igbm93LlxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHVwZGF0ZSB0aGUgdmFsdWUgb2YgY29uY3VycmVuY3kgcHJvcGVydHkgYmVmb3JlIHNhdmluZzogXCIgKyBwcm9wZXJ0eS5uYW1lKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBmaW5kT3JDcmVhdGVFbnRpdHlHcm91cChlbTogRW50aXR5TWFuYWdlciwgZW50aXR5VHlwZTogRW50aXR5VHlwZSkge1xyXG4gIGxldCBncm91cCA9IGVtLl9lbnRpdHlHcm91cE1hcFtlbnRpdHlUeXBlLm5hbWVdO1xyXG4gIGlmICghZ3JvdXApIHtcclxuICAgIGdyb3VwID0gbmV3IEVudGl0eUdyb3VwKGVtLCBlbnRpdHlUeXBlKTtcclxuICAgIGVtLl9lbnRpdHlHcm91cE1hcFtlbnRpdHlUeXBlLm5hbWVdID0gZ3JvdXA7XHJcbiAgfVxyXG4gIHJldHVybiBncm91cDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlRW50aXR5R3JvdXBzKGVtOiBFbnRpdHlNYW5hZ2VyLCBlbnRpdHlUeXBlOiBFbnRpdHlUeXBlKSB7XHJcbiAgbGV0IGVudGl0eVR5cGVzID0gZW50aXR5VHlwZS5nZXRTZWxmQW5kU3VidHlwZXMoKTtcclxuICByZXR1cm4gZW50aXR5VHlwZXMubWFwKChldCkgPT4ge1xyXG4gICAgcmV0dXJuIGZpbmRPckNyZWF0ZUVudGl0eUdyb3VwKGVtLCBldCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVud3JhcEluc3RhbmNlKHN0cnVjdE9iajogU3RydWN0dXJhbE9iamVjdCwgdHJhbnNmb3JtRm4/OiAoZHA6IERhdGFQcm9wZXJ0eSwgdmFsOiBhbnkpID0+IGFueSkge1xyXG5cclxuICBsZXQgcmF3T2JqZWN0OiBhbnkgPSB7fTtcclxuICBsZXQgc3R5cGUgPSBFbnRpdHlBc3BlY3QuaXNFbnRpdHkoc3RydWN0T2JqKSA/IHN0cnVjdE9iai5lbnRpdHlUeXBlIDogc3RydWN0T2JqLmNvbXBsZXhUeXBlO1xyXG4gIGxldCBzZXJpYWxpemVyRm4gPSBnZXRTZXJpYWxpemVyRm4oc3R5cGUpO1xyXG4gIGxldCB1bm1hcHBlZCA9IHt9O1xyXG4gIHN0eXBlLmRhdGFQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKGRwKSB7XHJcbiAgICBpZiAoZHAuaXNDb21wbGV4UHJvcGVydHkpIHtcclxuICAgICAgcmF3T2JqZWN0W2RwLm5hbWVPblNlcnZlcl0gPSBjb3JlLm1hcChzdHJ1Y3RPYmouZ2V0UHJvcGVydHkoZHAubmFtZSksIGZ1bmN0aW9uIChjbykge1xyXG4gICAgICAgIHJldHVybiB1bndyYXBJbnN0YW5jZShjbywgdHJhbnNmb3JtRm4pO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCB2YWwgPSBzdHJ1Y3RPYmouZ2V0UHJvcGVydHkoZHAubmFtZSk7XHJcbiAgICAgIHZhbCA9IHRyYW5zZm9ybUZuID8gdHJhbnNmb3JtRm4oZHAsIHZhbCkgOiB2YWw7XHJcbiAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG4gICAgICB2YWwgPSBzZXJpYWxpemVyRm4gPyBzZXJpYWxpemVyRm4oZHAsIHZhbCkgOiB2YWw7XHJcbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChkcC5pc1VubWFwcGVkKSB7XHJcbiAgICAgICAgICB1bm1hcHBlZFtkcC5uYW1lT25TZXJ2ZXJdID0gY29yZS50b0pTT05TYWZlKHZhbCwgY29yZS50b0pTT05TYWZlUmVwbGFjZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByYXdPYmplY3RbZHAubmFtZU9uU2VydmVyXSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgaWYgKCFjb3JlLmlzRW1wdHkodW5tYXBwZWQpKSB7XHJcbiAgICAvLyBUT0RPOiByZXZpZXcgdGhpcy5cclxuICAgIChyYXdPYmplY3QgYXMgYW55KS5fX3VubWFwcGVkID0gdW5tYXBwZWQ7XHJcbiAgfVxyXG4gIHJldHVybiByYXdPYmplY3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVud3JhcE9yaWdpbmFsVmFsdWVzKHRhcmdldDogU3RydWN0dXJhbE9iamVjdCwgbWV0YWRhdGFTdG9yZTogTWV0YWRhdGFTdG9yZSwgdHJhbnNmb3JtRm4/OiAoZHA6IERhdGFQcm9wZXJ0eSwgdmFsOiBhbnkpID0+IGFueSkge1xyXG4gIGxldCBzdHlwZSA9IEVudGl0eUFzcGVjdC5pc0VudGl0eSh0YXJnZXQpID8gdGFyZ2V0LmVudGl0eVR5cGUgOiB0YXJnZXQuY29tcGxleFR5cGU7XHJcbiAgbGV0IGFzcGVjdCA9IEVudGl0eUFzcGVjdC5pc0VudGl0eSh0YXJnZXQpID8gdGFyZ2V0LmVudGl0eUFzcGVjdCA6IHRhcmdldC5jb21wbGV4QXNwZWN0O1xyXG4gIGxldCBmbiA9IG1ldGFkYXRhU3RvcmUubmFtaW5nQ29udmVudGlvbi5jbGllbnRQcm9wZXJ0eU5hbWVUb1NlcnZlcjtcclxuICBsZXQgcmVzdWx0ID0ge307XHJcbiAgY29yZS5vYmplY3RGb3JFYWNoKGFzcGVjdC5vcmlnaW5hbFZhbHVlcywgZnVuY3Rpb24gKHByb3BOYW1lLCB2YWwpIHtcclxuICAgIGxldCBwcm9wID0gc3R5cGUuZ2V0UHJvcGVydHkocHJvcE5hbWUpIGFzIERhdGFQcm9wZXJ0eTtcclxuICAgIHZhbCA9IHRyYW5zZm9ybUZuID8gdHJhbnNmb3JtRm4ocHJvcCwgdmFsKSA6IHZhbDtcclxuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXN1bHRbZm4ocHJvcE5hbWUsIHByb3ApXSA9IHZhbDtcclxuICAgIH1cclxuICB9KTtcclxuICBzdHlwZS5jb21wbGV4UHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChjcCkge1xyXG4gICAgbGV0IG5leHRUYXJnZXQgPSB0YXJnZXQuZ2V0UHJvcGVydHkoY3AubmFtZSk7XHJcbiAgICBpZiAoY3AuaXNTY2FsYXIpIHtcclxuICAgICAgbGV0IHVud3JhcHBlZENvID0gdW53cmFwT3JpZ2luYWxWYWx1ZXMobmV4dFRhcmdldCwgbWV0YWRhdGFTdG9yZSwgdHJhbnNmb3JtRm4pO1xyXG4gICAgICBpZiAoIWNvcmUuaXNFbXB0eSh1bndyYXBwZWRDbykpIHtcclxuICAgICAgICByZXN1bHRbZm4oY3AubmFtZSwgY3ApXSA9IHVud3JhcHBlZENvO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgdW53cmFwcGVkQ29zID0gbmV4dFRhcmdldC5tYXAoKGl0ZW06IGFueSkgPT4ge1xyXG4gICAgICAgIHJldHVybiB1bndyYXBPcmlnaW5hbFZhbHVlcyhpdGVtLCBtZXRhZGF0YVN0b3JlLCB0cmFuc2Zvcm1Gbik7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXN1bHRbZm4oY3AubmFtZSwgY3ApXSA9IHVud3JhcHBlZENvcztcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB1bndyYXBDaGFuZ2VkVmFsdWVzKGVudGl0eTogRW50aXR5LCBtZXRhZGF0YVN0b3JlOiBNZXRhZGF0YVN0b3JlLCB0cmFuc2Zvcm1GbjogKGRwOiBEYXRhUHJvcGVydHksIHZhbDogYW55KSA9PiBhbnkpIHtcclxuICBsZXQgc3R5cGUgPSBlbnRpdHkuZW50aXR5VHlwZTtcclxuICBsZXQgc2VyaWFsaXplckZuID0gZ2V0U2VyaWFsaXplckZuKHN0eXBlKTtcclxuICBsZXQgZm4gPSBtZXRhZGF0YVN0b3JlLm5hbWluZ0NvbnZlbnRpb24uY2xpZW50UHJvcGVydHlOYW1lVG9TZXJ2ZXI7XHJcbiAgbGV0IHJlc3VsdCA9IHt9O1xyXG4gIGNvcmUub2JqZWN0Rm9yRWFjaChlbnRpdHkuZW50aXR5QXNwZWN0Lm9yaWdpbmFsVmFsdWVzLCBmdW5jdGlvbiAocHJvcE5hbWUsIHZhbHVlKSB7XHJcbiAgICBsZXQgcHJvcCA9IHN0eXBlLmdldFByb3BlcnR5KHByb3BOYW1lKSBhcyBEYXRhUHJvcGVydHk7XHJcbiAgICBsZXQgdmFsID0gZW50aXR5LmdldFByb3BlcnR5KHByb3BOYW1lKTtcclxuICAgIHZhbCA9IHRyYW5zZm9ybUZuID8gdHJhbnNmb3JtRm4ocHJvcCwgdmFsKSA6IHZhbDtcclxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG4gICAgdmFsID0gc2VyaWFsaXplckZuID8gc2VyaWFsaXplckZuKHByb3AsIHZhbCkgOiB2YWw7XHJcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmVzdWx0W2ZuKHByb3BOYW1lLCBwcm9wKV0gPSB2YWw7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgLy8gYW55IGNoYW5nZSB0byBhbnkgY29tcGxleCBvYmplY3Qgb3IgYXJyYXkgb2YgY29tcGxleCBvYmplY3RzIHJldHVybnMgdGhlIEVOVElSRVxyXG4gIC8vIGN1cnJlbnQgY29tcGxleCBvYmplY3Qgb3IgY29tcGxleCBvYmplY3QgYXJyYXkuICBUaGlzIGlzIGJ5IGRlc2lnbi4gQ29tcGxleCBPYmplY3RzXHJcbiAgLy8gYXJlIGF0b21pYy5cclxuICBzdHlwZS5jb21wbGV4UHJvcGVydGllcy5mb3JFYWNoKChjcCkgPT4ge1xyXG4gICAgaWYgKGNwSGFzT3JpZ2luYWxWYWx1ZXMoZW50aXR5LCBjcCkpIHtcclxuICAgICAgbGV0IGNvT3JDb3MgPSBlbnRpdHkuZ2V0UHJvcGVydHkoY3AubmFtZSk7XHJcbiAgICAgIHJlc3VsdFtmbihjcC5uYW1lLCBjcCldID0gY29yZS5tYXAoY29PckNvcywgZnVuY3Rpb24gKGNvKSB7XHJcbiAgICAgICAgcmV0dXJuIHVud3JhcEluc3RhbmNlKGNvLCB0cmFuc2Zvcm1Gbik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNwSGFzT3JpZ2luYWxWYWx1ZXMoc3RydWN0dXJhbE9iamVjdDogU3RydWN0dXJhbE9iamVjdCwgY3A6IERhdGFQcm9wZXJ0eSk6IGJvb2xlYW4ge1xyXG4gIGxldCBjb09yQ29zID0gc3RydWN0dXJhbE9iamVjdC5nZXRQcm9wZXJ0eShjcC5uYW1lKTtcclxuICBpZiAoY3AuaXNTY2FsYXIpIHtcclxuICAgIHJldHVybiBjb0hhc09yaWdpbmFsVmFsdWVzKGNvT3JDb3MpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyB0aGlzIG9jY3VycyB3aGVuIGEgbm9uc2NhbGFyIGNvIGFycmF5IGhhcyBoYWQgY29zIGFkZGVkIG9yIHJlbW92ZWQuXHJcbiAgICBpZiAoY29PckNvcy5fb3JpZ1ZhbHVlcykgcmV0dXJuIHRydWU7XHJcbiAgICByZXR1cm4gY29PckNvcy5zb21lKGZ1bmN0aW9uIChjbzogQ29tcGxleE9iamVjdCkge1xyXG4gICAgICByZXR1cm4gY29IYXNPcmlnaW5hbFZhbHVlcyhjbyk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4ZWN1dGVRdWVyeUxvY2FsbHlDb3JlKGVtOiBFbnRpdHlNYW5hZ2VyLCBxdWVyeTogRW50aXR5UXVlcnkpIHtcclxuICBhc3NlcnRQYXJhbShxdWVyeSwgXCJxdWVyeVwiKS5pc0luc3RhbmNlT2YoRW50aXR5UXVlcnkpLmNoZWNrKCk7XHJcblxyXG4gIGxldCBtZXRhZGF0YVN0b3JlID0gZW0ubWV0YWRhdGFTdG9yZTtcclxuICBsZXQgZW50aXR5VHlwZSA9IHF1ZXJ5Ll9nZXRGcm9tRW50aXR5VHlwZShtZXRhZGF0YVN0b3JlLCB0cnVlKTtcclxuICAvLyB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgZ3JvdXBzIGlzIHRoaXMgaXMgYSBiYXNlIGVudGl0eSB0eXBlLlxyXG4gIGxldCBncm91cHMgPSBmaW5kT3JDcmVhdGVFbnRpdHlHcm91cHMoZW0sIGVudGl0eVR5cGUhKTtcclxuICAvLyBmaWx0ZXIgdGhlbiBvcmRlciB0aGVuIHNraXAgdGhlbiB0YWtlXHJcbiAgbGV0IGZpbHRlckZ1bmMgPSBxdWVyeS53aGVyZVByZWRpY2F0ZSAmJiBxdWVyeS53aGVyZVByZWRpY2F0ZS50b0Z1bmN0aW9uKHsgZW50aXR5VHlwZTogZW50aXR5VHlwZSB9KTtcclxuXHJcbiAgbGV0IHF1ZXJ5T3B0aW9ucyA9IFF1ZXJ5T3B0aW9ucy5yZXNvbHZlKFtxdWVyeS5xdWVyeU9wdGlvbnMsIGVtLnF1ZXJ5T3B0aW9ucywgUXVlcnlPcHRpb25zLmRlZmF1bHRJbnN0YW5jZV0pO1xyXG4gIGxldCBpbmNsdWRlRGVsZXRlZCA9IHF1ZXJ5T3B0aW9ucy5pbmNsdWRlRGVsZXRlZCA9PT0gdHJ1ZTtcclxuXHJcbiAgbGV0IG5ld0ZpbHRlckZ1bmMgPSBmdW5jdGlvbiAoZW50aXR5OiBFbnRpdHkpIHtcclxuICAgIHJldHVybiBlbnRpdHkgJiYgKGluY2x1ZGVEZWxldGVkIHx8ICFlbnRpdHkuZW50aXR5QXNwZWN0LmVudGl0eVN0YXRlLmlzRGVsZXRlZCgpKSAmJiAoZmlsdGVyRnVuYyA/IGZpbHRlckZ1bmMoZW50aXR5KSA6IHRydWUpO1xyXG4gIH07XHJcblxyXG4gIGxldCByZXN1bHQ6IGFueVtdID0gW107XHJcbiAgLy8gVE9ETzogbWFwTWFueVxyXG4gIGdyb3Vwcy5mb3JFYWNoKChncm91cCkgPT4ge1xyXG4gICAgbGV0IGVudGl0aWVzID0gZ3JvdXAuX2VudGl0aWVzLmZpbHRlcihuZXdGaWx0ZXJGdW5jKSBhcyBFbnRpdHlbXTtcclxuICAgIGlmIChlbnRpdGllcy5sZW5ndGgpIHtcclxuICAgICAgcmVzdWx0ID0gcmVzdWx0Lmxlbmd0aCA/IHJlc3VsdC5jb25jYXQoZW50aXRpZXMpIDogZW50aXRpZXM7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGxldCBvcmRlckJ5Q29tcGFyZXIgPSBxdWVyeS5vcmRlckJ5Q2xhdXNlICYmIHF1ZXJ5Lm9yZGVyQnlDbGF1c2UuZ2V0Q29tcGFyZXIoZW50aXR5VHlwZSEpO1xyXG4gIGlmIChvcmRlckJ5Q29tcGFyZXIpIHtcclxuICAgIHJlc3VsdC5zb3J0KG9yZGVyQnlDb21wYXJlcik7XHJcbiAgfVxyXG5cclxuICBsZXQgaW5saW5lQ291bnQgPSBxdWVyeS5pbmxpbmVDb3VudEVuYWJsZWQgPyByZXN1bHQubGVuZ3RoIDogdW5kZWZpbmVkO1xyXG5cclxuICBsZXQgc2tpcENvdW50ID0gcXVlcnkuc2tpcENvdW50O1xyXG4gIGlmIChza2lwQ291bnQpIHtcclxuICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZShza2lwQ291bnQpO1xyXG4gIH1cclxuICBsZXQgdGFrZUNvdW50ID0gcXVlcnkudGFrZUNvdW50O1xyXG4gIGlmICh0YWtlQ291bnQpIHtcclxuICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCB0YWtlQ291bnQpO1xyXG4gIH1cclxuXHJcbiAgbGV0IHNlbGVjdENsYXVzZSA9IHF1ZXJ5LnNlbGVjdENsYXVzZTtcclxuICBpZiAoc2VsZWN0Q2xhdXNlKSB7XHJcbiAgICBsZXQgc2VsZWN0Rm4gPSBzZWxlY3RDbGF1c2UudG9GdW5jdGlvbigpO1xyXG4gICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChzZWxlY3RGbik7XHJcbiAgfVxyXG4gIHJldHVybiB7IHJlc3VsdHM6IHJlc3VsdCwgaW5saW5lQ291bnQ6IGlubGluZUNvdW50IH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvSGFzT3JpZ2luYWxWYWx1ZXMoY286IENvbXBsZXhPYmplY3QpIHtcclxuICAvLyBuZXh0IGxpbmUgY2hlY2tzIGFsbCBub24gY29tcGxleCBwcm9wZXJ0aWVzIG9mIHRoZSBjby5cclxuICBpZiAoIWNvcmUuaXNFbXB0eShjby5jb21wbGV4QXNwZWN0Lm9yaWdpbmFsVmFsdWVzKSkgcmV0dXJuIHRydWU7XHJcbiAgLy8gbm93IG5lZWQgdG8gcmVjdXJzaXZlbHkgY2hlY2sgZWFjaCBvZiB0aGUgY3BzXHJcbiAgcmV0dXJuIGNvLmNvbXBsZXhUeXBlLmNvbXBsZXhQcm9wZXJ0aWVzLnNvbWUoZnVuY3Rpb24gKGNwKSB7XHJcbiAgICByZXR1cm4gY3BIYXNPcmlnaW5hbFZhbHVlcyhjbywgY3ApO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTZXJpYWxpemVyRm4oc3R5cGU6IEVudGl0eVR5cGUgfCBDb21wbGV4VHlwZSkge1xyXG4gIHJldHVybiBzdHlwZS5zZXJpYWxpemVyRm4gfHwgKHN0eXBlLm1ldGFkYXRhU3RvcmUgJiYgc3R5cGUubWV0YWRhdGFTdG9yZS5zZXJpYWxpemVyRm4pO1xyXG59XHJcblxyXG4iXX0=