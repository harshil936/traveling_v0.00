import * as tslib_1 from "tslib";
import { core } from './core';
import { config } from './config';
import { BreezeEvent } from './event';
import { assertParam, assertConfig, Param } from './assert-param';
import { DataType } from './data-type';
import { EntityAspect, ComplexAspect } from './entity-aspect';
import { EntityKey } from './entity-key';
import { Validator } from './validate';
import { BreezeEnum } from './enum';
import { DataService } from './data-service';
import { NamingConvention } from './naming-convention';
import { CsdlMetadataParser } from './csdl-metadata-parser'; // TODO isolate this later;
import { LocalQueryComparisonOptions } from './local-query-comparison-options';
import { defaultPropertyInterceptor } from './default-property-interceptor';
/**
An instance of the MetadataStore contains all of the metadata about a collection of [[EntityType]]'s.
MetadataStores may be shared across [[EntityManager]]'s.  If an EntityManager is created without an
explicit MetadataStore, the MetadataStore from the MetadataStore.defaultInstance property will be used.
@dynamic
**/
var MetadataStore = /** @class */ (function () {
    /**
    Constructs a new MetadataStore.
    
    >     let ms = new MetadataStore();
  
    The store can then be associated with an EntityManager
    >     let entityManager = new EntityManager( {
    >         serviceName: "breeze/NorthwindIBModel",
    >         metadataStore: ms
    >     });
  
    or for an existing EntityManager
    >    // Assume em1 is an existing EntityManager
    >    em1.setProperties( { metadataStore: ms });
    
    @param config - Configuration settings .
      - namingConvention - (default=NamingConvention.defaultInstance) NamingConvention to be used in mapping property names
    between client and server. Uses the NamingConvention.defaultInstance if not specified.
      - localQueryComparisonOptions - (default=LocalQueryComparisonOptions.defaultInstance) The LocalQueryComparisonOptions to be
    used when performing "local queries" in order to match the semantics of queries against a remote service.
      - serializerFn - A function that is used to mediate the serialization of instances of this type.
    **/
    function MetadataStore(config) {
        config = config || {};
        assertConfig(config)
            .whereParam("namingConvention").isOptional().isInstanceOf(NamingConvention).withDefault(NamingConvention.defaultInstance)
            .whereParam("localQueryComparisonOptions").isOptional().isInstanceOf(LocalQueryComparisonOptions).withDefault(LocalQueryComparisonOptions.defaultInstance)
            .whereParam("serializerFn").isOptional().isFunction()
            .applyAll(this);
        this.dataServices = []; // array of dataServices;
        this._resourceEntityTypeMap = {}; // key is resource name - value is qualified entityType name
        this._structuralTypeMap = {}; // key is qualified structuraltype name - value is structuralType. ( structural = entityType or complexType).
        this._shortNameMap = {}; // key is shortName, value is qualified name - does not need to be serialized.
        this._ctorRegistry = {}; // key is either short or qual type name - value is ctor;
        this._incompleteTypeMap = {}; // key is entityTypeName; value is array of nav props
        this._incompleteComplexTypeMap = {}; // key is complexTypeName; value is array of complexType props
        this._id = MetadataStore.__id++;
        this.metadataFetched = new BreezeEvent("metadataFetched", this);
    }
    // for debugging use the line below instead.
    //ctor.normalizeTypeName = function (rawTypeName) { return parseTypeName(rawTypeName).typeName; };
    /**
    General purpose property set method
    
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     em1.metadataStore.setProperties( {
    >         version: "6.1.3",
    >         serializerFn: function(prop, value) {
    >         return (prop.isUnmapped) ? undefined : value;
    >         }
    >     )};
    @param config -  An object containing the selected properties and values to set.
    **/
    MetadataStore.prototype.setProperties = function (config) {
        assertConfig(config)
            .whereParam("name").isString().isOptional()
            .whereParam("serializerFn").isFunction().isOptional()
            .applyAll(this);
    };
    /**
    Adds a DataService to this MetadataStore. If a DataService with the same serviceName is already
    in the MetadataStore an exception will be thrown.
    @param dataService - The [[DataService]] to add
    @param shouldOverwrite - (default=false) Permit overwrite of existing DataService rather than throw exception
    **/
    MetadataStore.prototype.addDataService = function (dataService, shouldOverwrite) {
        assertParam(dataService, "dataService").isInstanceOf(DataService).check();
        assertParam(shouldOverwrite, "shouldOverwrite").isBoolean().isOptional().check();
        var ix = this._getDataServiceIndex(dataService.serviceName);
        if (ix >= 0) {
            if (!!shouldOverwrite) {
                this.dataServices[ix] = dataService;
            }
            else {
                throw new Error("A dataService with this name '" + dataService.serviceName + "' already exists in this MetadataStore");
            }
        }
        else {
            this.dataServices.push(dataService);
        }
    };
    /** @hidden @internal */
    MetadataStore.prototype._getDataServiceIndex = function (serviceName) {
        return core.arrayIndexOf(this.dataServices, function (ds) {
            return ds.serviceName === serviceName;
        });
    };
    /**
    Adds an EntityType to this MetadataStore.  No additional properties may be added to the EntityType after its has
    been added to the MetadataStore.
    @param structuralType - The EntityType or ComplexType to add
    **/
    MetadataStore.prototype.addEntityType = function (stype) {
        var structuralType;
        if (stype instanceof EntityType || stype instanceof ComplexType) {
            structuralType = stype;
        }
        else {
            structuralType = stype.isComplexType ? new ComplexType(stype) : new EntityType(stype);
        }
        // if (!structuralType.isComplexType) { // same as below but isn't a 'type guard'
        if (structuralType instanceof EntityType) {
            if (structuralType.baseTypeName && !structuralType.baseEntityType) {
                var baseEntityType = this._getStructuralType(structuralType.baseTypeName, true);
                // safe cast because we know that baseEntityType must be an EntityType if the structuralType is an EntityType
                structuralType._updateFromBase(baseEntityType);
            }
            if (structuralType.keyProperties.length === 0 && !structuralType.isAbstract) {
                throw new Error("Unable to add " + structuralType.name +
                    " to this MetadataStore.  An EntityType must have at least one property designated as a key property - See the 'DataProperty.isPartOfKey' property.");
            }
        }
        structuralType.metadataStore = this;
        // don't register anon types
        if (!structuralType.isAnonymous) {
            if (this._structuralTypeMap[structuralType.name]) {
                throw new Error("Type " + structuralType.name + " already exists in this MetadataStore.");
            }
            this._structuralTypeMap[structuralType.name] = structuralType;
            this._shortNameMap[structuralType.shortName] = structuralType.name;
        }
        structuralType.getProperties().forEach(function (p) {
            structuralType._updateNames(p);
            if (!p.isUnmapped) {
                structuralType._mappedPropertiesCount++;
            }
        });
        structuralType._updateCps();
        // 'isEntityType' is a type guard
        if (structuralType instanceof EntityType) {
            structuralType._updateNps();
            // give the type it's base's resource name if it doesn't have its own.
            var defResourceName = structuralType.defaultResourceName || (structuralType.baseEntityType && structuralType.baseEntityType.defaultResourceName);
            if (defResourceName && !this.getEntityTypeNameForResourceName(defResourceName)) {
                this.setEntityTypeForResourceName(defResourceName, structuralType.name);
            }
            structuralType.defaultResourceName = defResourceName;
            // check if this structural type's name, short version or qualified version has a registered ctor.
            structuralType.getEntityCtor();
        }
    };
    /**
    Exports this MetadataStore to a serialized string appropriate for local storage.   This operation is also called
    internally when exporting an EntityManager.
    >      // assume ms is a previously created MetadataStore
    >      let metadataAsString = ms.exportMetadata();
    >      window.localStorage.setItem("metadata", metadataAsString);
    >      // and later, usually in a different session imported
    >      let metadataFromStorage = window.localStorage.getItem("metadata");
    >      let newMetadataStore = new MetadataStore();
    >      newMetadataStore.importMetadata(metadataFromStorage);
    @return A serialized version of this MetadataStore that may be stored locally and later restored.
    **/
    MetadataStore.prototype.exportMetadata = function () {
        var result = JSON.stringify({
            "metadataVersion": MetadataStore.metadataVersion,
            "name": this.name,
            "namingConvention": this.namingConvention.name,
            "localQueryComparisonOptions": this.localQueryComparisonOptions.name,
            "dataServices": this.dataServices,
            "structuralTypes": core.objectMap(this._structuralTypeMap),
            "resourceEntityTypeMap": this._resourceEntityTypeMap
        }, null, config.stringifyPad);
        return result;
    };
    /**
    Imports a previously exported serialized MetadataStore into this MetadataStore.
      
    >      // assume ms is a previously created MetadataStore
    >      let metadataAsString = ms.exportMetadata();
    >      window.localStorage.setItem("metadata", metadataAsString);
    >      // and later, usually in a different session
    >      let metadataFromStorage = window.localStorage.getItem("metadata");
    >      let newMetadataStore = new MetadataStore();
    >      newMetadataStore.importMetadata(metadataFromStorage);
    @param exportedMetadata - A previously exported MetadataStore.
    @param allowMerge -  Allows custom metadata to be merged into existing metadata types.
    @return This MetadataStore.
    @chainable
    **/
    MetadataStore.prototype.importMetadata = function (exportedMetadata, allowMerge) {
        var _this = this;
        if (allowMerge === void 0) { allowMerge = false; }
        assertParam(allowMerge, "allowMerge").isOptional().isBoolean().check();
        this._deferredTypes = {};
        // insure that we don't mutate incoming exportedMetadata ( if its an object)
        var metadataAsString = (typeof (exportedMetadata) === "string") ? exportedMetadata : JSON.stringify(exportedMetadata);
        var metadataJson = JSON.parse(metadataAsString);
        if (metadataJson.schema) {
            return CsdlMetadataParser.parse(this, metadataJson.schema, metadataJson.altMetadata);
        }
        var json = metadataJson;
        if (json.metadataVersion && json.metadataVersion !== MetadataStore.metadataVersion) {
            var msg = core.formatString("Cannot import metadata with a different 'metadataVersion' (%1) than the current 'MetadataStore.metadataVersion' (%2) ", json.metadataVersion, MetadataStore.metadataVersion);
            throw new Error(msg);
        }
        var ncName = json.namingConvention;
        var lqcoName = json.localQueryComparisonOptions;
        if (this.isEmpty()) {
            this.namingConvention = config._fetchObject(NamingConvention, ncName) || this.namingConvention;
            this.localQueryComparisonOptions = config._fetchObject(LocalQueryComparisonOptions, lqcoName) || this.localQueryComparisonOptions;
        }
        else {
            if (ncName && this.namingConvention.name !== ncName) {
                throw new Error("Cannot import metadata with a different 'namingConvention' from the current MetadataStore");
            }
            if (lqcoName && this.localQueryComparisonOptions.name !== lqcoName) {
                throw new Error("Cannot import metadata with different 'localQueryComparisonOptions' from the current MetadataStore");
            }
        }
        //noinspection JSHint
        json.dataServices && json.dataServices.forEach(function (ds) {
            var realDs = DataService.fromJSON(ds);
            _this.addDataService(realDs, true);
        });
        json.structuralTypes && json.structuralTypes.forEach(function (stype) {
            structuralTypeFromJson(_this, stype, allowMerge);
        });
        core.extend(this._resourceEntityTypeMap, json.resourceEntityTypeMap);
        core.extend(this._incompleteTypeMap, json.incompleteTypeMap);
        return this;
    };
    /**
    Creates a new MetadataStore from a previously exported serialized MetadataStore
    >      // assume ms is a previously created MetadataStore
    >      let metadataAsString = ms.exportMetadata();
    >      window.localStorage.setItem("metadata", metadataAsString);
    >      // and later, usually in a different session
    >      let metadataFromStorage = window.localStorage.getItem("metadata");
    >      let newMetadataStore = MetadataStore.importMetadata(metadataFromStorage);
    @param exportedString - A previously exported MetadataStore.
    @return A new MetadataStore.
    **/
    MetadataStore.importMetadata = function (exportedString) {
        var ms = new MetadataStore();
        ms.importMetadata(exportedString);
        return ms;
    };
    /**
    Returns whether Metadata has been retrieved for a specified service name.
    >      // Assume em1 is an existing EntityManager.
    >      if (!em1.metadataStore.hasMetadataFor("breeze/NorthwindIBModel"))) {
    >          // do something interesting
    >      }
    @param serviceName - The service name.
    @return Whether metadata has already been retrieved for the specified service name.
    **/
    MetadataStore.prototype.hasMetadataFor = function (serviceName) {
        return !!this.getDataService(serviceName);
    };
    /**
    Returns the DataService for a specified service name
    >      // Assume em1 is an existing EntityManager.
    >      let ds = em1.metadataStore.getDataService("breeze/NorthwindIBModel");
    >      let adapterName = ds.adapterName; // may be null
    @param serviceName - The service name.
    @return The DataService with the specified name.
    **/
    MetadataStore.prototype.getDataService = function (serviceName) {
        assertParam(serviceName, "serviceName").isString().check();
        serviceName = DataService._normalizeServiceName(serviceName);
        return core.arrayFirst(this.dataServices, function (ds) {
            return ds.serviceName === serviceName;
        });
    };
    /**
    Fetches the metadata for a specified 'service'. This method is automatically called
    internally by an EntityManager before its first query against a new service. __Async__
  
    Usually you will not actually process the results of a fetchMetadata call directly, but will instead
    ask for the metadata from the EntityManager after the fetchMetadata call returns.
    >      let ms = new MetadataStore();
    >      // or more commonly
    >      // let ms = anEntityManager.metadataStore;
    >      ms.fetchMetadata("breeze/NorthwindIBModel").then(function(rawMetadata) {
    >            // do something with the metadata
    >      }).catch(function(exception) {
    >          // handle exception here
    >      });
    @param dataService -  Either a DataService or just the name of the DataService to fetch metadata for.
    @param callback - Function called on success.
    @param errorCallback - Function called on failure.
    @return Promise
    **/
    MetadataStore.prototype.fetchMetadata = function (dataService, callback, errorCallback) {
        var _this = this;
        try {
            assertParam(dataService, "dataService").isString().or().isInstanceOf(DataService).check();
            assertParam(callback, "callback").isFunction().isOptional().check();
            assertParam(errorCallback, "errorCallback").isFunction().isOptional().check();
            if (typeof dataService === "string") {
                // use the dataService with a matching name or create a new one.
                dataService = this.getDataService(dataService) || new DataService({ serviceName: dataService });
            }
            dataService = DataService.resolve([dataService]);
            if (this.hasMetadataFor(dataService.serviceName)) {
                throw new Error("Metadata for a specific serviceName may only be fetched once per MetadataStore. ServiceName: " + dataService.serviceName);
            }
            return dataService.adapterInstance.fetchMetadata(this, dataService).then(function (rawMetadata) {
                _this.metadataFetched.publish({ metadataStore: _this, dataService: dataService, rawMetadata: rawMetadata });
                if (callback)
                    callback(rawMetadata);
                return Promise.resolve(rawMetadata);
            }, function (error) {
                if (errorCallback)
                    errorCallback(error);
                return Promise.reject(error);
            });
        }
        catch (e) {
            return Promise.reject(e);
        }
    };
    // TODO: strongly type interceptor below.
    /**
    Used to register a constructor for an EntityType that is not known via standard Metadata discovery;
    i.e. an unmapped type.
    @param entityCtor - The constructor function for the 'unmapped' type.
    @param interceptor - An interceptor function
    **/
    MetadataStore.prototype.trackUnmappedType = function (entityCtor, interceptor) {
        assertParam(entityCtor, "entityCtor").isFunction().check();
        assertParam(interceptor, "interceptor").isFunction().isOptional().check();
        // TODO: think about adding this to the MetadataStore.
        var entityType = new EntityType(this);
        entityType._setCtor(entityCtor, interceptor);
    };
    /**
    Provides a mechanism to register a 'custom' constructor to be used when creating new instances
    of the specified entity type.  If this call is not made, a default constructor is created for
    the entity as needed.
    This call may be made before or after the corresponding EntityType has been discovered via
    Metadata discovery.
    >      let Customer = function () {
    >              this.miscData = "asdf";
    >          };
    >      Customer.prototype.doFoo() {
    >              ...
    >          }
    >      // assume em1 is a preexisting EntityManager;
    >      em1.metadataStore.registerEntityTypeCtor("Customer", Customer);
    >      // any queries or EntityType.create calls from this point on will call the Customer constructor
    >      // registered above.
    @param structuralTypeName - The name of the EntityType or ComplexType.
    @param aCtor - The constructor for this EntityType or ComplexType; may be null if all you want to do is set the next parameter.
    @param initFn - A function or the name of a function on the entity that is to be executed immediately after the entity has been created
    and populated with any initial values. Called with 'initFn(entity)'
    @param noTrackingFn - A function that is executed immediately after a noTracking entity has been created and whose return
    value will be used in place of the noTracking entity.
    **/
    MetadataStore.prototype.registerEntityTypeCtor = function (structuralTypeName, aCtor, initFn, noTrackingFn) {
        assertParam(structuralTypeName, "structuralTypeName").isString().check();
        assertParam(aCtor, "aCtor").isFunction().isOptional().check();
        assertParam(initFn, "initFn").isOptional().isFunction().or().isString().check();
        assertParam(noTrackingFn, "noTrackingFn").isOptional().isFunction().check();
        var qualifiedTypeName = getQualifiedTypeName(this, structuralTypeName, false);
        var typeName = qualifiedTypeName || structuralTypeName;
        if (aCtor) {
            if (aCtor._$typeName && aCtor._$typeName !== typeName) {
                // TODO: wrap this - console and especially console.warn does not exist in all browsers.
                console.warn("Registering a constructor for " + typeName + " that is already used for " + aCtor._$typeName + ".");
            }
            aCtor._$typeName = typeName;
        }
        this._ctorRegistry[typeName] = { ctor: aCtor, initFn: initFn, noTrackingFn: noTrackingFn };
        if (qualifiedTypeName) {
            var stype = this._structuralTypeMap[qualifiedTypeName];
            stype && stype.getCtor(true); // this will complete the registration if avail now.
        }
    };
    /**
    Returns whether this MetadataStore contains any metadata yet.
    >      // assume em1 is a preexisting EntityManager;
    >      if (em1.metadataStore.isEmpty()) {
    >          // do something interesting
    >      }
    **/
    MetadataStore.prototype.isEmpty = function () {
        return core.isEmpty(this._structuralTypeMap);
    };
    /**
    Returns an [[EntityType]] or null given its name.
    >      // assume em1 is a preexisting EntityManager
    >      let odType = em1.metadataStore.getAsEntityType("OrderDetail");
  
    or to throw an error if the type is not found
    >      let badType = em1.metadataStore.getAsEntityType("Foo", false);
    >      // badType will not get set and an exception will be thrown.
    @param structuralTypeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    MetadataStore.prototype.getAsEntityType = function (typeName, okIfNotFound) {
        if (okIfNotFound === void 0) { okIfNotFound = false; }
        var st = this.getStructuralType(typeName, okIfNotFound);
        if (st instanceof EntityType) {
            return st;
        }
        else if (okIfNotFound) {
            return null;
        }
        else {
            var msg = core.formatString("Unable to locate an 'EntityType' by the name: '%1'. Be sure to execute a query or call fetchMetadata first.", typeName);
            throw new Error(msg);
        }
    };
    /**
    Returns an [[EntityType]] or null given its name.
    >      // assume em1 is a preexisting EntityManager
    >      let locType = em1.metadataStore.getAsComplexType("Location");
  
    or to throw an error if the type is not found
    >      let badType = em1.metadataStore.getAsComplexType("Foo", false);
    >      // badType will not get set and an exception will be thrown.
    @param structuralTypeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    MetadataStore.prototype.getAsComplexType = function (typeName, okIfNotFound) {
        if (okIfNotFound === void 0) { okIfNotFound = false; }
        var st = this.getStructuralType(typeName, okIfNotFound);
        if (st instanceof ComplexType) {
            return st;
        }
        else if (okIfNotFound) {
            return null;
        }
        else {
            var msg = core.formatString("Unable to locate an 'ComplexType' by the name: '%1'. Be sure to execute a query or call fetchMetadata first.", typeName);
            throw new Error(msg);
        }
    };
    /**
    Returns an [[EntityType]] or a [[ComplexType]] given its name.
    @deprecated Replaced by getStructuralType but ... it is probably more usefull to call either getAsEntityType or getAsComplexType instead
    @param typeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    MetadataStore.prototype.getEntityType = function (typeName, okIfNotFound) {
        if (okIfNotFound === void 0) { okIfNotFound = false; }
        return this.getStructuralType(typeName, okIfNotFound);
    };
    /**
    Returns an [[EntityType]] or a [[ComplexType]] given its name.
    >      // assume em1 is a preexisting EntityManager
    >      let odType = em1.metadataStore.getStructuralType("OrderDetail");
  
    or to throw an error if the type is not found
    >      let badType = em1.metadataStore.getStructuralType("Foo", false);
    >      // badType will not get set and an exception will be thrown.
    @deprecated Preferably use either getAsEntityType or getAsComplexType.  Get
    @param typeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    MetadataStore.prototype.getStructuralType = function (typeName, okIfNotFound) {
        if (okIfNotFound === void 0) { okIfNotFound = false; }
        assertParam(typeName, "typeName").isString().check();
        assertParam(okIfNotFound, "okIfNotFound").isBoolean().isOptional().check(false);
        return this._getStructuralType(typeName, okIfNotFound);
    };
    /** @hidden @internal */
    MetadataStore.prototype._getStructuralType = function (typeName, okIfNotFound) {
        if (okIfNotFound === void 0) { okIfNotFound = false; }
        var qualTypeName = getQualifiedTypeName(this, typeName, false);
        var type = this._structuralTypeMap[qualTypeName];
        if (!type) {
            if (okIfNotFound)
                return null;
            var msg = core.formatString("Unable to locate a 'Type' by the name: '%1'. Be sure to execute a query or call fetchMetadata first.", typeName);
            throw new Error(msg);
        }
        return type;
    };
    /**
    Returns an array containing all of the [[EntityType]]s or [[ComplexType]]s in this MetadataStore.
    >      // assume em1 is a preexisting EntityManager
    >      let allTypes = em1.metadataStore.getEntityTypes();
    **/
    MetadataStore.prototype.getEntityTypes = function () {
        return getTypesFromMap(this._structuralTypeMap);
    };
    MetadataStore.prototype.getIncompleteNavigationProperties = function () {
        return core.objectMap(this._incompleteTypeMap, function (key, value) {
            return value;
        });
    };
    /**
    Returns a fully qualified entityTypeName for a specified resource name.  The reverse of this operation
    can be obtained via the  [[EntityType.defaultResourceName]] property
    **/
    MetadataStore.prototype.getEntityTypeNameForResourceName = function (resourceName) {
        assertParam(resourceName, "resourceName").isString().check();
        return this._resourceEntityTypeMap[resourceName];
    };
    /**
    Associates a resourceName with an entityType.
  
    This method is only needed in those cases where multiple resources return the same
    entityType.  In this case Metadata discovery will only determine a single resource name for
    each entityType.
    @param resourceName - The resource name
    @param entityTypeOrName - If passing a string either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown. If the entityType has not yet been discovered then a fully qualified name must be used.
    **/
    MetadataStore.prototype.setEntityTypeForResourceName = function (resourceName, entityTypeOrName) {
        assertParam(resourceName, "resourceName").isString().check();
        assertParam(entityTypeOrName, "entityTypeOrName").isInstanceOf(EntityType).or().isString().check();
        var entityTypeName;
        if (entityTypeOrName instanceof EntityType) {
            entityTypeName = entityTypeOrName.name;
        }
        else {
            entityTypeName = getQualifiedTypeName(this, entityTypeOrName, true);
        }
        this._resourceEntityTypeMap[resourceName] = entityTypeName;
        var entityType = this._getStructuralType(entityTypeName, true);
        if (entityType && entityType instanceof EntityType && !entityType.defaultResourceName) {
            entityType.defaultResourceName = resourceName;
        }
    };
    /** __Dev Only__ - for use when creating a new MetadataParserAdapter  */
    MetadataStore.parseTypeName = function (entityTypeName) {
        // TODO: removed 
        // if (!entityTypeName) {
        //   return null;
        // }
        var typeParts = entityTypeName.split(":#");
        if (typeParts.length > 1) {
            return MetadataStore.makeTypeHash(typeParts[0], typeParts[1]);
        }
        if (core.stringStartsWith(entityTypeName, MetadataStore.ANONTYPE_PREFIX)) {
            var typeHash = MetadataStore.makeTypeHash(entityTypeName);
            typeHash.isAnonymous = true;
            return typeHash;
        }
        var entityTypeNameNoAssembly = entityTypeName.split(",")[0];
        typeParts = entityTypeNameNoAssembly.split(".");
        if (typeParts.length > 1) {
            var shortName = typeParts[typeParts.length - 1];
            var namespaceParts = typeParts.slice(0, typeParts.length - 1);
            var ns = namespaceParts.join(".");
            return MetadataStore.makeTypeHash(shortName, ns);
        }
        else {
            return MetadataStore.makeTypeHash(entityTypeName);
        }
    };
    /** __Dev Only__ - for use when creating a new MetadataParserAdapter  */
    MetadataStore.makeTypeHash = function (shortName, ns) {
        return {
            shortTypeName: shortName,
            namespace: ns,
            typeName: qualifyTypeName(shortName, ns)
        };
    };
    // protected methods
    /** @hidden @internal */
    MetadataStore.prototype._checkEntityType = function (entity) {
        if (entity.entityType)
            return;
        var typeName = entity.prototype._$typeName;
        if (!typeName) {
            throw new Error("This entity has not been registered. See the MetadataStore.registerEntityTypeCtor method");
        }
        // we know that it is an EntityType ( as opposed to a ComplexType)
        var entityType = this._getStructuralType(typeName);
        if (entityType) {
            entity.entityType = entityType;
        }
    };
    /** @hidden @internal */
    MetadataStore.__id = 0;
    /** @hidden @internal */
    MetadataStore.ANONTYPE_PREFIX = "_IB_";
    /** The version of any MetadataStores created by this class */
    MetadataStore.metadataVersion = '1.0.5';
    // needs to be made avail to dataService.xxx files
    MetadataStore.normalizeTypeName = core.memoize(function (rawTypeName) {
        return rawTypeName && MetadataStore.parseTypeName(rawTypeName).typeName;
    });
    return MetadataStore;
}());
export { MetadataStore };
MetadataStore.prototype._$typeName = "MetadataStore";
BreezeEvent.bubbleEvent(MetadataStore.prototype);
function getTypesFromMap(typeMap) {
    var types = [];
    for (var key in typeMap) {
        var value = typeMap[key];
        // skip 'shortName' entries
        if (key === value.name) {
            types.push(typeMap[key]);
        }
    }
    return types;
}
function structuralTypeFromJson(metadataStore, json, allowMerge) {
    var typeName = qualifyTypeName(json.shortName, json.namespace);
    var stype = metadataStore._getStructuralType(typeName, true);
    if (stype) {
        if (allowMerge) {
            return mergeStructuralType(stype, json);
        }
        else {
            // allow it but don't replace anything.
            return stype;
        }
    }
    var config = {
        shortName: json.shortName,
        namespace: json.namespace,
        isAbstract: json.isAbstract,
        autoGeneratedKeyType: AutoGeneratedKeyType.fromName(json.autoGeneratedKeyType),
        defaultResourceName: json.defaultResourceName,
        custom: json.custom
    };
    stype = json.isComplexType ? new ComplexType(config) : new EntityType(config);
    // baseType may not have been imported yet so we need to defer handling this type until later.
    if (json.baseTypeName && stype instanceof EntityType) {
        stype.baseTypeName = json.baseTypeName;
        var baseEntityType = metadataStore._getStructuralType(json.baseTypeName, true);
        if (baseEntityType) {
            completeStructuralTypeFromJson(metadataStore, json, stype);
        }
        else {
            core.getArray(metadataStore._deferredTypes, json.baseTypeName).push({ json: json, stype: stype });
        }
    }
    else {
        completeStructuralTypeFromJson(metadataStore, json, stype);
    }
    // stype may or may not have been added to the metadataStore at this point.
    return stype;
}
function mergeStructuralType(stype, json) {
    if (json.custom) {
        stype.custom = json.custom;
    }
    mergeProps(stype, json.dataProperties);
    mergeProps(stype, json.navigationProperties);
    return stype;
}
function mergeProps(stype, jsonProps) {
    if (!jsonProps)
        return;
    jsonProps.forEach(function (jsonProp) {
        var propName = jsonProp.name;
        if (!propName) {
            if (jsonProp.nameOnServer) {
                propName = stype.metadataStore.namingConvention.serverPropertyNameToClient(jsonProp.nameOnServer, {});
            }
            else {
                // backslash-quote works around compiler bug
                var msg = "Unable to complete \'importMetadata\' - cannot locate a \'name\' or \'nameOnServer\' for one of the imported property nodes";
                throw new Error(msg);
            }
        }
        if (jsonProp.custom) {
            var prop = stype.getProperty(propName, true);
            prop.custom = jsonProp.custom;
        }
    });
}
function completeStructuralTypeFromJson(metadataStore, json, stype) {
    // validators from baseType work because validation walks thru base types
    // so no need to copy down.
    if (json.validators) {
        stype.validators = json.validators.map(Validator.fromJSON);
    }
    json.dataProperties.forEach(function (dp) {
        stype._addPropertyCore(DataProperty.fromJSON(dp));
    });
    var isEntityType = !json.isComplexType;
    if (isEntityType) {
        //noinspection JSHint
        json.navigationProperties && json.navigationProperties.forEach(function (np) {
            stype._addPropertyCore(NavigationProperty.fromJSON(np));
        });
    }
    metadataStore.addEntityType(stype);
    var deferredTypes = metadataStore._deferredTypes;
    var deferrals = deferredTypes[stype.name];
    if (deferrals) {
        deferrals.forEach(function (d) {
            completeStructuralTypeFromJson(metadataStore, d.json, d.stype);
        });
        delete deferredTypes[stype.name];
    }
}
function getQualifiedTypeName(metadataStore, structTypeName, throwIfNotFound) {
    if (isQualifiedTypeName(structTypeName))
        return structTypeName;
    var result = metadataStore._shortNameMap[structTypeName];
    if (!result && throwIfNotFound) {
        throw new Error("Unable to locate 'entityTypeName' of: " + structTypeName);
    }
    return result;
}
/** Container for all of the metadata about a specific type of Entity.
**/
var EntityType = /** @class */ (function () {
    /** EntityType constructor
    >      let entityType = new EntityType( {
    >          shortName: "person",
    >          namespace: "myAppNamespace"
    >      });
    @param config - Configuration settings or a MetadataStore.  If this parameter is just a MetadataStore
    then what will be created is an 'anonymous' type that will never be communicated to or from the server. It is purely for
    client side use and will be given an automatically generated name. Normally, however, you will use a configuration object.
    **/
    function EntityType(config) {
        /** Always false for an EntityType. **/
        this.isComplexType = false;
        /**
        @deprecated Use [[getCtor]] instead.
        */
        this.getEntityCtor = this.getCtor;
        if (arguments.length > 1) {
            throw new Error("The EntityType ctor has a single argument that is either a 'MetadataStore' or a configuration object.");
        }
        // let etConfig =  <EntityTypeConfig> <any> undefined;
        var etConfig = undefined;
        if (config._$typeName === "MetadataStore") {
            this.metadataStore = config;
            this.shortName = "Anon_" + (++EntityType.__nextAnonIx);
            this.namespace = "";
            this.isAnonymous = true;
            // etConfig = undefined;
        }
        else {
            etConfig = config;
            assertConfig(config)
                .whereParam("shortName").isNonEmptyString()
                .whereParam("namespace").isString().isOptional().withDefault("")
                .whereParam("baseTypeName").isString().isOptional()
                .whereParam("isAbstract").isBoolean().isOptional().withDefault(false)
                .whereParam("autoGeneratedKeyType").isEnumOf(AutoGeneratedKeyType).isOptional().withDefault(AutoGeneratedKeyType.None)
                .whereParam("defaultResourceName").isNonEmptyString().isOptional().withDefault(null)
                .whereParam("dataProperties").isOptional()
                .whereParam("navigationProperties").isOptional()
                .whereParam("serializerFn").isOptional().isFunction()
                .whereParam("custom").isOptional()
                .applyAll(this);
        }
        this.name = qualifyTypeName(this.shortName, this.namespace);
        // the defaultResourceName may also be set up either via metadata lookup or first query or via the 'setProperties' method
        this.dataProperties = [];
        this.navigationProperties = [];
        this.complexProperties = [];
        this.keyProperties = [];
        this.foreignKeyProperties = [];
        this.inverseForeignKeyProperties = [];
        this.concurrencyProperties = [];
        this.unmappedProperties = []; // will be updated later.
        this.validators = [];
        this.warnings = [];
        this._mappedPropertiesCount = 0;
        this.subtypes = [];
        // now process any data/nav props
        if (etConfig && etConfig.dataProperties) {
            addProperties(this, etConfig.dataProperties, DataProperty);
        }
        if (etConfig && etConfig.navigationProperties) {
            addProperties(this, etConfig.navigationProperties, NavigationProperty);
        }
    }
    /**
    General purpose property set method
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      custType.setProperties( {
    >          autoGeneratedKeyType: AutoGeneratedKeyType.Identity;
    >          defaultResourceName: "CustomersAndIncludedOrders"
    >      )};
    @param config - a configuration object
    **/
    EntityType.prototype.setProperties = function (config) {
        assertConfig(config)
            .whereParam("autoGeneratedKeyType").isEnumOf(AutoGeneratedKeyType).isOptional()
            .whereParam("defaultResourceName").isString().isOptional()
            .whereParam("serializerFn").isFunction().isOptional()
            .whereParam("custom").isOptional()
            .applyAll(this);
        if (config.defaultResourceName) {
            this.defaultResourceName = config.defaultResourceName;
        }
    };
    /**
    Returns whether this type is a subtype of a specified type.
    **/
    EntityType.prototype.isSubtypeOf = function (entityType) {
        assertParam(entityType, "entityType").isInstanceOf(EntityType).check();
        var baseType = this;
        do {
            if (baseType === entityType)
                return true;
            baseType = baseType.baseEntityType;
        } while (baseType);
        return false;
    };
    /**
    Returns an array containing this type and any/all subtypes of this type down thru the hierarchy.
    **/
    EntityType.prototype.getSelfAndSubtypes = function () {
        var result = [this];
        this.subtypes.forEach(function (st) {
            var subtypes = st.getSelfAndSubtypes();
            result.push.apply(result, subtypes);
        });
        return result;
    };
    EntityType.prototype.getAllValidators = function () {
        var result = this.validators.slice(0);
        var bt = this.baseEntityType;
        while (bt) {
            result.push.apply(result, bt.validators);
            bt = bt.baseEntityType;
        }
        return result;
    };
    /**
    Adds a  [[DataProperty]] or a [[NavigationProperty]] to this EntityType.
    >      // assume myEntityType is a newly constructed EntityType.
    >      myEntityType.addProperty(dataProperty1);
    >      myEntityType.addProperty(dataProperty2);
    >      myEntityType.addProperty(navigationProperty1);
    **/
    EntityType.prototype.addProperty = function (property) {
        assertParam(property, "property").isInstanceOf(DataProperty).or().isInstanceOf(NavigationProperty).check();
        // true is 2nd arg to force resolve of any navigation properties.
        var newprop = this._addPropertyCore(property, true);
        if (this.subtypes && this.subtypes.length) {
            var stype_1 = this;
            stype_1.getSelfAndSubtypes().forEach(function (st) {
                if (st !== stype_1) {
                    if (property.isNavigationProperty) {
                        st._addPropertyCore(new NavigationProperty(property), true);
                    }
                    else {
                        st._addPropertyCore(new DataProperty(property), true);
                    }
                }
            });
        }
        return newprop;
    };
    /** @hidden @internal */
    EntityType.prototype._updateFromBase = function (baseEntityType) {
        var _this = this;
        this.baseEntityType = baseEntityType;
        if (this.autoGeneratedKeyType === AutoGeneratedKeyType.None) {
            this.autoGeneratedKeyType = baseEntityType.autoGeneratedKeyType;
        }
        baseEntityType.dataProperties.forEach(function (dp) {
            var newDp = new DataProperty(dp);
            // don't need to copy validators becaue we will walk the hierarchy to find them
            newDp.validators = [];
            newDp.baseProperty = dp;
            _this._addPropertyCore(newDp);
        }, this);
        baseEntityType.navigationProperties.forEach(function (np) {
            var newNp = new NavigationProperty(np);
            // don't need to copy validators becaue we will walk the hierarchy to find them
            newNp.validators = [];
            newNp.baseProperty = np;
            _this._addPropertyCore(newNp);
        }, this);
        baseEntityType.subtypes.push(this);
    };
    /** @hidden @internal */
    EntityType.prototype._addPropertyCore = function (property, shouldResolve) {
        if (shouldResolve === void 0) { shouldResolve = false; }
        if (this.isFrozen) {
            throw new Error("The '" + this.name + "' EntityType/ComplexType has been frozen. You can only add properties to an EntityType/ComplexType before any instances of that type have been created and attached to an entityManager.");
        }
        var parentType = property.parentType;
        if (parentType) {
            if (parentType !== this) {
                throw new Error("This property: " + property.name + " has already been added to " + property.parentType.name);
            }
            else {
                // adding the same property more than once to the same entityType is just ignored.
                return;
            }
        }
        property.parentType = this;
        var ms = this.metadataStore;
        // if (property.isDataProperty) { // modified because doesn't act as a type guard 
        if (property instanceof DataProperty) {
            this._addDataProperty(property);
        }
        else {
            this._addNavigationProperty(property);
            // metadataStore can be undefined if this entityType has not yet been added to a MetadataStore.
            if (shouldResolve && ms) {
                tryResolveNp(property, ms);
            }
        }
        // unmapped properties can be added AFTER entityType has already resolved all property names.
        if (ms && !(property.name && property.nameOnServer)) {
            updateClientServerNames(ms.namingConvention, property, "name");
        }
        // props can be added after entity prototype has already been wrapped.
        if (ms && this._extra) {
            if (this._extra.alreadyWrappedProps) {
                var proto_1 = this._ctor.prototype;
                config.interfaceRegistry.modelLibrary.getDefaultInstance().initializeEntityPrototype(proto_1);
            }
        }
    };
    /**
    Create a new entity of this type.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getAsEntityType("Customer");
    >      let cust1 = custType.createEntity();
    >      em1.addEntity(cust1);
    @param initialValues- Configuration object of the properties to set immediately after creation.
    @return The new entity.
    **/
    EntityType.prototype.createEntity = function (initialValues) {
        // ignore the _$eref once the entity is attached to an entityManager.
        if (initialValues && initialValues._$eref && !initialValues._$eref.entityAspect.entityManager)
            return initialValues._$eref;
        var instance = this._createInstanceCore();
        if (initialValues) {
            // only assign an _eref if the object is fully "keyed"
            if (this.keyProperties.every(function (kp) {
                return initialValues[kp.name] != null;
            })) {
                initialValues._$eref = instance;
            }
            this._updateTargetFromRaw(instance, initialValues, getRawValueFromConfig);
            this.navigationProperties.forEach(function (np) {
                var relatedEntity;
                var val = initialValues[np.name];
                if (val != undefined) {
                    var navEntityType_1 = np.entityType;
                    if (np.isScalar) {
                        relatedEntity = val.entityAspect ? val : navEntityType_1.createEntity(val);
                        instance.setProperty(np.name, relatedEntity);
                    }
                    else {
                        var relatedEntities_1 = instance.getProperty(np.name);
                        val.forEach(function (v) {
                            relatedEntity = v.entityAspect ? v : navEntityType_1.createEntity(v);
                            relatedEntities_1.push(relatedEntity);
                        });
                    }
                }
            });
        }
        this._initializeInstance(instance);
        return instance;
    };
    /** @hidden @internal */
    EntityType.prototype._createInstanceCore = function () {
        var aCtor = this.getCtor();
        var instance = new aCtor();
        new EntityAspect(instance);
        return instance;
    };
    /** @hidden @internal */
    EntityType.prototype._initializeInstance = function (instance) {
        if (this.baseEntityType) {
            this.baseEntityType._initializeInstance(instance);
        }
        var initFn = this.initFn;
        if (initFn) {
            var fn = (typeof initFn === "string") ? instance[initFn] : initFn;
            fn(instance);
        }
        this.complexProperties && this.complexProperties.forEach(function (cp) {
            var complexType = cp.dataType;
            var ctInstance = instance.getProperty(cp.name);
            if (Array.isArray(ctInstance)) {
                ctInstance.forEach(function (ctInst) {
                    complexType._initializeInstance(ctInst);
                });
            }
            else {
                complexType._initializeInstance(ctInstance);
            }
        });
        // not needed for complexObjects
        if (instance.entityAspect) {
            instance.entityAspect._initialized = true;
        }
    };
    /**
    Returns the constructor for this EntityType.
    @param forceRefresh - Whether to ignore any cached version of this constructor. (default == false)
    @return The constructor for this EntityType.
    **/
    EntityType.prototype.getCtor = function (forceRefresh) {
        if (forceRefresh === void 0) { forceRefresh = false; }
        if (this._ctor && !forceRefresh)
            return this._ctor;
        var ctorRegistry = this.metadataStore._ctorRegistry;
        var r = ctorRegistry[this.name] || ctorRegistry[this.shortName] || {};
        var aCtor = r.ctor || this._ctor;
        var ctorType = aCtor && aCtor.prototype && (aCtor.prototype.entityType || aCtor.prototype.complexType);
        if (ctorType && ctorType.metadataStore !== this.metadataStore) {
            // We can't risk a mismatch between the ctor and the type info in a specific metadatastore
            // because modelLibraries rely on type info to intercept ctor properties
            throw new Error("Cannot register the same constructor for " + this.name + " in different metadata stores.  Please define a separate constructor for each metadata store.");
        }
        if (r.ctor && forceRefresh) {
            this._extra = undefined;
        }
        if (!aCtor) {
            var createCtor = config.interfaceRegistry.modelLibrary.getDefaultInstance().createCtor;
            aCtor = createCtor ? createCtor(this) : createEmptyCtor(this);
        }
        this.initFn = r.initFn;
        this.noTrackingFn = r.noTrackingFn;
        aCtor.prototype._$typeName = this.name;
        this._setCtor(aCtor);
        return aCtor;
    };
    /** @hidden @internal */
    // May make public later.
    EntityType.prototype._setCtor = function (aCtor, interceptor) {
        var instanceProto = aCtor.prototype;
        // place for extra breeze related data
        this._extra = this._extra || {};
        var instance = new aCtor();
        calcUnmappedProperties(this, instance);
        if (this._$typeName === "EntityType") {
            // insure that all of the properties are on the 'template' instance before watching the class.
            instanceProto.entityType = this;
        }
        else {
            instanceProto.complexType = this;
        }
        // defaultPropertyInterceptor is a 'global' (but internal to breeze) function;
        instanceProto._$interceptor = interceptor || defaultPropertyInterceptor;
        config.interfaceRegistry.modelLibrary.getDefaultInstance().initializeEntityPrototype(instanceProto);
        this._ctor = aCtor;
    };
    /**
    Adds either an entity or property level validator to this EntityType.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let countryProp = custType.getProperty("Country");
    >      let valFn = function (v) {
    >              if (v == null) return true;
    >              return (core.stringStartsWith(v, "US"));
    >          };
    >      let countryValidator = new Validator("countryIsUS", valFn,
    >      { displayName: "Country", messageTemplate: "'%displayName%' must start with 'US'" });
    >      custType.addValidator(countryValidator, countryProp);
  
    This is the same as adding an entity level validator via the 'validators' property of DataProperty or NavigationProperty
    >      countryProp.validators.push(countryValidator);
  
    Entity level validators can also be added by omitting the 'property' parameter.
    >      custType.addValidator(someEntityLevelValidator);
  
    or
    >      custType.validators.push(someEntityLevelValidator);
    @param validator - Validator to add.
    @param property - Property to add this validator to.  If omitted, the validator is assumed to be an
    entity level validator and is added to the EntityType's 'validators'.
    **/
    EntityType.prototype.addValidator = function (validator, property) {
        assertParam(validator, "validator").isInstanceOf(Validator).check();
        assertParam(property, "property").isOptional().isString().or().isEntityProperty().check();
        if (property != null) {
            var prop = (typeof property === 'string') ? this.getProperty(property, true) : property;
            prop.validators.push(validator);
        }
        else {
            this.validators.push(validator);
        }
    };
    /**
    Returns all of the properties ( dataProperties and navigationProperties) for this EntityType.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let arrayOfProps = custType.getProperties();
    @return An array of Data and Navigation properties.
    **/
    EntityType.prototype.getProperties = function () {
        return this.dataProperties.concat(this.navigationProperties);
    };
    /**
    Returns all of the property names ( for both dataProperties and navigationProperties) for this EntityType.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let arrayOfPropNames = custType.getPropertyNames();
    **/
    EntityType.prototype.getPropertyNames = function () {
        return this.getProperties().map(core.pluck('name'));
    };
    /**
    Returns a data property with the specified name or null.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let customerNameDataProp = custType.getDataProperty("CustomerName");
    @return A DataProperty or null if not found.
    **/
    EntityType.prototype.getDataProperty = function (propertyName) {
        return core.arrayFirst(this.dataProperties, core.propEq('name', propertyName));
    };
    /**
    Returns a navigation property with the specified name or null.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let customerOrdersNavProp = custType.getDataProperty("Orders");
    @return A NavigationProperty or null if not found.
    **/
    EntityType.prototype.getNavigationProperty = function (propertyName) {
        return core.arrayFirst(this.navigationProperties, core.propEq('name', propertyName));
    };
    /**
    Returns either a DataProperty or a NavigationProperty with the specified name or null.
    
    This method also accepts a '.' delimited property path and will return the 'property' at the
    end of the path.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let companyNameProp = custType.getProperty("CompanyName");
  
    This method can also walk a property path to return a property
    >      let orderDetailType = em1.metadataStore.getEntityType("OrderDetail");
    >      let companyNameProp2 = orderDetailType.getProperty("Order.Customer.CompanyName");
    >      // companyNameProp === companyNameProp2
    @param [throwIfNotFound=false] {Boolean} Whether to throw an exception if not found.
    @return A DataProperty or NavigationProperty or null if not found.
    **/
    EntityType.prototype.getProperty = function (propertyPath, throwIfNotFound) {
        if (throwIfNotFound === void 0) { throwIfNotFound = false; }
        var props = this.getPropertiesOnPath(propertyPath, false, throwIfNotFound);
        return (props && props.length > 0) ? props[props.length - 1] : null;
    };
    /** @hidden @internal */
    // TODO: have this return empty array instead of null and fix consumers.
    // TODO: think about renaming with '_' prefix.
    EntityType.prototype.getPropertiesOnPath = function (propertyPath, useServerName, throwIfNotFound) {
        if (throwIfNotFound === void 0) { throwIfNotFound = false; }
        var propertyNames = (Array.isArray(propertyPath)) ? propertyPath : propertyPath.trim().split('.');
        var ok = true;
        var key = useServerName === true ? "nameOnServer" : useServerName === false ? "name" : null;
        var parentType = this;
        var getProps = function (propName) {
            var fn = key === null ? core.propsEq("name", "nameOnServer", propName) : core.propEq(key, propName);
            var prop = core.arrayFirst(parentType.getProperties(), fn);
            if (prop) {
                parentType = (prop instanceof NavigationProperty) ? prop.entityType : prop.dataType;
                // parentType = prop.isNavigationProperty ? prop.entityType : prop.dataType;
            }
            else if (throwIfNotFound) {
                throw new Error("unable to locate property: " + propName + " on entityType: " + parentType.name);
            }
            else {
                ok = false;
            }
            return prop;
        };
        var props = propertyNames.map(getProps);
        return ok ? props : null;
    };
    /** For use in pluggable adapters. */
    // TODO: document use
    EntityType.prototype.clientPropertyPathToServer = function (propertyPath, delimiter) {
        if (delimiter === void 0) { delimiter = '.'; }
        var propNames;
        if (this.isAnonymous) {
            var fn_1 = this.metadataStore.namingConvention.clientPropertyNameToServer;
            propNames = propertyPath.split(".").map(function (propName) {
                return fn_1(propName);
            });
        }
        else {
            var props = this.getPropertiesOnPath(propertyPath, false, true);
            propNames = props.map(function (prop) { return prop.nameOnServer; });
        }
        return propNames.join(delimiter);
    };
    /** For use in pluggable adapters. */
    // TODO: document use
    EntityType.prototype.getEntityKeyFromRawEntity = function (rawEntity, rawValueFn) {
        var keyValues = this.keyProperties.map(function (dp) {
            var val = rawValueFn(rawEntity, dp);
            return DataType.parseRawValue(val, dp.dataType);
        });
        return new EntityKey(this, keyValues);
    };
    /** @hidden @internal */
    EntityType.prototype._updateTargetFromRaw = function (target, raw, rawValueFn) {
        // called recursively for complex properties
        this.dataProperties.forEach(function (dp) {
            if (!dp.isSettable)
                return;
            var rawVal = rawValueFn(raw, dp);
            if (rawVal === undefined)
                return;
            var dataType = dp.dataType; // this will be a complexType when dp is a complexProperty
            var oldVal;
            if (dp.isComplexProperty) {
                var complexType_1 = dp.dataType;
                if (rawVal === null)
                    return; // rawVal may be null in nosql dbs where it was never defined for the given row.
                oldVal = target.getProperty(dp.name);
                if (dp.isScalar) {
                    complexType_1._updateTargetFromRaw(oldVal, rawVal, rawValueFn);
                }
                else {
                    if (Array.isArray(rawVal)) {
                        var newVal = rawVal.map(function (rawCo) {
                            var newCo = complexType_1._createInstanceCore(target, dp);
                            complexType_1._updateTargetFromRaw(newCo, rawCo, rawValueFn);
                            complexType_1._initializeInstance(newCo);
                            return newCo;
                        });
                        if (!core.arrayEquals(oldVal, newVal, coEquals)) {
                            // clear the old array and push new objects into it.
                            oldVal.length = 0;
                            newVal.forEach(function (nv) {
                                oldVal.push(nv);
                            });
                        }
                    }
                    else {
                        oldVal.length = 0;
                    }
                }
            }
            else {
                if (dp.isScalar) {
                    var newVal = DataType.parseRawValue(rawVal, dataType);
                    target.setProperty(dp.name, newVal);
                }
                else {
                    oldVal = target.getProperty(dp.name);
                    if (Array.isArray(rawVal)) {
                        // need to compare values
                        var newVal = rawVal.map(function (rv) {
                            return DataType.parseRawValue(rv, dataType);
                        });
                        if (!core.arrayEquals(oldVal, newVal)) {
                            // clear the old array and push new objects into it.
                            oldVal.length = 0;
                            newVal.forEach(function (nv) {
                                oldVal.push(nv);
                            });
                        }
                    }
                    else {
                        oldVal.length = 0;
                    }
                }
            }
        });
        // if merging from an import then raw will have an entityAspect or a complexAspect
        var rawAspect = raw.entityAspect || raw.complexAspect;
        if (rawAspect) {
            var targetAspect = EntityAspect.isEntity(target) ? target.entityAspect : target.complexAspect;
            if (rawAspect.originalValuesMap) {
                targetAspect.originalValues = rawAspect.originalValuesMap;
            }
            if (rawAspect.extraMetadata) {
                targetAspect.extraMetadata = rawAspect.extraMetadata;
            }
        }
    };
    /**
    Returns a string representation of this EntityType.
    **/
    EntityType.prototype.toString = function () {
        return this.name;
    };
    EntityType.prototype.toJSON = function () {
        return core.toJson(this, {
            shortName: null,
            namespace: null,
            baseTypeName: null,
            isAbstract: false,
            autoGeneratedKeyType: null,
            defaultResourceName: null,
            dataProperties: localPropsOnly,
            navigationProperties: localPropsOnly,
            validators: null,
            custom: null
        });
    };
    /** @hidden @internal */
    EntityType.prototype._updateNames = function (property) {
        var nc = this.metadataStore.namingConvention;
        updateClientServerNames(nc, property, "name");
        if (property.isNavigationProperty) {
            updateClientServerNames(nc, property, "foreignKeyNames");
            updateClientServerNames(nc, property, "invForeignKeyNames");
            // these will get set later via _updateNps
            // this.inverse
            // this.entityType
            // this.relatedDataProperties
            //    dataProperty.relatedNavigationProperty
            //    dataProperty.inverseNavigationProperty
        }
    };
    /** @hidden @internal */
    EntityType.prototype._checkNavProperty = function (navigationProperty) {
        // if (navigationProperty.isNavigationProperty) {
        if (navigationProperty instanceof NavigationProperty) {
            if (navigationProperty.parentType !== this) {
                throw new Error(core.formatString("The navigationProperty '%1' is not a property of entity type '%2'", navigationProperty.name, this.name));
            }
            return navigationProperty;
        }
        if (typeof (navigationProperty) === 'string') {
            var np = this.getProperty(navigationProperty);
            // if (np && np.isNavigationProperty) return np;
            if (np && np instanceof NavigationProperty)
                return np;
        }
        throw new Error("The 'navigationProperty' parameter must either be a NavigationProperty or the name of a NavigationProperty");
    };
    /** @hidden @internal */
    EntityType.prototype._addDataProperty = function (dp) {
        this.dataProperties.push(dp);
        if (dp.isPartOfKey) {
            this.keyProperties.push(dp);
        }
        if (dp.isComplexProperty) {
            this.complexProperties.push(dp);
        }
        if (dp.concurrencyMode && dp.concurrencyMode !== "None") {
            this.concurrencyProperties.push(dp);
        }
        if (dp.isUnmapped) {
            this.unmappedProperties.push(dp);
        }
    };
    /** @hidden @internal */
    EntityType.prototype._addNavigationProperty = function (np) {
        this.navigationProperties.push(np);
        if (!isQualifiedTypeName(np.entityTypeName)) {
            np.entityTypeName = qualifyTypeName(np.entityTypeName, this.namespace);
        }
    };
    /** @hidden @internal */
    EntityType.prototype._updateCps = function () {
        var metadataStore = this.metadataStore;
        var incompleteTypeMap = metadataStore._incompleteComplexTypeMap;
        this.complexProperties.forEach(function (cp) {
            if (cp.complexType)
                return;
            if (!resolveCp(cp, metadataStore)) {
                core.getArray(incompleteTypeMap, cp.complexTypeName).push(cp);
            }
        });
        if (this.isComplexType) {
            (incompleteTypeMap[this.name] || []).forEach(function (cp) {
                resolveCp(cp, metadataStore);
            });
            delete incompleteTypeMap[this.name];
        }
    };
    /** @hidden @internal */
    EntityType.prototype._updateNps = function () {
        var metadataStore = this.metadataStore;
        // resolve all navProps for this entityType
        this.navigationProperties.forEach(function (np) {
            tryResolveNp(np, metadataStore);
        });
        var incompleteTypeMap = metadataStore._incompleteTypeMap;
        // next resolve all navProp that point to this entityType.
        (incompleteTypeMap[this.name] || []).forEach(function (np) {
            tryResolveNp(np, metadataStore);
        });
        // every navProp that pointed to this type should now be resolved
        delete incompleteTypeMap[this.name];
    };
    /** @hidden @internal */
    EntityType.__nextAnonIx = 0;
    /** @hidden @internal */
    EntityType.qualifyTypeName = qualifyTypeName;
    return EntityType;
}());
export { EntityType };
EntityType.prototype._$typeName = "EntityType";
function getRawValueFromConfig(rawEntity, dp) {
    // 'true' fork can happen if an initializer contains an actaul instance of an already created complex object.
    return (rawEntity.entityAspect || rawEntity.complexAspect) ? rawEntity.getProperty(dp.name) : rawEntity[dp.name];
}
function updateClientServerNames(nc, parent, clientPropName) {
    var serverPropName = clientPropName + "OnServer";
    var clientName = parent[clientPropName];
    if (clientName && clientName.length) {
        // if (parent.isUnmapped) return;
        var serverNames = core.toArray(clientName).map(function (cName) {
            var sName = nc.clientPropertyNameToServer(cName, parent);
            var testName = nc.serverPropertyNameToClient(sName, parent);
            if (cName !== testName) {
                throw new Error("NamingConvention for this client property name does not roundtrip properly:" + cName + "-->" + testName);
            }
            return sName;
        });
        parent[serverPropName] = Array.isArray(clientName) ? serverNames : serverNames[0];
    }
    else {
        var serverName = parent[serverPropName];
        if ((!serverName) || serverName.length === 0)
            return;
        var clientNames = core.toArray(serverName).map(function (sName) {
            var cName = nc.serverPropertyNameToClient(sName, parent);
            var testName = nc.clientPropertyNameToServer(cName, parent);
            if (sName !== testName) {
                throw new Error("NamingConvention for this server property name does not roundtrip properly:" + sName + "-->" + testName);
            }
            return cName;
        });
        parent[clientPropName] = Array.isArray(serverName) ? clientNames : clientNames[0];
    }
}
function createEmptyCtor(type) {
    if (config.noEval) {
        var Entity = function () { };
        return Entity;
    }
    else {
        var name_1 = type.name.replace(/\W/g, '_');
        return Function('return function ' + name_1 + '(){}')();
    }
}
function coEquals(co1, co2) {
    var complexType = co1.complexAspect.parentProperty.dataType;
    var dataProps = complexType.dataProperties;
    var areEqual = dataProps.every(function (dp) {
        if (!dp.isSettable)
            return true;
        var v1 = co1.getProperty(dp.name);
        var v2 = co2.getProperty(dp.name);
        if (dp.isComplexProperty && dp.isScalar) {
            return coEquals(v1, v2);
        }
        else if (dp.isComplexProperty && !dp.isScalar) {
            return core.arrayEquals(v1, v2, coEquals);
        }
        else {
            var dataType = dp.dataType; // this will be a complexType when dp is a complexProperty
            return (v1 === v2 || (dataType && dataType.normalize && v1 && v2 && dataType.normalize(v1) === dataType.normalize(v2)));
        }
    });
    return areEqual;
}
function localPropsOnly(props) {
    return props.filter(function (prop) {
        return prop.baseProperty == null;
    });
}
function resolveCp(cp, metadataStore) {
    var complexType = metadataStore._getStructuralType(cp.complexTypeName, true);
    if (!complexType)
        return false;
    if (!(complexType instanceof ComplexType)) {
        throw new Error("Unable to resolve ComplexType with the name: " + cp.complexTypeName + " for the property: " + cp.name);
    }
    cp.dataType = complexType;
    cp.defaultValue = null;
    return true;
}
function tryResolveNp(np, metadataStore) {
    if (np.entityType)
        return true;
    var entityType = metadataStore._getStructuralType(np.entityTypeName, true);
    if (entityType) {
        np.entityType = entityType;
        np._resolveNp();
        // don't bother removing - _updateNps will do it later.
        // __arrayRemoveItem(incompleteNps, np, false);
    }
    else {
        var incompleteNps = core.getArray(metadataStore._incompleteTypeMap, np.entityTypeName);
        core.arrayAddItemUnique(incompleteNps, np);
    }
    return !!entityType;
}
function calcUnmappedProperties(stype, instance) {
    var metadataPropNames = stype.getPropertyNames();
    var modelLib = config.interfaceRegistry.modelLibrary.getDefaultInstance();
    var trackablePropNames = modelLib.getTrackablePropertyNames(instance);
    trackablePropNames.forEach(function (pn) {
        if (metadataPropNames.indexOf(pn) === -1) {
            var val = instance[pn];
            try {
                if (typeof val === "function")
                    val = val();
            }
            catch (e) {
            }
            var dt = DataType.fromValue(val);
            var newProp_1 = new DataProperty({
                name: pn,
                dataType: dt,
                isNullable: true,
                isUnmapped: true
            });
            newProp_1.isSettable = core.isSettable(instance, pn);
            if (stype instanceof EntityType && stype.subtypes != null && stype.subtypes.length) {
                stype.getSelfAndSubtypes().forEach(function (st) {
                    st._addPropertyCore(new DataProperty(newProp_1));
                });
            }
            else {
                stype._addPropertyCore(newProp_1);
            }
        }
    });
}
/**  Container for all of the metadata about a specific type of Complex object.
>     let complexType = new ComplexType( {
>         shortName: "address",
>         namespace: "myAppNamespace"
>     });
@param config - Configuration settings
**/
var ComplexType = /** @class */ (function () {
    function ComplexType(config) {
        /** For polymorphic purpose only - always true here */
        this.isComplexType = true;
        // copy entityType methods onto complexType
        /** See [[EntityType.getCtor]] */
        this.getCtor = EntityType.prototype.getCtor;
        // note the name change.
        this.createInstance = EntityType.prototype.createEntity;
        /** See [EntityType.addValidator] */
        this.addValidator = EntityType.prototype.addValidator;
        this.getProperty = EntityType.prototype.getProperty;
        this.getPropertiesOnPath = EntityType.prototype.getPropertiesOnPath;
        this.getPropertyNames = EntityType.prototype.getPropertyNames;
        /** @hidden @internal */
        this._addPropertyCore = EntityType.prototype._addPropertyCore;
        /** @hidden @internal */
        this._addDataProperty = EntityType.prototype._addDataProperty;
        /** @hidden @internal */
        this._updateNames = EntityType.prototype._updateNames;
        /** @hidden @internal */
        this._updateCps = EntityType.prototype._updateCps;
        /** @hidden @internal */
        this._initializeInstance = EntityType.prototype._initializeInstance;
        /** @hidden @internal */
        this._updateTargetFromRaw = EntityType.prototype._updateTargetFromRaw;
        /** @hidden @internal */
        this._setCtor = EntityType.prototype._setCtor;
        if (arguments.length > 1) {
            throw new Error("The ComplexType ctor has a single argument that is a configuration object.");
        }
        assertConfig(config)
            .whereParam("shortName").isNonEmptyString()
            .whereParam("namespace").isString().isOptional().withDefault("")
            .whereParam("dataProperties").isOptional()
            .whereParam("isComplexType").isOptional().isBoolean() // needed because this ctor can get called from the addEntityType method which needs the isComplexType prop
            .whereParam("custom").isOptional()
            .applyAll(this);
        this.name = qualifyTypeName(this.shortName, this.namespace);
        this.isComplexType = true;
        this.dataProperties = [];
        this.complexProperties = [];
        this.validators = [];
        this.concurrencyProperties = [];
        this.unmappedProperties = [];
        this._mappedPropertiesCount = 0;
        // keyProperties and navigationProperties are not used on complexTypes - but here to allow sharing of code between EntityType and ComplexType.
        this.navigationProperties = [];
        this.keyProperties = []; // may be used later to enforce uniqueness on arrays of complextypes.
        if (config.dataProperties) {
            addProperties(this, config.dataProperties, DataProperty);
        }
    }
    /**
    General purpose property set method
    >      // assume em1 is an EntityManager
    >      let addresstType = em1.metadataStore.getEntityType("Address");
    >      addressType.setProperties( {
    >          custom: { foo: 7, bar: "test" }
    >      });
    @param config - Custom config object
    @param config.custom - {Object}
    **/
    ComplexType.prototype.setProperties = function (config) {
        assertConfig(config)
            .whereParam("custom").isOptional()
            .applyAll(this);
    };
    ComplexType.prototype.getAllValidators = function () {
        // ComplexType inheritance is not YET supported.
        return this.validators;
    };
    /** @hidden @internal */
    ComplexType.prototype._createInstanceCore = function (parent, parentProperty) {
        var aCtor = this.getCtor();
        var instance = new aCtor();
        new ComplexAspect(instance, parent, parentProperty);
        // initialization occurs during either attach or in createInstance call.
        return instance;
    };
    ComplexType.prototype.addProperty = function (dataProperty) {
        assertParam(dataProperty, "dataProperty").isInstanceOf(DataProperty).check();
        return this._addPropertyCore(dataProperty);
    };
    ComplexType.prototype.getProperties = function () {
        return this.dataProperties;
    };
    ComplexType.prototype.toJSON = function () {
        return core.toJson(this, {
            shortName: null,
            namespace: null,
            isComplexType: null,
            dataProperties: null,
            validators: null,
            custom: null
        });
    };
    return ComplexType;
}());
export { ComplexType };
ComplexType.prototype._$typeName = "ComplexType";
/** Creates an instance of this complexType */
ComplexType.prototype.createInstance = EntityType.prototype.createEntity;
/**
A DataProperty describes the metadata for a single property of an  [[EntityType]] that contains simple data.

Instances of the DataProperty class are constructed automatically during Metadata retrieval. However it is also possible to construct them
directly via the constructor.
**/
var DataProperty = /** @class */ (function () {
    /** DataProperty constructor
    >      let lastNameProp = new DataProperty( {
    >          name: "lastName",
    >          dataType: DataType.String,
    >          isNullable: true,
    >          maxLength: 20
    >      });
    >      // assuming personEntityType is a newly constructed EntityType
    >      personEntityType.addProperty(lastNameProperty);
    @param config - A configuration Object or a DataProperty
    */
    function DataProperty(config) {
        /** Is this a DataProperty? - always true here. Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
        this.isDataProperty = true;
        /** Is this a NavigationProperty? - always false here.  Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
        this.isNavigationProperty = false;
        assertConfig(config)
            .whereParam("name").isString().isOptional()
            .whereParam("nameOnServer").isString().isOptional()
            .whereParam("dataType").isEnumOf(DataType).isOptional().or().isString().or().isInstanceOf(ComplexType)
            .whereParam("complexTypeName").isOptional()
            .whereParam("isNullable").isBoolean().isOptional().withDefault(true)
            .whereParam("isScalar").isOptional().withDefault(true) // will be false for some NoSQL databases.
            .whereParam("defaultValue").isOptional()
            .whereParam("isPartOfKey").isBoolean().isOptional()
            .whereParam("isUnmapped").isBoolean().isOptional()
            .whereParam("isSettable").isBoolean().isOptional().withDefault(true)
            .whereParam("concurrencyMode").isString().isOptional()
            .whereParam("maxLength").isNumber().isOptional()
            .whereParam("validators").isInstanceOf(Validator).isArray().isOptional().withDefault([])
            .whereParam("displayName").isOptional()
            .whereParam("enumType").isOptional()
            .whereParam("rawTypeName").isOptional() // occurs with undefined datatypes
            .whereParam("custom").isOptional()
            .applyAll(this);
        var hasName = !!(this.name || this.nameOnServer);
        if (!hasName) {
            throw new Error("A DataProperty must be instantiated with either a 'name' or a 'nameOnServer' property");
        }
        // name/nameOnServer is resolved later when a metadataStore is available.
        if (this.complexTypeName) {
            this.isComplexProperty = true;
            // this.dataType = null; // TODO: would like to remove this line because dataType will be set later.
        }
        else if (typeof (this.dataType) === "string") {
            var dt = DataType.fromName(this.dataType);
            if (!dt) {
                throw new Error("Unable to find a DataType enumeration by the name of: " + this.dataType);
            }
            this.dataType = dt;
        }
        else if (!this.dataType) {
            this.dataType = DataType.String;
        }
        // == as opposed to === is deliberate here.
        if (this.defaultValue == null) {
            if (this.isNullable) {
                this.defaultValue = null;
            }
            else {
                if (this.isComplexProperty) {
                    // what to do? - shouldn't happen from EF - but otherwise ???
                }
                else if (this.dataType === DataType.Binary) {
                    this.defaultValue = "AAAAAAAAJ3U="; // hack for all binary fields but value is specifically valid for timestamp fields - arbitrary valid 8 byte base64 value.
                }
                else {
                    this.defaultValue = this.dataType.defaultValue;
                    if (this.defaultValue == null) {
                        throw new Error("A nonnullable DataProperty cannot have a null defaultValue. Name: " + (this.name || this.nameOnServer));
                    }
                }
            }
        }
        else if (this.dataType.isNumeric) {
            // in case the defaultValue comes in as a string ( which it does in EF6).
            if (typeof (this.defaultValue) === "string") {
                this.defaultValue = parseFloat(this.defaultValue);
            }
        }
        if (this.isComplexProperty) {
            this.isScalar = this.isScalar == null || this.isScalar === true;
        }
    }
    DataProperty.getRawValueFromServer = function (rawEntity, dp) {
        if (dp.isUnmapped) {
            return rawEntity[dp.nameOnServer || dp.name];
        }
        else {
            var val = rawEntity[dp.nameOnServer];
            return val !== undefined ? val : dp.defaultValue;
        }
    };
    DataProperty.getRawValueFromClient = function (rawEntity, dp) {
        var val = rawEntity[dp.name];
        return val !== undefined ? val : dp.defaultValue;
    };
    DataProperty.prototype.resolveProperty = function (propName) {
        var result = this[propName];
        var baseProp = this.baseProperty;
        while (result == undefined && baseProp != null) {
            result = baseProp[propName];
            baseProp = baseProp.baseProperty;
        }
        return result;
    };
    DataProperty.prototype.formatName = function () {
        return this.parentType.name + "--" + this.name;
    };
    /**
    General purpose property set method
    >      // assume em1 is an EntityManager
    >      let prop = myEntityType.getProperty("myProperty");
    >      prop.setProperties( {
    >          custom: { foo: 7, bar: "test" }
    >      });
    @param config - A configuration object.
    **/
    DataProperty.prototype.setProperties = function (config) {
        assertConfig(config)
            .whereParam("displayName").isOptional()
            .whereParam("custom").isOptional()
            .applyAll(this);
    };
    DataProperty.prototype.getAllValidators = function () {
        var validators = this.validators.slice(0);
        var baseProp = this.baseProperty;
        while (baseProp) {
            validators.push.apply(validators, baseProp.validators);
            baseProp = baseProp.baseProperty;
        }
        return validators;
    };
    DataProperty.prototype.toJSON = function () {
        // do not serialize dataTypes that are complexTypes
        return core.toJson(this, {
            name: null,
            dataType: function (v) {
                return (v && v instanceof DataType) ? v.name : undefined;
            },
            complexTypeName: null,
            isNullable: true,
            defaultValue: null,
            isPartOfKey: false,
            isUnmapped: false,
            isSettable: true,
            concurrencyMode: null,
            maxLength: null,
            validators: null,
            displayName: null,
            enumType: null,
            rawTypeName: null,
            isScalar: true,
            custom: null
        });
    };
    DataProperty.fromJSON = function (json) {
        json.dataType = DataType.fromName(json.dataType);
        // Parse default value into correct data type. (dateTime instances require extra work to deserialize properly.)
        if (json.defaultValue && json.dataType && json.dataType.parse) {
            json.defaultValue = json.dataType.parse(json.defaultValue, typeof json.defaultValue);
        }
        if (json.validators) {
            json.validators = json.validators.map(Validator.fromJSON);
        }
        return new DataProperty(json);
    };
    return DataProperty;
}());
export { DataProperty };
DataProperty.prototype._$typeName = "DataProperty";
/**   A NavigationProperty describes the metadata for a single property of an [[EntityType]] that return instances of other EntityTypes.

Instances of the NavigationProperty class are constructed automatically during Metadata retrieval.   However it is also possible to construct them
directly via the constructor.
**/
var NavigationProperty = /** @class */ (function () {
    /** NavigationProperty constructor
    >      let homeAddressProp = new NavigationProperty( {
    >          name: "homeAddress",
    >          entityTypeName: "Address:#myNamespace",
    >          isScalar: true,
    >          associationName: "address_person",
    >          foreignKeyNames: ["homeAddressId"]
    >      });
    >      let homeAddressIdProp = new DataProperty( {
    >          name: "homeAddressId"
    >          dataType: DataType.Integer
    >      });
    >      // assuming personEntityType is a newly constructed EntityType
    >      personEntityType.addProperty(homeAddressProp);
    >      personEntityType.addProperty(homeAddressIdProp);
    @param config - A configuration object.
    **/
    function NavigationProperty(config) {
        /** Is this a DataProperty? - always false here
        Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
        this.isDataProperty = false;
        /** Is this a NavigationProperty? - always true here
        Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
        this.isNavigationProperty = true;
        this.formatName = DataProperty.prototype.formatName;
        this.getAllValidators = DataProperty.prototype.getAllValidators;
        this.resolveProperty = DataProperty.prototype.resolveProperty;
        assertConfig(config)
            .whereParam("name").isString().isOptional()
            .whereParam("nameOnServer").isString().isOptional()
            .whereParam("entityTypeName").isString()
            .whereParam("isScalar").isBoolean().isOptional().withDefault(true)
            .whereParam("associationName").isString().isOptional()
            .whereParam("foreignKeyNames").isArray().isString().isOptional().withDefault([])
            .whereParam("foreignKeyNamesOnServer").isArray().isString().isOptional().withDefault([])
            .whereParam("invForeignKeyNames").isArray().isString().isOptional().withDefault([])
            .whereParam("invForeignKeyNamesOnServer").isArray().isString().isOptional().withDefault([])
            .whereParam("validators").isInstanceOf(Validator).isArray().isOptional().withDefault([])
            .whereParam("displayName").isOptional()
            .whereParam("custom").isOptional()
            .applyAll(this);
        var hasName = !!(this.name || this.nameOnServer);
        if (!hasName) {
            throw new Error("A Navigation property must be instantiated with either a 'name' or a 'nameOnServer' property");
        }
    }
    /**
    General purpose property set method
    >      // assume myEntityType is an EntityType
    >      let prop = myEntityType.getProperty("myProperty");
    >      prop.setProperties( {
    >          custom: { foo: 7, bar: "test" }
    >      });
    @param config - A config object
    **/
    // TODO: create an interface for this.
    NavigationProperty.prototype.setProperties = function (config) {
        if (!this.parentType) {
            throw new Error("Cannot call NavigationProperty.setProperties until the parent EntityType of the NavigationProperty has been set.");
        }
        var inverse = config.inverse;
        if (inverse)
            delete config.inverse;
        assertConfig(config)
            .whereParam("displayName").isOptional()
            .whereParam("foreignKeyNames").isArray().isString().isOptional().withDefault([])
            .whereParam("invForeignKeyNames").isArray().isString().isOptional().withDefault([])
            .whereParam("custom").isOptional()
            .applyAll(this);
        this.parentType._updateNames(this);
        this._resolveNp();
        if (inverse) {
            this.setInverse(inverse);
        }
    };
    Object.defineProperty(NavigationProperty.prototype, "inverse", {
        /** The inverse of this NavigationProperty.  The NavigationProperty that represents a navigation in the opposite direction
        to this NavigationProperty. May be undefined for a undirectional NavigationProperty. __Read Only__ */
        get: function () {
            return this.getInverse();
        },
        enumerable: true,
        configurable: true
    });
    /** @hidden @internal */
    NavigationProperty.prototype.getInverse = function () {
        var np = this;
        while (!np._inverse && np.baseProperty) {
            np = np.baseProperty;
        }
        return np._inverse;
    };
    NavigationProperty.prototype.setInverse = function (inverseNp) {
        // let invNp: NavigationProperty;
        var invNp = (inverseNp instanceof NavigationProperty) ? inverseNp : this.entityType.getNavigationProperty(inverseNp);
        if (!invNp) {
            throw throwSetInverseError(this, "Unable to find inverse property: " + inverseNp);
        }
        if (this._inverse || invNp._inverse) {
            throwSetInverseError(this, "It has already been set on one side or the other.");
        }
        if (invNp.entityType !== this.parentType) {
            throwSetInverseError(this, invNp.formatName + " is not a valid inverse property for this.");
        }
        if (this.associationName) {
            invNp.associationName = this.associationName;
        }
        else {
            if (!invNp.associationName) {
                invNp.associationName = this.formatName() + "_" + invNp.formatName();
            }
            this.associationName = invNp.associationName;
        }
        this._resolveNp();
        invNp._resolveNp();
    };
    // // In progress - will be used for manual metadata config
    // createInverse(config: any) {
    //   if (!this.entityType) {
    //     throwCreateInverseError(this, "has not yet been defined.");
    //   }
    //   if (this.entityType.isFrozen) {
    //     throwCreateInverseError(this, "is frozen.");
    //   }
    //   let metadataStore = this.entityType.metadataStore;
    //   if (metadataStore == null) {
    //     throwCreateInverseError(this, "has not yet been added to the metadataStore.");
    //   }
    //   config.entityTypeName = this.parentEntityType.name;
    //   config.associationName = this.associationName;
    //   let invNp = new NavigationProperty(config);
    //   this.parentEntityType.addNavigationProperty(invNp);
    //   return invNp;
    // };
    NavigationProperty.prototype.toJSON = function () {
        return core.toJson(this, {
            name: null,
            entityTypeName: null,
            isScalar: null,
            associationName: null,
            validators: null,
            displayName: null,
            foreignKeyNames: null,
            invForeignKeyNames: null,
            custom: null
        });
    };
    NavigationProperty.fromJSON = function (json) {
        if (json.validators) {
            json.validators = json.validators.map(Validator.fromJSON);
        }
        return new NavigationProperty(json);
    };
    /** @hidden @internal */
    NavigationProperty.prototype._resolveNp = function () {
        var np = this;
        var entityType = np.entityType;
        var invNp = core.arrayFirst(entityType.navigationProperties, function (altNp) {
            // Can't do this because of possibility of comparing a base class np with a subclass altNp.
            // return altNp.associationName === np.associationName
            //    && altNp !== np;
            // So use this instead.
            return altNp.associationName === np.associationName &&
                (altNp.name !== np.name || altNp.entityTypeName !== np.entityTypeName);
        });
        np._inverse = invNp || undefined;
        //if (invNp && invNp.inverse == null) {
        //    invNp._resolveNp();
        //}
        if (!invNp) {
            // unidirectional 1-n relationship
            np.invForeignKeyNames.forEach(function (invFkName) {
                var fkProp = entityType.getDataProperty(invFkName);
                if (fkProp == null) {
                    throw new Error("EntityType '" + np.entityTypeName + "' has no foreign key matching '" + invFkName + "'");
                }
                var invEntityType = np.parentType;
                invNp = core.arrayFirst(invEntityType.navigationProperties, function (np2) {
                    return np2.invForeignKeyNames && np2.invForeignKeyNames.indexOf(fkProp.name) >= 0 && np2.entityType === fkProp.parentType;
                });
                fkProp.inverseNavigationProperty = invNp || undefined;
                core.arrayAddItemUnique(entityType.foreignKeyProperties, fkProp);
            });
        }
        resolveRelated(np);
    };
    return NavigationProperty;
}());
export { NavigationProperty };
NavigationProperty.prototype._$typeName = "NavigationProperty";
function throwSetInverseError(np, message) {
    throw new Error("Cannot set the inverse property for: " + np.formatName() + ". " + message);
}
// Not current used.
// function throwCreateInverseError(np: NavigationProperty, message: string) {
//   throw new Error("Cannot create inverse for: " + np.formatName() + ". The entityType for this navigation property " + message);
// }
// sets navigation property: relatedDataProperties and dataProperty: relatedNavigationProperty
function resolveRelated(np) {
    var fkNames = np.foreignKeyNames;
    if (fkNames.length === 0)
        return;
    var parentEntityType = np.parentType;
    var fkProps = fkNames.map(function (fkName) {
        return parentEntityType.getDataProperty(fkName);
    });
    var fkPropCollection = parentEntityType.foreignKeyProperties;
    fkProps.forEach(function (dp) {
        core.arrayAddItemUnique(fkPropCollection, dp);
        dp.relatedNavigationProperty = np;
        // now update the inverse
        core.arrayAddItemUnique(np.entityType.inverseForeignKeyProperties, dp);
        if (np.relatedDataProperties) {
            core.arrayAddItemUnique(np.relatedDataProperties, dp);
        }
        else {
            np.relatedDataProperties = [dp];
        }
    });
}
/**
AutoGeneratedKeyType is an 'Enum' containing all of the valid states for an automatically generated key.
**/
var AutoGeneratedKeyType = /** @class */ (function (_super) {
    tslib_1.__extends(AutoGeneratedKeyType, _super);
    function AutoGeneratedKeyType() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
    This entity does not have an autogenerated key.
    The client must set the key before adding the entity to the EntityManager
    **/
    AutoGeneratedKeyType.None = new AutoGeneratedKeyType();
    /**
    This entity's key is an Identity column and is set by the backend database.
    Keys for new entities will be temporary until the entities are saved at which point the keys will
    be converted to their 'real' versions.
    **/
    AutoGeneratedKeyType.Identity = new AutoGeneratedKeyType();
    /**
    This entity's key is generated by a KeyGenerator and is set by the backend database.
    Keys for new entities will be temporary until the entities are saved at which point the keys will
    be converted to their 'real' versions.
    **/
    AutoGeneratedKeyType.KeyGenerator = new AutoGeneratedKeyType();
    return AutoGeneratedKeyType;
}(BreezeEnum));
export { AutoGeneratedKeyType };
AutoGeneratedKeyType.prototype._$typeName = "AutoGeneratedKeyType";
Error['x'] = AutoGeneratedKeyType.resolveSymbols();
var proto = Param.prototype;
// 'this' below is TS annotation 
proto.isEntity = function () {
    return this._addContext({
        fn: isEntity,
        msg: " must be an entity"
    });
};
function isEntity(context, v) {
    if (v == null)
        return false;
    return (v.entityType !== undefined);
}
proto.isEntityProperty = function () {
    return this._addContext({
        fn: isEntityProperty,
        msg: " must be either a DataProperty or a NavigationProperty"
    });
};
function isEntityProperty(context, v) {
    if (v == null)
        return false;
    return (v.isDataProperty || v.isNavigationProperty);
}
// functions shared between classes related to Metadata
function isQualifiedTypeName(entityTypeName) {
    return entityTypeName.indexOf(":#") >= 0;
}
export function qualifyTypeName(shortName, ns) {
    if (ns && ns.length > 0) {
        return shortName + ":#" + ns;
    }
    else {
        return shortName;
    }
}
// Used by both ComplexType and EntityType
function addProperties(entityType, propObj, ctor) {
    if (propObj == null)
        return;
    if (Array.isArray(propObj)) {
        propObj.forEach(entityType._addPropertyCore.bind(entityType));
    }
    else if (typeof (propObj) === 'object') {
        for (var key in propObj) {
            if (core.hasOwnProperty(propObj, key)) {
                var value = propObj[key];
                value.name = key;
                var prop = new ctor(value);
                entityType._addPropertyCore(prop);
            }
        }
    }
    else {
        throw new Error("The 'dataProperties' or 'navigationProperties' values must be either an array of data/nav properties or an object where each property defines a data/nav property");
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXR5LW1ldGFkYXRhLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYnJlZXplLWNsaWVudC8iLCJzb3VyY2VzIjpbInNyYy9lbnRpdHktbWV0YWRhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQWlCLE1BQU0sUUFBUSxDQUFDO0FBQzdDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDbEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUN0QyxPQUFPLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUEyQyxNQUFNLGlCQUFpQixDQUFDO0FBQ3ZHLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDekMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUN2QyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQyxDQUFDLDJCQUEyQjtBQUN4RixPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUMvRSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQXVDNUU7Ozs7O0dBS0c7QUFDSDtJQXFERTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJHO0lBQ0gsdUJBQVksTUFBNEI7UUFDdEMsTUFBTSxHQUFHLE1BQU0sSUFBSSxFQUFFLENBQUM7UUFDdEIsWUFBWSxDQUFDLE1B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RSxPQUEyQixFQUFFLElBQVM7SUFDdkYsSUFBSSxPQUFPLElBQUksSUFBSTtRQUFFLE9BQU87SUFDNUIsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQzFCLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0tBQy9EO1NBQU0sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssUUFBUSxFQUFFO1FBQ3hDLEtBQUssSUFBSSxHQUFHLElBQUksT0FBTyxFQUFFO1lBQ3ZCLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLEVBQUU7Z0JBQ3JDLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDekIsS0FBSyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7Z0JBQ2pCLElBQUksSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMzQixVQUFVLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDbkM7U0FDRjtLQUNGO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLG1LQUFtSyxDQUFDLENBQUM7S0FDdEw7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29yZSwgRXJyb3JDYWxsYmFjayB9IGZyb20gJy4vY29yZSc7XHJcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgQnJlZXplRXZlbnQgfSBmcm9tICcuL2V2ZW50JztcclxuaW1wb3J0IHsgYXNzZXJ0UGFyYW0sIGFzc2VydENvbmZpZywgUGFyYW0gfSBmcm9tICcuL2Fzc2VydC1wYXJhbSc7XHJcbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi9kYXRhLXR5cGUnO1xyXG5pbXBvcnQgeyBFbnRpdHlBc3BlY3QsIENvbXBsZXhBc3BlY3QsIEVudGl0eSwgQ29tcGxleE9iamVjdCwgU3RydWN0dXJhbE9iamVjdCB9IGZyb20gJy4vZW50aXR5LWFzcGVjdCc7XHJcbmltcG9ydCB7IEVudGl0eUtleSB9IGZyb20gJy4vZW50aXR5LWtleSc7XHJcbmltcG9ydCB7IFZhbGlkYXRvciB9IGZyb20gJy4vdmFsaWRhdGUnO1xyXG5pbXBvcnQgeyBCcmVlemVFbnVtIH0gZnJvbSAnLi9lbnVtJztcclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuL2RhdGEtc2VydmljZSc7XHJcbmltcG9ydCB7IE5hbWluZ0NvbnZlbnRpb24gfSBmcm9tICcuL25hbWluZy1jb252ZW50aW9uJztcclxuaW1wb3J0IHsgQ3NkbE1ldGFkYXRhUGFyc2VyIH0gZnJvbSAnLi9jc2RsLW1ldGFkYXRhLXBhcnNlcic7IC8vIFRPRE8gaXNvbGF0ZSB0aGlzIGxhdGVyO1xyXG5pbXBvcnQgeyBMb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnMgfSBmcm9tICcuL2xvY2FsLXF1ZXJ5LWNvbXBhcmlzb24tb3B0aW9ucyc7XHJcbmltcG9ydCB7IGRlZmF1bHRQcm9wZXJ0eUludGVyY2VwdG9yIH0gZnJvbSAnLi9kZWZhdWx0LXByb3BlcnR5LWludGVyY2VwdG9yJztcclxuXHJcbmV4cG9ydCB0eXBlIEVudGl0eVByb3BlcnR5ID0gRGF0YVByb3BlcnR5IHwgTmF2aWdhdGlvblByb3BlcnR5O1xyXG5leHBvcnQgdHlwZSBTdHJ1Y3R1cmFsVHlwZSA9IEVudGl0eVR5cGUgfCBDb21wbGV4VHlwZTtcclxuXHJcbi8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIElTdHJ1Y3R1cmFsVHlwZU1hcCB7XHJcbiAgW2luZGV4OiBzdHJpbmddOiBTdHJ1Y3R1cmFsVHlwZTtcclxufVxyXG5cclxuLy8gVE9ETzogY29uc2lkZXIgZXhwb3NpbmcgbGF0ZXJcclxuLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSU1ldGFkYXRhSnNvbiB7XHJcbiAgbWV0YWRhdGFWZXJzaW9uOiBzdHJpbmc7XHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIG5hbWluZ0NvbnZlbnRpb246IHN0cmluZztcclxuICBsb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnM6IHN0cmluZztcclxuICBkYXRhU2VydmljZXM6IE9iamVjdFtdOyAvLyBJRGF0YVNlcnZpY2VKc29uW11cclxuICBzdHJ1Y3R1cmFsVHlwZXM6IE9iamVjdFtdOyAvLyBJU3RydWN0dXJhbFR5cGVKc29uW107IFxyXG4gIHJlc291cmNlRW50aXR5VHlwZU1hcDogT2JqZWN0W107IC8vIElSZXNvdXJjZUVudGl0eVR5cGVKc29uW11cclxuICBpbmNvbXBsZXRlVHlwZU1hcDogT2JqZWN0W107XHJcbn1cclxuXHJcbi8qKiBDb25maWd1cmF0aW9uIGluZm8gdG8gYmUgcGFzc2VkIHRvIHRoZSBbW01ldGFkYXRhU3RvcmVdXSBjb25zdHJ1Y3RvciAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFkYXRhU3RvcmVDb25maWcge1xyXG4gIC8qKiBUaGUgIFtbTmFtaW5nQ29udmVudGlvbl1dIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1ldGFkYXRhU3RvcmUuICovXHJcbiAgbmFtaW5nQ29udmVudGlvbj86IE5hbWluZ0NvbnZlbnRpb247XHJcbiAgLyoqIFRoZSAgW1tMb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnNdXSBhc3NvY2lhdGVkIHdpdGggdGhpcyBNZXRhZGF0YVN0b3JlLiAqL1xyXG4gIGxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucz86IExvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucztcclxuICBzZXJpYWxpemVyRm4/OiAocHJvcDogRW50aXR5UHJvcGVydHksIHZhbDogYW55KSA9PiBhbnk7XHJcbiAgbmFtZT86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YUZldGNoZWRFdmVudEFyZ3Mge1xyXG4gIG1ldGFkYXRhU3RvcmU6IE1ldGFkYXRhU3RvcmU7XHJcbiAgZGF0YVNlcnZpY2U6IERhdGFTZXJ2aWNlIHwgc3RyaW5nO1xyXG4gIHJhd01ldGFkYXRhOiBhbnk7XHJcbn1cclxuXHJcbi8qKlxyXG5BbiBpbnN0YW5jZSBvZiB0aGUgTWV0YWRhdGFTdG9yZSBjb250YWlucyBhbGwgb2YgdGhlIG1ldGFkYXRhIGFib3V0IGEgY29sbGVjdGlvbiBvZiBbW0VudGl0eVR5cGVdXSdzLlxyXG5NZXRhZGF0YVN0b3JlcyBtYXkgYmUgc2hhcmVkIGFjcm9zcyBbW0VudGl0eU1hbmFnZXJdXSdzLiAgSWYgYW4gRW50aXR5TWFuYWdlciBpcyBjcmVhdGVkIHdpdGhvdXQgYW5cclxuZXhwbGljaXQgTWV0YWRhdGFTdG9yZSwgdGhlIE1ldGFkYXRhU3RvcmUgZnJvbSB0aGUgTWV0YWRhdGFTdG9yZS5kZWZhdWx0SW5zdGFuY2UgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxyXG5AZHluYW1pY1xyXG4qKi9cclxuZXhwb3J0IGNsYXNzIE1ldGFkYXRhU3RvcmUge1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF8kdHlwZU5hbWU6IHN0cmluZzsgLy8gb24gcHJvdG9cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgc3RhdGljIF9faWQgPSAwO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXRpYyBBTk9OVFlQRV9QUkVGSVggPSBcIl9JQl9cIjtcclxuICAvKiogVGhlIHZlcnNpb24gb2YgYW55IE1ldGFkYXRhU3RvcmVzIGNyZWF0ZWQgYnkgdGhpcyBjbGFzcyAqL1xyXG4gIHN0YXRpYyBtZXRhZGF0YVZlcnNpb24gPSAnMS4wLjUnO1xyXG5cclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgZGF0YVNlcnZpY2VzOiBEYXRhU2VydmljZVtdO1xyXG5cclxuICAvKiogVGhlICBbW05hbWluZ0NvbnZlbnRpb25dXSBhc3NvY2lhdGVkIHdpdGggdGhpcyBNZXRhZGF0YVN0b3JlLiBfX1JlYWQgT25seV9fICovXHJcbiAgbmFtaW5nQ29udmVudGlvbjogTmFtaW5nQ29udmVudGlvbjtcclxuICAvKiogVGhlICBbW0xvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9uc11dIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1ldGFkYXRhU3RvcmUuIF9fUmVhZCBPbmx5X18gKi9cclxuICBsb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnM6IExvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucztcclxuICBzZXJpYWxpemVyRm4/OiAocHJvcDogRW50aXR5UHJvcGVydHksIHZhbDogYW55KSA9PiBhbnk7XHJcbiAgLyoqXHJcbiAgQW4gW1tCcmVlemVFdmVudF1dIHRoYXQgZmlyZXMgYWZ0ZXIgYSBNZXRhZGF0YVN0b3JlIGhhcyBjb21wbGV0ZWQgZmV0Y2hpbmcgbWV0YWRhdGEgZnJvbSBhIHJlbW90ZSBzZXJ2aWNlLlxyXG4gIFxyXG4gIEBldmVudEFyZ3MgLVxyXG4gICAgLSBtZXRhZGF0YVN0b3JlIC0gVGhlIE1ldGFkYXRhU3RvcmUgaW50byB3aGljaCB0aGUgbWV0YWRhdGEgd2FzIGZldGNoZWQuXHJcbiAgICAtIGRhdGFTZXJ2aWNlIC0gVGhlIFtbRGF0YVNlcnZpY2VdXSB0aGF0IG1ldGFkYXRhIHdhcyBmZXRjaGVkIGZyb20uXHJcbiAgICAtIHJhd01ldGFkYXRhIC0ge09iamVjdH0gVGhlIHJhdyBtZXRhZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2aWNlLiAoSXQgd2lsbCBoYXZlIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQgYnkgdGhpcyBwb2ludCkuXHJcbiAgPiAgICAgIGxldCBtcyA9IG15RW50aXR5TWFuYWdlci5tZXRhZGF0YVN0b3JlO1xyXG4gID4gICAgICBtcy5tZXRhZGF0YUZldGNoZWQuc3Vic2NyaWJlKGZ1bmN0aW9uKGFyZ3MpIHtcclxuICA+ICAgICAgICAgIGxldCBtZXRhZGF0YVN0b3JlID0gYXJncy5tZXRhZGF0YVN0b3JlO1xyXG4gID4gICAgICAgICAgbGV0IGRhdGFTZXJ2aWNlID0gYXJncy5kYXRhU2VydmljZTtcclxuICA+ICAgICAgfSk7XHJcbiAgQGV2ZW50XHJcbiAgKiovXHJcbiAgbWV0YWRhdGFGZXRjaGVkOiBCcmVlemVFdmVudDxNZXRhZGF0YUZldGNoZWRFdmVudEFyZ3M+O1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9yZXNvdXJjZUVudGl0eVR5cGVNYXA6IHt9O1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9lbnRpdHlUeXBlUmVzb3VyY2VNYXA6IHt9O1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9zdHJ1Y3R1cmFsVHlwZU1hcDogSVN0cnVjdHVyYWxUeXBlTWFwOyAvLyBrZXkgaXMgcXVhbGlmaWVkIHN0cnVjdHVyYWx0eXBlIG5hbWUgLSB2YWx1ZSBpcyBzdHJ1Y3R1cmFsVHlwZS4gKCBzdHJ1Y3R1cmFsID0gZW50aXR5VHlwZSBvciBjb21wbGV4VHlwZSkuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICoqL1xyXG4gIF9zaG9ydE5hbWVNYXA6IHt9OyAvLyBrZXkgaXMgc2hvcnROYW1lLCB2YWx1ZSBpcyBxdWFsaWZpZWQgbmFtZSAtIGRvZXMgbm90IG5lZWQgdG8gYmUgc2VyaWFsaXplZC5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKiovXHJcbiAgX2N0b3JSZWdpc3RyeToge307IC8vIGtleSBpcyBlaXRoZXIgc2hvcnQgb3IgcXVhbCB0eXBlIG5hbWUgLSB2YWx1ZSBpcyBjdG9yO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqKi9cclxuICBfaW5jb21wbGV0ZVR5cGVNYXA6IHt9OyAvLyBrZXkgaXMgZW50aXR5VHlwZU5hbWU7IHZhbHVlIGlzIGFycmF5IG9mIG5hdiBwcm9wc1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqKi9cclxuICBfaW5jb21wbGV0ZUNvbXBsZXhUeXBlTWFwOiB7fTsgLy9cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKiovXHJcbiAgX2RlZmVycmVkVHlwZXM6IHt9O1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqKi9cclxuICBfaWQ6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgQ29uc3RydWN0cyBhIG5ldyBNZXRhZGF0YVN0b3JlLlxyXG4gIFxyXG4gID4gICAgIGxldCBtcyA9IG5ldyBNZXRhZGF0YVN0b3JlKCk7XHJcblxyXG4gIFRoZSBzdG9yZSBjYW4gdGhlbiBiZSBhc3NvY2lhdGVkIHdpdGggYW4gRW50aXR5TWFuYWdlclxyXG4gID4gICAgIGxldCBlbnRpdHlNYW5hZ2VyID0gbmV3IEVudGl0eU1hbmFnZXIoIHtcclxuICA+ICAgICAgICAgc2VydmljZU5hbWU6IFwiYnJlZXplL05vcnRod2luZElCTW9kZWxcIiwgXHJcbiAgPiAgICAgICAgIG1ldGFkYXRhU3RvcmU6IG1zIFxyXG4gID4gICAgIH0pO1xyXG5cclxuICBvciBmb3IgYW4gZXhpc3RpbmcgRW50aXR5TWFuYWdlclxyXG4gID4gICAgLy8gQXNzdW1lIGVtMSBpcyBhbiBleGlzdGluZyBFbnRpdHlNYW5hZ2VyXHJcbiAgPiAgICBlbTEuc2V0UHJvcGVydGllcyggeyBtZXRhZGF0YVN0b3JlOiBtcyB9KTtcclxuICBcclxuICBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBzZXR0aW5ncyAuXHJcbiAgICAtIG5hbWluZ0NvbnZlbnRpb24gLSAoZGVmYXVsdD1OYW1pbmdDb252ZW50aW9uLmRlZmF1bHRJbnN0YW5jZSkgTmFtaW5nQ29udmVudGlvbiB0byBiZSB1c2VkIGluIG1hcHBpbmcgcHJvcGVydHkgbmFtZXNcclxuICBiZXR3ZWVuIGNsaWVudCBhbmQgc2VydmVyLiBVc2VzIHRoZSBOYW1pbmdDb252ZW50aW9uLmRlZmF1bHRJbnN0YW5jZSBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgLSBsb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnMgLSAoZGVmYXVsdD1Mb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnMuZGVmYXVsdEluc3RhbmNlKSBUaGUgTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zIHRvIGJlXHJcbiAgdXNlZCB3aGVuIHBlcmZvcm1pbmcgXCJsb2NhbCBxdWVyaWVzXCIgaW4gb3JkZXIgdG8gbWF0Y2ggdGhlIHNlbWFudGljcyBvZiBxdWVyaWVzIGFnYWluc3QgYSByZW1vdGUgc2VydmljZS5cclxuICAgIC0gc2VyaWFsaXplckZuIC0gQSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbWVkaWF0ZSB0aGUgc2VyaWFsaXphdGlvbiBvZiBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxyXG4gICoqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZz86IE1ldGFkYXRhU3RvcmVDb25maWcpIHtcclxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgIGFzc2VydENvbmZpZyhjb25maWcpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwibmFtaW5nQ29udmVudGlvblwiKS5pc09wdGlvbmFsKCkuaXNJbnN0YW5jZU9mKE5hbWluZ0NvbnZlbnRpb24pLndpdGhEZWZhdWx0KE5hbWluZ0NvbnZlbnRpb24uZGVmYXVsdEluc3RhbmNlKVxyXG4gICAgICAud2hlcmVQYXJhbShcImxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9uc1wiKS5pc09wdGlvbmFsKCkuaXNJbnN0YW5jZU9mKExvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucykud2l0aERlZmF1bHQoTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zLmRlZmF1bHRJbnN0YW5jZSlcclxuICAgICAgLndoZXJlUGFyYW0oXCJzZXJpYWxpemVyRm5cIikuaXNPcHRpb25hbCgpLmlzRnVuY3Rpb24oKVxyXG4gICAgICAuYXBwbHlBbGwodGhpcyk7XHJcbiAgICB0aGlzLmRhdGFTZXJ2aWNlcyA9IFtdOyAvLyBhcnJheSBvZiBkYXRhU2VydmljZXM7XHJcbiAgICB0aGlzLl9yZXNvdXJjZUVudGl0eVR5cGVNYXAgPSB7fTsgLy8ga2V5IGlzIHJlc291cmNlIG5hbWUgLSB2YWx1ZSBpcyBxdWFsaWZpZWQgZW50aXR5VHlwZSBuYW1lXHJcbiAgICB0aGlzLl9zdHJ1Y3R1cmFsVHlwZU1hcCA9IHt9OyAvLyBrZXkgaXMgcXVhbGlmaWVkIHN0cnVjdHVyYWx0eXBlIG5hbWUgLSB2YWx1ZSBpcyBzdHJ1Y3R1cmFsVHlwZS4gKCBzdHJ1Y3R1cmFsID0gZW50aXR5VHlwZSBvciBjb21wbGV4VHlwZSkuXHJcbiAgICB0aGlzLl9zaG9ydE5hbWVNYXAgPSB7fTsgLy8ga2V5IGlzIHNob3J0TmFtZSwgdmFsdWUgaXMgcXVhbGlmaWVkIG5hbWUgLSBkb2VzIG5vdCBuZWVkIHRvIGJlIHNlcmlhbGl6ZWQuXHJcbiAgICB0aGlzLl9jdG9yUmVnaXN0cnkgPSB7fTsgLy8ga2V5IGlzIGVpdGhlciBzaG9ydCBvciBxdWFsIHR5cGUgbmFtZSAtIHZhbHVlIGlzIGN0b3I7XHJcblxyXG4gICAgdGhpcy5faW5jb21wbGV0ZVR5cGVNYXAgPSB7fTsgLy8ga2V5IGlzIGVudGl0eVR5cGVOYW1lOyB2YWx1ZSBpcyBhcnJheSBvZiBuYXYgcHJvcHNcclxuICAgIHRoaXMuX2luY29tcGxldGVDb21wbGV4VHlwZU1hcCA9IHt9OyAvLyBrZXkgaXMgY29tcGxleFR5cGVOYW1lOyB2YWx1ZSBpcyBhcnJheSBvZiBjb21wbGV4VHlwZSBwcm9wc1xyXG4gICAgdGhpcy5faWQgPSBNZXRhZGF0YVN0b3JlLl9faWQrKztcclxuICAgIHRoaXMubWV0YWRhdGFGZXRjaGVkID0gbmV3IEJyZWV6ZUV2ZW50KFwibWV0YWRhdGFGZXRjaGVkXCIsIHRoaXMpO1xyXG5cclxuICB9XHJcblxyXG4gIC8vIG5lZWRzIHRvIGJlIG1hZGUgYXZhaWwgdG8gZGF0YVNlcnZpY2UueHh4IGZpbGVzXHJcbiAgc3RhdGljIG5vcm1hbGl6ZVR5cGVOYW1lID0gY29yZS5tZW1vaXplKGZ1bmN0aW9uIChyYXdUeXBlTmFtZTogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gcmF3VHlwZU5hbWUgJiYgTWV0YWRhdGFTdG9yZS5wYXJzZVR5cGVOYW1lKHJhd1R5cGVOYW1lKS50eXBlTmFtZTtcclxuICB9KTtcclxuICAvLyBmb3IgZGVidWdnaW5nIHVzZSB0aGUgbGluZSBiZWxvdyBpbnN0ZWFkLlxyXG4gIC8vY3Rvci5ub3JtYWxpemVUeXBlTmFtZSA9IGZ1bmN0aW9uIChyYXdUeXBlTmFtZSkgeyByZXR1cm4gcGFyc2VUeXBlTmFtZShyYXdUeXBlTmFtZSkudHlwZU5hbWU7IH07XHJcblxyXG4gIC8qKlxyXG4gIEdlbmVyYWwgcHVycG9zZSBwcm9wZXJ0eSBzZXQgbWV0aG9kXHJcbiAgXHJcbiAgPiAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgZW0xLm1ldGFkYXRhU3RvcmUuc2V0UHJvcGVydGllcygge1xyXG4gID4gICAgICAgICB2ZXJzaW9uOiBcIjYuMS4zXCIsXHJcbiAgPiAgICAgICAgIHNlcmlhbGl6ZXJGbjogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcclxuICA+ICAgICAgICAgcmV0dXJuIChwcm9wLmlzVW5tYXBwZWQpID8gdW5kZWZpbmVkIDogdmFsdWU7XHJcbiAgPiAgICAgICAgIH1cclxuICA+ICAgICApfTtcclxuICBAcGFyYW0gY29uZmlnIC0gIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzZWxlY3RlZCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgdG8gc2V0LlxyXG4gICoqL1xyXG4gIHNldFByb3BlcnRpZXMoY29uZmlnOiBNZXRhZGF0YVN0b3JlQ29uZmlnKSB7XHJcbiAgICBhc3NlcnRDb25maWcoY29uZmlnKVxyXG4gICAgICAud2hlcmVQYXJhbShcIm5hbWVcIikuaXNTdHJpbmcoKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJzZXJpYWxpemVyRm5cIikuaXNGdW5jdGlvbigpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAuYXBwbHlBbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBBZGRzIGEgRGF0YVNlcnZpY2UgdG8gdGhpcyBNZXRhZGF0YVN0b3JlLiBJZiBhIERhdGFTZXJ2aWNlIHdpdGggdGhlIHNhbWUgc2VydmljZU5hbWUgaXMgYWxyZWFkeVxyXG4gIGluIHRoZSBNZXRhZGF0YVN0b3JlIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuICBAcGFyYW0gZGF0YVNlcnZpY2UgLSBUaGUgW1tEYXRhU2VydmljZV1dIHRvIGFkZFxyXG4gIEBwYXJhbSBzaG91bGRPdmVyd3JpdGUgLSAoZGVmYXVsdD1mYWxzZSkgUGVybWl0IG92ZXJ3cml0ZSBvZiBleGlzdGluZyBEYXRhU2VydmljZSByYXRoZXIgdGhhbiB0aHJvdyBleGNlcHRpb25cclxuICAqKi9cclxuICBhZGREYXRhU2VydmljZShkYXRhU2VydmljZTogRGF0YVNlcnZpY2UsIHNob3VsZE92ZXJ3cml0ZT86IGJvb2xlYW4pIHtcclxuICAgIGFzc2VydFBhcmFtKGRhdGFTZXJ2aWNlLCBcImRhdGFTZXJ2aWNlXCIpLmlzSW5zdGFuY2VPZihEYXRhU2VydmljZSkuY2hlY2soKTtcclxuICAgIGFzc2VydFBhcmFtKHNob3VsZE92ZXJ3cml0ZSwgXCJzaG91bGRPdmVyd3JpdGVcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcbiAgICBsZXQgaXggPSB0aGlzLl9nZXREYXRhU2VydmljZUluZGV4KGRhdGFTZXJ2aWNlLnNlcnZpY2VOYW1lKTtcclxuICAgIGlmIChpeCA+PSAwKSB7XHJcbiAgICAgIGlmICghIXNob3VsZE92ZXJ3cml0ZSkge1xyXG4gICAgICAgIHRoaXMuZGF0YVNlcnZpY2VzW2l4XSA9IGRhdGFTZXJ2aWNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgZGF0YVNlcnZpY2Ugd2l0aCB0aGlzIG5hbWUgJ1wiICsgZGF0YVNlcnZpY2Uuc2VydmljZU5hbWUgKyBcIicgYWxyZWFkeSBleGlzdHMgaW4gdGhpcyBNZXRhZGF0YVN0b3JlXCIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRhdGFTZXJ2aWNlcy5wdXNoKGRhdGFTZXJ2aWNlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9nZXREYXRhU2VydmljZUluZGV4KHNlcnZpY2VOYW1lOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBjb3JlLmFycmF5SW5kZXhPZih0aGlzLmRhdGFTZXJ2aWNlcywgZnVuY3Rpb24gKGRzKSB7XHJcbiAgICAgIHJldHVybiBkcy5zZXJ2aWNlTmFtZSA9PT0gc2VydmljZU5hbWU7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIEFkZHMgYW4gRW50aXR5VHlwZSB0byB0aGlzIE1ldGFkYXRhU3RvcmUuICBObyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgbWF5IGJlIGFkZGVkIHRvIHRoZSBFbnRpdHlUeXBlIGFmdGVyIGl0cyBoYXNcclxuICBiZWVuIGFkZGVkIHRvIHRoZSBNZXRhZGF0YVN0b3JlLlxyXG4gIEBwYXJhbSBzdHJ1Y3R1cmFsVHlwZSAtIFRoZSBFbnRpdHlUeXBlIG9yIENvbXBsZXhUeXBlIHRvIGFkZFxyXG4gICoqL1xyXG4gIGFkZEVudGl0eVR5cGUoc3R5cGU6IFN0cnVjdHVyYWxUeXBlIHwgRW50aXR5VHlwZUNvbmZpZyB8IENvbXBsZXhUeXBlQ29uZmlnKSB7XHJcbiAgICBsZXQgc3RydWN0dXJhbFR5cGU6IFN0cnVjdHVyYWxUeXBlO1xyXG4gICAgaWYgKHN0eXBlIGluc3RhbmNlb2YgRW50aXR5VHlwZSB8fCBzdHlwZSBpbnN0YW5jZW9mIENvbXBsZXhUeXBlKSB7XHJcbiAgICAgIHN0cnVjdHVyYWxUeXBlID0gc3R5cGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdHJ1Y3R1cmFsVHlwZSA9IChzdHlwZSBhcyBhbnkpLmlzQ29tcGxleFR5cGUgPyBuZXcgQ29tcGxleFR5cGUoc3R5cGUpIDogbmV3IEVudGl0eVR5cGUoc3R5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGlmICghc3RydWN0dXJhbFR5cGUuaXNDb21wbGV4VHlwZSkgeyAvLyBzYW1lIGFzIGJlbG93IGJ1dCBpc24ndCBhICd0eXBlIGd1YXJkJ1xyXG4gICAgaWYgKHN0cnVjdHVyYWxUeXBlIGluc3RhbmNlb2YgRW50aXR5VHlwZSkge1xyXG4gICAgICBpZiAoc3RydWN0dXJhbFR5cGUuYmFzZVR5cGVOYW1lICYmICFzdHJ1Y3R1cmFsVHlwZS5iYXNlRW50aXR5VHlwZSkge1xyXG4gICAgICAgIGxldCBiYXNlRW50aXR5VHlwZSA9IHRoaXMuX2dldFN0cnVjdHVyYWxUeXBlKHN0cnVjdHVyYWxUeXBlLmJhc2VUeXBlTmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgLy8gc2FmZSBjYXN0IGJlY2F1c2Ugd2Uga25vdyB0aGF0IGJhc2VFbnRpdHlUeXBlIG11c3QgYmUgYW4gRW50aXR5VHlwZSBpZiB0aGUgc3RydWN0dXJhbFR5cGUgaXMgYW4gRW50aXR5VHlwZVxyXG4gICAgICAgIHN0cnVjdHVyYWxUeXBlLl91cGRhdGVGcm9tQmFzZShiYXNlRW50aXR5VHlwZSBhcyBFbnRpdHlUeXBlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RydWN0dXJhbFR5cGUua2V5UHJvcGVydGllcy5sZW5ndGggPT09IDAgJiYgIXN0cnVjdHVyYWxUeXBlLmlzQWJzdHJhY3QpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gYWRkIFwiICsgc3RydWN0dXJhbFR5cGUubmFtZSArXHJcbiAgICAgICAgICBcIiB0byB0aGlzIE1ldGFkYXRhU3RvcmUuICBBbiBFbnRpdHlUeXBlIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgcHJvcGVydHkgZGVzaWduYXRlZCBhcyBhIGtleSBwcm9wZXJ0eSAtIFNlZSB0aGUgJ0RhdGFQcm9wZXJ0eS5pc1BhcnRPZktleScgcHJvcGVydHkuXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RydWN0dXJhbFR5cGUubWV0YWRhdGFTdG9yZSA9IHRoaXM7XHJcbiAgICAvLyBkb24ndCByZWdpc3RlciBhbm9uIHR5cGVzXHJcbiAgICBpZiAoIShzdHJ1Y3R1cmFsVHlwZSBhcyBhbnkpLmlzQW5vbnltb3VzKSB7XHJcbiAgICAgIGlmICh0aGlzLl9zdHJ1Y3R1cmFsVHlwZU1hcFtzdHJ1Y3R1cmFsVHlwZS5uYW1lXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgXCIgKyBzdHJ1Y3R1cmFsVHlwZS5uYW1lICsgXCIgYWxyZWFkeSBleGlzdHMgaW4gdGhpcyBNZXRhZGF0YVN0b3JlLlwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fc3RydWN0dXJhbFR5cGVNYXBbc3RydWN0dXJhbFR5cGUubmFtZV0gPSBzdHJ1Y3R1cmFsVHlwZTtcclxuICAgICAgdGhpcy5fc2hvcnROYW1lTWFwW3N0cnVjdHVyYWxUeXBlLnNob3J0TmFtZV0gPSBzdHJ1Y3R1cmFsVHlwZS5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHN0cnVjdHVyYWxUeXBlLmdldFByb3BlcnRpZXMoKS5mb3JFYWNoKHAgPT4ge1xyXG4gICAgICBzdHJ1Y3R1cmFsVHlwZS5fdXBkYXRlTmFtZXMocCk7XHJcbiAgICAgIGlmICghcC5pc1VubWFwcGVkKSB7XHJcbiAgICAgICAgc3RydWN0dXJhbFR5cGUuX21hcHBlZFByb3BlcnRpZXNDb3VudCsrO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBzdHJ1Y3R1cmFsVHlwZS5fdXBkYXRlQ3BzKCk7XHJcblxyXG4gICAgLy8gJ2lzRW50aXR5VHlwZScgaXMgYSB0eXBlIGd1YXJkXHJcbiAgICBpZiAoc3RydWN0dXJhbFR5cGUgaW5zdGFuY2VvZiBFbnRpdHlUeXBlKSB7XHJcbiAgICAgIHN0cnVjdHVyYWxUeXBlLl91cGRhdGVOcHMoKTtcclxuICAgICAgLy8gZ2l2ZSB0aGUgdHlwZSBpdCdzIGJhc2UncyByZXNvdXJjZSBuYW1lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBpdHMgb3duLlxyXG4gICAgICBsZXQgZGVmUmVzb3VyY2VOYW1lID0gc3RydWN0dXJhbFR5cGUuZGVmYXVsdFJlc291cmNlTmFtZSB8fCAoc3RydWN0dXJhbFR5cGUuYmFzZUVudGl0eVR5cGUgJiYgc3RydWN0dXJhbFR5cGUuYmFzZUVudGl0eVR5cGUuZGVmYXVsdFJlc291cmNlTmFtZSk7XHJcbiAgICAgIGlmIChkZWZSZXNvdXJjZU5hbWUgJiYgIXRoaXMuZ2V0RW50aXR5VHlwZU5hbWVGb3JSZXNvdXJjZU5hbWUoZGVmUmVzb3VyY2VOYW1lKSkge1xyXG4gICAgICAgIHRoaXMuc2V0RW50aXR5VHlwZUZvclJlc291cmNlTmFtZShkZWZSZXNvdXJjZU5hbWUsIHN0cnVjdHVyYWxUeXBlLm5hbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHN0cnVjdHVyYWxUeXBlLmRlZmF1bHRSZXNvdXJjZU5hbWUgPSBkZWZSZXNvdXJjZU5hbWU7XHJcbiAgICAgIC8vIGNoZWNrIGlmIHRoaXMgc3RydWN0dXJhbCB0eXBlJ3MgbmFtZSwgc2hvcnQgdmVyc2lvbiBvciBxdWFsaWZpZWQgdmVyc2lvbiBoYXMgYSByZWdpc3RlcmVkIGN0b3IuXHJcbiAgICAgIHN0cnVjdHVyYWxUeXBlLmdldEVudGl0eUN0b3IoKTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgRXhwb3J0cyB0aGlzIE1ldGFkYXRhU3RvcmUgdG8gYSBzZXJpYWxpemVkIHN0cmluZyBhcHByb3ByaWF0ZSBmb3IgbG9jYWwgc3RvcmFnZS4gICBUaGlzIG9wZXJhdGlvbiBpcyBhbHNvIGNhbGxlZFxyXG4gIGludGVybmFsbHkgd2hlbiBleHBvcnRpbmcgYW4gRW50aXR5TWFuYWdlci5cclxuICA+ICAgICAgLy8gYXNzdW1lIG1zIGlzIGEgcHJldmlvdXNseSBjcmVhdGVkIE1ldGFkYXRhU3RvcmVcclxuICA+ICAgICAgbGV0IG1ldGFkYXRhQXNTdHJpbmcgPSBtcy5leHBvcnRNZXRhZGF0YSgpO1xyXG4gID4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJtZXRhZGF0YVwiLCBtZXRhZGF0YUFzU3RyaW5nKTtcclxuICA+ICAgICAgLy8gYW5kIGxhdGVyLCB1c3VhbGx5IGluIGEgZGlmZmVyZW50IHNlc3Npb24gaW1wb3J0ZWRcclxuICA+ICAgICAgbGV0IG1ldGFkYXRhRnJvbVN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtZXRhZGF0YVwiKTtcclxuICA+ICAgICAgbGV0IG5ld01ldGFkYXRhU3RvcmUgPSBuZXcgTWV0YWRhdGFTdG9yZSgpO1xyXG4gID4gICAgICBuZXdNZXRhZGF0YVN0b3JlLmltcG9ydE1ldGFkYXRhKG1ldGFkYXRhRnJvbVN0b3JhZ2UpO1xyXG4gIEByZXR1cm4gQSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhpcyBNZXRhZGF0YVN0b3JlIHRoYXQgbWF5IGJlIHN0b3JlZCBsb2NhbGx5IGFuZCBsYXRlciByZXN0b3JlZC5cclxuICAqKi9cclxuICBleHBvcnRNZXRhZGF0YSgpIHtcclxuICAgIGxldCByZXN1bHQgPSBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgIFwibWV0YWRhdGFWZXJzaW9uXCI6IE1ldGFkYXRhU3RvcmUubWV0YWRhdGFWZXJzaW9uLFxyXG4gICAgICBcIm5hbWVcIjogdGhpcy5uYW1lLFxyXG4gICAgICBcIm5hbWluZ0NvbnZlbnRpb25cIjogdGhpcy5uYW1pbmdDb252ZW50aW9uLm5hbWUsXHJcbiAgICAgIFwibG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zXCI6IHRoaXMubG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zLm5hbWUsXHJcbiAgICAgIFwiZGF0YVNlcnZpY2VzXCI6IHRoaXMuZGF0YVNlcnZpY2VzLFxyXG4gICAgICBcInN0cnVjdHVyYWxUeXBlc1wiOiBjb3JlLm9iamVjdE1hcCh0aGlzLl9zdHJ1Y3R1cmFsVHlwZU1hcCksXHJcbiAgICAgIFwicmVzb3VyY2VFbnRpdHlUeXBlTWFwXCI6IHRoaXMuX3Jlc291cmNlRW50aXR5VHlwZU1hcFxyXG4gICAgfSwgbnVsbCwgY29uZmlnLnN0cmluZ2lmeVBhZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgSW1wb3J0cyBhIHByZXZpb3VzbHkgZXhwb3J0ZWQgc2VyaWFsaXplZCBNZXRhZGF0YVN0b3JlIGludG8gdGhpcyBNZXRhZGF0YVN0b3JlLlxyXG4gICAgXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBtcyBpcyBhIHByZXZpb3VzbHkgY3JlYXRlZCBNZXRhZGF0YVN0b3JlXHJcbiAgPiAgICAgIGxldCBtZXRhZGF0YUFzU3RyaW5nID0gbXMuZXhwb3J0TWV0YWRhdGEoKTtcclxuICA+ICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWV0YWRhdGFcIiwgbWV0YWRhdGFBc1N0cmluZyk7XHJcbiAgPiAgICAgIC8vIGFuZCBsYXRlciwgdXN1YWxseSBpbiBhIGRpZmZlcmVudCBzZXNzaW9uXHJcbiAgPiAgICAgIGxldCBtZXRhZGF0YUZyb21TdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibWV0YWRhdGFcIik7XHJcbiAgPiAgICAgIGxldCBuZXdNZXRhZGF0YVN0b3JlID0gbmV3IE1ldGFkYXRhU3RvcmUoKTtcclxuICA+ICAgICAgbmV3TWV0YWRhdGFTdG9yZS5pbXBvcnRNZXRhZGF0YShtZXRhZGF0YUZyb21TdG9yYWdlKTtcclxuICBAcGFyYW0gZXhwb3J0ZWRNZXRhZGF0YSAtIEEgcHJldmlvdXNseSBleHBvcnRlZCBNZXRhZGF0YVN0b3JlLlxyXG4gIEBwYXJhbSBhbGxvd01lcmdlIC0gIEFsbG93cyBjdXN0b20gbWV0YWRhdGEgdG8gYmUgbWVyZ2VkIGludG8gZXhpc3RpbmcgbWV0YWRhdGEgdHlwZXMuXHJcbiAgQHJldHVybiBUaGlzIE1ldGFkYXRhU3RvcmUuXHJcbiAgQGNoYWluYWJsZVxyXG4gICoqL1xyXG4gIGltcG9ydE1ldGFkYXRhKGV4cG9ydGVkTWV0YWRhdGE6IHN0cmluZyB8IE9iamVjdCwgYWxsb3dNZXJnZTogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICBhc3NlcnRQYXJhbShhbGxvd01lcmdlLCBcImFsbG93TWVyZ2VcIikuaXNPcHRpb25hbCgpLmlzQm9vbGVhbigpLmNoZWNrKCk7XHJcbiAgICB0aGlzLl9kZWZlcnJlZFR5cGVzID0ge307XHJcbiAgICAvLyBpbnN1cmUgdGhhdCB3ZSBkb24ndCBtdXRhdGUgaW5jb21pbmcgZXhwb3J0ZWRNZXRhZGF0YSAoIGlmIGl0cyBhbiBvYmplY3QpXHJcbiAgICBsZXQgbWV0YWRhdGFBc1N0cmluZyA9ICh0eXBlb2YgKGV4cG9ydGVkTWV0YWRhdGEpID09PSBcInN0cmluZ1wiKSA/IGV4cG9ydGVkTWV0YWRhdGEgOiBKU09OLnN0cmluZ2lmeShleHBvcnRlZE1ldGFkYXRhKTtcclxuICAgIGNvbnN0IG1ldGFkYXRhSnNvbiA9IEpTT04ucGFyc2UobWV0YWRhdGFBc1N0cmluZyk7XHJcblxyXG4gICAgaWYgKG1ldGFkYXRhSnNvbi5zY2hlbWEpIHtcclxuICAgICAgcmV0dXJuIENzZGxNZXRhZGF0YVBhcnNlci5wYXJzZSh0aGlzLCBtZXRhZGF0YUpzb24uc2NoZW1hLCBtZXRhZGF0YUpzb24uYWx0TWV0YWRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBqc29uID0gbWV0YWRhdGFKc29uIGFzIElNZXRhZGF0YUpzb247XHJcbiAgICBpZiAoanNvbi5tZXRhZGF0YVZlcnNpb24gJiYganNvbi5tZXRhZGF0YVZlcnNpb24gIT09IE1ldGFkYXRhU3RvcmUubWV0YWRhdGFWZXJzaW9uKSB7XHJcbiAgICAgIGxldCBtc2cgPSBjb3JlLmZvcm1hdFN0cmluZyhcIkNhbm5vdCBpbXBvcnQgbWV0YWRhdGEgd2l0aCBhIGRpZmZlcmVudCAnbWV0YWRhdGFWZXJzaW9uJyAoJTEpIHRoYW4gdGhlIGN1cnJlbnQgJ01ldGFkYXRhU3RvcmUubWV0YWRhdGFWZXJzaW9uJyAoJTIpIFwiLFxyXG4gICAgICAgIGpzb24ubWV0YWRhdGFWZXJzaW9uLCBNZXRhZGF0YVN0b3JlLm1ldGFkYXRhVmVyc2lvbik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBuY05hbWUgPSBqc29uLm5hbWluZ0NvbnZlbnRpb247XHJcbiAgICBsZXQgbHFjb05hbWUgPSBqc29uLmxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucztcclxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xyXG4gICAgICB0aGlzLm5hbWluZ0NvbnZlbnRpb24gPSBjb25maWcuX2ZldGNoT2JqZWN0KE5hbWluZ0NvbnZlbnRpb24sIG5jTmFtZSkgfHwgdGhpcy5uYW1pbmdDb252ZW50aW9uO1xyXG4gICAgICB0aGlzLmxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucyA9IGNvbmZpZy5fZmV0Y2hPYmplY3QoTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zLCBscWNvTmFtZSkgfHwgdGhpcy5sb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnM7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAobmNOYW1lICYmIHRoaXMubmFtaW5nQ29udmVudGlvbi5uYW1lICE9PSBuY05hbWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW1wb3J0IG1ldGFkYXRhIHdpdGggYSBkaWZmZXJlbnQgJ25hbWluZ0NvbnZlbnRpb24nIGZyb20gdGhlIGN1cnJlbnQgTWV0YWRhdGFTdG9yZVwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobHFjb05hbWUgJiYgdGhpcy5sb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnMubmFtZSAhPT0gbHFjb05hbWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW1wb3J0IG1ldGFkYXRhIHdpdGggZGlmZmVyZW50ICdsb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnMnIGZyb20gdGhlIGN1cnJlbnQgTWV0YWRhdGFTdG9yZVwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vbm9pbnNwZWN0aW9uIEpTSGludFxyXG4gICAganNvbi5kYXRhU2VydmljZXMgJiYganNvbi5kYXRhU2VydmljZXMuZm9yRWFjaCgoZHMpID0+IHtcclxuICAgICAgbGV0IHJlYWxEcyA9IERhdGFTZXJ2aWNlLmZyb21KU09OKGRzKTtcclxuICAgICAgdGhpcy5hZGREYXRhU2VydmljZShyZWFsRHMsIHRydWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAganNvbi5zdHJ1Y3R1cmFsVHlwZXMgJiYganNvbi5zdHJ1Y3R1cmFsVHlwZXMuZm9yRWFjaCgoc3R5cGUpID0+IHtcclxuICAgICAgc3RydWN0dXJhbFR5cGVGcm9tSnNvbih0aGlzLCBzdHlwZSwgYWxsb3dNZXJnZSk7XHJcbiAgICB9KTtcclxuICAgIGNvcmUuZXh0ZW5kKHRoaXMuX3Jlc291cmNlRW50aXR5VHlwZU1hcCwganNvbi5yZXNvdXJjZUVudGl0eVR5cGVNYXApO1xyXG4gICAgY29yZS5leHRlbmQodGhpcy5faW5jb21wbGV0ZVR5cGVNYXAsIGpzb24uaW5jb21wbGV0ZVR5cGVNYXApO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgQ3JlYXRlcyBhIG5ldyBNZXRhZGF0YVN0b3JlIGZyb20gYSBwcmV2aW91c2x5IGV4cG9ydGVkIHNlcmlhbGl6ZWQgTWV0YWRhdGFTdG9yZVxyXG4gID4gICAgICAvLyBhc3N1bWUgbXMgaXMgYSBwcmV2aW91c2x5IGNyZWF0ZWQgTWV0YWRhdGFTdG9yZVxyXG4gID4gICAgICBsZXQgbWV0YWRhdGFBc1N0cmluZyA9IG1zLmV4cG9ydE1ldGFkYXRhKCk7XHJcbiAgPiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm1ldGFkYXRhXCIsIG1ldGFkYXRhQXNTdHJpbmcpO1xyXG4gID4gICAgICAvLyBhbmQgbGF0ZXIsIHVzdWFsbHkgaW4gYSBkaWZmZXJlbnQgc2Vzc2lvblxyXG4gID4gICAgICBsZXQgbWV0YWRhdGFGcm9tU3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1ldGFkYXRhXCIpO1xyXG4gID4gICAgICBsZXQgbmV3TWV0YWRhdGFTdG9yZSA9IE1ldGFkYXRhU3RvcmUuaW1wb3J0TWV0YWRhdGEobWV0YWRhdGFGcm9tU3RvcmFnZSk7XHJcbiAgQHBhcmFtIGV4cG9ydGVkU3RyaW5nIC0gQSBwcmV2aW91c2x5IGV4cG9ydGVkIE1ldGFkYXRhU3RvcmUuXHJcbiAgQHJldHVybiBBIG5ldyBNZXRhZGF0YVN0b3JlLlxyXG4gICoqL1xyXG4gIHN0YXRpYyBpbXBvcnRNZXRhZGF0YShleHBvcnRlZFN0cmluZzogc3RyaW5nKSB7XHJcbiAgICBsZXQgbXMgPSBuZXcgTWV0YWRhdGFTdG9yZSgpO1xyXG4gICAgbXMuaW1wb3J0TWV0YWRhdGEoZXhwb3J0ZWRTdHJpbmcpO1xyXG4gICAgcmV0dXJuIG1zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyB3aGV0aGVyIE1ldGFkYXRhIGhhcyBiZWVuIHJldHJpZXZlZCBmb3IgYSBzcGVjaWZpZWQgc2VydmljZSBuYW1lLlxyXG4gID4gICAgICAvLyBBc3N1bWUgZW0xIGlzIGFuIGV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgPiAgICAgIGlmICghZW0xLm1ldGFkYXRhU3RvcmUuaGFzTWV0YWRhdGFGb3IoXCJicmVlemUvTm9ydGh3aW5kSUJNb2RlbFwiKSkpIHtcclxuICA+ICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyBpbnRlcmVzdGluZ1xyXG4gID4gICAgICB9XHJcbiAgQHBhcmFtIHNlcnZpY2VOYW1lIC0gVGhlIHNlcnZpY2UgbmFtZS5cclxuICBAcmV0dXJuIFdoZXRoZXIgbWV0YWRhdGEgaGFzIGFscmVhZHkgYmVlbiByZXRyaWV2ZWQgZm9yIHRoZSBzcGVjaWZpZWQgc2VydmljZSBuYW1lLlxyXG4gICoqL1xyXG4gIGhhc01ldGFkYXRhRm9yKHNlcnZpY2VOYW1lOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiAhIXRoaXMuZ2V0RGF0YVNlcnZpY2Uoc2VydmljZU5hbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyB0aGUgRGF0YVNlcnZpY2UgZm9yIGEgc3BlY2lmaWVkIHNlcnZpY2UgbmFtZVxyXG4gID4gICAgICAvLyBBc3N1bWUgZW0xIGlzIGFuIGV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgPiAgICAgIGxldCBkcyA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldERhdGFTZXJ2aWNlKFwiYnJlZXplL05vcnRod2luZElCTW9kZWxcIik7XHJcbiAgPiAgICAgIGxldCBhZGFwdGVyTmFtZSA9IGRzLmFkYXB0ZXJOYW1lOyAvLyBtYXkgYmUgbnVsbFxyXG4gIEBwYXJhbSBzZXJ2aWNlTmFtZSAtIFRoZSBzZXJ2aWNlIG5hbWUuXHJcbiAgQHJldHVybiBUaGUgRGF0YVNlcnZpY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgKiovXHJcbiAgZ2V0RGF0YVNlcnZpY2Uoc2VydmljZU5hbWU6IHN0cmluZykge1xyXG4gICAgYXNzZXJ0UGFyYW0oc2VydmljZU5hbWUsIFwic2VydmljZU5hbWVcIikuaXNTdHJpbmcoKS5jaGVjaygpO1xyXG5cclxuICAgIHNlcnZpY2VOYW1lID0gRGF0YVNlcnZpY2UuX25vcm1hbGl6ZVNlcnZpY2VOYW1lKHNlcnZpY2VOYW1lKTtcclxuICAgIHJldHVybiBjb3JlLmFycmF5Rmlyc3QodGhpcy5kYXRhU2VydmljZXMsIGZ1bmN0aW9uIChkczogRGF0YVNlcnZpY2UpIHtcclxuICAgICAgcmV0dXJuIGRzLnNlcnZpY2VOYW1lID09PSBzZXJ2aWNlTmFtZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgRmV0Y2hlcyB0aGUgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWVkICdzZXJ2aWNlJy4gVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWRcclxuICBpbnRlcm5hbGx5IGJ5IGFuIEVudGl0eU1hbmFnZXIgYmVmb3JlIGl0cyBmaXJzdCBxdWVyeSBhZ2FpbnN0IGEgbmV3IHNlcnZpY2UuIF9fQXN5bmNfX1xyXG5cclxuICBVc3VhbGx5IHlvdSB3aWxsIG5vdCBhY3R1YWxseSBwcm9jZXNzIHRoZSByZXN1bHRzIG9mIGEgZmV0Y2hNZXRhZGF0YSBjYWxsIGRpcmVjdGx5LCBidXQgd2lsbCBpbnN0ZWFkXHJcbiAgYXNrIGZvciB0aGUgbWV0YWRhdGEgZnJvbSB0aGUgRW50aXR5TWFuYWdlciBhZnRlciB0aGUgZmV0Y2hNZXRhZGF0YSBjYWxsIHJldHVybnMuXHJcbiAgPiAgICAgIGxldCBtcyA9IG5ldyBNZXRhZGF0YVN0b3JlKCk7XHJcbiAgPiAgICAgIC8vIG9yIG1vcmUgY29tbW9ubHlcclxuICA+ICAgICAgLy8gbGV0IG1zID0gYW5FbnRpdHlNYW5hZ2VyLm1ldGFkYXRhU3RvcmU7XHJcbiAgPiAgICAgIG1zLmZldGNoTWV0YWRhdGEoXCJicmVlemUvTm9ydGh3aW5kSUJNb2RlbFwiKS50aGVuKGZ1bmN0aW9uKHJhd01ldGFkYXRhKSB7XHJcbiAgPiAgICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBtZXRhZGF0YVxyXG4gID4gICAgICB9KS5jYXRjaChmdW5jdGlvbihleGNlcHRpb24pIHtcclxuICA+ICAgICAgICAgIC8vIGhhbmRsZSBleGNlcHRpb24gaGVyZVxyXG4gID4gICAgICB9KTtcclxuICBAcGFyYW0gZGF0YVNlcnZpY2UgLSAgRWl0aGVyIGEgRGF0YVNlcnZpY2Ugb3IganVzdCB0aGUgbmFtZSBvZiB0aGUgRGF0YVNlcnZpY2UgdG8gZmV0Y2ggbWV0YWRhdGEgZm9yLlxyXG4gIEBwYXJhbSBjYWxsYmFjayAtIEZ1bmN0aW9uIGNhbGxlZCBvbiBzdWNjZXNzLlxyXG4gIEBwYXJhbSBlcnJvckNhbGxiYWNrIC0gRnVuY3Rpb24gY2FsbGVkIG9uIGZhaWx1cmUuXHJcbiAgQHJldHVybiBQcm9taXNlXHJcbiAgKiovXHJcbiAgZmV0Y2hNZXRhZGF0YShkYXRhU2VydmljZTogc3RyaW5nIHwgRGF0YVNlcnZpY2UsIGNhbGxiYWNrPzogKHNjaGVtYTogYW55KSA9PiB2b2lkLCBlcnJvckNhbGxiYWNrPzogRXJyb3JDYWxsYmFjaykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXNzZXJ0UGFyYW0oZGF0YVNlcnZpY2UsIFwiZGF0YVNlcnZpY2VcIikuaXNTdHJpbmcoKS5vcigpLmlzSW5zdGFuY2VPZihEYXRhU2VydmljZSkuY2hlY2soKTtcclxuICAgICAgYXNzZXJ0UGFyYW0oY2FsbGJhY2ssIFwiY2FsbGJhY2tcIikuaXNGdW5jdGlvbigpLmlzT3B0aW9uYWwoKS5jaGVjaygpO1xyXG4gICAgICBhc3NlcnRQYXJhbShlcnJvckNhbGxiYWNrLCBcImVycm9yQ2FsbGJhY2tcIikuaXNGdW5jdGlvbigpLmlzT3B0aW9uYWwoKS5jaGVjaygpO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBkYXRhU2VydmljZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIC8vIHVzZSB0aGUgZGF0YVNlcnZpY2Ugd2l0aCBhIG1hdGNoaW5nIG5hbWUgb3IgY3JlYXRlIGEgbmV3IG9uZS5cclxuICAgICAgICBkYXRhU2VydmljZSA9IHRoaXMuZ2V0RGF0YVNlcnZpY2UoZGF0YVNlcnZpY2UpIHx8IG5ldyBEYXRhU2VydmljZSh7IHNlcnZpY2VOYW1lOiBkYXRhU2VydmljZSB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGF0YVNlcnZpY2UgPSBEYXRhU2VydmljZS5yZXNvbHZlKFtkYXRhU2VydmljZV0pO1xyXG5cclxuICAgICAgaWYgKHRoaXMuaGFzTWV0YWRhdGFGb3IoZGF0YVNlcnZpY2Uuc2VydmljZU5hbWUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgc2VydmljZU5hbWUgbWF5IG9ubHkgYmUgZmV0Y2hlZCBvbmNlIHBlciBNZXRhZGF0YVN0b3JlLiBTZXJ2aWNlTmFtZTogXCIgKyBkYXRhU2VydmljZS5zZXJ2aWNlTmFtZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBkYXRhU2VydmljZS5hZGFwdGVySW5zdGFuY2UhLmZldGNoTWV0YWRhdGEodGhpcywgZGF0YVNlcnZpY2UpLnRoZW4oKHJhd01ldGFkYXRhOiBhbnkpID0+IHtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhRmV0Y2hlZC5wdWJsaXNoKHsgbWV0YWRhdGFTdG9yZTogdGhpcywgZGF0YVNlcnZpY2U6IGRhdGFTZXJ2aWNlLCByYXdNZXRhZGF0YTogcmF3TWV0YWRhdGEgfSk7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhyYXdNZXRhZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyYXdNZXRhZGF0YSk7XHJcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIGVycm9yQ2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gVE9ETzogc3Ryb25nbHkgdHlwZSBpbnRlcmNlcHRvciBiZWxvdy5cclxuICAvKipcclxuICBVc2VkIHRvIHJlZ2lzdGVyIGEgY29uc3RydWN0b3IgZm9yIGFuIEVudGl0eVR5cGUgdGhhdCBpcyBub3Qga25vd24gdmlhIHN0YW5kYXJkIE1ldGFkYXRhIGRpc2NvdmVyeTtcclxuICBpLmUuIGFuIHVubWFwcGVkIHR5cGUuXHJcbiAgQHBhcmFtIGVudGl0eUN0b3IgLSBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSAndW5tYXBwZWQnIHR5cGUuXHJcbiAgQHBhcmFtIGludGVyY2VwdG9yIC0gQW4gaW50ZXJjZXB0b3IgZnVuY3Rpb25cclxuICAqKi9cclxuICB0cmFja1VubWFwcGVkVHlwZShlbnRpdHlDdG9yOiBhbnksIGludGVyY2VwdG9yOiBhbnkpIHtcclxuICAgIGFzc2VydFBhcmFtKGVudGl0eUN0b3IsIFwiZW50aXR5Q3RvclwiKS5pc0Z1bmN0aW9uKCkuY2hlY2soKTtcclxuICAgIGFzc2VydFBhcmFtKGludGVyY2VwdG9yLCBcImludGVyY2VwdG9yXCIpLmlzRnVuY3Rpb24oKS5pc09wdGlvbmFsKCkuY2hlY2soKTtcclxuICAgIC8vIFRPRE86IHRoaW5rIGFib3V0IGFkZGluZyB0aGlzIHRvIHRoZSBNZXRhZGF0YVN0b3JlLlxyXG4gICAgbGV0IGVudGl0eVR5cGUgPSBuZXcgRW50aXR5VHlwZSh0aGlzKTtcclxuICAgIGVudGl0eVR5cGUuX3NldEN0b3IoZW50aXR5Q3RvciwgaW50ZXJjZXB0b3IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gcmVnaXN0ZXIgYSAnY3VzdG9tJyBjb25zdHJ1Y3RvciB0byBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xyXG4gIG9mIHRoZSBzcGVjaWZpZWQgZW50aXR5IHR5cGUuICBJZiB0aGlzIGNhbGwgaXMgbm90IG1hZGUsIGEgZGVmYXVsdCBjb25zdHJ1Y3RvciBpcyBjcmVhdGVkIGZvclxyXG4gIHRoZSBlbnRpdHkgYXMgbmVlZGVkLlxyXG4gIFRoaXMgY2FsbCBtYXkgYmUgbWFkZSBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgRW50aXR5VHlwZSBoYXMgYmVlbiBkaXNjb3ZlcmVkIHZpYVxyXG4gIE1ldGFkYXRhIGRpc2NvdmVyeS5cclxuICA+ICAgICAgbGV0IEN1c3RvbWVyID0gZnVuY3Rpb24gKCkge1xyXG4gID4gICAgICAgICAgICAgIHRoaXMubWlzY0RhdGEgPSBcImFzZGZcIjtcclxuICA+ICAgICAgICAgIH07XHJcbiAgPiAgICAgIEN1c3RvbWVyLnByb3RvdHlwZS5kb0ZvbygpIHtcclxuICA+ICAgICAgICAgICAgICAuLi5cclxuICA+ICAgICAgICAgIH1cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXI7XHJcbiAgPiAgICAgIGVtMS5tZXRhZGF0YVN0b3JlLnJlZ2lzdGVyRW50aXR5VHlwZUN0b3IoXCJDdXN0b21lclwiLCBDdXN0b21lcik7XHJcbiAgPiAgICAgIC8vIGFueSBxdWVyaWVzIG9yIEVudGl0eVR5cGUuY3JlYXRlIGNhbGxzIGZyb20gdGhpcyBwb2ludCBvbiB3aWxsIGNhbGwgdGhlIEN1c3RvbWVyIGNvbnN0cnVjdG9yXHJcbiAgPiAgICAgIC8vIHJlZ2lzdGVyZWQgYWJvdmUuXHJcbiAgQHBhcmFtIHN0cnVjdHVyYWxUeXBlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBFbnRpdHlUeXBlIG9yIENvbXBsZXhUeXBlLlxyXG4gIEBwYXJhbSBhQ3RvciAtIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhpcyBFbnRpdHlUeXBlIG9yIENvbXBsZXhUeXBlOyBtYXkgYmUgbnVsbCBpZiBhbGwgeW91IHdhbnQgdG8gZG8gaXMgc2V0IHRoZSBuZXh0IHBhcmFtZXRlci5cclxuICBAcGFyYW0gaW5pdEZuIC0gQSBmdW5jdGlvbiBvciB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIG9uIHRoZSBlbnRpdHkgdGhhdCBpcyB0byBiZSBleGVjdXRlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgZW50aXR5IGhhcyBiZWVuIGNyZWF0ZWRcclxuICBhbmQgcG9wdWxhdGVkIHdpdGggYW55IGluaXRpYWwgdmFsdWVzLiBDYWxsZWQgd2l0aCAnaW5pdEZuKGVudGl0eSknXHJcbiAgQHBhcmFtIG5vVHJhY2tpbmdGbiAtIEEgZnVuY3Rpb24gdGhhdCBpcyBleGVjdXRlZCBpbW1lZGlhdGVseSBhZnRlciBhIG5vVHJhY2tpbmcgZW50aXR5IGhhcyBiZWVuIGNyZWF0ZWQgYW5kIHdob3NlIHJldHVyblxyXG4gIHZhbHVlIHdpbGwgYmUgdXNlZCBpbiBwbGFjZSBvZiB0aGUgbm9UcmFja2luZyBlbnRpdHkuXHJcbiAgKiovXHJcbiAgcmVnaXN0ZXJFbnRpdHlUeXBlQ3RvcihzdHJ1Y3R1cmFsVHlwZU5hbWU6IHN0cmluZywgYUN0b3I/OiBhbnksIGluaXRGbj86IEZ1bmN0aW9uIHwgc3RyaW5nLCBub1RyYWNraW5nRm4/OiBGdW5jdGlvbikge1xyXG4gICAgYXNzZXJ0UGFyYW0oc3RydWN0dXJhbFR5cGVOYW1lLCBcInN0cnVjdHVyYWxUeXBlTmFtZVwiKS5pc1N0cmluZygpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShhQ3RvciwgXCJhQ3RvclwiKS5pc0Z1bmN0aW9uKCkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShpbml0Rm4sIFwiaW5pdEZuXCIpLmlzT3B0aW9uYWwoKS5pc0Z1bmN0aW9uKCkub3IoKS5pc1N0cmluZygpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShub1RyYWNraW5nRm4sIFwibm9UcmFja2luZ0ZuXCIpLmlzT3B0aW9uYWwoKS5pc0Z1bmN0aW9uKCkuY2hlY2soKTtcclxuXHJcbiAgICBsZXQgcXVhbGlmaWVkVHlwZU5hbWUgPSBnZXRRdWFsaWZpZWRUeXBlTmFtZSh0aGlzLCBzdHJ1Y3R1cmFsVHlwZU5hbWUsIGZhbHNlKTtcclxuICAgIGxldCB0eXBlTmFtZSA9IHF1YWxpZmllZFR5cGVOYW1lIHx8IHN0cnVjdHVyYWxUeXBlTmFtZTtcclxuXHJcbiAgICBpZiAoYUN0b3IpIHtcclxuICAgICAgaWYgKGFDdG9yLl8kdHlwZU5hbWUgJiYgYUN0b3IuXyR0eXBlTmFtZSAhPT0gdHlwZU5hbWUpIHtcclxuICAgICAgICAvLyBUT0RPOiB3cmFwIHRoaXMgLSBjb25zb2xlIGFuZCBlc3BlY2lhbGx5IGNvbnNvbGUud2FybiBkb2VzIG5vdCBleGlzdCBpbiBhbGwgYnJvd3NlcnMuXHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiUmVnaXN0ZXJpbmcgYSBjb25zdHJ1Y3RvciBmb3IgXCIgKyB0eXBlTmFtZSArIFwiIHRoYXQgaXMgYWxyZWFkeSB1c2VkIGZvciBcIiArIGFDdG9yLl8kdHlwZU5hbWUgKyBcIi5cIik7XHJcbiAgICAgIH1cclxuICAgICAgYUN0b3IuXyR0eXBlTmFtZSA9IHR5cGVOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2N0b3JSZWdpc3RyeVt0eXBlTmFtZV0gPSB7IGN0b3I6IGFDdG9yLCBpbml0Rm46IGluaXRGbiwgbm9UcmFja2luZ0ZuOiBub1RyYWNraW5nRm4gfTtcclxuICAgIGlmIChxdWFsaWZpZWRUeXBlTmFtZSkge1xyXG4gICAgICBsZXQgc3R5cGUgPSB0aGlzLl9zdHJ1Y3R1cmFsVHlwZU1hcFtxdWFsaWZpZWRUeXBlTmFtZV07XHJcbiAgICAgIHN0eXBlICYmIHN0eXBlLmdldEN0b3IodHJ1ZSk7IC8vIHRoaXMgd2lsbCBjb21wbGV0ZSB0aGUgcmVnaXN0cmF0aW9uIGlmIGF2YWlsIG5vdy5cclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIHdoZXRoZXIgdGhpcyBNZXRhZGF0YVN0b3JlIGNvbnRhaW5zIGFueSBtZXRhZGF0YSB5ZXQuXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYSBwcmVleGlzdGluZyBFbnRpdHlNYW5hZ2VyO1xyXG4gID4gICAgICBpZiAoZW0xLm1ldGFkYXRhU3RvcmUuaXNFbXB0eSgpKSB7XHJcbiAgPiAgICAgICAgICAvLyBkbyBzb21ldGhpbmcgaW50ZXJlc3RpbmdcclxuICA+ICAgICAgfVxyXG4gICoqL1xyXG4gIGlzRW1wdHkoKSB7XHJcbiAgICByZXR1cm4gY29yZS5pc0VtcHR5KHRoaXMuX3N0cnVjdHVyYWxUeXBlTWFwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYW4gW1tFbnRpdHlUeXBlXV0gb3IgbnVsbCBnaXZlbiBpdHMgbmFtZS5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXJcclxuICA+ICAgICAgbGV0IG9kVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEFzRW50aXR5VHlwZShcIk9yZGVyRGV0YWlsXCIpO1xyXG5cclxuICBvciB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdHlwZSBpcyBub3QgZm91bmRcclxuICA+ICAgICAgbGV0IGJhZFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRBc0VudGl0eVR5cGUoXCJGb29cIiwgZmFsc2UpO1xyXG4gID4gICAgICAvLyBiYWRUeXBlIHdpbGwgbm90IGdldCBzZXQgYW5kIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuICBAcGFyYW0gc3RydWN0dXJhbFR5cGVOYW1lIC0gRWl0aGVyIHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvciBhIHNob3J0IG5hbWUgbWF5IGJlIHVzZWQuIElmIGEgc2hvcnQgbmFtZSBpcyBzcGVjaWZpZWQgYW5kIG11bHRpcGxlIHR5cGVzIHNoYXJlXHJcbiAgdGhhdCBzYW1lIHNob3J0IG5hbWUgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG4gIEBwYXJhbSBva0lmTm90Rm91bmQgLSAoZGVmYXVsdD1mYWxzZSkgV2hldGhlciB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGUgc3BlY2lmaWVkIEVudGl0eVR5cGUgaXMgbm90IGZvdW5kLlxyXG4gIEByZXR1cm4gVGhlIEVudGl0eVR5cGUuIENvbXBsZXhUeXBlIG9yICdudWxsJyBpZiBub3Qgbm90IGZvdW5kLlxyXG4gICoqL1xyXG4gIGdldEFzRW50aXR5VHlwZSh0eXBlTmFtZTogc3RyaW5nLCBva0lmTm90Rm91bmQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgY29uc3Qgc3QgPSB0aGlzLmdldFN0cnVjdHVyYWxUeXBlKHR5cGVOYW1lLCBva0lmTm90Rm91bmQpO1xyXG4gICAgaWYgKHN0IGluc3RhbmNlb2YgRW50aXR5VHlwZSkge1xyXG4gICAgICByZXR1cm4gc3QgYXMgRW50aXR5VHlwZTtcclxuICAgIH0gZWxzZSBpZiAob2tJZk5vdEZvdW5kKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IG1zZyA9IGNvcmUuZm9ybWF0U3RyaW5nKFwiVW5hYmxlIHRvIGxvY2F0ZSBhbiAnRW50aXR5VHlwZScgYnkgdGhlIG5hbWU6ICclMScuIEJlIHN1cmUgdG8gZXhlY3V0ZSBhIHF1ZXJ5IG9yIGNhbGwgZmV0Y2hNZXRhZGF0YSBmaXJzdC5cIiwgdHlwZU5hbWUpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYW4gW1tFbnRpdHlUeXBlXV0gb3IgbnVsbCBnaXZlbiBpdHMgbmFtZS5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXJcclxuICA+ICAgICAgbGV0IGxvY1R5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRBc0NvbXBsZXhUeXBlKFwiTG9jYXRpb25cIik7XHJcblxyXG4gIG9yIHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSB0eXBlIGlzIG5vdCBmb3VuZFxyXG4gID4gICAgICBsZXQgYmFkVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEFzQ29tcGxleFR5cGUoXCJGb29cIiwgZmFsc2UpO1xyXG4gID4gICAgICAvLyBiYWRUeXBlIHdpbGwgbm90IGdldCBzZXQgYW5kIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuICBAcGFyYW0gc3RydWN0dXJhbFR5cGVOYW1lIC0gRWl0aGVyIHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvciBhIHNob3J0IG5hbWUgbWF5IGJlIHVzZWQuIElmIGEgc2hvcnQgbmFtZSBpcyBzcGVjaWZpZWQgYW5kIG11bHRpcGxlIHR5cGVzIHNoYXJlXHJcbiAgdGhhdCBzYW1lIHNob3J0IG5hbWUgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG4gIEBwYXJhbSBva0lmTm90Rm91bmQgLSAoZGVmYXVsdD1mYWxzZSkgV2hldGhlciB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGUgc3BlY2lmaWVkIEVudGl0eVR5cGUgaXMgbm90IGZvdW5kLlxyXG4gIEByZXR1cm4gVGhlIEVudGl0eVR5cGUuIENvbXBsZXhUeXBlIG9yICdudWxsJyBpZiBub3Qgbm90IGZvdW5kLlxyXG4gICoqL1xyXG4gZ2V0QXNDb21wbGV4VHlwZSh0eXBlTmFtZTogc3RyaW5nLCBva0lmTm90Rm91bmQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gIGNvbnN0IHN0ID0gdGhpcy5nZXRTdHJ1Y3R1cmFsVHlwZSh0eXBlTmFtZSwgb2tJZk5vdEZvdW5kKTtcclxuICBpZiAoc3QgaW5zdGFuY2VvZiBDb21wbGV4VHlwZSkge1xyXG4gICAgcmV0dXJuIHN0IGFzIENvbXBsZXhUeXBlO1xyXG4gIH0gZWxzZSBpZiAob2tJZk5vdEZvdW5kKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9IGVsc2Uge1xyXG4gICAgbGV0IG1zZyA9IGNvcmUuZm9ybWF0U3RyaW5nKFwiVW5hYmxlIHRvIGxvY2F0ZSBhbiAnQ29tcGxleFR5cGUnIGJ5IHRoZSBuYW1lOiAnJTEnLiBCZSBzdXJlIHRvIGV4ZWN1dGUgYSBxdWVyeSBvciBjYWxsIGZldGNoTWV0YWRhdGEgZmlyc3QuXCIsIHR5cGVOYW1lKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhbiBbW0VudGl0eVR5cGVdXSBvciBhIFtbQ29tcGxleFR5cGVdXSBnaXZlbiBpdHMgbmFtZS5cclxuICBAZGVwcmVjYXRlZCBSZXBsYWNlZCBieSBnZXRTdHJ1Y3R1cmFsVHlwZSBidXQgLi4uIGl0IGlzIHByb2JhYmx5IG1vcmUgdXNlZnVsbCB0byBjYWxsIGVpdGhlciBnZXRBc0VudGl0eVR5cGUgb3IgZ2V0QXNDb21wbGV4VHlwZSBpbnN0ZWFkXHJcbiAgQHBhcmFtIHR5cGVOYW1lIC0gRWl0aGVyIHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvciBhIHNob3J0IG5hbWUgbWF5IGJlIHVzZWQuIElmIGEgc2hvcnQgbmFtZSBpcyBzcGVjaWZpZWQgYW5kIG11bHRpcGxlIHR5cGVzIHNoYXJlXHJcbiAgdGhhdCBzYW1lIHNob3J0IG5hbWUgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG4gIEBwYXJhbSBva0lmTm90Rm91bmQgLSAoZGVmYXVsdD1mYWxzZSkgV2hldGhlciB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGUgc3BlY2lmaWVkIEVudGl0eVR5cGUgaXMgbm90IGZvdW5kLlxyXG4gIEByZXR1cm4gVGhlIEVudGl0eVR5cGUuIENvbXBsZXhUeXBlIG9yICdudWxsJyBpZiBub3Qgbm90IGZvdW5kLlxyXG4gICoqL1xyXG4gIGdldEVudGl0eVR5cGUodHlwZU5hbWU6IHN0cmluZywgb2tJZk5vdEZvdW5kOiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFN0cnVjdHVyYWxUeXBlKHR5cGVOYW1lLCBva0lmTm90Rm91bmQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhbiBbW0VudGl0eVR5cGVdXSBvciBhIFtbQ29tcGxleFR5cGVdXSBnaXZlbiBpdHMgbmFtZS5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXJcclxuICA+ICAgICAgbGV0IG9kVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldFN0cnVjdHVyYWxUeXBlKFwiT3JkZXJEZXRhaWxcIik7XHJcblxyXG4gIG9yIHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSB0eXBlIGlzIG5vdCBmb3VuZFxyXG4gID4gICAgICBsZXQgYmFkVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldFN0cnVjdHVyYWxUeXBlKFwiRm9vXCIsIGZhbHNlKTtcclxuICA+ICAgICAgLy8gYmFkVHlwZSB3aWxsIG5vdCBnZXQgc2V0IGFuZCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcbiAgQGRlcHJlY2F0ZWQgUHJlZmVyYWJseSB1c2UgZWl0aGVyIGdldEFzRW50aXR5VHlwZSBvciBnZXRBc0NvbXBsZXhUeXBlLiAgR2V0XHJcbiAgQHBhcmFtIHR5cGVOYW1lIC0gRWl0aGVyIHRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvciBhIHNob3J0IG5hbWUgbWF5IGJlIHVzZWQuIElmIGEgc2hvcnQgbmFtZSBpcyBzcGVjaWZpZWQgYW5kIG11bHRpcGxlIHR5cGVzIHNoYXJlXHJcbiAgdGhhdCBzYW1lIHNob3J0IG5hbWUgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG4gIEBwYXJhbSBva0lmTm90Rm91bmQgLSAoZGVmYXVsdD1mYWxzZSkgV2hldGhlciB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGUgc3BlY2lmaWVkIEVudGl0eVR5cGUgaXMgbm90IGZvdW5kLlxyXG4gIEByZXR1cm4gVGhlIEVudGl0eVR5cGUuIENvbXBsZXhUeXBlIG9yICdudWxsJyBpZiBub3Qgbm90IGZvdW5kLlxyXG4gICoqL1xyXG4gIGdldFN0cnVjdHVyYWxUeXBlKHR5cGVOYW1lOiBzdHJpbmcsIG9rSWZOb3RGb3VuZDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICBhc3NlcnRQYXJhbSh0eXBlTmFtZSwgXCJ0eXBlTmFtZVwiKS5pc1N0cmluZygpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShva0lmTm90Rm91bmQsIFwib2tJZk5vdEZvdW5kXCIpLmlzQm9vbGVhbigpLmlzT3B0aW9uYWwoKS5jaGVjayhmYWxzZSk7XHJcbiAgICByZXR1cm4gdGhpcy5fZ2V0U3RydWN0dXJhbFR5cGUodHlwZU5hbWUsIG9rSWZOb3RGb3VuZCk7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfZ2V0U3RydWN0dXJhbFR5cGUodHlwZU5hbWU6IHN0cmluZywgb2tJZk5vdEZvdW5kOiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgIGxldCBxdWFsVHlwZU5hbWUgPSBnZXRRdWFsaWZpZWRUeXBlTmFtZSh0aGlzLCB0eXBlTmFtZSwgZmFsc2UpO1xyXG4gICAgbGV0IHR5cGUgPSB0aGlzLl9zdHJ1Y3R1cmFsVHlwZU1hcFtxdWFsVHlwZU5hbWVdO1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgIGlmIChva0lmTm90Rm91bmQpIHJldHVybiBudWxsO1xyXG4gICAgICBsZXQgbXNnID0gY29yZS5mb3JtYXRTdHJpbmcoXCJVbmFibGUgdG8gbG9jYXRlIGEgJ1R5cGUnIGJ5IHRoZSBuYW1lOiAnJTEnLiBCZSBzdXJlIHRvIGV4ZWN1dGUgYSBxdWVyeSBvciBjYWxsIGZldGNoTWV0YWRhdGEgZmlyc3QuXCIsIHR5cGVOYW1lKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHlwZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlIFtbRW50aXR5VHlwZV1dcyBvciBbW0NvbXBsZXhUeXBlXV1zIGluIHRoaXMgTWV0YWRhdGFTdG9yZS5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXJcclxuICA+ICAgICAgbGV0IGFsbFR5cGVzID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZXMoKTtcclxuICAqKi9cclxuICBnZXRFbnRpdHlUeXBlcygpIHtcclxuICAgIHJldHVybiBnZXRUeXBlc0Zyb21NYXAodGhpcy5fc3RydWN0dXJhbFR5cGVNYXApO1xyXG4gIH1cclxuXHJcbiAgZ2V0SW5jb21wbGV0ZU5hdmlnYXRpb25Qcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIGNvcmUub2JqZWN0TWFwKHRoaXMuX2luY29tcGxldGVUeXBlTWFwLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBmdWxseSBxdWFsaWZpZWQgZW50aXR5VHlwZU5hbWUgZm9yIGEgc3BlY2lmaWVkIHJlc291cmNlIG5hbWUuICBUaGUgcmV2ZXJzZSBvZiB0aGlzIG9wZXJhdGlvblxyXG4gIGNhbiBiZSBvYnRhaW5lZCB2aWEgdGhlICBbW0VudGl0eVR5cGUuZGVmYXVsdFJlc291cmNlTmFtZV1dIHByb3BlcnR5XHJcbiAgKiovXHJcbiAgZ2V0RW50aXR5VHlwZU5hbWVGb3JSZXNvdXJjZU5hbWUocmVzb3VyY2VOYW1lOiBzdHJpbmcpIHtcclxuICAgIGFzc2VydFBhcmFtKHJlc291cmNlTmFtZSwgXCJyZXNvdXJjZU5hbWVcIikuaXNTdHJpbmcoKS5jaGVjaygpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3Jlc291cmNlRW50aXR5VHlwZU1hcFtyZXNvdXJjZU5hbWVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgQXNzb2NpYXRlcyBhIHJlc291cmNlTmFtZSB3aXRoIGFuIGVudGl0eVR5cGUuXHJcblxyXG4gIFRoaXMgbWV0aG9kIGlzIG9ubHkgbmVlZGVkIGluIHRob3NlIGNhc2VzIHdoZXJlIG11bHRpcGxlIHJlc291cmNlcyByZXR1cm4gdGhlIHNhbWVcclxuICBlbnRpdHlUeXBlLiAgSW4gdGhpcyBjYXNlIE1ldGFkYXRhIGRpc2NvdmVyeSB3aWxsIG9ubHkgZGV0ZXJtaW5lIGEgc2luZ2xlIHJlc291cmNlIG5hbWUgZm9yXHJcbiAgZWFjaCBlbnRpdHlUeXBlLlxyXG4gIEBwYXJhbSByZXNvdXJjZU5hbWUgLSBUaGUgcmVzb3VyY2UgbmFtZVxyXG4gIEBwYXJhbSBlbnRpdHlUeXBlT3JOYW1lIC0gSWYgcGFzc2luZyBhIHN0cmluZyBlaXRoZXIgdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9yIGEgc2hvcnQgbmFtZSBtYXkgYmUgdXNlZC4gSWYgYSBzaG9ydCBuYW1lIGlzIHNwZWNpZmllZCBhbmQgbXVsdGlwbGUgdHlwZXMgc2hhcmVcclxuICB0aGF0IHNhbWUgc2hvcnQgbmFtZSBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uIElmIHRoZSBlbnRpdHlUeXBlIGhhcyBub3QgeWV0IGJlZW4gZGlzY292ZXJlZCB0aGVuIGEgZnVsbHkgcXVhbGlmaWVkIG5hbWUgbXVzdCBiZSB1c2VkLlxyXG4gICoqL1xyXG4gIHNldEVudGl0eVR5cGVGb3JSZXNvdXJjZU5hbWUocmVzb3VyY2VOYW1lOiBzdHJpbmcsIGVudGl0eVR5cGVPck5hbWU6IEVudGl0eVR5cGUgfCBzdHJpbmcpIHtcclxuICAgIGFzc2VydFBhcmFtKHJlc291cmNlTmFtZSwgXCJyZXNvdXJjZU5hbWVcIikuaXNTdHJpbmcoKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0oZW50aXR5VHlwZU9yTmFtZSwgXCJlbnRpdHlUeXBlT3JOYW1lXCIpLmlzSW5zdGFuY2VPZihFbnRpdHlUeXBlKS5vcigpLmlzU3RyaW5nKCkuY2hlY2soKTtcclxuXHJcbiAgICBsZXQgZW50aXR5VHlwZU5hbWU6IHN0cmluZztcclxuICAgIGlmIChlbnRpdHlUeXBlT3JOYW1lIGluc3RhbmNlb2YgRW50aXR5VHlwZSkge1xyXG4gICAgICBlbnRpdHlUeXBlTmFtZSA9IGVudGl0eVR5cGVPck5hbWUubmFtZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVudGl0eVR5cGVOYW1lID0gZ2V0UXVhbGlmaWVkVHlwZU5hbWUodGhpcywgZW50aXR5VHlwZU9yTmFtZSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcmVzb3VyY2VFbnRpdHlUeXBlTWFwW3Jlc291cmNlTmFtZV0gPSBlbnRpdHlUeXBlTmFtZTtcclxuICAgIGxldCBlbnRpdHlUeXBlID0gdGhpcy5fZ2V0U3RydWN0dXJhbFR5cGUoZW50aXR5VHlwZU5hbWUsIHRydWUpO1xyXG4gICAgaWYgKGVudGl0eVR5cGUgJiYgZW50aXR5VHlwZSBpbnN0YW5jZW9mIEVudGl0eVR5cGUgJiYgIWVudGl0eVR5cGUuZGVmYXVsdFJlc291cmNlTmFtZSkge1xyXG4gICAgICBlbnRpdHlUeXBlLmRlZmF1bHRSZXNvdXJjZU5hbWUgPSByZXNvdXJjZU5hbWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogX19EZXYgT25seV9fIC0gZm9yIHVzZSB3aGVuIGNyZWF0aW5nIGEgbmV3IE1ldGFkYXRhUGFyc2VyQWRhcHRlciAgKi9cclxuICBzdGF0aWMgcGFyc2VUeXBlTmFtZShlbnRpdHlUeXBlTmFtZTogc3RyaW5nKSB7XHJcbiAgICAvLyBUT0RPOiByZW1vdmVkIFxyXG4gICAgLy8gaWYgKCFlbnRpdHlUeXBlTmFtZSkge1xyXG4gICAgLy8gICByZXR1cm4gbnVsbDtcclxuICAgIC8vIH1cclxuXHJcbiAgICBsZXQgdHlwZVBhcnRzID0gZW50aXR5VHlwZU5hbWUuc3BsaXQoXCI6I1wiKTtcclxuICAgIGlmICh0eXBlUGFydHMubGVuZ3RoID4gMSkge1xyXG4gICAgICByZXR1cm4gTWV0YWRhdGFTdG9yZS5tYWtlVHlwZUhhc2godHlwZVBhcnRzWzBdLCB0eXBlUGFydHNbMV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb3JlLnN0cmluZ1N0YXJ0c1dpdGgoZW50aXR5VHlwZU5hbWUsIE1ldGFkYXRhU3RvcmUuQU5PTlRZUEVfUFJFRklYKSkge1xyXG4gICAgICBsZXQgdHlwZUhhc2ggPSBNZXRhZGF0YVN0b3JlLm1ha2VUeXBlSGFzaChlbnRpdHlUeXBlTmFtZSk7XHJcbiAgICAgICh0eXBlSGFzaCBhcyBhbnkpLmlzQW5vbnltb3VzID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIHR5cGVIYXNoO1xyXG4gICAgfVxyXG4gICAgbGV0IGVudGl0eVR5cGVOYW1lTm9Bc3NlbWJseSA9IGVudGl0eVR5cGVOYW1lLnNwbGl0KFwiLFwiKVswXTtcclxuICAgIHR5cGVQYXJ0cyA9IGVudGl0eVR5cGVOYW1lTm9Bc3NlbWJseS5zcGxpdChcIi5cIik7XHJcbiAgICBpZiAodHlwZVBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgbGV0IHNob3J0TmFtZSA9IHR5cGVQYXJ0c1t0eXBlUGFydHMubGVuZ3RoIC0gMV07XHJcbiAgICAgIGxldCBuYW1lc3BhY2VQYXJ0cyA9IHR5cGVQYXJ0cy5zbGljZSgwLCB0eXBlUGFydHMubGVuZ3RoIC0gMSk7XHJcbiAgICAgIGxldCBucyA9IG5hbWVzcGFjZVBhcnRzLmpvaW4oXCIuXCIpO1xyXG4gICAgICByZXR1cm4gTWV0YWRhdGFTdG9yZS5tYWtlVHlwZUhhc2goc2hvcnROYW1lLCBucyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gTWV0YWRhdGFTdG9yZS5tYWtlVHlwZUhhc2goZW50aXR5VHlwZU5hbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIF9fRGV2IE9ubHlfXyAtIGZvciB1c2Ugd2hlbiBjcmVhdGluZyBhIG5ldyBNZXRhZGF0YVBhcnNlckFkYXB0ZXIgICovXHJcbiAgc3RhdGljIG1ha2VUeXBlSGFzaChzaG9ydE5hbWU6IHN0cmluZywgbnM/OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNob3J0VHlwZU5hbWU6IHNob3J0TmFtZSxcclxuICAgICAgbmFtZXNwYWNlOiBucyxcclxuICAgICAgdHlwZU5hbWU6IHF1YWxpZnlUeXBlTmFtZShzaG9ydE5hbWUsIG5zKVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIHByb3RlY3RlZCBtZXRob2RzXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2NoZWNrRW50aXR5VHlwZShlbnRpdHk6IEVudGl0eSkge1xyXG4gICAgaWYgKGVudGl0eS5lbnRpdHlUeXBlKSByZXR1cm47XHJcbiAgICBsZXQgdHlwZU5hbWUgPSBlbnRpdHkucHJvdG90eXBlLl8kdHlwZU5hbWU7XHJcbiAgICBpZiAoIXR5cGVOYW1lKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZW50aXR5IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLiBTZWUgdGhlIE1ldGFkYXRhU3RvcmUucmVnaXN0ZXJFbnRpdHlUeXBlQ3RvciBtZXRob2RcIik7XHJcbiAgICB9XHJcbiAgICAvLyB3ZSBrbm93IHRoYXQgaXQgaXMgYW4gRW50aXR5VHlwZSAoIGFzIG9wcG9zZWQgdG8gYSBDb21wbGV4VHlwZSlcclxuICAgIGxldCBlbnRpdHlUeXBlID0gdGhpcy5fZ2V0U3RydWN0dXJhbFR5cGUodHlwZU5hbWUpIGFzIEVudGl0eVR5cGU7XHJcbiAgICBpZiAoZW50aXR5VHlwZSkge1xyXG4gICAgICBlbnRpdHkuZW50aXR5VHlwZSA9IGVudGl0eVR5cGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbn1cclxuTWV0YWRhdGFTdG9yZS5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IFwiTWV0YWRhdGFTdG9yZVwiO1xyXG5cclxuQnJlZXplRXZlbnQuYnViYmxlRXZlbnQoTWV0YWRhdGFTdG9yZS5wcm90b3R5cGUpO1xyXG5cclxuZnVuY3Rpb24gZ2V0VHlwZXNGcm9tTWFwKHR5cGVNYXA6IElTdHJ1Y3R1cmFsVHlwZU1hcCkge1xyXG4gIGxldCB0eXBlczogKFN0cnVjdHVyYWxUeXBlKVtdID0gW107XHJcbiAgZm9yIChsZXQga2V5IGluIHR5cGVNYXApIHtcclxuICAgIGxldCB2YWx1ZSA9IHR5cGVNYXBba2V5XTtcclxuICAgIC8vIHNraXAgJ3Nob3J0TmFtZScgZW50cmllc1xyXG4gICAgaWYgKGtleSA9PT0gdmFsdWUubmFtZSkge1xyXG4gICAgICB0eXBlcy5wdXNoKHR5cGVNYXBba2V5XSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0eXBlcztcclxufVxyXG5cclxuZnVuY3Rpb24gc3RydWN0dXJhbFR5cGVGcm9tSnNvbihtZXRhZGF0YVN0b3JlOiBNZXRhZGF0YVN0b3JlLCBqc29uOiBhbnksIGFsbG93TWVyZ2U6IGJvb2xlYW4pIHtcclxuICBsZXQgdHlwZU5hbWUgPSBxdWFsaWZ5VHlwZU5hbWUoanNvbi5zaG9ydE5hbWUsIGpzb24ubmFtZXNwYWNlKTtcclxuICBsZXQgc3R5cGUgPSBtZXRhZGF0YVN0b3JlLl9nZXRTdHJ1Y3R1cmFsVHlwZSh0eXBlTmFtZSwgdHJ1ZSk7XHJcbiAgaWYgKHN0eXBlKSB7XHJcbiAgICBpZiAoYWxsb3dNZXJnZSkge1xyXG4gICAgICByZXR1cm4gbWVyZ2VTdHJ1Y3R1cmFsVHlwZShzdHlwZSwganNvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBhbGxvdyBpdCBidXQgZG9uJ3QgcmVwbGFjZSBhbnl0aGluZy5cclxuICAgICAgcmV0dXJuIHN0eXBlO1xyXG4gICAgfVxyXG4gIH1cclxuICBsZXQgY29uZmlnID0ge1xyXG4gICAgc2hvcnROYW1lOiBqc29uLnNob3J0TmFtZSxcclxuICAgIG5hbWVzcGFjZToganNvbi5uYW1lc3BhY2UsXHJcbiAgICBpc0Fic3RyYWN0OiBqc29uLmlzQWJzdHJhY3QsXHJcbiAgICBhdXRvR2VuZXJhdGVkS2V5VHlwZTogQXV0b0dlbmVyYXRlZEtleVR5cGUuZnJvbU5hbWUoanNvbi5hdXRvR2VuZXJhdGVkS2V5VHlwZSksXHJcbiAgICBkZWZhdWx0UmVzb3VyY2VOYW1lOiBqc29uLmRlZmF1bHRSZXNvdXJjZU5hbWUsXHJcbiAgICBjdXN0b206IGpzb24uY3VzdG9tXHJcbiAgfTtcclxuXHJcbiAgc3R5cGUgPSBqc29uLmlzQ29tcGxleFR5cGUgPyBuZXcgQ29tcGxleFR5cGUoY29uZmlnKSA6IG5ldyBFbnRpdHlUeXBlKGNvbmZpZyk7XHJcblxyXG4gIC8vIGJhc2VUeXBlIG1heSBub3QgaGF2ZSBiZWVuIGltcG9ydGVkIHlldCBzbyB3ZSBuZWVkIHRvIGRlZmVyIGhhbmRsaW5nIHRoaXMgdHlwZSB1bnRpbCBsYXRlci5cclxuICBpZiAoanNvbi5iYXNlVHlwZU5hbWUgJiYgc3R5cGUgaW5zdGFuY2VvZiBFbnRpdHlUeXBlKSB7XHJcbiAgICBzdHlwZS5iYXNlVHlwZU5hbWUgPSBqc29uLmJhc2VUeXBlTmFtZTtcclxuICAgIGxldCBiYXNlRW50aXR5VHlwZSA9IG1ldGFkYXRhU3RvcmUuX2dldFN0cnVjdHVyYWxUeXBlKGpzb24uYmFzZVR5cGVOYW1lLCB0cnVlKTtcclxuICAgIGlmIChiYXNlRW50aXR5VHlwZSkge1xyXG4gICAgICBjb21wbGV0ZVN0cnVjdHVyYWxUeXBlRnJvbUpzb24obWV0YWRhdGFTdG9yZSwganNvbiwgc3R5cGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY29yZS5nZXRBcnJheShtZXRhZGF0YVN0b3JlLl9kZWZlcnJlZFR5cGVzLCBqc29uLmJhc2VUeXBlTmFtZSkucHVzaCh7IGpzb246IGpzb24sIHN0eXBlOiBzdHlwZSB9KTtcclxuXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbXBsZXRlU3RydWN0dXJhbFR5cGVGcm9tSnNvbihtZXRhZGF0YVN0b3JlLCBqc29uLCBzdHlwZSk7XHJcbiAgfVxyXG5cclxuICAvLyBzdHlwZSBtYXkgb3IgbWF5IG5vdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIG1ldGFkYXRhU3RvcmUgYXQgdGhpcyBwb2ludC5cclxuICByZXR1cm4gc3R5cGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlU3RydWN0dXJhbFR5cGUoc3R5cGU6IFN0cnVjdHVyYWxUeXBlLCBqc29uOiBhbnkpIHtcclxuICBpZiAoanNvbi5jdXN0b20pIHtcclxuICAgIHN0eXBlLmN1c3RvbSA9IGpzb24uY3VzdG9tO1xyXG4gIH1cclxuXHJcbiAgbWVyZ2VQcm9wcyhzdHlwZSwganNvbi5kYXRhUHJvcGVydGllcyk7XHJcbiAgbWVyZ2VQcm9wcyhzdHlwZSwganNvbi5uYXZpZ2F0aW9uUHJvcGVydGllcyk7XHJcbiAgcmV0dXJuIHN0eXBlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZVByb3BzKHN0eXBlOiBTdHJ1Y3R1cmFsVHlwZSwganNvblByb3BzOiBhbnlbXSkge1xyXG4gIGlmICghanNvblByb3BzKSByZXR1cm47XHJcbiAganNvblByb3BzLmZvckVhY2goKGpzb25Qcm9wKSA9PiB7XHJcbiAgICBsZXQgcHJvcE5hbWUgPSBqc29uUHJvcC5uYW1lO1xyXG4gICAgaWYgKCFwcm9wTmFtZSkge1xyXG4gICAgICBpZiAoanNvblByb3AubmFtZU9uU2VydmVyKSB7XHJcbiAgICAgICAgcHJvcE5hbWUgPSBzdHlwZS5tZXRhZGF0YVN0b3JlLm5hbWluZ0NvbnZlbnRpb24uc2VydmVyUHJvcGVydHlOYW1lVG9DbGllbnQoanNvblByb3AubmFtZU9uU2VydmVyLCB7fSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gYmFja3NsYXNoLXF1b3RlIHdvcmtzIGFyb3VuZCBjb21waWxlciBidWdcclxuICAgICAgICBjb25zdCBtc2cgPSBcIlVuYWJsZSB0byBjb21wbGV0ZSBcXCdpbXBvcnRNZXRhZGF0YVxcJyAtIGNhbm5vdCBsb2NhdGUgYSBcXCduYW1lXFwnIG9yIFxcJ25hbWVPblNlcnZlclxcJyBmb3Igb25lIG9mIHRoZSBpbXBvcnRlZCBwcm9wZXJ0eSBub2Rlc1wiO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoanNvblByb3AuY3VzdG9tKSB7XHJcbiAgICAgIGxldCBwcm9wID0gc3R5cGUuZ2V0UHJvcGVydHkocHJvcE5hbWUsIHRydWUpO1xyXG4gICAgICBwcm9wIS5jdXN0b20gPSBqc29uUHJvcC5jdXN0b207XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBsZXRlU3RydWN0dXJhbFR5cGVGcm9tSnNvbihtZXRhZGF0YVN0b3JlOiBNZXRhZGF0YVN0b3JlLCBqc29uOiBhbnksIHN0eXBlOiBhbnkpIHtcclxuXHJcbiAgLy8gdmFsaWRhdG9ycyBmcm9tIGJhc2VUeXBlIHdvcmsgYmVjYXVzZSB2YWxpZGF0aW9uIHdhbGtzIHRocnUgYmFzZSB0eXBlc1xyXG4gIC8vIHNvIG5vIG5lZWQgdG8gY29weSBkb3duLlxyXG4gIGlmIChqc29uLnZhbGlkYXRvcnMpIHtcclxuICAgIHN0eXBlLnZhbGlkYXRvcnMgPSBqc29uLnZhbGlkYXRvcnMubWFwKFZhbGlkYXRvci5mcm9tSlNPTik7XHJcbiAgfVxyXG5cclxuICBqc29uLmRhdGFQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKGRwOiBPYmplY3QpIHtcclxuICAgIHN0eXBlLl9hZGRQcm9wZXJ0eUNvcmUoRGF0YVByb3BlcnR5LmZyb21KU09OKGRwKSk7XHJcbiAgfSk7XHJcblxyXG5cclxuICBsZXQgaXNFbnRpdHlUeXBlID0gIWpzb24uaXNDb21wbGV4VHlwZTtcclxuICBpZiAoaXNFbnRpdHlUeXBlKSB7XHJcbiAgICAvL25vaW5zcGVjdGlvbiBKU0hpbnRcclxuICAgIGpzb24ubmF2aWdhdGlvblByb3BlcnRpZXMgJiYganNvbi5uYXZpZ2F0aW9uUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChucDogT2JqZWN0KSB7XHJcbiAgICAgIHN0eXBlLl9hZGRQcm9wZXJ0eUNvcmUoTmF2aWdhdGlvblByb3BlcnR5LmZyb21KU09OKG5wKSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG1ldGFkYXRhU3RvcmUuYWRkRW50aXR5VHlwZShzdHlwZSk7XHJcblxyXG4gIGxldCBkZWZlcnJlZFR5cGVzID0gbWV0YWRhdGFTdG9yZS5fZGVmZXJyZWRUeXBlcztcclxuICBsZXQgZGVmZXJyYWxzID0gZGVmZXJyZWRUeXBlc1tzdHlwZS5uYW1lXTtcclxuICBpZiAoZGVmZXJyYWxzKSB7XHJcbiAgICBkZWZlcnJhbHMuZm9yRWFjaChmdW5jdGlvbiAoZDogYW55KSB7XHJcbiAgICAgIGNvbXBsZXRlU3RydWN0dXJhbFR5cGVGcm9tSnNvbihtZXRhZGF0YVN0b3JlLCBkLmpzb24sIGQuc3R5cGUpO1xyXG4gICAgfSk7XHJcbiAgICBkZWxldGUgZGVmZXJyZWRUeXBlc1tzdHlwZS5uYW1lXTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFF1YWxpZmllZFR5cGVOYW1lKG1ldGFkYXRhU3RvcmU6IE1ldGFkYXRhU3RvcmUsIHN0cnVjdFR5cGVOYW1lOiBzdHJpbmcsIHRocm93SWZOb3RGb3VuZD86IGJvb2xlYW4pIHtcclxuICBpZiAoaXNRdWFsaWZpZWRUeXBlTmFtZShzdHJ1Y3RUeXBlTmFtZSkpIHJldHVybiBzdHJ1Y3RUeXBlTmFtZTtcclxuICBsZXQgcmVzdWx0ID0gbWV0YWRhdGFTdG9yZS5fc2hvcnROYW1lTWFwW3N0cnVjdFR5cGVOYW1lXTtcclxuICBpZiAoIXJlc3VsdCAmJiB0aHJvd0lmTm90Rm91bmQpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBsb2NhdGUgJ2VudGl0eVR5cGVOYW1lJyBvZjogXCIgKyBzdHJ1Y3RUeXBlTmFtZSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKiBDb25maWd1cmF0aW9uIGluZm8gdG8gYmUgcGFzc2VkIHRvIHRoZSBbW0VudGl0eVR5cGVdXSBjb25zdHJ1Y3RvciAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eVR5cGVDb25maWcge1xyXG4gIHNob3J0TmFtZT86IHN0cmluZztcclxuICBuYW1lc3BhY2U/OiBzdHJpbmc7XHJcbiAgYmFzZVR5cGVOYW1lPzogc3RyaW5nO1xyXG4gIGlzQWJzdHJhY3Q/OiBib29sZWFuO1xyXG4gIGF1dG9HZW5lcmF0ZWRLZXlUeXBlPzogQXV0b0dlbmVyYXRlZEtleVR5cGU7XHJcbiAgZGVmYXVsdFJlc291cmNlTmFtZT86IHN0cmluZztcclxuICBkYXRhUHJvcGVydGllcz86IERhdGFQcm9wZXJ0eVtdIHwgT2JqZWN0W10gfCBPYmplY3Q7ICAvLyBUT0RPOiBzZWUgaWYgd2UgY2FuJ3QgcXVhbGlmeSBPYmplY3RbXSBhIGxpdHRsZSBiZXR0ZXIuXHJcbiAgbmF2aWdhdGlvblByb3BlcnRpZXM/OiBOYXZpZ2F0aW9uUHJvcGVydHlbXSB8IE9iamVjdFtdIHwgT2JqZWN0O1xyXG4gIHNlcmlhbGl6ZXJGbj86IChwcm9wOiBFbnRpdHlQcm9wZXJ0eSwgdmFsOiBhbnkpID0+IGFueTtcclxuICBjdXN0b20/OiBPYmplY3Q7XHJcbn1cclxuXHJcbi8qKiBDb25maWd1cmF0aW9uIGluZm8gdG8gYmUgcGFzc2VkIHRvIHRoZSBbW0VudGl0eVR5cGUuc2V0UHJvcGVydGllc11dIG1ldGhvZCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eVR5cGVTZXRDb25maWcge1xyXG4gIGF1dG9HZW5lcmF0ZWRLZXlUeXBlPzogQXV0b0dlbmVyYXRlZEtleVR5cGU7XHJcbiAgZGVmYXVsdFJlc291cmNlTmFtZT86IHN0cmluZztcclxuICBzZXJpYWxpemVyRm4/OiAocHJvcDogRW50aXR5UHJvcGVydHksIHZhbDogYW55KSA9PiBhbnk7XHJcbiAgY3VzdG9tPzogT2JqZWN0O1xyXG59XHJcblxyXG4vKiogQ29udGFpbmVyIGZvciBhbGwgb2YgdGhlIG1ldGFkYXRhIGFib3V0IGEgc3BlY2lmaWMgdHlwZSBvZiBFbnRpdHkuXHJcbioqL1xyXG5leHBvcnQgY2xhc3MgRW50aXR5VHlwZSB7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgXyR0eXBlTmFtZTogc3RyaW5nOyAvLyBvbiBwcm90b1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXRpYyBfX25leHRBbm9uSXggPSAwO1xyXG4gIC8qKiBBbHdheXMgZmFsc2UgZm9yIGFuIEVudGl0eVR5cGUuICoqL1xyXG4gIGlzQ29tcGxleFR5cGUgPSBmYWxzZTtcclxuICAvKiogVGhlIFtbTWV0YWRhdGFTdG9yZV1dIHRoYXQgY29udGFpbnMgdGhpcyBFbnRpdHlUeXBlLiBfX1JlYWQgT25seV9fICoqL1xyXG4gIG1ldGFkYXRhU3RvcmU6IE1ldGFkYXRhU3RvcmU7XHJcbiAgLyoqIFRoZSBEYXRhUHJvcGVydGllcyAoc2VlIFtbRGF0YVByb3BlcnR5XV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5VHlwZS4gX19SZWFkIE9ubHlfXyAgKiovXHJcbiAgZGF0YVByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG4gIC8qKiAgVGhlIE5hdmlnYXRpb25Qcm9wZXJ0aWVzIChzZWUgW1tOYXZpZ2F0aW9uUHJvcGVydHldXSBhc3NvY2lhdGVkIHdpdGggdGhpcyBFbnRpdHlUeXBlLiBfX1JlYWQgT25seV9fICAqKi9cclxuICBuYXZpZ2F0aW9uUHJvcGVydGllczogTmF2aWdhdGlvblByb3BlcnR5W107XHJcbiAgLyoqXHJcbiAgVGhlIERhdGFQcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eVR5cGUgdGhhdCBtYWtlIHVwIGl0J3MgW1tFbnRpdHlLZXldXS4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBrZXlQcm9wZXJ0aWVzOiBEYXRhUHJvcGVydHlbXTtcclxuICAvKiogVGhlIERhdGFQcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eVR5cGUgdGhhdCBhcmUgZm9yZWlnbiBrZXkgcHJvcGVydGllcy4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBmb3JlaWduS2V5UHJvcGVydGllczogRGF0YVByb3BlcnR5W107XHJcbiAgaW52ZXJzZUZvcmVpZ25LZXlQcm9wZXJ0aWVzOiBEYXRhUHJvcGVydHlbXTtcclxuICAvKiogIFRoZSBEYXRhUHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBFbnRpdHlUeXBlIHRoYXQgYXJlIGNvbmN1cnJlbmN5IHByb3BlcnRpZXMuIF9fUmVhZCBPbmx5X18gKiovXHJcbiAgY29uY3VycmVuY3lQcm9wZXJ0aWVzOiBEYXRhUHJvcGVydHlbXTtcclxuICAvKiogVGhlIERhdGFQcm9wZXJ0aWVzIGZvciB0aGlzIEVudGl0eVR5cGUgdGhhdCBjb250YWluIGluc3RhbmNlcyBvZiBhIFtbQ29tcGxleFR5cGVdXS4gX19SZWFkIE9ubHlfXyAgICoqL1xyXG4gIGNvbXBsZXhQcm9wZXJ0aWVzOiBEYXRhUHJvcGVydHlbXTtcclxuICAvKiogVGhlIERhdGFQcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eVR5cGUgdGhhdCBhcmUgbm90IG1hcHBlZCB0byBhbnkgYmFja2VuZCBkYXRhc3RvcmUuIFRoZXNlIGFyZSBlZmZlY3RpdmVseSBmcmVlIHN0YW5kaW5nXHJcbiAgcHJvcGVydGllcy4gX19SZWFkIE9ubHlfXyAqKi9cclxuICB1bm1hcHBlZFByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG5cclxuICAvKiogVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoaXMgRW50aXR5VHlwZS4gX19SZWFkIE9ubHlfXyAgKiovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgc2hvcnQsIHVucXVhbGlmaWVkLCBuYW1lIGZvciB0aGlzIEVudGl0eVR5cGUuIF9fUmVhZCBPbmx5X18gICoqL1xyXG4gIHNob3J0TmFtZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgbmFtZXNwYWNlIGZvciB0aGlzIEVudGl0eVR5cGUuIF9fUmVhZCBPbmx5X18gICoqL1xyXG4gIG5hbWVzcGFjZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgbmFtZSBvZiB0aGlzIEVudGl0eVR5cGUncyBiYXNlIEVudGl0eVR5cGUgIChpZiBhbnkpICovXHJcbiAgYmFzZVR5cGVOYW1lPzogc3RyaW5nO1xyXG4gIC8qKiBUaGUgYmFzZSBFbnRpdHlUeXBlIChpZiBhbnkpIGZvciB0aGlzIEVudGl0eVR5cGUuIF9fUmVhZCBPbmx5X18gICAqKi9cclxuICBiYXNlRW50aXR5VHlwZTogRW50aXR5VHlwZTtcclxuICBzdWJ0eXBlczogRW50aXR5VHlwZVtdO1xyXG5cclxuICAvKiogIFdoZXRoZXIgdGhpcyBFbnRpdHlUeXBlIGlzIGFic3RyYWN0LiBfX1JlYWQgT25seV9fICoqL1xyXG4gIGlzQWJzdHJhY3Q6IGJvb2xlYW47XHJcbiAgLyoqICBXaGV0aGVyIHRoaXMgRW50aXR5VHlwZSBpcyBhbm9ueW1vdXMuIEFub255bW91cyB0eXBlcyB3aWxsIG5ldmVyIGJlIGNvbW11bmljYXRlZCB0byBvciBmcm9tIHRoZSBzZXJ2ZXIuIFRoZXkgYXJlIHB1cmVseSBmb3JcclxuICBjbGllbnQgc2lkZSB1c2UgYW5kIGFyZSBnaXZlbiBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBuYW1lLiAgX19SZWFkIE9ubHlfXyAqKi9cclxuICBpc0Fub255bW91czogYm9vbGVhbjtcclxuICAvKiogV2hldGhlciB0aGlzIEVudGl0eVR5cGUgaGFzIGJlZW4gJ2Zyb3plbicuICBFbnRpdHlUeXBlcyBiZWNvbWUgZnJvemVuIGFmdGVyIHRoZSBmaXJzdCBpbnN0YW5jZSBcclxuICBvZiB0aGF0IHR5cGUgaGFzIGJlZW4gY3JlYXRlZCBhbmQgYXR0YWNoZWQgdG8gYW4gRW50aXR5TWFuYWdlci4gKi9cclxuICBpc0Zyb3plbjogYm9vbGVhbjtcclxuXHJcbiAgLyoqIFRoZSBbW0F1dG9HZW5lcmF0ZWRLZXlUeXBlXV0gZm9yIHRoaXMgRW50aXR5VHlwZS4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBhdXRvR2VuZXJhdGVkS2V5VHlwZTogQXV0b0dlbmVyYXRlZEtleVR5cGU7XHJcbiAgLyoqICAgVGhlIGRlZmF1bHQgcmVzb3VyY2UgbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBFbnRpdHlUeXBlLiAgQW4gRW50aXR5VHlwZSBtYXkgYmUgcXVlcmllZCB2aWEgYSB2YXJpZXR5IG9mICdyZXNvdXJjZSBuYW1lcycgYnV0IHRoaXMgb25lXHJcbiAgaXMgdXNlZCBhcyB0aGUgZGVmYXVsdCB3aGVuIG5vIHJlc291cmNlIG5hbWUgaXMgcHJvdmlkZWQuICBUaGlzIHdpbGwgb2NjdXIgd2hlbiBjYWxsaW5nIFtbRW50aXR5QXNwZWN0LmxvYWROYXZpZ2F0aW9uUHJvcGVydHldXVxyXG4gIG9yIHdoZW4gZXhlY3V0aW5nIGFueSBbW0VudGl0eVF1ZXJ5XV0gdGhhdCB3YXMgY3JlYXRlZCB2aWEgYW4gW1tFbnRpdHlLZXldXS4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBkZWZhdWx0UmVzb3VyY2VOYW1lOiBzdHJpbmc7XHJcbiAgLyoqIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgc2VyaWFsaXphdGlvbiBvZiBhbnkgRW50aXR5UHJvcGVydGllcyBvZiB0aGlzIHR5cGUuICovXHJcbiAgc2VyaWFsaXplckZuPzogKHByb3A6IEVudGl0eVByb3BlcnR5LCB2YWw6IGFueSkgPT4gYW55O1xyXG4gIC8qKiAgQSBmcmVlIGZvcm0gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGFueSBjdXN0b20gbWV0YWRhdGEgZm9yIHRoaXMgRW50aXR5VHlwZS4gX19SZWFkIE9ubHlfXyAgKiovXHJcbiAgY3VzdG9tPzogT2JqZWN0O1xyXG4gIC8qKiBUaGUgZW50aXR5IGxldmVsIHZhbGlkYXRvcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5VHlwZS4gVmFsaWRhdG9ycyBjYW4gYmUgYWRkZWQgYW5kXHJcbiAgcmVtb3ZlZCBmcm9tIHRoaXMgY29sbGVjdGlvbi4gX19SZWFkIE9ubHlfXy4gICAqKi9cclxuICB2YWxpZGF0b3JzOiBWYWxpZGF0b3JbXTtcclxuXHJcbiAgd2FybmluZ3M6IGFueVtdO1xyXG4gIGluaXRGbjogRnVuY3Rpb24gfCBzdHJpbmc7XHJcbiAgbm9UcmFja2luZ0ZuOiBGdW5jdGlvbjtcclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2V4dHJhOiBhbnk7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2N0b3I6IHsgbmV3ICgpOiBTdHJ1Y3R1cmFsT2JqZWN0IH07XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX21hcHBlZFByb3BlcnRpZXNDb3VudDogbnVtYmVyO1xyXG5cclxuICAvKiogXHJcbiAgQGRlcHJlY2F0ZWQgVXNlIFtbZ2V0Q3Rvcl1dIGluc3RlYWQuICAgXHJcbiAgKi9cclxuICBnZXRFbnRpdHlDdG9yID0gdGhpcy5nZXRDdG9yO1xyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgcXVhbGlmeVR5cGVOYW1lID0gcXVhbGlmeVR5cGVOYW1lO1xyXG5cclxuXHJcbiAgLyoqIEVudGl0eVR5cGUgY29uc3RydWN0b3IgIFxyXG4gID4gICAgICBsZXQgZW50aXR5VHlwZSA9IG5ldyBFbnRpdHlUeXBlKCB7XHJcbiAgPiAgICAgICAgICBzaG9ydE5hbWU6IFwicGVyc29uXCIsXHJcbiAgPiAgICAgICAgICBuYW1lc3BhY2U6IFwibXlBcHBOYW1lc3BhY2VcIlxyXG4gID4gICAgICB9KTtcclxuICBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBzZXR0aW5ncyBvciBhIE1ldGFkYXRhU3RvcmUuICBJZiB0aGlzIHBhcmFtZXRlciBpcyBqdXN0IGEgTWV0YWRhdGFTdG9yZVxyXG4gIHRoZW4gd2hhdCB3aWxsIGJlIGNyZWF0ZWQgaXMgYW4gJ2Fub255bW91cycgdHlwZSB0aGF0IHdpbGwgbmV2ZXIgYmUgY29tbXVuaWNhdGVkIHRvIG9yIGZyb20gdGhlIHNlcnZlci4gSXQgaXMgcHVyZWx5IGZvclxyXG4gIGNsaWVudCBzaWRlIHVzZSBhbmQgd2lsbCBiZSBnaXZlbiBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBuYW1lLiBOb3JtYWxseSwgaG93ZXZlciwgeW91IHdpbGwgdXNlIGEgY29uZmlndXJhdGlvbiBvYmplY3QuXHJcbiAgKiovXHJcbiAgY29uc3RydWN0b3IoY29uZmlnOiBNZXRhZGF0YVN0b3JlIHwgRW50aXR5VHlwZUNvbmZpZykge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBFbnRpdHlUeXBlIGN0b3IgaGFzIGEgc2luZ2xlIGFyZ3VtZW50IHRoYXQgaXMgZWl0aGVyIGEgJ01ldGFkYXRhU3RvcmUnIG9yIGEgY29uZmlndXJhdGlvbiBvYmplY3QuXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gbGV0IGV0Q29uZmlnID0gIDxFbnRpdHlUeXBlQ29uZmlnPiA8YW55PiB1bmRlZmluZWQ7XHJcbiAgICBsZXQgZXRDb25maWc6IEVudGl0eVR5cGVDb25maWcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKChjb25maWcgYXMgYW55KS5fJHR5cGVOYW1lID09PSBcIk1ldGFkYXRhU3RvcmVcIikge1xyXG4gICAgICB0aGlzLm1ldGFkYXRhU3RvcmUgPSBjb25maWcgYXMgTWV0YWRhdGFTdG9yZTtcclxuICAgICAgdGhpcy5zaG9ydE5hbWUgPSBcIkFub25fXCIgKyAoKytFbnRpdHlUeXBlLl9fbmV4dEFub25JeCk7XHJcbiAgICAgIHRoaXMubmFtZXNwYWNlID0gXCJcIjtcclxuICAgICAgdGhpcy5pc0Fub255bW91cyA9IHRydWU7XHJcbiAgICAgIC8vIGV0Q29uZmlnID0gdW5kZWZpbmVkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXRDb25maWcgPSBjb25maWcgYXMgRW50aXR5VHlwZUNvbmZpZztcclxuICAgICAgYXNzZXJ0Q29uZmlnKGNvbmZpZylcclxuICAgICAgICAud2hlcmVQYXJhbShcInNob3J0TmFtZVwiKS5pc05vbkVtcHR5U3RyaW5nKClcclxuICAgICAgICAud2hlcmVQYXJhbShcIm5hbWVzcGFjZVwiKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChcIlwiKVxyXG4gICAgICAgIC53aGVyZVBhcmFtKFwiYmFzZVR5cGVOYW1lXCIpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgICAgLndoZXJlUGFyYW0oXCJpc0Fic3RyYWN0XCIpLmlzQm9vbGVhbigpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChmYWxzZSlcclxuICAgICAgICAud2hlcmVQYXJhbShcImF1dG9HZW5lcmF0ZWRLZXlUeXBlXCIpLmlzRW51bU9mKEF1dG9HZW5lcmF0ZWRLZXlUeXBlKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQoQXV0b0dlbmVyYXRlZEtleVR5cGUuTm9uZSlcclxuICAgICAgICAud2hlcmVQYXJhbShcImRlZmF1bHRSZXNvdXJjZU5hbWVcIikuaXNOb25FbXB0eVN0cmluZygpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChudWxsKVxyXG4gICAgICAgIC53aGVyZVBhcmFtKFwiZGF0YVByb3BlcnRpZXNcIikuaXNPcHRpb25hbCgpXHJcbiAgICAgICAgLndoZXJlUGFyYW0oXCJuYXZpZ2F0aW9uUHJvcGVydGllc1wiKS5pc09wdGlvbmFsKClcclxuICAgICAgICAud2hlcmVQYXJhbShcInNlcmlhbGl6ZXJGblwiKS5pc09wdGlvbmFsKCkuaXNGdW5jdGlvbigpXHJcbiAgICAgICAgLndoZXJlUGFyYW0oXCJjdXN0b21cIikuaXNPcHRpb25hbCgpXHJcbiAgICAgICAgLmFwcGx5QWxsKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubmFtZSA9IHF1YWxpZnlUeXBlTmFtZSh0aGlzLnNob3J0TmFtZSwgdGhpcy5uYW1lc3BhY2UpO1xyXG5cclxuICAgIC8vIHRoZSBkZWZhdWx0UmVzb3VyY2VOYW1lIG1heSBhbHNvIGJlIHNldCB1cCBlaXRoZXIgdmlhIG1ldGFkYXRhIGxvb2t1cCBvciBmaXJzdCBxdWVyeSBvciB2aWEgdGhlICdzZXRQcm9wZXJ0aWVzJyBtZXRob2RcclxuICAgIHRoaXMuZGF0YVByb3BlcnRpZXMgPSBbXTtcclxuICAgIHRoaXMubmF2aWdhdGlvblByb3BlcnRpZXMgPSBbXTtcclxuICAgIHRoaXMuY29tcGxleFByb3BlcnRpZXMgPSBbXTtcclxuICAgIHRoaXMua2V5UHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy5mb3JlaWduS2V5UHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy5pbnZlcnNlRm9yZWlnbktleVByb3BlcnRpZXMgPSBbXTtcclxuICAgIHRoaXMuY29uY3VycmVuY3lQcm9wZXJ0aWVzID0gW107XHJcbiAgICB0aGlzLnVubWFwcGVkUHJvcGVydGllcyA9IFtdOyAvLyB3aWxsIGJlIHVwZGF0ZWQgbGF0ZXIuXHJcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSBbXTtcclxuICAgIHRoaXMud2FybmluZ3MgPSBbXTtcclxuICAgIHRoaXMuX21hcHBlZFByb3BlcnRpZXNDb3VudCA9IDA7XHJcbiAgICB0aGlzLnN1YnR5cGVzID0gW107XHJcbiAgICAvLyBub3cgcHJvY2VzcyBhbnkgZGF0YS9uYXYgcHJvcHNcclxuICAgIGlmIChldENvbmZpZyAmJiBldENvbmZpZy5kYXRhUHJvcGVydGllcykge1xyXG4gICAgICBhZGRQcm9wZXJ0aWVzKHRoaXMsIGV0Q29uZmlnLmRhdGFQcm9wZXJ0aWVzLCBEYXRhUHJvcGVydHkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGV0Q29uZmlnICYmIGV0Q29uZmlnLm5hdmlnYXRpb25Qcm9wZXJ0aWVzKSB7XHJcbiAgICAgIGFkZFByb3BlcnRpZXModGhpcywgZXRDb25maWcubmF2aWdhdGlvblByb3BlcnRpZXMsIE5hdmlnYXRpb25Qcm9wZXJ0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBHZW5lcmFsIHB1cnBvc2UgcHJvcGVydHkgc2V0IG1ldGhvZFxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXIgY29udGFpbmluZyBhIG51bWJlciBvZiBleGlzdGluZyBlbnRpdGllcy5cclxuICA+ICAgICAgbGV0IGN1c3RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkN1c3RvbWVyXCIpO1xyXG4gID4gICAgICBjdXN0VHlwZS5zZXRQcm9wZXJ0aWVzKCB7XHJcbiAgPiAgICAgICAgICBhdXRvR2VuZXJhdGVkS2V5VHlwZTogQXV0b0dlbmVyYXRlZEtleVR5cGUuSWRlbnRpdHk7XHJcbiAgPiAgICAgICAgICBkZWZhdWx0UmVzb3VyY2VOYW1lOiBcIkN1c3RvbWVyc0FuZEluY2x1ZGVkT3JkZXJzXCJcclxuICA+ICAgICAgKX07XHJcbiAgQHBhcmFtIGNvbmZpZyAtIGEgY29uZmlndXJhdGlvbiBvYmplY3RcclxuICAqKi9cclxuICBzZXRQcm9wZXJ0aWVzKGNvbmZpZzogRW50aXR5VHlwZVNldENvbmZpZykge1xyXG4gICAgYXNzZXJ0Q29uZmlnKGNvbmZpZylcclxuICAgICAgLndoZXJlUGFyYW0oXCJhdXRvR2VuZXJhdGVkS2V5VHlwZVwiKS5pc0VudW1PZihBdXRvR2VuZXJhdGVkS2V5VHlwZSkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZGVmYXVsdFJlc291cmNlTmFtZVwiKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcInNlcmlhbGl6ZXJGblwiKS5pc0Z1bmN0aW9uKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiY3VzdG9tXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAuYXBwbHlBbGwodGhpcyk7XHJcbiAgICBpZiAoY29uZmlnLmRlZmF1bHRSZXNvdXJjZU5hbWUpIHtcclxuICAgICAgdGhpcy5kZWZhdWx0UmVzb3VyY2VOYW1lID0gY29uZmlnLmRlZmF1bHRSZXNvdXJjZU5hbWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIHdoZXRoZXIgdGhpcyB0eXBlIGlzIGEgc3VidHlwZSBvZiBhIHNwZWNpZmllZCB0eXBlLlxyXG4gICoqL1xyXG4gIGlzU3VidHlwZU9mKGVudGl0eVR5cGU6IEVudGl0eVR5cGUpIHtcclxuICAgIGFzc2VydFBhcmFtKGVudGl0eVR5cGUsIFwiZW50aXR5VHlwZVwiKS5pc0luc3RhbmNlT2YoRW50aXR5VHlwZSkuY2hlY2soKTtcclxuICAgIGxldCBiYXNlVHlwZTogRW50aXR5VHlwZSA9IHRoaXM7XHJcbiAgICBkbyB7XHJcbiAgICAgIGlmIChiYXNlVHlwZSA9PT0gZW50aXR5VHlwZSkgcmV0dXJuIHRydWU7XHJcbiAgICAgIGJhc2VUeXBlID0gYmFzZVR5cGUuYmFzZUVudGl0eVR5cGU7XHJcbiAgICB9IHdoaWxlIChiYXNlVHlwZSk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhpcyB0eXBlIGFuZCBhbnkvYWxsIHN1YnR5cGVzIG9mIHRoaXMgdHlwZSBkb3duIHRocnUgdGhlIGhpZXJhcmNoeS5cclxuICAqKi9cclxuICBnZXRTZWxmQW5kU3VidHlwZXMoKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gW3RoaXNdO1xyXG4gICAgdGhpcy5zdWJ0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdCkge1xyXG4gICAgICBsZXQgc3VidHlwZXMgPSBzdC5nZXRTZWxmQW5kU3VidHlwZXMoKTtcclxuICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBzdWJ0eXBlcyk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBnZXRBbGxWYWxpZGF0b3JzKCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IHRoaXMudmFsaWRhdG9ycy5zbGljZSgwKTtcclxuICAgIGxldCBidCA9IHRoaXMuYmFzZUVudGl0eVR5cGU7XHJcbiAgICB3aGlsZSAoYnQpIHtcclxuICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBidC52YWxpZGF0b3JzKTtcclxuICAgICAgYnQgPSBidC5iYXNlRW50aXR5VHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBBZGRzIGEgIFtbRGF0YVByb3BlcnR5XV0gb3IgYSBbW05hdmlnYXRpb25Qcm9wZXJ0eV1dIHRvIHRoaXMgRW50aXR5VHlwZS5cclxuICA+ICAgICAgLy8gYXNzdW1lIG15RW50aXR5VHlwZSBpcyBhIG5ld2x5IGNvbnN0cnVjdGVkIEVudGl0eVR5cGUuXHJcbiAgPiAgICAgIG15RW50aXR5VHlwZS5hZGRQcm9wZXJ0eShkYXRhUHJvcGVydHkxKTtcclxuICA+ICAgICAgbXlFbnRpdHlUeXBlLmFkZFByb3BlcnR5KGRhdGFQcm9wZXJ0eTIpO1xyXG4gID4gICAgICBteUVudGl0eVR5cGUuYWRkUHJvcGVydHkobmF2aWdhdGlvblByb3BlcnR5MSk7XHJcbiAgKiovXHJcbiAgYWRkUHJvcGVydHkocHJvcGVydHk6IEVudGl0eVByb3BlcnR5KSB7XHJcbiAgICBhc3NlcnRQYXJhbShwcm9wZXJ0eSwgXCJwcm9wZXJ0eVwiKS5pc0luc3RhbmNlT2YoRGF0YVByb3BlcnR5KS5vcigpLmlzSW5zdGFuY2VPZihOYXZpZ2F0aW9uUHJvcGVydHkpLmNoZWNrKCk7XHJcblxyXG4gICAgLy8gdHJ1ZSBpcyAybmQgYXJnIHRvIGZvcmNlIHJlc29sdmUgb2YgYW55IG5hdmlnYXRpb24gcHJvcGVydGllcy5cclxuICAgIGxldCBuZXdwcm9wID0gdGhpcy5fYWRkUHJvcGVydHlDb3JlKHByb3BlcnR5LCB0cnVlKTtcclxuXHJcbiAgICBpZiAodGhpcy5zdWJ0eXBlcyAmJiB0aGlzLnN1YnR5cGVzLmxlbmd0aCkge1xyXG4gICAgICBsZXQgc3R5cGUgPSB0aGlzO1xyXG4gICAgICBzdHlwZS5nZXRTZWxmQW5kU3VidHlwZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdCkge1xyXG4gICAgICAgIGlmIChzdCAhPT0gc3R5cGUpIHtcclxuICAgICAgICAgIGlmIChwcm9wZXJ0eS5pc05hdmlnYXRpb25Qcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICBzdC5fYWRkUHJvcGVydHlDb3JlKG5ldyBOYXZpZ2F0aW9uUHJvcGVydHkocHJvcGVydHkpLCB0cnVlKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0Ll9hZGRQcm9wZXJ0eUNvcmUobmV3IERhdGFQcm9wZXJ0eShwcm9wZXJ0eSBhcyBEYXRhUHJvcGVydHkpLCB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld3Byb3A7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfdXBkYXRlRnJvbUJhc2UoYmFzZUVudGl0eVR5cGU6IEVudGl0eVR5cGUpIHtcclxuICAgIHRoaXMuYmFzZUVudGl0eVR5cGUgPSBiYXNlRW50aXR5VHlwZTtcclxuICAgIGlmICh0aGlzLmF1dG9HZW5lcmF0ZWRLZXlUeXBlID09PSBBdXRvR2VuZXJhdGVkS2V5VHlwZS5Ob25lKSB7XHJcbiAgICAgIHRoaXMuYXV0b0dlbmVyYXRlZEtleVR5cGUgPSBiYXNlRW50aXR5VHlwZS5hdXRvR2VuZXJhdGVkS2V5VHlwZTtcclxuICAgIH1cclxuXHJcbiAgICBiYXNlRW50aXR5VHlwZS5kYXRhUHJvcGVydGllcy5mb3JFYWNoKChkcCkgPT4ge1xyXG4gICAgICBsZXQgbmV3RHAgPSBuZXcgRGF0YVByb3BlcnR5KGRwKTtcclxuICAgICAgLy8gZG9uJ3QgbmVlZCB0byBjb3B5IHZhbGlkYXRvcnMgYmVjYXVlIHdlIHdpbGwgd2FsayB0aGUgaGllcmFyY2h5IHRvIGZpbmQgdGhlbVxyXG4gICAgICBuZXdEcC52YWxpZGF0b3JzID0gW107XHJcbiAgICAgIG5ld0RwLmJhc2VQcm9wZXJ0eSA9IGRwO1xyXG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUNvcmUobmV3RHApO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBiYXNlRW50aXR5VHlwZS5uYXZpZ2F0aW9uUHJvcGVydGllcy5mb3JFYWNoKChucCkgPT4ge1xyXG4gICAgICBsZXQgbmV3TnAgPSBuZXcgTmF2aWdhdGlvblByb3BlcnR5KG5wKTtcclxuICAgICAgLy8gZG9uJ3QgbmVlZCB0byBjb3B5IHZhbGlkYXRvcnMgYmVjYXVlIHdlIHdpbGwgd2FsayB0aGUgaGllcmFyY2h5IHRvIGZpbmQgdGhlbVxyXG4gICAgICBuZXdOcC52YWxpZGF0b3JzID0gW107XHJcbiAgICAgIG5ld05wLmJhc2VQcm9wZXJ0eSA9IG5wO1xyXG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUNvcmUobmV3TnApO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBiYXNlRW50aXR5VHlwZS5zdWJ0eXBlcy5wdXNoKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2FkZFByb3BlcnR5Q29yZShwcm9wZXJ0eTogRW50aXR5UHJvcGVydHksIHNob3VsZFJlc29sdmU6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgaWYgKHRoaXMuaXNGcm96ZW4pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdcIiArIHRoaXMubmFtZSArIFwiJyBFbnRpdHlUeXBlL0NvbXBsZXhUeXBlIGhhcyBiZWVuIGZyb3plbi4gWW91IGNhbiBvbmx5IGFkZCBwcm9wZXJ0aWVzIHRvIGFuIEVudGl0eVR5cGUvQ29tcGxleFR5cGUgYmVmb3JlIGFueSBpbnN0YW5jZXMgb2YgdGhhdCB0eXBlIGhhdmUgYmVlbiBjcmVhdGVkIGFuZCBhdHRhY2hlZCB0byBhbiBlbnRpdHlNYW5hZ2VyLlwiKTtcclxuICAgIH1cclxuICAgIGxldCBwYXJlbnRUeXBlID0gcHJvcGVydHkucGFyZW50VHlwZTtcclxuICAgIGlmIChwYXJlbnRUeXBlKSB7XHJcbiAgICAgIGlmIChwYXJlbnRUeXBlICE9PSB0aGlzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBwcm9wZXJ0eTogXCIgKyBwcm9wZXJ0eS5uYW1lICsgXCIgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byBcIiArIHByb3BlcnR5LnBhcmVudFR5cGUubmFtZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gYWRkaW5nIHRoZSBzYW1lIHByb3BlcnR5IG1vcmUgdGhhbiBvbmNlIHRvIHRoZSBzYW1lIGVudGl0eVR5cGUgaXMganVzdCBpZ25vcmVkLlxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvcGVydHkucGFyZW50VHlwZSA9IHRoaXM7XHJcbiAgICBsZXQgbXMgPSB0aGlzLm1ldGFkYXRhU3RvcmU7XHJcbiAgICAvLyBpZiAocHJvcGVydHkuaXNEYXRhUHJvcGVydHkpIHsgLy8gbW9kaWZpZWQgYmVjYXVzZSBkb2Vzbid0IGFjdCBhcyBhIHR5cGUgZ3VhcmQgXHJcbiAgICBpZiAocHJvcGVydHkgaW5zdGFuY2VvZiBEYXRhUHJvcGVydHkpIHtcclxuICAgICAgdGhpcy5fYWRkRGF0YVByb3BlcnR5KHByb3BlcnR5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2FkZE5hdmlnYXRpb25Qcm9wZXJ0eShwcm9wZXJ0eSk7XHJcbiAgICAgIC8vIG1ldGFkYXRhU3RvcmUgY2FuIGJlIHVuZGVmaW5lZCBpZiB0aGlzIGVudGl0eVR5cGUgaGFzIG5vdCB5ZXQgYmVlbiBhZGRlZCB0byBhIE1ldGFkYXRhU3RvcmUuXHJcbiAgICAgIGlmIChzaG91bGRSZXNvbHZlICYmIG1zKSB7XHJcbiAgICAgICAgdHJ5UmVzb2x2ZU5wKHByb3BlcnR5LCBtcyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHVubWFwcGVkIHByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIEFGVEVSIGVudGl0eVR5cGUgaGFzIGFscmVhZHkgcmVzb2x2ZWQgYWxsIHByb3BlcnR5IG5hbWVzLlxyXG4gICAgaWYgKG1zICYmICEocHJvcGVydHkubmFtZSAmJiBwcm9wZXJ0eS5uYW1lT25TZXJ2ZXIpKSB7XHJcbiAgICAgIHVwZGF0ZUNsaWVudFNlcnZlck5hbWVzKG1zLm5hbWluZ0NvbnZlbnRpb24sIHByb3BlcnR5LCBcIm5hbWVcIik7XHJcbiAgICB9XHJcbiAgICAvLyBwcm9wcyBjYW4gYmUgYWRkZWQgYWZ0ZXIgZW50aXR5IHByb3RvdHlwZSBoYXMgYWxyZWFkeSBiZWVuIHdyYXBwZWQuXHJcbiAgICBpZiAobXMgJiYgdGhpcy5fZXh0cmEpIHtcclxuICAgICAgaWYgKHRoaXMuX2V4dHJhLmFscmVhZHlXcmFwcGVkUHJvcHMpIHtcclxuICAgICAgICBsZXQgcHJvdG8gPSB0aGlzLl9jdG9yLnByb3RvdHlwZTtcclxuICAgICAgICBjb25maWcuaW50ZXJmYWNlUmVnaXN0cnkubW9kZWxMaWJyYXJ5LmdldERlZmF1bHRJbnN0YW5jZSgpLmluaXRpYWxpemVFbnRpdHlQcm90b3R5cGUocHJvdG8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBDcmVhdGUgYSBuZXcgZW50aXR5IG9mIHRoaXMgdHlwZS5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEFzRW50aXR5VHlwZShcIkN1c3RvbWVyXCIpO1xyXG4gID4gICAgICBsZXQgY3VzdDEgPSBjdXN0VHlwZS5jcmVhdGVFbnRpdHkoKTtcclxuICA+ICAgICAgZW0xLmFkZEVudGl0eShjdXN0MSk7XHJcbiAgQHBhcmFtIGluaXRpYWxWYWx1ZXMtIENvbmZpZ3VyYXRpb24gb2JqZWN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRvIHNldCBpbW1lZGlhdGVseSBhZnRlciBjcmVhdGlvbi5cclxuICBAcmV0dXJuIFRoZSBuZXcgZW50aXR5LlxyXG4gICoqL1xyXG4gIGNyZWF0ZUVudGl0eShpbml0aWFsVmFsdWVzPzogYW55KTogYW55IHtcclxuICAgIC8vIGlnbm9yZSB0aGUgXyRlcmVmIG9uY2UgdGhlIGVudGl0eSBpcyBhdHRhY2hlZCB0byBhbiBlbnRpdHlNYW5hZ2VyLlxyXG4gICAgaWYgKGluaXRpYWxWYWx1ZXMgJiYgaW5pdGlhbFZhbHVlcy5fJGVyZWYgJiYgIWluaXRpYWxWYWx1ZXMuXyRlcmVmLmVudGl0eUFzcGVjdC5lbnRpdHlNYW5hZ2VyKSByZXR1cm4gaW5pdGlhbFZhbHVlcy5fJGVyZWY7XHJcblxyXG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5fY3JlYXRlSW5zdGFuY2VDb3JlKCk7XHJcblxyXG4gICAgaWYgKGluaXRpYWxWYWx1ZXMpIHtcclxuICAgICAgLy8gb25seSBhc3NpZ24gYW4gX2VyZWYgaWYgdGhlIG9iamVjdCBpcyBmdWxseSBcImtleWVkXCJcclxuICAgICAgaWYgKHRoaXMua2V5UHJvcGVydGllcy5ldmVyeShmdW5jdGlvbiAoa3ApIHtcclxuICAgICAgICByZXR1cm4gaW5pdGlhbFZhbHVlc1trcC5uYW1lXSAhPSBudWxsO1xyXG4gICAgICB9KSkge1xyXG4gICAgICAgIGluaXRpYWxWYWx1ZXMuXyRlcmVmID0gaW5zdGFuY2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3VwZGF0ZVRhcmdldEZyb21SYXcoaW5zdGFuY2UsIGluaXRpYWxWYWx1ZXMsIGdldFJhd1ZhbHVlRnJvbUNvbmZpZyk7XHJcblxyXG4gICAgICB0aGlzLm5hdmlnYXRpb25Qcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKG5wKSB7XHJcbiAgICAgICAgbGV0IHJlbGF0ZWRFbnRpdHk6IGFueTtcclxuICAgICAgICBsZXQgdmFsID0gaW5pdGlhbFZhbHVlc1tucC5uYW1lXTtcclxuICAgICAgICBpZiAodmFsICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbGV0IG5hdkVudGl0eVR5cGUgPSBucC5lbnRpdHlUeXBlO1xyXG4gICAgICAgICAgaWYgKG5wLmlzU2NhbGFyKSB7XHJcbiAgICAgICAgICAgIHJlbGF0ZWRFbnRpdHkgPSB2YWwuZW50aXR5QXNwZWN0ID8gdmFsIDogbmF2RW50aXR5VHlwZS5jcmVhdGVFbnRpdHkodmFsKTtcclxuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcGVydHkobnAubmFtZSwgcmVsYXRlZEVudGl0eSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcmVsYXRlZEVudGl0aWVzID0gaW5zdGFuY2UuZ2V0UHJvcGVydHkobnAubmFtZSk7XHJcbiAgICAgICAgICAgIHZhbC5mb3JFYWNoKCh2OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICByZWxhdGVkRW50aXR5ID0gdi5lbnRpdHlBc3BlY3QgPyB2IDogbmF2RW50aXR5VHlwZS5jcmVhdGVFbnRpdHkodik7XHJcbiAgICAgICAgICAgICAgcmVsYXRlZEVudGl0aWVzLnB1c2gocmVsYXRlZEVudGl0eSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5faW5pdGlhbGl6ZUluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxuICB9XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9jcmVhdGVJbnN0YW5jZUNvcmUoKSB7XHJcbiAgICBsZXQgYUN0b3IgPSB0aGlzLmdldEN0b3IoKTtcclxuICAgIGxldCBpbnN0YW5jZSA9IG5ldyBhQ3RvcigpO1xyXG4gICAgbmV3IEVudGl0eUFzcGVjdChpbnN0YW5jZSBhcyBFbnRpdHkpO1xyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2luaXRpYWxpemVJbnN0YW5jZShpbnN0YW5jZTogYW55KSB7XHJcbiAgICBpZiAodGhpcy5iYXNlRW50aXR5VHlwZSkge1xyXG4gICAgICB0aGlzLmJhc2VFbnRpdHlUeXBlLl9pbml0aWFsaXplSW5zdGFuY2UoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgbGV0IGluaXRGbiA9IHRoaXMuaW5pdEZuO1xyXG4gICAgaWYgKGluaXRGbikge1xyXG4gICAgICBsZXQgZm4gPSAodHlwZW9mIGluaXRGbiA9PT0gXCJzdHJpbmdcIikgPyBpbnN0YW5jZVtpbml0Rm5dIDogaW5pdEZuO1xyXG4gICAgICBmbihpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvbXBsZXhQcm9wZXJ0aWVzICYmIHRoaXMuY29tcGxleFByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoY3ApIHtcclxuICAgICAgbGV0IGNvbXBsZXhUeXBlID0gY3AuZGF0YVR5cGUgYXMgQ29tcGxleFR5cGU7XHJcbiAgICAgIGxldCBjdEluc3RhbmNlID0gaW5zdGFuY2UuZ2V0UHJvcGVydHkoY3AubmFtZSk7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGN0SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgY3RJbnN0YW5jZS5mb3JFYWNoKChjdEluc3QpID0+IHtcclxuICAgICAgICAgIGNvbXBsZXhUeXBlLl9pbml0aWFsaXplSW5zdGFuY2UoY3RJbnN0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb21wbGV4VHlwZS5faW5pdGlhbGl6ZUluc3RhbmNlKGN0SW5zdGFuY2UpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIG5vdCBuZWVkZWQgZm9yIGNvbXBsZXhPYmplY3RzXHJcbiAgICBpZiAoaW5zdGFuY2UuZW50aXR5QXNwZWN0KSB7XHJcbiAgICAgIGluc3RhbmNlLmVudGl0eUFzcGVjdC5faW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyB0aGUgY29uc3RydWN0b3IgZm9yIHRoaXMgRW50aXR5VHlwZS5cclxuICBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gV2hldGhlciB0byBpZ25vcmUgYW55IGNhY2hlZCB2ZXJzaW9uIG9mIHRoaXMgY29uc3RydWN0b3IuIChkZWZhdWx0ID09IGZhbHNlKVxyXG4gIEByZXR1cm4gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGlzIEVudGl0eVR5cGUuXHJcbiAgKiovXHJcbiAgZ2V0Q3Rvcihmb3JjZVJlZnJlc2g6IGJvb2xlYW4gPSBmYWxzZSk6IHsgbmV3ICgpOiBTdHJ1Y3R1cmFsT2JqZWN0IH0ge1xyXG4gICAgaWYgKHRoaXMuX2N0b3IgJiYgIWZvcmNlUmVmcmVzaCkgcmV0dXJuIHRoaXMuX2N0b3I7XHJcblxyXG4gICAgbGV0IGN0b3JSZWdpc3RyeSA9IHRoaXMubWV0YWRhdGFTdG9yZS5fY3RvclJlZ2lzdHJ5O1xyXG4gICAgbGV0IHIgPSBjdG9yUmVnaXN0cnlbdGhpcy5uYW1lXSB8fCBjdG9yUmVnaXN0cnlbdGhpcy5zaG9ydE5hbWVdIHx8IHt9O1xyXG4gICAgbGV0IGFDdG9yID0gci5jdG9yIHx8IHRoaXMuX2N0b3I7XHJcblxyXG4gICAgbGV0IGN0b3JUeXBlID0gYUN0b3IgJiYgYUN0b3IucHJvdG90eXBlICYmIChhQ3Rvci5wcm90b3R5cGUuZW50aXR5VHlwZSB8fCBhQ3Rvci5wcm90b3R5cGUuY29tcGxleFR5cGUpO1xyXG4gICAgaWYgKGN0b3JUeXBlICYmIGN0b3JUeXBlLm1ldGFkYXRhU3RvcmUgIT09IHRoaXMubWV0YWRhdGFTdG9yZSkge1xyXG4gICAgICAvLyBXZSBjYW4ndCByaXNrIGEgbWlzbWF0Y2ggYmV0d2VlbiB0aGUgY3RvciBhbmQgdGhlIHR5cGUgaW5mbyBpbiBhIHNwZWNpZmljIG1ldGFkYXRhc3RvcmVcclxuICAgICAgLy8gYmVjYXVzZSBtb2RlbExpYnJhcmllcyByZWx5IG9uIHR5cGUgaW5mbyB0byBpbnRlcmNlcHQgY3RvciBwcm9wZXJ0aWVzXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWdpc3RlciB0aGUgc2FtZSBjb25zdHJ1Y3RvciBmb3IgXCIgKyB0aGlzLm5hbWUgKyBcIiBpbiBkaWZmZXJlbnQgbWV0YWRhdGEgc3RvcmVzLiAgUGxlYXNlIGRlZmluZSBhIHNlcGFyYXRlIGNvbnN0cnVjdG9yIGZvciBlYWNoIG1ldGFkYXRhIHN0b3JlLlwiKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHIuY3RvciAmJiBmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgdGhpcy5fZXh0cmEgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhQ3Rvcikge1xyXG4gICAgICBsZXQgY3JlYXRlQ3RvciA9IGNvbmZpZy5pbnRlcmZhY2VSZWdpc3RyeS5tb2RlbExpYnJhcnkuZ2V0RGVmYXVsdEluc3RhbmNlKCkuY3JlYXRlQ3RvcjtcclxuICAgICAgYUN0b3IgPSBjcmVhdGVDdG9yID8gY3JlYXRlQ3Rvcih0aGlzKSA6IGNyZWF0ZUVtcHR5Q3Rvcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmluaXRGbiA9IHIuaW5pdEZuO1xyXG4gICAgdGhpcy5ub1RyYWNraW5nRm4gPSByLm5vVHJhY2tpbmdGbjtcclxuXHJcbiAgICBhQ3Rvci5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IHRoaXMubmFtZTtcclxuICAgIHRoaXMuX3NldEN0b3IoYUN0b3IpO1xyXG4gICAgcmV0dXJuIGFDdG9yO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIC8vIE1heSBtYWtlIHB1YmxpYyBsYXRlci5cclxuICBfc2V0Q3RvcihhQ3RvcjogeyBuZXcgKCk6IFN0cnVjdHVyYWxPYmplY3QgfSwgaW50ZXJjZXB0b3I/OiBhbnkpIHtcclxuXHJcbiAgICBsZXQgaW5zdGFuY2VQcm90byA9IGFDdG9yLnByb3RvdHlwZTtcclxuXHJcbiAgICAvLyBwbGFjZSBmb3IgZXh0cmEgYnJlZXplIHJlbGF0ZWQgZGF0YVxyXG4gICAgdGhpcy5fZXh0cmEgPSB0aGlzLl9leHRyYSB8fCB7fTtcclxuXHJcbiAgICBsZXQgaW5zdGFuY2UgPSBuZXcgYUN0b3IoKTtcclxuICAgIGNhbGNVbm1hcHBlZFByb3BlcnRpZXModGhpcywgaW5zdGFuY2UpO1xyXG5cclxuICAgIGlmICh0aGlzLl8kdHlwZU5hbWUgPT09IFwiRW50aXR5VHlwZVwiKSB7XHJcbiAgICAgIC8vIGluc3VyZSB0aGF0IGFsbCBvZiB0aGUgcHJvcGVydGllcyBhcmUgb24gdGhlICd0ZW1wbGF0ZScgaW5zdGFuY2UgYmVmb3JlIHdhdGNoaW5nIHRoZSBjbGFzcy5cclxuICAgICAgaW5zdGFuY2VQcm90by5lbnRpdHlUeXBlID0gdGhpcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluc3RhbmNlUHJvdG8uY29tcGxleFR5cGUgPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRlZmF1bHRQcm9wZXJ0eUludGVyY2VwdG9yIGlzIGEgJ2dsb2JhbCcgKGJ1dCBpbnRlcm5hbCB0byBicmVlemUpIGZ1bmN0aW9uO1xyXG4gICAgKGluc3RhbmNlUHJvdG8gYXMgYW55KS5fJGludGVyY2VwdG9yID0gaW50ZXJjZXB0b3IgfHwgZGVmYXVsdFByb3BlcnR5SW50ZXJjZXB0b3I7XHJcbiAgICBjb25maWcuaW50ZXJmYWNlUmVnaXN0cnkubW9kZWxMaWJyYXJ5LmdldERlZmF1bHRJbnN0YW5jZSgpLmluaXRpYWxpemVFbnRpdHlQcm90b3R5cGUoaW5zdGFuY2VQcm90byk7XHJcbiAgICB0aGlzLl9jdG9yID0gYUN0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBBZGRzIGVpdGhlciBhbiBlbnRpdHkgb3IgcHJvcGVydHkgbGV2ZWwgdmFsaWRhdG9yIHRvIHRoaXMgRW50aXR5VHlwZS5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICA+ICAgICAgbGV0IGNvdW50cnlQcm9wID0gY3VzdFR5cGUuZ2V0UHJvcGVydHkoXCJDb3VudHJ5XCIpO1xyXG4gID4gICAgICBsZXQgdmFsRm4gPSBmdW5jdGlvbiAodikge1xyXG4gID4gICAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gID4gICAgICAgICAgICAgIHJldHVybiAoY29yZS5zdHJpbmdTdGFydHNXaXRoKHYsIFwiVVNcIikpO1xyXG4gID4gICAgICAgICAgfTtcclxuICA+ICAgICAgbGV0IGNvdW50cnlWYWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKFwiY291bnRyeUlzVVNcIiwgdmFsRm4sXHJcbiAgPiAgICAgIHsgZGlzcGxheU5hbWU6IFwiQ291bnRyeVwiLCBtZXNzYWdlVGVtcGxhdGU6IFwiJyVkaXNwbGF5TmFtZSUnIG11c3Qgc3RhcnQgd2l0aCAnVVMnXCIgfSk7XHJcbiAgPiAgICAgIGN1c3RUeXBlLmFkZFZhbGlkYXRvcihjb3VudHJ5VmFsaWRhdG9yLCBjb3VudHJ5UHJvcCk7XHJcblxyXG4gIFRoaXMgaXMgdGhlIHNhbWUgYXMgYWRkaW5nIGFuIGVudGl0eSBsZXZlbCB2YWxpZGF0b3IgdmlhIHRoZSAndmFsaWRhdG9ycycgcHJvcGVydHkgb2YgRGF0YVByb3BlcnR5IG9yIE5hdmlnYXRpb25Qcm9wZXJ0eVxyXG4gID4gICAgICBjb3VudHJ5UHJvcC52YWxpZGF0b3JzLnB1c2goY291bnRyeVZhbGlkYXRvcik7XHJcblxyXG4gIEVudGl0eSBsZXZlbCB2YWxpZGF0b3JzIGNhbiBhbHNvIGJlIGFkZGVkIGJ5IG9taXR0aW5nIHRoZSAncHJvcGVydHknIHBhcmFtZXRlci5cclxuICA+ICAgICAgY3VzdFR5cGUuYWRkVmFsaWRhdG9yKHNvbWVFbnRpdHlMZXZlbFZhbGlkYXRvcik7XHJcblxyXG4gIG9yXHJcbiAgPiAgICAgIGN1c3RUeXBlLnZhbGlkYXRvcnMucHVzaChzb21lRW50aXR5TGV2ZWxWYWxpZGF0b3IpO1xyXG4gIEBwYXJhbSB2YWxpZGF0b3IgLSBWYWxpZGF0b3IgdG8gYWRkLlxyXG4gIEBwYXJhbSBwcm9wZXJ0eSAtIFByb3BlcnR5IHRvIGFkZCB0aGlzIHZhbGlkYXRvciB0by4gIElmIG9taXR0ZWQsIHRoZSB2YWxpZGF0b3IgaXMgYXNzdW1lZCB0byBiZSBhblxyXG4gIGVudGl0eSBsZXZlbCB2YWxpZGF0b3IgYW5kIGlzIGFkZGVkIHRvIHRoZSBFbnRpdHlUeXBlJ3MgJ3ZhbGlkYXRvcnMnLlxyXG4gICoqL1xyXG4gIGFkZFZhbGlkYXRvcih2YWxpZGF0b3I6IFZhbGlkYXRvciwgcHJvcGVydHk/OiBFbnRpdHlQcm9wZXJ0eSB8IHN0cmluZykge1xyXG4gICAgYXNzZXJ0UGFyYW0odmFsaWRhdG9yLCBcInZhbGlkYXRvclwiKS5pc0luc3RhbmNlT2YoVmFsaWRhdG9yKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0ocHJvcGVydHksIFwicHJvcGVydHlcIikuaXNPcHRpb25hbCgpLmlzU3RyaW5nKCkub3IoKS5pc0VudGl0eVByb3BlcnR5KCkuY2hlY2soKTtcclxuICAgIGlmIChwcm9wZXJ0eSAhPSBudWxsKSB7XHJcbiAgICAgIGxldCBwcm9wID0gKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpID8gdGhpcy5nZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdHJ1ZSkgOiBwcm9wZXJ0eTtcclxuICAgICAgcHJvcCEudmFsaWRhdG9ycy5wdXNoKHZhbGlkYXRvcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnZhbGlkYXRvcnMucHVzaCh2YWxpZGF0b3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhbGwgb2YgdGhlIHByb3BlcnRpZXMgKCBkYXRhUHJvcGVydGllcyBhbmQgbmF2aWdhdGlvblByb3BlcnRpZXMpIGZvciB0aGlzIEVudGl0eVR5cGUuXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgPiAgICAgIGxldCBhcnJheU9mUHJvcHMgPSBjdXN0VHlwZS5nZXRQcm9wZXJ0aWVzKCk7XHJcbiAgQHJldHVybiBBbiBhcnJheSBvZiBEYXRhIGFuZCBOYXZpZ2F0aW9uIHByb3BlcnRpZXMuXHJcbiAgKiovXHJcbiAgZ2V0UHJvcGVydGllcygpOiBFbnRpdHlQcm9wZXJ0eVtdIHtcclxuICAgIHJldHVybiAodGhpcy5kYXRhUHJvcGVydGllcyBhcyBFbnRpdHlQcm9wZXJ0eVtdKS5jb25jYXQodGhpcy5uYXZpZ2F0aW9uUHJvcGVydGllcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGFsbCBvZiB0aGUgcHJvcGVydHkgbmFtZXMgKCBmb3IgYm90aCBkYXRhUHJvcGVydGllcyBhbmQgbmF2aWdhdGlvblByb3BlcnRpZXMpIGZvciB0aGlzIEVudGl0eVR5cGUuXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgPiAgICAgIGxldCBhcnJheU9mUHJvcE5hbWVzID0gY3VzdFR5cGUuZ2V0UHJvcGVydHlOYW1lcygpO1xyXG4gICoqL1xyXG4gIGdldFByb3BlcnR5TmFtZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRQcm9wZXJ0aWVzKCkubWFwKGNvcmUucGx1Y2soJ25hbWUnKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGEgZGF0YSBwcm9wZXJ0eSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBvciBudWxsLlxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXIgY29udGFpbmluZyBhIG51bWJlciBvZiBleGlzdGluZyBlbnRpdGllcy5cclxuICA+ICAgICAgbGV0IGN1c3RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkN1c3RvbWVyXCIpO1xyXG4gID4gICAgICBsZXQgY3VzdG9tZXJOYW1lRGF0YVByb3AgPSBjdXN0VHlwZS5nZXREYXRhUHJvcGVydHkoXCJDdXN0b21lck5hbWVcIik7XHJcbiAgQHJldHVybiBBIERhdGFQcm9wZXJ0eSBvciBudWxsIGlmIG5vdCBmb3VuZC5cclxuICAqKi9cclxuICBnZXREYXRhUHJvcGVydHkocHJvcGVydHlOYW1lOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBjb3JlLmFycmF5Rmlyc3QodGhpcy5kYXRhUHJvcGVydGllcywgY29yZS5wcm9wRXEoJ25hbWUnLCBwcm9wZXJ0eU5hbWUpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBuYXZpZ2F0aW9uIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIG9yIG51bGwuXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgPiAgICAgIGxldCBjdXN0b21lck9yZGVyc05hdlByb3AgPSBjdXN0VHlwZS5nZXREYXRhUHJvcGVydHkoXCJPcmRlcnNcIik7XHJcbiAgQHJldHVybiBBIE5hdmlnYXRpb25Qcm9wZXJ0eSBvciBudWxsIGlmIG5vdCBmb3VuZC5cclxuICAqKi9cclxuICBnZXROYXZpZ2F0aW9uUHJvcGVydHkocHJvcGVydHlOYW1lOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBjb3JlLmFycmF5Rmlyc3QodGhpcy5uYXZpZ2F0aW9uUHJvcGVydGllcywgY29yZS5wcm9wRXEoJ25hbWUnLCBwcm9wZXJ0eU5hbWUpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgZWl0aGVyIGEgRGF0YVByb3BlcnR5IG9yIGEgTmF2aWdhdGlvblByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIG9yIG51bGwuXHJcbiAgXHJcbiAgVGhpcyBtZXRob2QgYWxzbyBhY2NlcHRzIGEgJy4nIGRlbGltaXRlZCBwcm9wZXJ0eSBwYXRoIGFuZCB3aWxsIHJldHVybiB0aGUgJ3Byb3BlcnR5JyBhdCB0aGVcclxuICBlbmQgb2YgdGhlIHBhdGguXHJcbiAgPiAgICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICA+ICAgICAgbGV0IGNvbXBhbnlOYW1lUHJvcCA9IGN1c3RUeXBlLmdldFByb3BlcnR5KFwiQ29tcGFueU5hbWVcIik7XHJcblxyXG4gIFRoaXMgbWV0aG9kIGNhbiBhbHNvIHdhbGsgYSBwcm9wZXJ0eSBwYXRoIHRvIHJldHVybiBhIHByb3BlcnR5XHJcbiAgPiAgICAgIGxldCBvcmRlckRldGFpbFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiT3JkZXJEZXRhaWxcIik7XHJcbiAgPiAgICAgIGxldCBjb21wYW55TmFtZVByb3AyID0gb3JkZXJEZXRhaWxUeXBlLmdldFByb3BlcnR5KFwiT3JkZXIuQ3VzdG9tZXIuQ29tcGFueU5hbWVcIik7XHJcbiAgPiAgICAgIC8vIGNvbXBhbnlOYW1lUHJvcCA9PT0gY29tcGFueU5hbWVQcm9wMlxyXG4gIEBwYXJhbSBbdGhyb3dJZk5vdEZvdW5kPWZhbHNlXSB7Qm9vbGVhbn0gV2hldGhlciB0byB0aHJvdyBhbiBleGNlcHRpb24gaWYgbm90IGZvdW5kLlxyXG4gIEByZXR1cm4gQSBEYXRhUHJvcGVydHkgb3IgTmF2aWdhdGlvblByb3BlcnR5IG9yIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICoqL1xyXG4gIGdldFByb3BlcnR5KHByb3BlcnR5UGF0aDogc3RyaW5nLCB0aHJvd0lmTm90Rm91bmQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgbGV0IHByb3BzID0gdGhpcy5nZXRQcm9wZXJ0aWVzT25QYXRoKHByb3BlcnR5UGF0aCwgZmFsc2UsIHRocm93SWZOb3RGb3VuZCk7XHJcbiAgICByZXR1cm4gKHByb3BzICYmIHByb3BzLmxlbmd0aCA+IDApID8gcHJvcHNbcHJvcHMubGVuZ3RoIC0gMV0gOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgLy8gVE9ETzogaGF2ZSB0aGlzIHJldHVybiBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIG51bGwgYW5kIGZpeCBjb25zdW1lcnMuXHJcbiAgLy8gVE9ETzogdGhpbmsgYWJvdXQgcmVuYW1pbmcgd2l0aCAnXycgcHJlZml4LlxyXG4gIGdldFByb3BlcnRpZXNPblBhdGgocHJvcGVydHlQYXRoOiBzdHJpbmcsIHVzZVNlcnZlck5hbWU6IGJvb2xlYW4gfCBudWxsLCB0aHJvd0lmTm90Rm91bmQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgbGV0IHByb3BlcnR5TmFtZXM6IHN0cmluZ1tdID0gKEFycmF5LmlzQXJyYXkocHJvcGVydHlQYXRoKSkgPyBwcm9wZXJ0eVBhdGggOiBwcm9wZXJ0eVBhdGgudHJpbSgpLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgbGV0IG9rID0gdHJ1ZTtcclxuICAgIGxldCBrZXkgPSB1c2VTZXJ2ZXJOYW1lID09PSB0cnVlID8gXCJuYW1lT25TZXJ2ZXJcIiA6IHVzZVNlcnZlck5hbWUgPT09IGZhbHNlID8gXCJuYW1lXCIgOiBudWxsO1xyXG4gICAgbGV0IHBhcmVudFR5cGUgPSB0aGlzIGFzIFN0cnVjdHVyYWxUeXBlO1xyXG4gICAgXHJcbiAgICBjb25zdCBnZXRQcm9wcyA9IChwcm9wTmFtZTogc3RyaW5nKSA9PiB7IFxyXG4gICAgICBjb25zdCBmbiA9IGtleSA9PT0gbnVsbCA/IGNvcmUucHJvcHNFcShcIm5hbWVcIiwgXCJuYW1lT25TZXJ2ZXJcIiwgcHJvcE5hbWUpIDogY29yZS5wcm9wRXEoa2V5LCBwcm9wTmFtZSk7XHJcbiAgICAgIGxldCBwcm9wID0gY29yZS5hcnJheUZpcnN0KHBhcmVudFR5cGUuZ2V0UHJvcGVydGllcygpLCBmbik7XHJcbiAgICAgIGlmIChwcm9wKSB7XHJcbiAgICAgICAgcGFyZW50VHlwZSA9IChwcm9wIGluc3RhbmNlb2YgTmF2aWdhdGlvblByb3BlcnR5KSA/IHByb3AuZW50aXR5VHlwZSA6IHByb3AuZGF0YVR5cGUgYXMgQ29tcGxleFR5cGU7XHJcbiAgICAgICAgLy8gcGFyZW50VHlwZSA9IHByb3AuaXNOYXZpZ2F0aW9uUHJvcGVydHkgPyBwcm9wLmVudGl0eVR5cGUgOiBwcm9wLmRhdGFUeXBlO1xyXG4gICAgICB9IGVsc2UgaWYgKHRocm93SWZOb3RGb3VuZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byBsb2NhdGUgcHJvcGVydHk6IFwiICsgcHJvcE5hbWUgKyBcIiBvbiBlbnRpdHlUeXBlOiBcIiArIHBhcmVudFR5cGUubmFtZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb2sgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcHJvcDtcclxuICAgIH07XHJcblxyXG4gICAgbGV0IHByb3BzID0gcHJvcGVydHlOYW1lcy5tYXAoZ2V0UHJvcHMpIGFzIEVudGl0eVByb3BlcnR5W107XHJcbiAgICByZXR1cm4gb2sgPyBwcm9wcyA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKiogRm9yIHVzZSBpbiBwbHVnZ2FibGUgYWRhcHRlcnMuICovXHJcbiAgLy8gVE9ETzogZG9jdW1lbnQgdXNlXHJcbiAgY2xpZW50UHJvcGVydHlQYXRoVG9TZXJ2ZXIocHJvcGVydHlQYXRoOiBzdHJpbmcsIGRlbGltaXRlcjogc3RyaW5nID0gJy4nKSB7XHJcbiAgICBsZXQgcHJvcE5hbWVzOiBzdHJpbmdbXTtcclxuICAgIGlmICh0aGlzLmlzQW5vbnltb3VzKSB7XHJcbiAgICAgIGxldCBmbiA9IHRoaXMubWV0YWRhdGFTdG9yZS5uYW1pbmdDb252ZW50aW9uLmNsaWVudFByb3BlcnR5TmFtZVRvU2VydmVyO1xyXG4gICAgICBwcm9wTmFtZXMgPSBwcm9wZXJ0eVBhdGguc3BsaXQoXCIuXCIpLm1hcChmdW5jdGlvbiAocHJvcE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gZm4ocHJvcE5hbWUpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxldCBwcm9wcyA9IHRoaXMuZ2V0UHJvcGVydGllc09uUGF0aChwcm9wZXJ0eVBhdGgsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgcHJvcE5hbWVzID0gcHJvcHMhLm1hcCgocHJvcDogRW50aXR5UHJvcGVydHkpID0+IHByb3AubmFtZU9uU2VydmVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wTmFtZXMuam9pbihkZWxpbWl0ZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEZvciB1c2UgaW4gcGx1Z2dhYmxlIGFkYXB0ZXJzLiAqL1xyXG4gIC8vIFRPRE86IGRvY3VtZW50IHVzZVxyXG4gIGdldEVudGl0eUtleUZyb21SYXdFbnRpdHkocmF3RW50aXR5OiBhbnksIHJhd1ZhbHVlRm46IEZ1bmN0aW9uKSB7XHJcbiAgICBsZXQga2V5VmFsdWVzID0gdGhpcy5rZXlQcm9wZXJ0aWVzLm1hcCgoZHApID0+IHtcclxuICAgICAgbGV0IHZhbCA9IHJhd1ZhbHVlRm4ocmF3RW50aXR5LCBkcCk7XHJcbiAgICAgIHJldHVybiBEYXRhVHlwZS5wYXJzZVJhd1ZhbHVlKHZhbCwgZHAuZGF0YVR5cGUgYXMgRGF0YVR5cGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbmV3IEVudGl0eUtleSh0aGlzLCBrZXlWYWx1ZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX3VwZGF0ZVRhcmdldEZyb21SYXcodGFyZ2V0OiBTdHJ1Y3R1cmFsT2JqZWN0LCByYXc6IGFueSwgcmF3VmFsdWVGbjogRnVuY3Rpb24pIHtcclxuICAgIC8vIGNhbGxlZCByZWN1cnNpdmVseSBmb3IgY29tcGxleCBwcm9wZXJ0aWVzXHJcbiAgICB0aGlzLmRhdGFQcm9wZXJ0aWVzLmZvckVhY2goKGRwKSA9PiB7XHJcbiAgICAgIGlmICghZHAuaXNTZXR0YWJsZSkgcmV0dXJuO1xyXG4gICAgICBsZXQgcmF3VmFsID0gcmF3VmFsdWVGbihyYXcsIGRwKTtcclxuICAgICAgaWYgKHJhd1ZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XHJcbiAgICAgIGxldCBkYXRhVHlwZSA9IGRwLmRhdGFUeXBlOyAvLyB0aGlzIHdpbGwgYmUgYSBjb21wbGV4VHlwZSB3aGVuIGRwIGlzIGEgY29tcGxleFByb3BlcnR5XHJcbiAgICAgIGxldCBvbGRWYWw6IGFueTtcclxuICAgICAgaWYgKGRwLmlzQ29tcGxleFByb3BlcnR5KSB7XHJcbiAgICAgICAgbGV0IGNvbXBsZXhUeXBlID0gZHAuZGF0YVR5cGUgYXMgQ29tcGxleFR5cGU7XHJcbiAgICAgICAgaWYgKHJhd1ZhbCA9PT0gbnVsbCkgcmV0dXJuOyAvLyByYXdWYWwgbWF5IGJlIG51bGwgaW4gbm9zcWwgZGJzIHdoZXJlIGl0IHdhcyBuZXZlciBkZWZpbmVkIGZvciB0aGUgZ2l2ZW4gcm93LlxyXG4gICAgICAgIG9sZFZhbCA9IHRhcmdldC5nZXRQcm9wZXJ0eShkcC5uYW1lKTtcclxuICAgICAgICBpZiAoZHAuaXNTY2FsYXIpIHtcclxuICAgICAgICAgIGNvbXBsZXhUeXBlLl91cGRhdGVUYXJnZXRGcm9tUmF3KG9sZFZhbCwgcmF3VmFsLCByYXdWYWx1ZUZuKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3VmFsKSkge1xyXG4gICAgICAgICAgICBsZXQgbmV3VmFsID0gcmF3VmFsLm1hcChmdW5jdGlvbiAocmF3Q28pIHtcclxuICAgICAgICAgICAgICBsZXQgbmV3Q28gPSBjb21wbGV4VHlwZS5fY3JlYXRlSW5zdGFuY2VDb3JlKHRhcmdldCwgZHApO1xyXG4gICAgICAgICAgICAgIGNvbXBsZXhUeXBlLl91cGRhdGVUYXJnZXRGcm9tUmF3KG5ld0NvLCByYXdDbywgcmF3VmFsdWVGbik7XHJcbiAgICAgICAgICAgICAgY29tcGxleFR5cGUuX2luaXRpYWxpemVJbnN0YW5jZShuZXdDbyk7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0NvO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFjb3JlLmFycmF5RXF1YWxzKG9sZFZhbCwgbmV3VmFsLCBjb0VxdWFscykpIHtcclxuICAgICAgICAgICAgICAvLyBjbGVhciB0aGUgb2xkIGFycmF5IGFuZCBwdXNoIG5ldyBvYmplY3RzIGludG8gaXQuXHJcbiAgICAgICAgICAgICAgb2xkVmFsLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgbmV3VmFsLmZvckVhY2goZnVuY3Rpb24gKG52KSB7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWwucHVzaChudik7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9sZFZhbC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoZHAuaXNTY2FsYXIpIHtcclxuICAgICAgICAgIGxldCBuZXdWYWwgPSBEYXRhVHlwZS5wYXJzZVJhd1ZhbHVlKHJhd1ZhbCwgZGF0YVR5cGUgYXMgRGF0YVR5cGUpO1xyXG4gICAgICAgICAgdGFyZ2V0LnNldFByb3BlcnR5KGRwLm5hbWUsIG5ld1ZhbCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9sZFZhbCA9IHRhcmdldC5nZXRQcm9wZXJ0eShkcC5uYW1lKTtcclxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd1ZhbCkpIHtcclxuICAgICAgICAgICAgLy8gbmVlZCB0byBjb21wYXJlIHZhbHVlc1xyXG4gICAgICAgICAgICBsZXQgbmV3VmFsID0gcmF3VmFsLm1hcCgocnYpID0+IHtcclxuICAgICAgICAgICAgICByZXR1cm4gRGF0YVR5cGUucGFyc2VSYXdWYWx1ZShydiwgZGF0YVR5cGUgYXMgRGF0YVR5cGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFjb3JlLmFycmF5RXF1YWxzKG9sZFZhbCwgbmV3VmFsKSkge1xyXG4gICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBvbGQgYXJyYXkgYW5kIHB1c2ggbmV3IG9iamVjdHMgaW50byBpdC5cclxuICAgICAgICAgICAgICBvbGRWYWwubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICBuZXdWYWwuZm9yRWFjaChmdW5jdGlvbiAobnYpIHtcclxuICAgICAgICAgICAgICAgIG9sZFZhbC5wdXNoKG52KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb2xkVmFsLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaWYgbWVyZ2luZyBmcm9tIGFuIGltcG9ydCB0aGVuIHJhdyB3aWxsIGhhdmUgYW4gZW50aXR5QXNwZWN0IG9yIGEgY29tcGxleEFzcGVjdFxyXG4gICAgbGV0IHJhd0FzcGVjdCA9IHJhdy5lbnRpdHlBc3BlY3QgfHwgcmF3LmNvbXBsZXhBc3BlY3Q7XHJcbiAgICBpZiAocmF3QXNwZWN0KSB7XHJcblxyXG4gICAgICBsZXQgdGFyZ2V0QXNwZWN0ID0gRW50aXR5QXNwZWN0LmlzRW50aXR5KHRhcmdldCkgPyB0YXJnZXQuZW50aXR5QXNwZWN0IDogdGFyZ2V0LmNvbXBsZXhBc3BlY3Q7XHJcbiAgICAgIGlmIChyYXdBc3BlY3Qub3JpZ2luYWxWYWx1ZXNNYXApIHtcclxuICAgICAgICB0YXJnZXRBc3BlY3Qub3JpZ2luYWxWYWx1ZXMgPSByYXdBc3BlY3Qub3JpZ2luYWxWYWx1ZXNNYXA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJhd0FzcGVjdC5leHRyYU1ldGFkYXRhKSB7XHJcbiAgICAgICAgdGFyZ2V0QXNwZWN0LmV4dHJhTWV0YWRhdGEgPSByYXdBc3BlY3QuZXh0cmFNZXRhZGF0YTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRW50aXR5VHlwZS5cclxuICAqKi9cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgfVxyXG5cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4gY29yZS50b0pzb24odGhpcywge1xyXG4gICAgICBzaG9ydE5hbWU6IG51bGwsXHJcbiAgICAgIG5hbWVzcGFjZTogbnVsbCxcclxuICAgICAgYmFzZVR5cGVOYW1lOiBudWxsLFxyXG4gICAgICBpc0Fic3RyYWN0OiBmYWxzZSxcclxuICAgICAgYXV0b0dlbmVyYXRlZEtleVR5cGU6IG51bGwsIC8vIGRvIG5vdCBzdXBwcmVzcyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgIGRlZmF1bHRSZXNvdXJjZU5hbWU6IG51bGwsXHJcbiAgICAgIGRhdGFQcm9wZXJ0aWVzOiBsb2NhbFByb3BzT25seSxcclxuICAgICAgbmF2aWdhdGlvblByb3BlcnRpZXM6IGxvY2FsUHJvcHNPbmx5LFxyXG4gICAgICB2YWxpZGF0b3JzOiBudWxsLFxyXG4gICAgICBjdXN0b206IG51bGxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX3VwZGF0ZU5hbWVzKHByb3BlcnR5OiBFbnRpdHlQcm9wZXJ0eSkge1xyXG4gICAgbGV0IG5jID0gdGhpcy5tZXRhZGF0YVN0b3JlLm5hbWluZ0NvbnZlbnRpb247XHJcbiAgICB1cGRhdGVDbGllbnRTZXJ2ZXJOYW1lcyhuYywgcHJvcGVydHksIFwibmFtZVwiKTtcclxuXHJcbiAgICBpZiAocHJvcGVydHkuaXNOYXZpZ2F0aW9uUHJvcGVydHkpIHtcclxuICAgICAgdXBkYXRlQ2xpZW50U2VydmVyTmFtZXMobmMsIHByb3BlcnR5LCBcImZvcmVpZ25LZXlOYW1lc1wiKTtcclxuICAgICAgdXBkYXRlQ2xpZW50U2VydmVyTmFtZXMobmMsIHByb3BlcnR5LCBcImludkZvcmVpZ25LZXlOYW1lc1wiKTtcclxuXHJcbiAgICAgIC8vIHRoZXNlIHdpbGwgZ2V0IHNldCBsYXRlciB2aWEgX3VwZGF0ZU5wc1xyXG4gICAgICAvLyB0aGlzLmludmVyc2VcclxuICAgICAgLy8gdGhpcy5lbnRpdHlUeXBlXHJcbiAgICAgIC8vIHRoaXMucmVsYXRlZERhdGFQcm9wZXJ0aWVzXHJcbiAgICAgIC8vICAgIGRhdGFQcm9wZXJ0eS5yZWxhdGVkTmF2aWdhdGlvblByb3BlcnR5XHJcbiAgICAgIC8vICAgIGRhdGFQcm9wZXJ0eS5pbnZlcnNlTmF2aWdhdGlvblByb3BlcnR5XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfY2hlY2tOYXZQcm9wZXJ0eShuYXZpZ2F0aW9uUHJvcGVydHk6IE5hdmlnYXRpb25Qcm9wZXJ0eSB8IHN0cmluZykge1xyXG4gICAgLy8gaWYgKG5hdmlnYXRpb25Qcm9wZXJ0eS5pc05hdmlnYXRpb25Qcm9wZXJ0eSkge1xyXG4gICAgaWYgKG5hdmlnYXRpb25Qcm9wZXJ0eSBpbnN0YW5jZW9mIE5hdmlnYXRpb25Qcm9wZXJ0eSkge1xyXG4gICAgICBpZiAobmF2aWdhdGlvblByb3BlcnR5LnBhcmVudFR5cGUgIT09IHRoaXMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY29yZS5mb3JtYXRTdHJpbmcoXCJUaGUgbmF2aWdhdGlvblByb3BlcnR5ICclMScgaXMgbm90IGEgcHJvcGVydHkgb2YgZW50aXR5IHR5cGUgJyUyJ1wiLFxyXG4gICAgICAgICAgbmF2aWdhdGlvblByb3BlcnR5Lm5hbWUsIHRoaXMubmFtZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuYXZpZ2F0aW9uUHJvcGVydHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiAobmF2aWdhdGlvblByb3BlcnR5KSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgbGV0IG5wID0gdGhpcy5nZXRQcm9wZXJ0eShuYXZpZ2F0aW9uUHJvcGVydHkpO1xyXG4gICAgICAvLyBpZiAobnAgJiYgbnAuaXNOYXZpZ2F0aW9uUHJvcGVydHkpIHJldHVybiBucDtcclxuICAgICAgaWYgKG5wICYmIG5wIGluc3RhbmNlb2YgTmF2aWdhdGlvblByb3BlcnR5KSByZXR1cm4gbnA7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ25hdmlnYXRpb25Qcm9wZXJ0eScgcGFyYW1ldGVyIG11c3QgZWl0aGVyIGJlIGEgTmF2aWdhdGlvblByb3BlcnR5IG9yIHRoZSBuYW1lIG9mIGEgTmF2aWdhdGlvblByb3BlcnR5XCIpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2FkZERhdGFQcm9wZXJ0eShkcDogRGF0YVByb3BlcnR5KSB7XHJcblxyXG4gICAgdGhpcy5kYXRhUHJvcGVydGllcy5wdXNoKGRwKTtcclxuXHJcbiAgICBpZiAoZHAuaXNQYXJ0T2ZLZXkpIHtcclxuICAgICAgdGhpcy5rZXlQcm9wZXJ0aWVzLnB1c2goZHApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkcC5pc0NvbXBsZXhQcm9wZXJ0eSkge1xyXG4gICAgICB0aGlzLmNvbXBsZXhQcm9wZXJ0aWVzLnB1c2goZHApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkcC5jb25jdXJyZW5jeU1vZGUgJiYgZHAuY29uY3VycmVuY3lNb2RlICE9PSBcIk5vbmVcIikge1xyXG4gICAgICB0aGlzLmNvbmN1cnJlbmN5UHJvcGVydGllcy5wdXNoKGRwKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZHAuaXNVbm1hcHBlZCkge1xyXG4gICAgICB0aGlzLnVubWFwcGVkUHJvcGVydGllcy5wdXNoKGRwKTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfYWRkTmF2aWdhdGlvblByb3BlcnR5KG5wOiBOYXZpZ2F0aW9uUHJvcGVydHkpIHtcclxuXHJcbiAgICB0aGlzLm5hdmlnYXRpb25Qcm9wZXJ0aWVzLnB1c2gobnApO1xyXG5cclxuICAgIGlmICghaXNRdWFsaWZpZWRUeXBlTmFtZShucC5lbnRpdHlUeXBlTmFtZSkpIHtcclxuICAgICAgbnAuZW50aXR5VHlwZU5hbWUgPSBxdWFsaWZ5VHlwZU5hbWUobnAuZW50aXR5VHlwZU5hbWUsIHRoaXMubmFtZXNwYWNlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF91cGRhdGVDcHMoKSB7XHJcbiAgICBsZXQgbWV0YWRhdGFTdG9yZSA9IHRoaXMubWV0YWRhdGFTdG9yZTtcclxuICAgIGxldCBpbmNvbXBsZXRlVHlwZU1hcCA9IG1ldGFkYXRhU3RvcmUuX2luY29tcGxldGVDb21wbGV4VHlwZU1hcDtcclxuICAgIHRoaXMuY29tcGxleFByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoY3ApIHtcclxuICAgICAgaWYgKGNwLmNvbXBsZXhUeXBlKSByZXR1cm47XHJcbiAgICAgIGlmICghcmVzb2x2ZUNwKGNwLCBtZXRhZGF0YVN0b3JlKSkge1xyXG4gICAgICAgIGNvcmUuZ2V0QXJyYXkoaW5jb21wbGV0ZVR5cGVNYXAsIGNwLmNvbXBsZXhUeXBlTmFtZSkucHVzaChjcCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLmlzQ29tcGxleFR5cGUpIHtcclxuICAgICAgKGluY29tcGxldGVUeXBlTWFwW3RoaXMubmFtZV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGNwOiBEYXRhUHJvcGVydHkpIHtcclxuICAgICAgICByZXNvbHZlQ3AoY3AsIG1ldGFkYXRhU3RvcmUpO1xyXG4gICAgICB9KTtcclxuICAgICAgZGVsZXRlIGluY29tcGxldGVUeXBlTWFwW3RoaXMubmFtZV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfdXBkYXRlTnBzKCkge1xyXG4gICAgbGV0IG1ldGFkYXRhU3RvcmUgPSB0aGlzLm1ldGFkYXRhU3RvcmU7XHJcblxyXG4gICAgLy8gcmVzb2x2ZSBhbGwgbmF2UHJvcHMgZm9yIHRoaXMgZW50aXR5VHlwZVxyXG4gICAgdGhpcy5uYXZpZ2F0aW9uUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChucCkge1xyXG4gICAgICB0cnlSZXNvbHZlTnAobnAsIG1ldGFkYXRhU3RvcmUpO1xyXG4gICAgfSk7XHJcbiAgICBsZXQgaW5jb21wbGV0ZVR5cGVNYXAgPSBtZXRhZGF0YVN0b3JlLl9pbmNvbXBsZXRlVHlwZU1hcDtcclxuICAgIC8vIG5leHQgcmVzb2x2ZSBhbGwgbmF2UHJvcCB0aGF0IHBvaW50IHRvIHRoaXMgZW50aXR5VHlwZS5cclxuICAgIChpbmNvbXBsZXRlVHlwZU1hcFt0aGlzLm5hbWVdIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChucDogTmF2aWdhdGlvblByb3BlcnR5KSB7XHJcbiAgICAgIHRyeVJlc29sdmVOcChucCwgbWV0YWRhdGFTdG9yZSk7XHJcbiAgICB9KTtcclxuICAgIC8vIGV2ZXJ5IG5hdlByb3AgdGhhdCBwb2ludGVkIHRvIHRoaXMgdHlwZSBzaG91bGQgbm93IGJlIHJlc29sdmVkXHJcbiAgICBkZWxldGUgaW5jb21wbGV0ZVR5cGVNYXBbdGhpcy5uYW1lXTtcclxuICB9XHJcbn1cclxuXHJcbkVudGl0eVR5cGUucHJvdG90eXBlLl8kdHlwZU5hbWUgPSBcIkVudGl0eVR5cGVcIjtcclxuXHJcbmZ1bmN0aW9uIGdldFJhd1ZhbHVlRnJvbUNvbmZpZyhyYXdFbnRpdHk6IGFueSwgZHA6IERhdGFQcm9wZXJ0eSkge1xyXG4gIC8vICd0cnVlJyBmb3JrIGNhbiBoYXBwZW4gaWYgYW4gaW5pdGlhbGl6ZXIgY29udGFpbnMgYW4gYWN0YXVsIGluc3RhbmNlIG9mIGFuIGFscmVhZHkgY3JlYXRlZCBjb21wbGV4IG9iamVjdC5cclxuICByZXR1cm4gKHJhd0VudGl0eS5lbnRpdHlBc3BlY3QgfHwgcmF3RW50aXR5LmNvbXBsZXhBc3BlY3QpID8gcmF3RW50aXR5LmdldFByb3BlcnR5KGRwLm5hbWUpIDogcmF3RW50aXR5W2RwLm5hbWVdO1xyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVDbGllbnRTZXJ2ZXJOYW1lcyhuYzogTmFtaW5nQ29udmVudGlvbiwgcGFyZW50OiBhbnksIGNsaWVudFByb3BOYW1lOiBzdHJpbmcpIHtcclxuICBsZXQgc2VydmVyUHJvcE5hbWUgPSBjbGllbnRQcm9wTmFtZSArIFwiT25TZXJ2ZXJcIjtcclxuICBsZXQgY2xpZW50TmFtZSA9IHBhcmVudFtjbGllbnRQcm9wTmFtZV07XHJcbiAgaWYgKGNsaWVudE5hbWUgJiYgY2xpZW50TmFtZS5sZW5ndGgpIHtcclxuICAgIC8vIGlmIChwYXJlbnQuaXNVbm1hcHBlZCkgcmV0dXJuO1xyXG4gICAgbGV0IHNlcnZlck5hbWVzID0gY29yZS50b0FycmF5KGNsaWVudE5hbWUpLm1hcChmdW5jdGlvbiAoY05hbWUpIHtcclxuICAgICAgbGV0IHNOYW1lID0gbmMuY2xpZW50UHJvcGVydHlOYW1lVG9TZXJ2ZXIoY05hbWUsIHBhcmVudCk7XHJcbiAgICAgIGxldCB0ZXN0TmFtZSA9IG5jLnNlcnZlclByb3BlcnR5TmFtZVRvQ2xpZW50KHNOYW1lLCBwYXJlbnQpO1xyXG4gICAgICBpZiAoY05hbWUgIT09IHRlc3ROYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmFtaW5nQ29udmVudGlvbiBmb3IgdGhpcyBjbGllbnQgcHJvcGVydHkgbmFtZSBkb2VzIG5vdCByb3VuZHRyaXAgcHJvcGVybHk6XCIgKyBjTmFtZSArIFwiLS0+XCIgKyB0ZXN0TmFtZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNOYW1lO1xyXG4gICAgfSk7XHJcbiAgICBwYXJlbnRbc2VydmVyUHJvcE5hbWVdID0gQXJyYXkuaXNBcnJheShjbGllbnROYW1lKSA/IHNlcnZlck5hbWVzIDogc2VydmVyTmFtZXNbMF07XHJcbiAgfSBlbHNlIHtcclxuICAgIGxldCBzZXJ2ZXJOYW1lID0gcGFyZW50W3NlcnZlclByb3BOYW1lXTtcclxuICAgIGlmICgoIXNlcnZlck5hbWUpIHx8IHNlcnZlck5hbWUubGVuZ3RoID09PSAwKSByZXR1cm47XHJcbiAgICBsZXQgY2xpZW50TmFtZXMgPSBjb3JlLnRvQXJyYXkoc2VydmVyTmFtZSkubWFwKGZ1bmN0aW9uIChzTmFtZSkge1xyXG4gICAgICBsZXQgY05hbWUgPSBuYy5zZXJ2ZXJQcm9wZXJ0eU5hbWVUb0NsaWVudChzTmFtZSwgcGFyZW50KTtcclxuICAgICAgbGV0IHRlc3ROYW1lID0gbmMuY2xpZW50UHJvcGVydHlOYW1lVG9TZXJ2ZXIoY05hbWUsIHBhcmVudCk7XHJcbiAgICAgIGlmIChzTmFtZSAhPT0gdGVzdE5hbWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1pbmdDb252ZW50aW9uIGZvciB0aGlzIHNlcnZlciBwcm9wZXJ0eSBuYW1lIGRvZXMgbm90IHJvdW5kdHJpcCBwcm9wZXJseTpcIiArIHNOYW1lICsgXCItLT5cIiArIHRlc3ROYW1lKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY05hbWU7XHJcbiAgICB9KTtcclxuICAgIHBhcmVudFtjbGllbnRQcm9wTmFtZV0gPSBBcnJheS5pc0FycmF5KHNlcnZlck5hbWUpID8gY2xpZW50TmFtZXMgOiBjbGllbnROYW1lc1swXTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5Q3Rvcih0eXBlOiBhbnkpIHtcclxuICBpZiAoY29uZmlnLm5vRXZhbCkge1xyXG4gICAgbGV0IEVudGl0eSA9IGZ1bmN0aW9uKCkge307XHJcbiAgICByZXR1cm4gRW50aXR5O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgbmFtZSA9IHR5cGUubmFtZS5yZXBsYWNlKC9cXFcvZywgJ18nKTtcclxuICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uICcgKyBuYW1lICsgJygpe30nKSgpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY29FcXVhbHMoY28xOiBDb21wbGV4T2JqZWN0LCBjbzI6IENvbXBsZXhPYmplY3QpOiBib29sZWFuIHtcclxuICBsZXQgY29tcGxleFR5cGUgPSBjbzEuY29tcGxleEFzcGVjdCEucGFyZW50UHJvcGVydHkhLmRhdGFUeXBlIGFzIENvbXBsZXhUeXBlO1xyXG4gIGxldCBkYXRhUHJvcHMgPSBjb21wbGV4VHlwZS5kYXRhUHJvcGVydGllcztcclxuICBsZXQgYXJlRXF1YWwgPSBkYXRhUHJvcHMuZXZlcnkoZnVuY3Rpb24gKGRwKSB7XHJcbiAgICBpZiAoIWRwLmlzU2V0dGFibGUpIHJldHVybiB0cnVlO1xyXG4gICAgbGV0IHYxID0gY28xLmdldFByb3BlcnR5KGRwLm5hbWUpO1xyXG4gICAgbGV0IHYyID0gY28yLmdldFByb3BlcnR5KGRwLm5hbWUpO1xyXG4gICAgaWYgKGRwLmlzQ29tcGxleFByb3BlcnR5ICYmIGRwLmlzU2NhbGFyKSB7XHJcbiAgICAgIHJldHVybiBjb0VxdWFscyh2MSwgdjIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZHAuaXNDb21wbGV4UHJvcGVydHkgJiYgIWRwLmlzU2NhbGFyKSB7XHJcbiAgICAgIHJldHVybiBjb3JlLmFycmF5RXF1YWxzKHYxLCB2MiwgY29FcXVhbHMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IGRhdGFUeXBlID0gPGFueT5kcC5kYXRhVHlwZTsgLy8gdGhpcyB3aWxsIGJlIGEgY29tcGxleFR5cGUgd2hlbiBkcCBpcyBhIGNvbXBsZXhQcm9wZXJ0eVxyXG4gICAgICByZXR1cm4gKHYxID09PSB2MiB8fCAoZGF0YVR5cGUgJiYgZGF0YVR5cGUubm9ybWFsaXplICYmIHYxICYmIHYyICYmIGRhdGFUeXBlLm5vcm1hbGl6ZSh2MSkgPT09IGRhdGFUeXBlLm5vcm1hbGl6ZSh2MikpKTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gYXJlRXF1YWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvY2FsUHJvcHNPbmx5KHByb3BzOiBFbnRpdHlQcm9wZXJ0eVtdKSB7XHJcbiAgcmV0dXJuIHByb3BzLmZpbHRlcihmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgcmV0dXJuIHByb3AuYmFzZVByb3BlcnR5ID09IG51bGw7XHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZXNvbHZlQ3AoY3A6IERhdGFQcm9wZXJ0eSwgbWV0YWRhdGFTdG9yZTogTWV0YWRhdGFTdG9yZSkge1xyXG4gIGxldCBjb21wbGV4VHlwZSA9IG1ldGFkYXRhU3RvcmUuX2dldFN0cnVjdHVyYWxUeXBlKGNwLmNvbXBsZXhUeXBlTmFtZSwgdHJ1ZSk7XHJcbiAgaWYgKCFjb21wbGV4VHlwZSkgcmV0dXJuIGZhbHNlO1xyXG4gIGlmICghKGNvbXBsZXhUeXBlIGluc3RhbmNlb2YgQ29tcGxleFR5cGUpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBDb21wbGV4VHlwZSB3aXRoIHRoZSBuYW1lOiBcIiArIGNwLmNvbXBsZXhUeXBlTmFtZSArIFwiIGZvciB0aGUgcHJvcGVydHk6IFwiICsgY3AubmFtZSk7XHJcbiAgfVxyXG4gIGNwLmRhdGFUeXBlID0gY29tcGxleFR5cGU7XHJcbiAgY3AuZGVmYXVsdFZhbHVlID0gbnVsbDtcclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJ5UmVzb2x2ZU5wKG5wOiBOYXZpZ2F0aW9uUHJvcGVydHksIG1ldGFkYXRhU3RvcmU6IE1ldGFkYXRhU3RvcmUpIHtcclxuICBpZiAobnAuZW50aXR5VHlwZSkgcmV0dXJuIHRydWU7XHJcblxyXG4gIGxldCBlbnRpdHlUeXBlID0gbWV0YWRhdGFTdG9yZS5fZ2V0U3RydWN0dXJhbFR5cGUobnAuZW50aXR5VHlwZU5hbWUsIHRydWUpIGFzIEVudGl0eVR5cGU7XHJcbiAgaWYgKGVudGl0eVR5cGUpIHtcclxuICAgIG5wLmVudGl0eVR5cGUgPSBlbnRpdHlUeXBlO1xyXG4gICAgbnAuX3Jlc29sdmVOcCgpO1xyXG4gICAgLy8gZG9uJ3QgYm90aGVyIHJlbW92aW5nIC0gX3VwZGF0ZU5wcyB3aWxsIGRvIGl0IGxhdGVyLlxyXG4gICAgLy8gX19hcnJheVJlbW92ZUl0ZW0oaW5jb21wbGV0ZU5wcywgbnAsIGZhbHNlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbGV0IGluY29tcGxldGVOcHMgPSBjb3JlLmdldEFycmF5KG1ldGFkYXRhU3RvcmUuX2luY29tcGxldGVUeXBlTWFwLCBucC5lbnRpdHlUeXBlTmFtZSk7XHJcbiAgICBjb3JlLmFycmF5QWRkSXRlbVVuaXF1ZShpbmNvbXBsZXRlTnBzLCBucCk7XHJcbiAgfVxyXG4gIHJldHVybiAhIWVudGl0eVR5cGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGNVbm1hcHBlZFByb3BlcnRpZXMoc3R5cGU6IFN0cnVjdHVyYWxUeXBlLCBpbnN0YW5jZTogYW55KSB7XHJcbiAgbGV0IG1ldGFkYXRhUHJvcE5hbWVzID0gc3R5cGUuZ2V0UHJvcGVydHlOYW1lcygpO1xyXG4gIGxldCBtb2RlbExpYiA9IGNvbmZpZy5pbnRlcmZhY2VSZWdpc3RyeS5tb2RlbExpYnJhcnkuZ2V0RGVmYXVsdEluc3RhbmNlKCk7XHJcbiAgbGV0IHRyYWNrYWJsZVByb3BOYW1lcyA9IG1vZGVsTGliLmdldFRyYWNrYWJsZVByb3BlcnR5TmFtZXMoaW5zdGFuY2UpO1xyXG4gIHRyYWNrYWJsZVByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwbjogc3RyaW5nKSB7XHJcbiAgICBpZiAobWV0YWRhdGFQcm9wTmFtZXMuaW5kZXhPZihwbikgPT09IC0xKSB7XHJcbiAgICAgIGxldCB2YWwgPSBpbnN0YW5jZVtwbl07XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIikgdmFsID0gdmFsKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgfVxyXG4gICAgICBsZXQgZHQgPSBEYXRhVHlwZS5mcm9tVmFsdWUodmFsKTtcclxuICAgICAgbGV0IG5ld1Byb3AgPSBuZXcgRGF0YVByb3BlcnR5KHtcclxuICAgICAgICBuYW1lOiBwbixcclxuICAgICAgICBkYXRhVHlwZTogZHQsXHJcbiAgICAgICAgaXNOdWxsYWJsZTogdHJ1ZSxcclxuICAgICAgICBpc1VubWFwcGVkOiB0cnVlXHJcbiAgICAgIH0pO1xyXG4gICAgICBuZXdQcm9wLmlzU2V0dGFibGUgPSBjb3JlLmlzU2V0dGFibGUoaW5zdGFuY2UsIHBuKTtcclxuICAgICAgaWYgKHN0eXBlIGluc3RhbmNlb2YgRW50aXR5VHlwZSAmJiBzdHlwZS5zdWJ0eXBlcyAhPSBudWxsICYmIHN0eXBlLnN1YnR5cGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHN0eXBlLmdldFNlbGZBbmRTdWJ0eXBlcygpLmZvckVhY2goKHN0KSA9PiB7XHJcbiAgICAgICAgICBzdC5fYWRkUHJvcGVydHlDb3JlKG5ldyBEYXRhUHJvcGVydHkobmV3UHJvcCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0eXBlLl9hZGRQcm9wZXJ0eUNvcmUobmV3UHJvcCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV4VHlwZUNvbmZpZyB7XHJcbiAgc2hvcnROYW1lPzogc3RyaW5nO1xyXG4gIG5hbWVzcGFjZT86IHN0cmluZztcclxuICBkYXRhUHJvcGVydGllcz86IERhdGFQcm9wZXJ0eVtdIHwgT2JqZWN0W10gfCBPYmplY3Q7XHJcbiAgaXNDb21wbGV4VHlwZT86IGJvb2xlYW47ICAvLyBuZWVkZWQgYmVjYXVzZSB0aGlzIGN0b3IgY2FuIGdldCBjYWxsZWQgZnJvbSB0aGUgYWRkRW50aXR5VHlwZSBtZXRob2Qgd2hpY2ggbmVlZHMgdGhlIGlzQ29tcGxleFR5cGUgcHJvcFxyXG4gIGN1c3RvbT86IE9iamVjdDtcclxufVxyXG5cclxuLyoqICBDb250YWluZXIgZm9yIGFsbCBvZiB0aGUgbWV0YWRhdGEgYWJvdXQgYSBzcGVjaWZpYyB0eXBlIG9mIENvbXBsZXggb2JqZWN0LlxyXG4+ICAgICBsZXQgY29tcGxleFR5cGUgPSBuZXcgQ29tcGxleFR5cGUoIHtcclxuPiAgICAgICAgIHNob3J0TmFtZTogXCJhZGRyZXNzXCIsXHJcbj4gICAgICAgICBuYW1lc3BhY2U6IFwibXlBcHBOYW1lc3BhY2VcIlxyXG4+ICAgICB9KTtcclxuQHBhcmFtIGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gc2V0dGluZ3NcclxuKiovXHJcbmV4cG9ydCBjbGFzcyBDb21wbGV4VHlwZSB7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgXyR0eXBlTmFtZTogc3RyaW5nOyAvLyBvbiBwcm90b1xyXG4gIC8qKiBGb3IgcG9seW1vcnBoaWMgcHVycG9zZSBvbmx5IC0gYWx3YXlzIHRydWUgaGVyZSAqL1xyXG4gIGlzQ29tcGxleFR5cGUgPSB0cnVlO1xyXG5cclxuICAvKiogVGhlIFtbTWV0YWRhdGFTdG9yZV1dIGNvbnRhaW5pbmcgdGhpcyBDb21wbGV4VHlwZS4gKi9cclxuICBtZXRhZGF0YVN0b3JlOiBNZXRhZGF0YVN0b3JlO1xyXG5cclxuICAvKiogIFRoZSBmdWxseSBxdWFsaWZlZCBuYW1lIG9mIHRoaXMgQ29tcGxleFR5cGUuIF9fUmVhZCBPbmx5X18gICoqL1xyXG4gIG5hbWU6IHN0cmluZztcclxuICAvKiogIFRoZSBzaG9ydCwgdW5xdWFsaWZpZWQsIG5hbWUgZm9yIHRoaXMgQ29tcGxleFR5cGUuIF9fUmVhZCBPbmx5X18gKiovXHJcbiAgc2hvcnROYW1lOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBUaGUgbmFtZXNwYWNlIGZvciB0aGlzIENvbXBsZXhUeXBlLiBfX1JlYWQgT25seV9fICoqL1xyXG4gIG5hbWVzcGFjZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgRGF0YVByb3BlcnRpZXMgKHNlZSBbW0RhdGFQcm9wZXJ0eV1dIGFzc29jaWF0ZWQgd2l0aCB0aGlzIENvbXBsZXhUeXBlLiBfX1JlYWQgT25seV9fICovXHJcbiAgZGF0YVByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG4gIC8qKiBUaGUgRGF0YVByb3BlcnRpZXMgZm9yIHRoaXMgQ29tcGxleFR5cGUgdGhhdCBjb250YWluIGluc3RhbmNlcyBvZiBhIFtbQ29tcGxleFR5cGVdXS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGNvbXBsZXhQcm9wZXJ0aWVzOiBEYXRhUHJvcGVydHlbXTtcclxuXHJcbiAgLyoqXHJcbiAgVGhlIGVudGl0eSBsZXZlbCB2YWxpZGF0b3JzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIENvbXBsZXhUeXBlLiBWYWxpZGF0b3JzIGNhbiBiZSBhZGRlZCBhbmRcclxuICByZW1vdmVkIGZyb20gdGhpcyBjb2xsZWN0aW9uLiBfX1JlYWQgT25seV9fICAqKi9cclxuICB2YWxpZGF0b3JzOiBWYWxpZGF0b3JbXTtcclxuICAvKiogRm9yIHBvbHltb3JwaGljIHB1cnBvc2Ugb25seSAtIGFsd2F5cyBlbXB0eSBoZXJlICovXHJcbiAgY29uY3VycmVuY3lQcm9wZXJ0aWVzOiBEYXRhUHJvcGVydHlbXTtcclxuICAvKiogVGhlIERhdGFQcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIENvbXBsZXhUeXBlIHRoYXQgYXJlIG5vdCBtYXBwZWQgdG8gYW55IGJhY2tlbmQgZGF0YXN0b3JlLiBUaGVzZSBhcmUgZWZmZWN0aXZlbHkgZnJlZSBzdGFuZGluZ1xyXG4gIHByb3BlcnRpZXMuIF9fUmVhZCBPbmx5X18gICAqKi9cclxuICB1bm1hcHBlZFByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG5cclxuICAvLyBrZXlQcm9wZXJ0aWVzIGFuZCBuYXZpZ2F0aW9uUHJvcGVydGllcyBhcmUgbm90IHVzZWQgb24gY29tcGxleFR5cGVzIC0gYnV0IGhlcmUgdG8gYWxsb3cgc2hhcmluZyBvZiBjb2RlIGJldHdlZW4gRW50aXR5VHlwZSBhbmQgQ29tcGxleFR5cGUuXHJcbiAgbmF2aWdhdGlvblByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG4gIC8vIGFuZCBtYXkgYmUgdXNlZCBsYXRlciB0byBlbmZvcmNlIHVuaXF1ZW5lc3Mgb24gYXJyYXlzIG9mIGNvbXBsZXh0eXBlcy5cclxuICBrZXlQcm9wZXJ0aWVzOiBEYXRhUHJvcGVydHlbXTtcclxuICB3YXJuaW5nczogYW55W107XHJcbiAgc2VyaWFsaXplckZuPzogKHByb3A6IEVudGl0eVByb3BlcnR5LCB2YWw6IGFueSkgPT4gYW55O1xyXG5cclxuICAvKiogQSBmcmVlIGZvcm0gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGFueSBjdXN0b20gbWV0YWRhdGEgZm9yIHRoaXMgQ29tcGxleFR5cGUuICoqKi9cclxuICBjdXN0b20/OiBhbnk7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX21hcHBlZFByb3BlcnRpZXNDb3VudDogbnVtYmVyO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9leHRyYT86IGFueTtcclxuXHJcbiAgLy8gY29weSBlbnRpdHlUeXBlIG1ldGhvZHMgb250byBjb21wbGV4VHlwZVxyXG4gIC8qKiBTZWUgW1tFbnRpdHlUeXBlLmdldEN0b3JdXSAqL1xyXG4gIGdldEN0b3IgPSBFbnRpdHlUeXBlLnByb3RvdHlwZS5nZXRDdG9yO1xyXG4gIC8vIG5vdGUgdGhlIG5hbWUgY2hhbmdlLlxyXG4gIGNyZWF0ZUluc3RhbmNlID0gRW50aXR5VHlwZS5wcm90b3R5cGUuY3JlYXRlRW50aXR5O1xyXG4gIC8qKiBTZWUgW0VudGl0eVR5cGUuYWRkVmFsaWRhdG9yXSAqL1xyXG4gIGFkZFZhbGlkYXRvciA9IEVudGl0eVR5cGUucHJvdG90eXBlLmFkZFZhbGlkYXRvcjtcclxuICBnZXRQcm9wZXJ0eSA9IEVudGl0eVR5cGUucHJvdG90eXBlLmdldFByb3BlcnR5O1xyXG4gIGdldFByb3BlcnRpZXNPblBhdGggPSBFbnRpdHlUeXBlLnByb3RvdHlwZS5nZXRQcm9wZXJ0aWVzT25QYXRoO1xyXG4gIGdldFByb3BlcnR5TmFtZXMgPSBFbnRpdHlUeXBlLnByb3RvdHlwZS5nZXRQcm9wZXJ0eU5hbWVzO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9hZGRQcm9wZXJ0eUNvcmUgPSBFbnRpdHlUeXBlLnByb3RvdHlwZS5fYWRkUHJvcGVydHlDb3JlO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9hZGREYXRhUHJvcGVydHkgPSBFbnRpdHlUeXBlLnByb3RvdHlwZS5fYWRkRGF0YVByb3BlcnR5O1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF91cGRhdGVOYW1lcyA9IEVudGl0eVR5cGUucHJvdG90eXBlLl91cGRhdGVOYW1lcztcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfdXBkYXRlQ3BzID0gRW50aXR5VHlwZS5wcm90b3R5cGUuX3VwZGF0ZUNwcztcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfaW5pdGlhbGl6ZUluc3RhbmNlID0gRW50aXR5VHlwZS5wcm90b3R5cGUuX2luaXRpYWxpemVJbnN0YW5jZTtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfdXBkYXRlVGFyZ2V0RnJvbVJhdyA9IEVudGl0eVR5cGUucHJvdG90eXBlLl91cGRhdGVUYXJnZXRGcm9tUmF3O1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9zZXRDdG9yID0gRW50aXR5VHlwZS5wcm90b3R5cGUuX3NldEN0b3I7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogQ29tcGxleFR5cGVDb25maWcpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgQ29tcGxleFR5cGUgY3RvciBoYXMgYSBzaW5nbGUgYXJndW1lbnQgdGhhdCBpcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3NlcnRDb25maWcoY29uZmlnKVxyXG4gICAgICAud2hlcmVQYXJhbShcInNob3J0TmFtZVwiKS5pc05vbkVtcHR5U3RyaW5nKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJuYW1lc3BhY2VcIikuaXNTdHJpbmcoKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQoXCJcIilcclxuICAgICAgLndoZXJlUGFyYW0oXCJkYXRhUHJvcGVydGllc1wiKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJpc0NvbXBsZXhUeXBlXCIpLmlzT3B0aW9uYWwoKS5pc0Jvb2xlYW4oKSAgIC8vIG5lZWRlZCBiZWNhdXNlIHRoaXMgY3RvciBjYW4gZ2V0IGNhbGxlZCBmcm9tIHRoZSBhZGRFbnRpdHlUeXBlIG1ldGhvZCB3aGljaCBuZWVkcyB0aGUgaXNDb21wbGV4VHlwZSBwcm9wXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiY3VzdG9tXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAuYXBwbHlBbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gcXVhbGlmeVR5cGVOYW1lKHRoaXMuc2hvcnROYW1lLCB0aGlzLm5hbWVzcGFjZSk7XHJcbiAgICB0aGlzLmlzQ29tcGxleFR5cGUgPSB0cnVlO1xyXG4gICAgdGhpcy5kYXRhUHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy5jb21wbGV4UHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy52YWxpZGF0b3JzID0gW107XHJcbiAgICB0aGlzLmNvbmN1cnJlbmN5UHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy51bm1hcHBlZFByb3BlcnRpZXMgPSBbXTtcclxuICAgIHRoaXMuX21hcHBlZFByb3BlcnRpZXNDb3VudCA9IDA7XHJcbiAgICAvLyBrZXlQcm9wZXJ0aWVzIGFuZCBuYXZpZ2F0aW9uUHJvcGVydGllcyBhcmUgbm90IHVzZWQgb24gY29tcGxleFR5cGVzIC0gYnV0IGhlcmUgdG8gYWxsb3cgc2hhcmluZyBvZiBjb2RlIGJldHdlZW4gRW50aXR5VHlwZSBhbmQgQ29tcGxleFR5cGUuXHJcbiAgICB0aGlzLm5hdmlnYXRpb25Qcm9wZXJ0aWVzID0gW107XHJcbiAgICB0aGlzLmtleVByb3BlcnRpZXMgPSBbXTsgLy8gbWF5IGJlIHVzZWQgbGF0ZXIgdG8gZW5mb3JjZSB1bmlxdWVuZXNzIG9uIGFycmF5cyBvZiBjb21wbGV4dHlwZXMuXHJcbiAgICBpZiAoY29uZmlnLmRhdGFQcm9wZXJ0aWVzKSB7XHJcbiAgICAgIGFkZFByb3BlcnRpZXModGhpcywgY29uZmlnLmRhdGFQcm9wZXJ0aWVzLCBEYXRhUHJvcGVydHkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgR2VuZXJhbCBwdXJwb3NlIHByb3BlcnR5IHNldCBtZXRob2RcclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyXHJcbiAgPiAgICAgIGxldCBhZGRyZXNzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQWRkcmVzc1wiKTtcclxuICA+ICAgICAgYWRkcmVzc1R5cGUuc2V0UHJvcGVydGllcygge1xyXG4gID4gICAgICAgICAgY3VzdG9tOiB7IGZvbzogNywgYmFyOiBcInRlc3RcIiB9XHJcbiAgPiAgICAgIH0pO1xyXG4gIEBwYXJhbSBjb25maWcgLSBDdXN0b20gY29uZmlnIG9iamVjdFxyXG4gIEBwYXJhbSBjb25maWcuY3VzdG9tIC0ge09iamVjdH1cclxuICAqKi9cclxuICBzZXRQcm9wZXJ0aWVzKGNvbmZpZzogeyBjdXN0b20/OiBPYmplY3QgfSkge1xyXG4gICAgYXNzZXJ0Q29uZmlnKGNvbmZpZylcclxuICAgICAgLndoZXJlUGFyYW0oXCJjdXN0b21cIikuaXNPcHRpb25hbCgpXHJcbiAgICAgIC5hcHBseUFsbCh0aGlzKTtcclxuICB9XHJcblxyXG5cclxuICBnZXRBbGxWYWxpZGF0b3JzKCkge1xyXG4gICAgLy8gQ29tcGxleFR5cGUgaW5oZXJpdGFuY2UgaXMgbm90IFlFVCBzdXBwb3J0ZWQuXHJcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0b3JzO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2NyZWF0ZUluc3RhbmNlQ29yZShwYXJlbnQ6IFN0cnVjdHVyYWxPYmplY3QsIHBhcmVudFByb3BlcnR5OiBEYXRhUHJvcGVydHkpIHtcclxuICAgIGxldCBhQ3RvciA9IHRoaXMuZ2V0Q3RvcigpO1xyXG4gICAgbGV0IGluc3RhbmNlID0gbmV3IGFDdG9yKCkgYXMgQ29tcGxleE9iamVjdDtcclxuICAgIG5ldyBDb21wbGV4QXNwZWN0KGluc3RhbmNlLCBwYXJlbnQsIHBhcmVudFByb3BlcnR5KTtcclxuICAgIC8vIGluaXRpYWxpemF0aW9uIG9jY3VycyBkdXJpbmcgZWl0aGVyIGF0dGFjaCBvciBpbiBjcmVhdGVJbnN0YW5jZSBjYWxsLlxyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH1cclxuXHJcblxyXG4gIGFkZFByb3BlcnR5KGRhdGFQcm9wZXJ0eTogRGF0YVByb3BlcnR5KSB7XHJcbiAgICBhc3NlcnRQYXJhbShkYXRhUHJvcGVydHksIFwiZGF0YVByb3BlcnR5XCIpLmlzSW5zdGFuY2VPZihEYXRhUHJvcGVydHkpLmNoZWNrKCk7XHJcbiAgICByZXR1cm4gdGhpcy5fYWRkUHJvcGVydHlDb3JlKGRhdGFQcm9wZXJ0eSk7XHJcbiAgfVxyXG5cclxuICBnZXRQcm9wZXJ0aWVzKCk6IEVudGl0eVByb3BlcnR5W10ge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YVByb3BlcnRpZXM7XHJcbiAgfVxyXG5cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4gY29yZS50b0pzb24odGhpcywge1xyXG4gICAgICBzaG9ydE5hbWU6IG51bGwsXHJcbiAgICAgIG5hbWVzcGFjZTogbnVsbCxcclxuICAgICAgaXNDb21wbGV4VHlwZTogbnVsbCxcclxuICAgICAgZGF0YVByb3BlcnRpZXM6IG51bGwsXHJcbiAgICAgIHZhbGlkYXRvcnM6IG51bGwsXHJcbiAgICAgIGN1c3RvbTogbnVsbFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxufVxyXG5Db21wbGV4VHlwZS5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IFwiQ29tcGxleFR5cGVcIjtcclxuLyoqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjb21wbGV4VHlwZSAqL1xyXG5Db21wbGV4VHlwZS5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2UgPSBFbnRpdHlUeXBlLnByb3RvdHlwZS5jcmVhdGVFbnRpdHk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERhdGFQcm9wZXJ0eUNvbmZpZyB7XHJcbiAgbmFtZT86IHN0cmluZztcclxuICBuYW1lT25TZXJ2ZXI/OiBzdHJpbmc7XHJcbiAgZGF0YVR5cGU/OiBEYXRhVHlwZSB8IHN0cmluZyB8IENvbXBsZXhUeXBlO1xyXG4gIGNvbXBsZXhUeXBlTmFtZT86IHN0cmluZztcclxuICBpc051bGxhYmxlPzogYm9vbGVhbjtcclxuICBpc1NjYWxhcj86IGJvb2xlYW47IC8vIHdpbGwgYmUgZmFsc2UgZm9yIHNvbWUgTm9TUUwgZGF0YWJhc2VzLlxyXG4gIGRlZmF1bHRWYWx1ZT86IGFueTtcclxuICBpc1BhcnRPZktleT86IGJvb2xlYW47XHJcbiAgaXNVbm1hcHBlZD86IGJvb2xlYW47XHJcbiAgaXNTZXR0YWJsZT86IGJvb2xlYW47XHJcbiAgY29uY3VycmVuY3lNb2RlPzogc3RyaW5nO1xyXG4gIG1heExlbmd0aD86IG51bWJlcjtcclxuICB2YWxpZGF0b3JzPzogVmFsaWRhdG9yW107XHJcbiAgZGlzcGxheU5hbWU/OiBzdHJpbmc7XHJcbiAgZW51bVR5cGU/OiBhbnk7XHJcbiAgcmF3VHlwZU5hbWU/OiBzdHJpbmc7ICAvLyBvY2N1cnMgd2l0aCB1bmRlZmluZWQgZGF0YXR5cGVzXHJcbiAgY3VzdG9tPzogT2JqZWN0O1xyXG59XHJcblxyXG4vKipcclxuQSBEYXRhUHJvcGVydHkgZGVzY3JpYmVzIHRoZSBtZXRhZGF0YSBmb3IgYSBzaW5nbGUgcHJvcGVydHkgb2YgYW4gIFtbRW50aXR5VHlwZV1dIHRoYXQgY29udGFpbnMgc2ltcGxlIGRhdGEuXHJcblxyXG5JbnN0YW5jZXMgb2YgdGhlIERhdGFQcm9wZXJ0eSBjbGFzcyBhcmUgY29uc3RydWN0ZWQgYXV0b21hdGljYWxseSBkdXJpbmcgTWV0YWRhdGEgcmV0cmlldmFsLiBIb3dldmVyIGl0IGlzIGFsc28gcG9zc2libGUgdG8gY29uc3RydWN0IHRoZW1cclxuZGlyZWN0bHkgdmlhIHRoZSBjb25zdHJ1Y3Rvci5cclxuKiovXHJcbmV4cG9ydCBjbGFzcyBEYXRhUHJvcGVydHkge1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF8kdHlwZU5hbWU6IHN0cmluZzsgLy8gb24gcHJvdG9cclxuICAvKiogSXMgdGhpcyBhIERhdGFQcm9wZXJ0eT8gLSBhbHdheXMgdHJ1ZSBoZXJlLiBBbGxvd3MgcG9seW1vcnBoaWMgdHJlYXRtZW50IG9mIERhdGFQcm9wZXJ0aWVzIGFuZCBOYXZpZ2F0aW9uUHJvcGVydGllcy4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGlzRGF0YVByb3BlcnR5ID0gdHJ1ZTtcclxuICAvKiogSXMgdGhpcyBhIE5hdmlnYXRpb25Qcm9wZXJ0eT8gLSBhbHdheXMgZmFsc2UgaGVyZS4gIEFsbG93cyBwb2x5bW9ycGhpYyB0cmVhdG1lbnQgb2YgRGF0YVByb3BlcnRpZXMgYW5kIE5hdmlnYXRpb25Qcm9wZXJ0aWVzLiBfX1JlYWQgT25seV9fICovXHJcbiAgaXNOYXZpZ2F0aW9uUHJvcGVydHkgPSBmYWxzZTtcclxuICAvKiogVGhlIG5hbWUgb2YgdGhpcyBwcm9wZXJ0eS4gX19SZWFkIE9ubHlfXyAgKiovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgbmFtZSBvZiB0aGlzIHByb3BlcnR5IG9uIHRoZSBzZXJ2ZXIuIF9fUmVhZCBPbmx5X18gKiovXHJcbiAgbmFtZU9uU2VydmVyOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBbW0RhdGFUeXBlXV0gb2YgdGhpcyBwcm9wZXJ0eS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGRhdGFUeXBlOiBEYXRhVHlwZSB8IENvbXBsZXhUeXBlOyAvLyB0aGlzIHdpbGwgYmUgYSBjb21wbGV4VHlwZSB3aGVuIGRwIGlzIGEgY29tcGxleFByb3BlcnR5XHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBbW0NvbXBsZXhUeXBlXV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHJvcGVydHk7IG1heSBiZSBudWxsLiBfX1JlYWQgT25seV9fICovXHJcbiAgY29tcGxleFR5cGVOYW1lOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBbW0NvbXBsZXhUeXBlXV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcHJvcGVydHk7IG1heSBiZSB1bmRlZmluZWQuIF9fUmVhZCBPbmx5X18gKi9cclxuICBjb21wbGV4VHlwZT86IENvbXBsZXhUeXBlO1xyXG4gIC8qKiAgV2hldGhlciB0aGUgY29udGVudHMgb2YgdGhpcyBwcm9wZXJ0eSBpcyBhbiBpbnN0YW5jZSBvZiBhIFtbQ29tcGxleFR5cGVdXS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGlzQ29tcGxleFByb3BlcnR5OiBib29sZWFuO1xyXG4gIC8qKiBXaGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgbnVsbGFibGUuIF9fUmVhZCBPbmx5X18gKi9cclxuICBpc051bGxhYmxlOiBib29sZWFuO1xyXG4gIC8qKiAgV2hldGhlciB0aGlzIHByb3BlcnR5IGlzIHNjYWxhciAoaS5lLiwgcmV0dXJucyBhIHNpbmdsZSB2YWx1ZSBhcyBvcHBvc2VkIHRvIGFuIGFycmF5KS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGlzU2NhbGFyOiBib29sZWFuOyAvLyB3aWxsIGJlIGZhbHNlIGZvciBzb21lIE5vU1FMIGRhdGFiYXNlcy5cclxuICAvKiogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBkZWZhdWx0VmFsdWU6IGFueTtcclxuICAvKiogIFdoZXRoZXIgdGhpcyBwcm9wZXJ0eSBpcyBhICdrZXknIHByb3BlcnR5LiBfX1JlYWQgT25seV9fICovXHJcbiAgaXNQYXJ0T2ZLZXk6IGJvb2xlYW47XHJcbiAgLyoqIFdoZXRoZXIgdGhpcyBwcm9wZXJ0eSBpcyBhbiAndW5tYXBwZWQnIHByb3BlcnR5LiBfX1JlYWQgT25seV9fICovXHJcbiAgaXNVbm1hcHBlZDogYm9vbGVhbjtcclxuICAvKiogV2hldGhlciB0aGlzIHByb3BlcnR5IGlzICdzZXR0YWJsZScuIF9fUmVhZCBPbmx5X18gKi9cclxuICBpc1NldHRhYmxlOiBib29sZWFuO1xyXG4gIC8vIFRPRE86IGRvYyB0aGlzXHJcbiAgY29uY3VycmVuY3lNb2RlOiBzdHJpbmc7XHJcbiAgLyoqICBUaGUgbWF4aW11bSBsZW5ndGggZm9yIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5LiBPbmx5IG1lYW5pbmdmdWwgZm9yIHN0cmluZ3MuIF9fUmVhZCBPbmx5X18gKi9cclxuICBtYXhMZW5ndGg/OiBudW1iZXI7XHJcbiAgLyoqIFRoZSBbW1ZhbGlkYXRvcl1dIGluc3RhbmNlcyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBwcm9wZXJ0eS4gVmFsaWRhdG9ycyBjYW4gYmUgYWRkZWQgYW5kXHJcbiAgcmVtb3ZlZCBmcm9tIHRoaXMgY29sbGVjdGlvbi4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIHZhbGlkYXRvcnM6IFZhbGlkYXRvcltdO1xyXG4gIC8qKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoaXMgcHJvcGVydHkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBkaXNwbGF5TmFtZTogc3RyaW5nO1xyXG4gIC8vIFRPRE86IGRvYyB0aGlzXHJcbiAgZW51bVR5cGU/OiBhbnk7XHJcbiAgLyoqIFRoZSByYXcgdHlwZSBuYW1lIG9mIHRoaXMgcHJvcGVydHkuIHdpbGwgb25seSBiZSBkZWZpbmVkIGZvciBwcm9wZXJ0aWVzIHdpdGggYSBEYXRhVHlwZSBvZiAnVW5kZWZpbmVkJyAqL1xyXG4gIHJhd1R5cGVOYW1lPzogc3RyaW5nOyAgLy8gb2NjdXJzIHdpdGggdW5kZWZpbmVkIGRhdGF0eXBlc1xyXG4gIC8qKiAgQSBmcmVlIGZvcm0gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGFueSBjdXN0b20gbWV0YWRhdGEgZm9yIHRoaXMgRGF0YVByb3BlcnR5LiBfX1JlYWQgT25seV9fICovXHJcbiAgY3VzdG9tPzogT2JqZWN0O1xyXG4gIC8vIFRPRE86IGRvYyB0aGlzXHJcbiAgaW52ZXJzZU5hdmlnYXRpb25Qcm9wZXJ0eT86IE5hdmlnYXRpb25Qcm9wZXJ0eTtcclxuICAvKipcclxuICBUaGUgbmF2aWdhdGlvbiBwcm9wZXJ0eSByZWxhdGVkIHRvIHRoaXMgcHJvcGVydHkuICBXaWxsIG9ubHkgYmUgc2V0IGlmIHRoaXMgaXMgYSBmb3JlaWduIGtleSBwcm9wZXJ0eS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIHJlbGF0ZWROYXZpZ2F0aW9uUHJvcGVydHk/OiBOYXZpZ2F0aW9uUHJvcGVydHk7XHJcbiAgLyoqIFRoZSBwYXJlbnQgdHlwZSB0aGF0IHRoaXMgcHJvcGVydHkgYmVsb25ncyB0byAtIHdpbGwgYmUgZWl0aGVyIGEgW1tFbnRpdHlUeXBlXV0gb3IgYSBbW0NvbXBsZXhUeXBlXV0uIF9fUmVhZCBPbmx5X18gKi9cclxuICBwYXJlbnRUeXBlOiBTdHJ1Y3R1cmFsVHlwZTtcclxuICAvKiogUHJvcGVydHkgb24gdGhlIGJhc2UgdHlwZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgaW5oZXJpdGVkIGZyb20uIFdpbGwgYmUgbnVsbCBpZiB0aGUgcHJvcGVydHkgaXMgbm90IG9uIHRoZSBiYXNlIHR5cGUuIF9fUmVhZCBPbmx5X18gKi9cclxuICBiYXNlUHJvcGVydHk/OiBEYXRhUHJvcGVydHk7XHJcblxyXG4gIC8qKiBEYXRhUHJvcGVydHkgY29uc3RydWN0b3JcclxuICA+ICAgICAgbGV0IGxhc3ROYW1lUHJvcCA9IG5ldyBEYXRhUHJvcGVydHkoIHtcclxuICA+ICAgICAgICAgIG5hbWU6IFwibGFzdE5hbWVcIixcclxuICA+ICAgICAgICAgIGRhdGFUeXBlOiBEYXRhVHlwZS5TdHJpbmcsXHJcbiAgPiAgICAgICAgICBpc051bGxhYmxlOiB0cnVlLFxyXG4gID4gICAgICAgICAgbWF4TGVuZ3RoOiAyMFxyXG4gID4gICAgICB9KTtcclxuICA+ICAgICAgLy8gYXNzdW1pbmcgcGVyc29uRW50aXR5VHlwZSBpcyBhIG5ld2x5IGNvbnN0cnVjdGVkIEVudGl0eVR5cGVcclxuICA+ICAgICAgcGVyc29uRW50aXR5VHlwZS5hZGRQcm9wZXJ0eShsYXN0TmFtZVByb3BlcnR5KTtcclxuICBAcGFyYW0gY29uZmlnIC0gQSBjb25maWd1cmF0aW9uIE9iamVjdCBvciBhIERhdGFQcm9wZXJ0eVxyXG4gICovXHJcbiAgY29uc3RydWN0b3IoY29uZmlnOiBEYXRhUHJvcGVydHlDb25maWcgfCBEYXRhUHJvcGVydHkpIHtcclxuICAgIGFzc2VydENvbmZpZyhjb25maWcpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwibmFtZVwiKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcIm5hbWVPblNlcnZlclwiKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImRhdGFUeXBlXCIpLmlzRW51bU9mKERhdGFUeXBlKS5pc09wdGlvbmFsKCkub3IoKS5pc1N0cmluZygpLm9yKCkuaXNJbnN0YW5jZU9mKENvbXBsZXhUeXBlKVxyXG4gICAgICAud2hlcmVQYXJhbShcImNvbXBsZXhUeXBlTmFtZVwiKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJpc051bGxhYmxlXCIpLmlzQm9vbGVhbigpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdCh0cnVlKVxyXG4gICAgICAud2hlcmVQYXJhbShcImlzU2NhbGFyXCIpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdCh0cnVlKS8vIHdpbGwgYmUgZmFsc2UgZm9yIHNvbWUgTm9TUUwgZGF0YWJhc2VzLlxyXG4gICAgICAud2hlcmVQYXJhbShcImRlZmF1bHRWYWx1ZVwiKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJpc1BhcnRPZktleVwiKS5pc0Jvb2xlYW4oKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJpc1VubWFwcGVkXCIpLmlzQm9vbGVhbigpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImlzU2V0dGFibGVcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KHRydWUpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiY29uY3VycmVuY3lNb2RlXCIpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwibWF4TGVuZ3RoXCIpLmlzTnVtYmVyKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwidmFsaWRhdG9yc1wiKS5pc0luc3RhbmNlT2YoVmFsaWRhdG9yKS5pc0FycmF5KCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KFtdKVxyXG4gICAgICAud2hlcmVQYXJhbShcImRpc3BsYXlOYW1lXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImVudW1UeXBlXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcInJhd1R5cGVOYW1lXCIpLmlzT3B0aW9uYWwoKSAvLyBvY2N1cnMgd2l0aCB1bmRlZmluZWQgZGF0YXR5cGVzXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiY3VzdG9tXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAuYXBwbHlBbGwodGhpcyk7XHJcbiAgICBsZXQgaGFzTmFtZSA9ICEhKHRoaXMubmFtZSB8fCB0aGlzLm5hbWVPblNlcnZlcik7XHJcbiAgICBpZiAoIWhhc05hbWUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBEYXRhUHJvcGVydHkgbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBlaXRoZXIgYSAnbmFtZScgb3IgYSAnbmFtZU9uU2VydmVyJyBwcm9wZXJ0eVwiKTtcclxuICAgIH1cclxuICAgIC8vIG5hbWUvbmFtZU9uU2VydmVyIGlzIHJlc29sdmVkIGxhdGVyIHdoZW4gYSBtZXRhZGF0YVN0b3JlIGlzIGF2YWlsYWJsZS5cclxuXHJcbiAgICBpZiAodGhpcy5jb21wbGV4VHlwZU5hbWUpIHtcclxuICAgICAgdGhpcy5pc0NvbXBsZXhQcm9wZXJ0eSA9IHRydWU7XHJcbiAgICAgIC8vIHRoaXMuZGF0YVR5cGUgPSBudWxsOyAvLyBUT0RPOiB3b3VsZCBsaWtlIHRvIHJlbW92ZSB0aGlzIGxpbmUgYmVjYXVzZSBkYXRhVHlwZSB3aWxsIGJlIHNldCBsYXRlci5cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mICh0aGlzLmRhdGFUeXBlKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICBsZXQgZHQgPSBEYXRhVHlwZS5mcm9tTmFtZSh0aGlzLmRhdGFUeXBlKTtcclxuICAgICAgaWYgKCFkdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGEgRGF0YVR5cGUgZW51bWVyYXRpb24gYnkgdGhlIG5hbWUgb2Y6IFwiICsgdGhpcy5kYXRhVHlwZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5kYXRhVHlwZSA9IGR0O1xyXG4gICAgfSBlbHNlIGlmICghdGhpcy5kYXRhVHlwZSkge1xyXG4gICAgICB0aGlzLmRhdGFUeXBlID0gRGF0YVR5cGUuU3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vID09IGFzIG9wcG9zZWQgdG8gPT09IGlzIGRlbGliZXJhdGUgaGVyZS5cclxuICAgIGlmICh0aGlzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgIGlmICh0aGlzLmlzTnVsbGFibGUpIHtcclxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV4UHJvcGVydHkpIHtcclxuICAgICAgICAgIC8vIHdoYXQgdG8gZG8/IC0gc2hvdWxkbid0IGhhcHBlbiBmcm9tIEVGIC0gYnV0IG90aGVyd2lzZSA/Pz9cclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVR5cGUgPT09IERhdGFUeXBlLkJpbmFyeSkge1xyXG4gICAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBcIkFBQUFBQUFBSjNVPVwiOyAvLyBoYWNrIGZvciBhbGwgYmluYXJ5IGZpZWxkcyBidXQgdmFsdWUgaXMgc3BlY2lmaWNhbGx5IHZhbGlkIGZvciB0aW1lc3RhbXAgZmllbGRzIC0gYXJiaXRyYXJ5IHZhbGlkIDggYnl0ZSBiYXNlNjQgdmFsdWUuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gKHRoaXMuZGF0YVR5cGUgYXMgYW55KS5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIG5vbm51bGxhYmxlIERhdGFQcm9wZXJ0eSBjYW5ub3QgaGF2ZSBhIG51bGwgZGVmYXVsdFZhbHVlLiBOYW1lOiBcIiArICh0aGlzLm5hbWUgfHwgdGhpcy5uYW1lT25TZXJ2ZXIpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoKHRoaXMuZGF0YVR5cGUgYXMgYW55KS5pc051bWVyaWMpIHtcclxuICAgICAgLy8gaW4gY2FzZSB0aGUgZGVmYXVsdFZhbHVlIGNvbWVzIGluIGFzIGEgc3RyaW5nICggd2hpY2ggaXQgZG9lcyBpbiBFRjYpLlxyXG4gICAgICBpZiAodHlwZW9mICh0aGlzLmRlZmF1bHRWYWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5kZWZhdWx0VmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaXNDb21wbGV4UHJvcGVydHkpIHtcclxuICAgICAgdGhpcy5pc1NjYWxhciA9IHRoaXMuaXNTY2FsYXIgPT0gbnVsbCB8fCB0aGlzLmlzU2NhbGFyID09PSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRSYXdWYWx1ZUZyb21TZXJ2ZXIocmF3RW50aXR5OiBPYmplY3QsIGRwOiBEYXRhUHJvcGVydHkpIHtcclxuICAgIGlmIChkcC5pc1VubWFwcGVkKSB7XHJcbiAgICAgIHJldHVybiByYXdFbnRpdHlbZHAubmFtZU9uU2VydmVyIHx8IGRwLm5hbWVdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IHZhbCA9IHJhd0VudGl0eVtkcC5uYW1lT25TZXJ2ZXJdO1xyXG4gICAgICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgPyB2YWwgOiBkcC5kZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0UmF3VmFsdWVGcm9tQ2xpZW50KHJhd0VudGl0eTogT2JqZWN0LCBkcDogRGF0YVByb3BlcnR5KSB7XHJcbiAgICBsZXQgdmFsID0gcmF3RW50aXR5W2RwLm5hbWVdO1xyXG4gICAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogZHAuZGVmYXVsdFZhbHVlO1xyXG4gIH1cclxuXHJcbiAgcmVzb2x2ZVByb3BlcnR5KHByb3BOYW1lOiBzdHJpbmcpIHtcclxuICAgIGxldCByZXN1bHQgPSB0aGlzW3Byb3BOYW1lXTtcclxuICAgIGxldCBiYXNlUHJvcCA9IHRoaXMuYmFzZVByb3BlcnR5O1xyXG4gICAgd2hpbGUgKHJlc3VsdCA9PSB1bmRlZmluZWQgJiYgYmFzZVByb3AgIT0gbnVsbCkge1xyXG4gICAgICByZXN1bHQgPSBiYXNlUHJvcFtwcm9wTmFtZV07XHJcbiAgICAgIGJhc2VQcm9wID0gYmFzZVByb3AuYmFzZVByb3BlcnR5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGZvcm1hdE5hbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRUeXBlLm5hbWUgKyBcIi0tXCIgKyB0aGlzLm5hbWU7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgR2VuZXJhbCBwdXJwb3NlIHByb3BlcnR5IHNldCBtZXRob2RcclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyXHJcbiAgPiAgICAgIGxldCBwcm9wID0gbXlFbnRpdHlUeXBlLmdldFByb3BlcnR5KFwibXlQcm9wZXJ0eVwiKTtcclxuICA+ICAgICAgcHJvcC5zZXRQcm9wZXJ0aWVzKCB7XHJcbiAgPiAgICAgICAgICBjdXN0b206IHsgZm9vOiA3LCBiYXI6IFwidGVzdFwiIH1cclxuICA+ICAgICAgfSk7XHJcbiAgQHBhcmFtIGNvbmZpZyAtIEEgY29uZmlndXJhdGlvbiBvYmplY3QuXHJcbiAgKiovXHJcbiAgc2V0UHJvcGVydGllcyhjb25maWc6IHsgZGlzcGxheU5hbWU/OiBzdHJpbmcsIGN1c3RvbT86IE9iamVjdCB9KSB7XHJcbiAgICBhc3NlcnRDb25maWcoY29uZmlnKVxyXG4gICAgICAud2hlcmVQYXJhbShcImRpc3BsYXlOYW1lXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImN1c3RvbVwiKS5pc09wdGlvbmFsKClcclxuICAgICAgLmFwcGx5QWxsKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0QWxsVmFsaWRhdG9ycygpIHtcclxuICAgIGxldCB2YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLnNsaWNlKDApO1xyXG4gICAgbGV0IGJhc2VQcm9wID0gdGhpcy5iYXNlUHJvcGVydHk7XHJcbiAgICB3aGlsZSAoYmFzZVByb3ApIHtcclxuICAgICAgdmFsaWRhdG9ycy5wdXNoLmFwcGx5KHZhbGlkYXRvcnMsIGJhc2VQcm9wLnZhbGlkYXRvcnMpO1xyXG4gICAgICBiYXNlUHJvcCA9IGJhc2VQcm9wLmJhc2VQcm9wZXJ0eTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWxpZGF0b3JzO1xyXG4gIH1cclxuXHJcbiAgdG9KU09OKCkge1xyXG4gICAgLy8gZG8gbm90IHNlcmlhbGl6ZSBkYXRhVHlwZXMgdGhhdCBhcmUgY29tcGxleFR5cGVzXHJcbiAgICByZXR1cm4gY29yZS50b0pzb24odGhpcywge1xyXG4gICAgICBuYW1lOiBudWxsLFxyXG4gICAgICBkYXRhVHlwZTogZnVuY3Rpb24gKHY6IGFueSkge1xyXG4gICAgICAgIHJldHVybiAodiAmJiB2IGluc3RhbmNlb2YgRGF0YVR5cGUpID8gdi5uYW1lIDogdW5kZWZpbmVkO1xyXG4gICAgICB9LCAvLyBkbyBub3Qgc2VyaWFsaXplIGRhdGFUeXBlcyB0aGF0IGFyZSBjb21wbGV4VHlwZXNcclxuICAgICAgY29tcGxleFR5cGVOYW1lOiBudWxsLFxyXG4gICAgICBpc051bGxhYmxlOiB0cnVlLFxyXG4gICAgICBkZWZhdWx0VmFsdWU6IG51bGwsXHJcbiAgICAgIGlzUGFydE9mS2V5OiBmYWxzZSxcclxuICAgICAgaXNVbm1hcHBlZDogZmFsc2UsXHJcbiAgICAgIGlzU2V0dGFibGU6IHRydWUsXHJcbiAgICAgIGNvbmN1cnJlbmN5TW9kZTogbnVsbCxcclxuICAgICAgbWF4TGVuZ3RoOiBudWxsLFxyXG4gICAgICB2YWxpZGF0b3JzOiBudWxsLFxyXG4gICAgICBkaXNwbGF5TmFtZTogbnVsbCxcclxuICAgICAgZW51bVR5cGU6IG51bGwsXHJcbiAgICAgIHJhd1R5cGVOYW1lOiBudWxsLFxyXG4gICAgICBpc1NjYWxhcjogdHJ1ZSxcclxuICAgICAgY3VzdG9tOiBudWxsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uOiBhbnkpIHtcclxuICAgIGpzb24uZGF0YVR5cGUgPSBEYXRhVHlwZS5mcm9tTmFtZShqc29uLmRhdGFUeXBlKTtcclxuICAgIC8vIFBhcnNlIGRlZmF1bHQgdmFsdWUgaW50byBjb3JyZWN0IGRhdGEgdHlwZS4gKGRhdGVUaW1lIGluc3RhbmNlcyByZXF1aXJlIGV4dHJhIHdvcmsgdG8gZGVzZXJpYWxpemUgcHJvcGVybHkuKVxyXG4gICAgaWYgKGpzb24uZGVmYXVsdFZhbHVlICYmIGpzb24uZGF0YVR5cGUgJiYganNvbi5kYXRhVHlwZS5wYXJzZSkge1xyXG4gICAgICBqc29uLmRlZmF1bHRWYWx1ZSA9IGpzb24uZGF0YVR5cGUucGFyc2UoanNvbi5kZWZhdWx0VmFsdWUsIHR5cGVvZiBqc29uLmRlZmF1bHRWYWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGpzb24udmFsaWRhdG9ycykge1xyXG4gICAgICBqc29uLnZhbGlkYXRvcnMgPSBqc29uLnZhbGlkYXRvcnMubWFwKFZhbGlkYXRvci5mcm9tSlNPTik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBEYXRhUHJvcGVydHkoanNvbik7XHJcbiAgfVxyXG5cclxufVxyXG5EYXRhUHJvcGVydHkucHJvdG90eXBlLl8kdHlwZU5hbWUgPSBcIkRhdGFQcm9wZXJ0eVwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0aW9uUHJvcGVydHlDb25maWcge1xyXG4gIG5hbWU/OiBzdHJpbmc7XHJcbiAgbmFtZU9uU2VydmVyPzogc3RyaW5nO1xyXG4gIGVudGl0eVR5cGVOYW1lPzogc3RyaW5nO1xyXG4gIGlzU2NhbGFyPzogYm9vbGVhbjtcclxuICBhc3NvY2lhdGlvbk5hbWU/OiBzdHJpbmc7XHJcbiAgZm9yZWlnbktleU5hbWVzPzogc3RyaW5nW107XHJcbiAgZm9yZWlnbktleU5hbWVzT25TZXJ2ZXI/OiBzdHJpbmdbXTtcclxuICBpbnZGb3JlaWduS2V5TmFtZXM/OiBzdHJpbmdbXTtcclxuICBpbnZGb3JlaWduS2V5TmFtZXNPblNlcnZlcj86IHN0cmluZ1tdO1xyXG4gIHZhbGlkYXRvcnM/OiBWYWxpZGF0b3JbXTtcclxuICBkaXNwbGF5TmFtZT86IHN0cmluZztcclxuICBjdXN0b20/OiBPYmplY3Q7XHJcbn1cclxuXHJcbi8qKiAgIEEgTmF2aWdhdGlvblByb3BlcnR5IGRlc2NyaWJlcyB0aGUgbWV0YWRhdGEgZm9yIGEgc2luZ2xlIHByb3BlcnR5IG9mIGFuIFtbRW50aXR5VHlwZV1dIHRoYXQgcmV0dXJuIGluc3RhbmNlcyBvZiBvdGhlciBFbnRpdHlUeXBlcy5cclxuXHJcbkluc3RhbmNlcyBvZiB0aGUgTmF2aWdhdGlvblByb3BlcnR5IGNsYXNzIGFyZSBjb25zdHJ1Y3RlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyBNZXRhZGF0YSByZXRyaWV2YWwuICAgSG93ZXZlciBpdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGNvbnN0cnVjdCB0aGVtXHJcbmRpcmVjdGx5IHZpYSB0aGUgY29uc3RydWN0b3IuXHJcbioqL1xyXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvblByb3BlcnR5IHtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfJHR5cGVOYW1lOiBzdHJpbmc7XHJcbiAgLyoqIElzIHRoaXMgYSBEYXRhUHJvcGVydHk/IC0gYWx3YXlzIGZhbHNlIGhlcmUgXHJcbiAgQWxsb3dzIHBvbHltb3JwaGljIHRyZWF0bWVudCBvZiBEYXRhUHJvcGVydGllcyBhbmQgTmF2aWdhdGlvblByb3BlcnRpZXMuIF9fUmVhZCBPbmx5X18gKi9cclxuICBpc0RhdGFQcm9wZXJ0eSA9IGZhbHNlO1xyXG4gIC8qKiBJcyB0aGlzIGEgTmF2aWdhdGlvblByb3BlcnR5PyAtIGFsd2F5cyB0cnVlIGhlcmVcclxuICBBbGxvd3MgcG9seW1vcnBoaWMgdHJlYXRtZW50IG9mIERhdGFQcm9wZXJ0aWVzIGFuZCBOYXZpZ2F0aW9uUHJvcGVydGllcy4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGlzTmF2aWdhdGlvblByb3BlcnR5ID0gdHJ1ZTtcclxuXHJcbiAgZm9ybWF0TmFtZSA9IERhdGFQcm9wZXJ0eS5wcm90b3R5cGUuZm9ybWF0TmFtZTtcclxuICBnZXRBbGxWYWxpZGF0b3JzID0gRGF0YVByb3BlcnR5LnByb3RvdHlwZS5nZXRBbGxWYWxpZGF0b3JzO1xyXG4gIHJlc29sdmVQcm9wZXJ0eSA9IERhdGFQcm9wZXJ0eS5wcm90b3R5cGUucmVzb2x2ZVByb3BlcnR5O1xyXG5cclxuICAvKiogVGhlIFtbRW50aXR5VHlwZV1dIHJldHVybmVkIGJ5IHRoaXMgcHJvcGVydHkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBlbnRpdHlUeXBlOiBFbnRpdHlUeXBlO1xyXG4gIC8qKiBUaGUgbmFtZSBvZiB0aGUgW1tFbnRpdHlUeXBlXV0gcmV0dXJuZWQgYnkgdGhpcyBwcm9wZXJ0eS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGVudGl0eVR5cGVOYW1lOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBbW0VudGl0eVR5cGVdXSB0aGF0IHRoaXMgcHJvcGVydHkgYmVsb25ncyB0by4gKCBzYW1lIGFzIGVudGl0eVR5cGUpLiBfX1JlYWQgT25seV9fICovXHJcbiAgcGFyZW50VHlwZTogRW50aXR5VHlwZTsgLy8gPz8gc2FtZSBhcyBlbnRpdHlUeXBlXHJcbiAgLyoqIFRoZSBbW0VudGl0eVR5cGVdXSB0aGF0IHRoaXMgcHJvcGVydHkgYmVsb25ncyB0by4gKCBzYW1lIGFzIGVudGl0eVR5cGUpLiBfX1JlYWQgT25seV9fICovXHJcbiAgcGFyZW50RW50aXR5VHlwZTogRW50aXR5VHlwZTsgLy8gPz8gc2FtZSBhcyBhYm92ZVxyXG4gIC8qKiBQcm9wZXJ0eSBvbiB0aGUgYmFzZSB0eXBlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBpbmhlcml0ZWQgZnJvbS4gV2lsbCBiZSBudWxsIGlmIHRoZSBwcm9wZXJ0eSBpcyBub3Qgb24gdGhlIGJhc2UgdHlwZS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGJhc2VQcm9wZXJ0eT86IE5hdmlnYXRpb25Qcm9wZXJ0eTtcclxuICAvKiogVGhlIGludmVyc2Ugb2YgdGhpcyBOYXZpZ2F0aW9uUHJvcGVydHkuICBUaGUgTmF2aWdhdGlvblByb3BlcnR5IHRoYXQgcmVwcmVzZW50cyBhIG5hdmlnYXRpb24gaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxyXG4gIHRvIHRoaXMgTmF2aWdhdGlvblByb3BlcnR5LiBNYXkgYmUgdW5kZWZpbmVkIGZvciBhIHVuZGlyZWN0aW9uYWwgTmF2aWdhdGlvblByb3BlcnR5LiBfX1JlYWQgT25seV9fICovXHJcbiAgcHJpdmF0ZSBfaW52ZXJzZT86IE5hdmlnYXRpb25Qcm9wZXJ0eTtcclxuICAvKiogVGhlIG5hbWUgb2YgdGhpcyBwcm9wZXJ0eS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIG5hbWU6IHN0cmluZztcclxuICAvKiogVGhlIG5hbWUgb2YgdGhpcyBwcm9wZXJ0eSBvbiB0aGUgc2VydmVyLiBfX1JlYWQgT25seV9fICovXHJcbiAgbmFtZU9uU2VydmVyOiBzdHJpbmc7XHJcbiAgLyoqXHJcbiAgV2hldGhlciB0aGlzIHByb3BlcnR5IHJldHVybnMgYSBzaW5nbGUgZW50aXR5IGFzIG9wcG9zZWQgdG8gIGFuIGFycmF5IG9mIGVudGl0aWVzLiBfX1JlYWQgT25seV9fICovXHJcbiAgaXNTY2FsYXI6IGJvb2xlYW47XHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBhc3NvY2lhdGlvbiB0byB3aGljaCB0aGF0IHRoaXMgcHJvcGVydHkgYmVsb25ncy4gIFRoaXMgYXNzb2NpYXRpb25OYW1lIHdpbGwgYmUgc2hhcmVkIHdpdGggdGhpc1xyXG4gIHByb3BlcnRpZXMgJ2ludmVyc2UnLiBfX1JlYWQgT25seV9fICovXHJcbiAgYXNzb2NpYXRpb25OYW1lOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBuYW1lcyBvZiB0aGUgZm9yZWlnbiBrZXkgRGF0YVByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgTmF2aWdhdGlvblByb3BlcnR5LiBUaGVyZSB3aWxsIHVzdWFsbHkgb25seSBiZSBhIHNpbmdsZSBEYXRhUHJvcGVydHkgYXNzb2NpYXRlZFxyXG4gIHdpdGggYSBOYXZpZ2F0aW9uIHByb3BlcnR5IGV4Y2VwdCBpbiB0aGUgY2FzZSBvZiBlbnRpdGllcyB3aXRoIG11bHRpcGFydCBrZXlzLiBfX1JlYWQgT25seV9fICovXHJcbiAgZm9yZWlnbktleU5hbWVzOiBzdHJpbmdbXTtcclxuICAvKiogVGhlIHNlcnZlciBzaWRlIG5hbWVzIG9mIHRoZSBmb3JlaWduIGtleSBEYXRhUHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBOYXZpZ2F0aW9uUHJvcGVydHkuIFRoZXJlIHdpbGwgdXN1YWxseSBvbmx5IGJlIGEgc2luZ2xlIERhdGFQcm9wZXJ0eSBhc3NvY2lhdGVkXHJcbiAgd2l0aCBhIE5hdmlnYXRpb24gcHJvcGVydHkgZXhjZXB0IGluIHRoZSBjYXNlIG9mIGVudGl0aWVzIHdpdGggbXVsdGlwYXJ0IGtleXMuIF9fUmVhZCBPbmx5X18gKi9cclxuICBmb3JlaWduS2V5TmFtZXNPblNlcnZlcjogc3RyaW5nW107XHJcbiAgaW52Rm9yZWlnbktleU5hbWVzOiBzdHJpbmdbXTtcclxuICBpbnZGb3JlaWduS2V5TmFtZXNPblNlcnZlcjogc3RyaW5nW107XHJcbiAgLyoqIFRoZSAnZm9yZWlnbiBrZXknIERhdGFQcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE5hdmlnYXRpb25Qcm9wZXJ0eS4gVGhlcmUgd2lsbCB1c3VhbGx5IG9ubHkgYmUgYSBzaW5nbGUgRGF0YVByb3BlcnR5IGFzc29jaWF0ZWRcclxuICB3aXRoIGEgTmF2aWdhdGlvbiBwcm9wZXJ0eSBleGNlcHQgaW4gdGhlIGNhc2Ugb2YgZW50aXRpZXMgd2l0aCBtdWx0aXBhcnQga2V5cy4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIHJlbGF0ZWREYXRhUHJvcGVydGllczogRGF0YVByb3BlcnR5W107XHJcbiAgLyoqIFRoZSBbW1ZhbGlkYXRvcl1dIGluc3RhbmNlcyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBwcm9wZXJ0eS4gVmFsaWRhdG9ycyBjYW4gYmUgYWRkZWQgYW5kXHJcbiAgcmVtb3ZlZCBmcm9tIHRoaXMgY29sbGVjdGlvbi4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIHZhbGlkYXRvcnM6IFZhbGlkYXRvcltdO1xyXG4gIC8qKiBUaGUgZGlzcGxheSBuYW1lIG9mIHRoaXMgcHJvcGVydHkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBkaXNwbGF5TmFtZTogc3RyaW5nO1xyXG4gIGlzVW5tYXBwZWQ6IGJvb2xlYW47XHJcbiAgLyoqIEEgZnJlZSBmb3JtIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlZmluZSBhbnkgY3VzdG9tIG1ldGFkYXRhIGZvciB0aGlzIE5hdmlnYXRpb25Qcm9wZXJ0eS4gICAqKi9cclxuICBjdXN0b206IE9iamVjdDtcclxuXHJcbiAgLyoqIE5hdmlnYXRpb25Qcm9wZXJ0eSBjb25zdHJ1Y3RvclxyXG4gID4gICAgICBsZXQgaG9tZUFkZHJlc3NQcm9wID0gbmV3IE5hdmlnYXRpb25Qcm9wZXJ0eSgge1xyXG4gID4gICAgICAgICAgbmFtZTogXCJob21lQWRkcmVzc1wiLFxyXG4gID4gICAgICAgICAgZW50aXR5VHlwZU5hbWU6IFwiQWRkcmVzczojbXlOYW1lc3BhY2VcIixcclxuICA+ICAgICAgICAgIGlzU2NhbGFyOiB0cnVlLFxyXG4gID4gICAgICAgICAgYXNzb2NpYXRpb25OYW1lOiBcImFkZHJlc3NfcGVyc29uXCIsXHJcbiAgPiAgICAgICAgICBmb3JlaWduS2V5TmFtZXM6IFtcImhvbWVBZGRyZXNzSWRcIl1cclxuICA+ICAgICAgfSk7XHJcbiAgPiAgICAgIGxldCBob21lQWRkcmVzc0lkUHJvcCA9IG5ldyBEYXRhUHJvcGVydHkoIHtcclxuICA+ICAgICAgICAgIG5hbWU6IFwiaG9tZUFkZHJlc3NJZFwiXHJcbiAgPiAgICAgICAgICBkYXRhVHlwZTogRGF0YVR5cGUuSW50ZWdlclxyXG4gID4gICAgICB9KTtcclxuICA+ICAgICAgLy8gYXNzdW1pbmcgcGVyc29uRW50aXR5VHlwZSBpcyBhIG5ld2x5IGNvbnN0cnVjdGVkIEVudGl0eVR5cGVcclxuICA+ICAgICAgcGVyc29uRW50aXR5VHlwZS5hZGRQcm9wZXJ0eShob21lQWRkcmVzc1Byb3ApO1xyXG4gID4gICAgICBwZXJzb25FbnRpdHlUeXBlLmFkZFByb3BlcnR5KGhvbWVBZGRyZXNzSWRQcm9wKTtcclxuICBAcGFyYW0gY29uZmlnIC0gQSBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAqKi9cclxuICBjb25zdHJ1Y3Rvcihjb25maWc6IE5hdmlnYXRpb25Qcm9wZXJ0eUNvbmZpZykge1xyXG4gICAgYXNzZXJ0Q29uZmlnKGNvbmZpZylcclxuICAgICAgLndoZXJlUGFyYW0oXCJuYW1lXCIpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwibmFtZU9uU2VydmVyXCIpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZW50aXR5VHlwZU5hbWVcIikuaXNTdHJpbmcoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImlzU2NhbGFyXCIpLmlzQm9vbGVhbigpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdCh0cnVlKVxyXG4gICAgICAud2hlcmVQYXJhbShcImFzc29jaWF0aW9uTmFtZVwiKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImZvcmVpZ25LZXlOYW1lc1wiKS5pc0FycmF5KCkuaXNTdHJpbmcoKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQoW10pXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZm9yZWlnbktleU5hbWVzT25TZXJ2ZXJcIikuaXNBcnJheSgpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KFtdKVxyXG4gICAgICAud2hlcmVQYXJhbShcImludkZvcmVpZ25LZXlOYW1lc1wiKS5pc0FycmF5KCkuaXNTdHJpbmcoKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQoW10pXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiaW52Rm9yZWlnbktleU5hbWVzT25TZXJ2ZXJcIikuaXNBcnJheSgpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KFtdKVxyXG4gICAgICAud2hlcmVQYXJhbShcInZhbGlkYXRvcnNcIikuaXNJbnN0YW5jZU9mKFZhbGlkYXRvcikuaXNBcnJheSgpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChbXSlcclxuICAgICAgLndoZXJlUGFyYW0oXCJkaXNwbGF5TmFtZVwiKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJjdXN0b21cIikuaXNPcHRpb25hbCgpXHJcbiAgICAgIC5hcHBseUFsbCh0aGlzKTtcclxuICAgIGxldCBoYXNOYW1lID0gISEodGhpcy5uYW1lIHx8IHRoaXMubmFtZU9uU2VydmVyKTtcclxuXHJcbiAgICBpZiAoIWhhc05hbWUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBOYXZpZ2F0aW9uIHByb3BlcnR5IG11c3QgYmUgaW5zdGFudGlhdGVkIHdpdGggZWl0aGVyIGEgJ25hbWUnIG9yIGEgJ25hbWVPblNlcnZlcicgcHJvcGVydHlcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBHZW5lcmFsIHB1cnBvc2UgcHJvcGVydHkgc2V0IG1ldGhvZFxyXG4gID4gICAgICAvLyBhc3N1bWUgbXlFbnRpdHlUeXBlIGlzIGFuIEVudGl0eVR5cGVcclxuICA+ICAgICAgbGV0IHByb3AgPSBteUVudGl0eVR5cGUuZ2V0UHJvcGVydHkoXCJteVByb3BlcnR5XCIpO1xyXG4gID4gICAgICBwcm9wLnNldFByb3BlcnRpZXMoIHtcclxuICA+ICAgICAgICAgIGN1c3RvbTogeyBmb286IDcsIGJhcjogXCJ0ZXN0XCIgfVxyXG4gID4gICAgICB9KTtcclxuICBAcGFyYW0gY29uZmlnIC0gQSBjb25maWcgb2JqZWN0XHJcbiAgKiovXHJcbiAgLy8gVE9ETzogY3JlYXRlIGFuIGludGVyZmFjZSBmb3IgdGhpcy5cclxuICBzZXRQcm9wZXJ0aWVzKGNvbmZpZzoge1xyXG4gICAgZGlzcGxheU5hbWU/OiBzdHJpbmcsXHJcbiAgICBmb3JlaWduS2V5TmFtZXM/OiBzdHJpbmdbXSxcclxuICAgIGludkZvcmVpZ25LZXlOYW1lcz86IHN0cmluZ1tdLFxyXG4gICAgaW52ZXJzZT86IE5hdmlnYXRpb25Qcm9wZXJ0eSB8IHN0cmluZyxcclxuICAgIGN1c3RvbT86IE9iamVjdFxyXG4gIH0pIHtcclxuICAgIGlmICghdGhpcy5wYXJlbnRUeXBlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIE5hdmlnYXRpb25Qcm9wZXJ0eS5zZXRQcm9wZXJ0aWVzIHVudGlsIHRoZSBwYXJlbnQgRW50aXR5VHlwZSBvZiB0aGUgTmF2aWdhdGlvblByb3BlcnR5IGhhcyBiZWVuIHNldC5cIik7XHJcbiAgICB9XHJcbiAgICBsZXQgaW52ZXJzZSA9IGNvbmZpZy5pbnZlcnNlO1xyXG4gICAgaWYgKGludmVyc2UpIGRlbGV0ZSBjb25maWcuaW52ZXJzZTtcclxuICAgIGFzc2VydENvbmZpZyhjb25maWcpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZGlzcGxheU5hbWVcIikuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZm9yZWlnbktleU5hbWVzXCIpLmlzQXJyYXkoKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChbXSlcclxuICAgICAgLndoZXJlUGFyYW0oXCJpbnZGb3JlaWduS2V5TmFtZXNcIikuaXNBcnJheSgpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KFtdKVxyXG4gICAgICAud2hlcmVQYXJhbShcImN1c3RvbVwiKS5pc09wdGlvbmFsKClcclxuICAgICAgLmFwcGx5QWxsKHRoaXMpO1xyXG4gICAgdGhpcy5wYXJlbnRUeXBlLl91cGRhdGVOYW1lcyh0aGlzKTtcclxuXHJcbiAgICB0aGlzLl9yZXNvbHZlTnAoKTtcclxuICAgIGlmIChpbnZlcnNlKSB7XHJcbiAgICAgIHRoaXMuc2V0SW52ZXJzZShpbnZlcnNlKTtcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvKiogVGhlIGludmVyc2Ugb2YgdGhpcyBOYXZpZ2F0aW9uUHJvcGVydHkuICBUaGUgTmF2aWdhdGlvblByb3BlcnR5IHRoYXQgcmVwcmVzZW50cyBhIG5hdmlnYXRpb24gaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxyXG4gIHRvIHRoaXMgTmF2aWdhdGlvblByb3BlcnR5LiBNYXkgYmUgdW5kZWZpbmVkIGZvciBhIHVuZGlyZWN0aW9uYWwgTmF2aWdhdGlvblByb3BlcnR5LiBfX1JlYWQgT25seV9fICovXHJcbiAgZ2V0IGludmVyc2UoKTogTmF2aWdhdGlvblByb3BlcnR5IHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLmdldEludmVyc2UoKTtcclxuICB9XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIGdldEludmVyc2UoKTogTmF2aWdhdGlvblByb3BlcnR5IHwgdW5kZWZpbmVkIHtcclxuICAgIGxldCBucDogTmF2aWdhdGlvblByb3BlcnR5ID0gdGhpcztcclxuICAgIHdoaWxlICghbnAuX2ludmVyc2UgJiYgbnAuYmFzZVByb3BlcnR5KSB7XHJcbiAgICAgIG5wID0gbnAuYmFzZVByb3BlcnR5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5wLl9pbnZlcnNlO1xyXG4gIH1cclxuXHJcbiAgc2V0SW52ZXJzZShpbnZlcnNlTnA6IE5hdmlnYXRpb25Qcm9wZXJ0eSB8IHN0cmluZykge1xyXG4gICAgLy8gbGV0IGludk5wOiBOYXZpZ2F0aW9uUHJvcGVydHk7XHJcbiAgICBsZXQgaW52TnAgPSAoaW52ZXJzZU5wIGluc3RhbmNlb2YgTmF2aWdhdGlvblByb3BlcnR5KSA/IGludmVyc2VOcCA6IHRoaXMuZW50aXR5VHlwZS5nZXROYXZpZ2F0aW9uUHJvcGVydHkoaW52ZXJzZU5wKTtcclxuXHJcbiAgICBpZiAoIWludk5wKSB7XHJcbiAgICAgIHRocm93IHRocm93U2V0SW52ZXJzZUVycm9yKHRoaXMsIFwiVW5hYmxlIHRvIGZpbmQgaW52ZXJzZSBwcm9wZXJ0eTogXCIgKyBpbnZlcnNlTnApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9pbnZlcnNlIHx8IGludk5wLl9pbnZlcnNlKSB7XHJcbiAgICAgIHRocm93U2V0SW52ZXJzZUVycm9yKHRoaXMsIFwiSXQgaGFzIGFscmVhZHkgYmVlbiBzZXQgb24gb25lIHNpZGUgb3IgdGhlIG90aGVyLlwiKTtcclxuICAgIH1cclxuICAgIGlmIChpbnZOcC5lbnRpdHlUeXBlICE9PSB0aGlzLnBhcmVudFR5cGUpIHtcclxuICAgICAgdGhyb3dTZXRJbnZlcnNlRXJyb3IodGhpcywgaW52TnAuZm9ybWF0TmFtZSArIFwiIGlzIG5vdCBhIHZhbGlkIGludmVyc2UgcHJvcGVydHkgZm9yIHRoaXMuXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuYXNzb2NpYXRpb25OYW1lKSB7XHJcbiAgICAgIGludk5wLmFzc29jaWF0aW9uTmFtZSA9IHRoaXMuYXNzb2NpYXRpb25OYW1lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKCFpbnZOcC5hc3NvY2lhdGlvbk5hbWUpIHtcclxuICAgICAgICBpbnZOcC5hc3NvY2lhdGlvbk5hbWUgPSB0aGlzLmZvcm1hdE5hbWUoKSArIFwiX1wiICsgaW52TnAuZm9ybWF0TmFtZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYXNzb2NpYXRpb25OYW1lID0gaW52TnAuYXNzb2NpYXRpb25OYW1lO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fcmVzb2x2ZU5wKCk7XHJcbiAgICBpbnZOcC5fcmVzb2x2ZU5wKCk7XHJcbiAgfVxyXG5cclxuICAvLyAvLyBJbiBwcm9ncmVzcyAtIHdpbGwgYmUgdXNlZCBmb3IgbWFudWFsIG1ldGFkYXRhIGNvbmZpZ1xyXG4gIC8vIGNyZWF0ZUludmVyc2UoY29uZmlnOiBhbnkpIHtcclxuXHJcbiAgLy8gICBpZiAoIXRoaXMuZW50aXR5VHlwZSkge1xyXG4gIC8vICAgICB0aHJvd0NyZWF0ZUludmVyc2VFcnJvcih0aGlzLCBcImhhcyBub3QgeWV0IGJlZW4gZGVmaW5lZC5cIik7XHJcbiAgLy8gICB9XHJcbiAgLy8gICBpZiAodGhpcy5lbnRpdHlUeXBlLmlzRnJvemVuKSB7XHJcbiAgLy8gICAgIHRocm93Q3JlYXRlSW52ZXJzZUVycm9yKHRoaXMsIFwiaXMgZnJvemVuLlwiKTtcclxuICAvLyAgIH1cclxuICAvLyAgIGxldCBtZXRhZGF0YVN0b3JlID0gdGhpcy5lbnRpdHlUeXBlLm1ldGFkYXRhU3RvcmU7XHJcbiAgLy8gICBpZiAobWV0YWRhdGFTdG9yZSA9PSBudWxsKSB7XHJcbiAgLy8gICAgIHRocm93Q3JlYXRlSW52ZXJzZUVycm9yKHRoaXMsIFwiaGFzIG5vdCB5ZXQgYmVlbiBhZGRlZCB0byB0aGUgbWV0YWRhdGFTdG9yZS5cIik7XHJcbiAgLy8gICB9XHJcblxyXG4gIC8vICAgY29uZmlnLmVudGl0eVR5cGVOYW1lID0gdGhpcy5wYXJlbnRFbnRpdHlUeXBlLm5hbWU7XHJcbiAgLy8gICBjb25maWcuYXNzb2NpYXRpb25OYW1lID0gdGhpcy5hc3NvY2lhdGlvbk5hbWU7XHJcbiAgLy8gICBsZXQgaW52TnAgPSBuZXcgTmF2aWdhdGlvblByb3BlcnR5KGNvbmZpZyk7XHJcbiAgLy8gICB0aGlzLnBhcmVudEVudGl0eVR5cGUuYWRkTmF2aWdhdGlvblByb3BlcnR5KGludk5wKTtcclxuICAvLyAgIHJldHVybiBpbnZOcDtcclxuICAvLyB9O1xyXG5cclxuXHJcblxyXG4gIHRvSlNPTigpIHtcclxuICAgIHJldHVybiBjb3JlLnRvSnNvbih0aGlzLCB7XHJcbiAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgIGVudGl0eVR5cGVOYW1lOiBudWxsLFxyXG4gICAgICBpc1NjYWxhcjogbnVsbCxcclxuICAgICAgYXNzb2NpYXRpb25OYW1lOiBudWxsLFxyXG4gICAgICB2YWxpZGF0b3JzOiBudWxsLFxyXG4gICAgICBkaXNwbGF5TmFtZTogbnVsbCxcclxuICAgICAgZm9yZWlnbktleU5hbWVzOiBudWxsLFxyXG4gICAgICBpbnZGb3JlaWduS2V5TmFtZXM6IG51bGwsXHJcbiAgICAgIGN1c3RvbTogbnVsbFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbUpTT04oanNvbjogYW55KSB7XHJcbiAgICBpZiAoanNvbi52YWxpZGF0b3JzKSB7XHJcbiAgICAgIGpzb24udmFsaWRhdG9ycyA9IGpzb24udmFsaWRhdG9ycy5tYXAoVmFsaWRhdG9yLmZyb21KU09OKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgTmF2aWdhdGlvblByb3BlcnR5KGpzb24pO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX3Jlc29sdmVOcCgpIHtcclxuICAgIGxldCBucCA9IHRoaXM7XHJcbiAgICBsZXQgZW50aXR5VHlwZSA9IG5wLmVudGl0eVR5cGU7XHJcbiAgICBsZXQgaW52TnAgPSBjb3JlLmFycmF5Rmlyc3QoZW50aXR5VHlwZS5uYXZpZ2F0aW9uUHJvcGVydGllcywgKGFsdE5wKSA9PiB7XHJcbiAgICAgIC8vIENhbid0IGRvIHRoaXMgYmVjYXVzZSBvZiBwb3NzaWJpbGl0eSBvZiBjb21wYXJpbmcgYSBiYXNlIGNsYXNzIG5wIHdpdGggYSBzdWJjbGFzcyBhbHROcC5cclxuICAgICAgLy8gcmV0dXJuIGFsdE5wLmFzc29jaWF0aW9uTmFtZSA9PT0gbnAuYXNzb2NpYXRpb25OYW1lXHJcbiAgICAgIC8vICAgICYmIGFsdE5wICE9PSBucDtcclxuICAgICAgLy8gU28gdXNlIHRoaXMgaW5zdGVhZC5cclxuICAgICAgcmV0dXJuIGFsdE5wLmFzc29jaWF0aW9uTmFtZSA9PT0gbnAuYXNzb2NpYXRpb25OYW1lICYmXHJcbiAgICAgICAgKGFsdE5wLm5hbWUgIT09IG5wLm5hbWUgfHwgYWx0TnAuZW50aXR5VHlwZU5hbWUgIT09IG5wLmVudGl0eVR5cGVOYW1lKTtcclxuICAgIH0pO1xyXG4gICAgbnAuX2ludmVyc2UgPSBpbnZOcCB8fCB1bmRlZmluZWQ7XHJcbiAgICAvL2lmIChpbnZOcCAmJiBpbnZOcC5pbnZlcnNlID09IG51bGwpIHtcclxuICAgIC8vICAgIGludk5wLl9yZXNvbHZlTnAoKTtcclxuICAgIC8vfVxyXG4gICAgaWYgKCFpbnZOcCkge1xyXG4gICAgICAvLyB1bmlkaXJlY3Rpb25hbCAxLW4gcmVsYXRpb25zaGlwXHJcbiAgICAgIG5wLmludkZvcmVpZ25LZXlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnZGa05hbWUpIHtcclxuICAgICAgICBsZXQgZmtQcm9wID0gZW50aXR5VHlwZS5nZXREYXRhUHJvcGVydHkoaW52RmtOYW1lKTtcclxuICAgICAgICBpZiAoZmtQcm9wID09IG51bGwpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVudGl0eVR5cGUgJ1wiICsgbnAuZW50aXR5VHlwZU5hbWUgKyBcIicgaGFzIG5vIGZvcmVpZ24ga2V5IG1hdGNoaW5nICdcIiArIGludkZrTmFtZSArIFwiJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGludkVudGl0eVR5cGUgPSBucC5wYXJlbnRUeXBlO1xyXG4gICAgICAgIGludk5wID0gY29yZS5hcnJheUZpcnN0KGludkVudGl0eVR5cGUubmF2aWdhdGlvblByb3BlcnRpZXMsIChucDIpID0+IHtcclxuICAgICAgICAgIHJldHVybiBucDIuaW52Rm9yZWlnbktleU5hbWVzICYmIG5wMi5pbnZGb3JlaWduS2V5TmFtZXMuaW5kZXhPZihma1Byb3AhLm5hbWUpID49IDAgJiYgbnAyLmVudGl0eVR5cGUgPT09IGZrUHJvcCEucGFyZW50VHlwZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBma1Byb3AuaW52ZXJzZU5hdmlnYXRpb25Qcm9wZXJ0eSA9IGludk5wIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICBjb3JlLmFycmF5QWRkSXRlbVVuaXF1ZShlbnRpdHlUeXBlLmZvcmVpZ25LZXlQcm9wZXJ0aWVzLCBma1Byb3ApO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXNvbHZlUmVsYXRlZChucCk7XHJcbiAgfVxyXG5cclxufVxyXG5OYXZpZ2F0aW9uUHJvcGVydHkucHJvdG90eXBlLl8kdHlwZU5hbWUgPSBcIk5hdmlnYXRpb25Qcm9wZXJ0eVwiO1xyXG5cclxuZnVuY3Rpb24gdGhyb3dTZXRJbnZlcnNlRXJyb3IobnA6IE5hdmlnYXRpb25Qcm9wZXJ0eSwgbWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB0aGUgaW52ZXJzZSBwcm9wZXJ0eSBmb3I6IFwiICsgbnAuZm9ybWF0TmFtZSgpICsgXCIuIFwiICsgbWVzc2FnZSk7XHJcbn1cclxuXHJcbi8vIE5vdCBjdXJyZW50IHVzZWQuXHJcbi8vIGZ1bmN0aW9uIHRocm93Q3JlYXRlSW52ZXJzZUVycm9yKG5wOiBOYXZpZ2F0aW9uUHJvcGVydHksIG1lc3NhZ2U6IHN0cmluZykge1xyXG4vLyAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgaW52ZXJzZSBmb3I6IFwiICsgbnAuZm9ybWF0TmFtZSgpICsgXCIuIFRoZSBlbnRpdHlUeXBlIGZvciB0aGlzIG5hdmlnYXRpb24gcHJvcGVydHkgXCIgKyBtZXNzYWdlKTtcclxuLy8gfVxyXG5cclxuLy8gc2V0cyBuYXZpZ2F0aW9uIHByb3BlcnR5OiByZWxhdGVkRGF0YVByb3BlcnRpZXMgYW5kIGRhdGFQcm9wZXJ0eTogcmVsYXRlZE5hdmlnYXRpb25Qcm9wZXJ0eVxyXG5mdW5jdGlvbiByZXNvbHZlUmVsYXRlZChucDogTmF2aWdhdGlvblByb3BlcnR5KSB7XHJcblxyXG4gIGxldCBma05hbWVzID0gbnAuZm9yZWlnbktleU5hbWVzO1xyXG4gIGlmIChma05hbWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xyXG5cclxuICBsZXQgcGFyZW50RW50aXR5VHlwZSA9IG5wLnBhcmVudFR5cGU7XHJcbiAgbGV0IGZrUHJvcHMgPSBma05hbWVzLm1hcChmdW5jdGlvbiAoZmtOYW1lKSB7XHJcbiAgICByZXR1cm4gcGFyZW50RW50aXR5VHlwZS5nZXREYXRhUHJvcGVydHkoZmtOYW1lKTtcclxuICB9KTtcclxuICBsZXQgZmtQcm9wQ29sbGVjdGlvbiA9IHBhcmVudEVudGl0eVR5cGUuZm9yZWlnbktleVByb3BlcnRpZXM7XHJcblxyXG4gIGZrUHJvcHMuZm9yRWFjaCgoZHA6IERhdGFQcm9wZXJ0eSkgPT4ge1xyXG4gICAgY29yZS5hcnJheUFkZEl0ZW1VbmlxdWUoZmtQcm9wQ29sbGVjdGlvbiwgZHApO1xyXG4gICAgZHAucmVsYXRlZE5hdmlnYXRpb25Qcm9wZXJ0eSA9IG5wO1xyXG4gICAgLy8gbm93IHVwZGF0ZSB0aGUgaW52ZXJzZVxyXG4gICAgY29yZS5hcnJheUFkZEl0ZW1VbmlxdWUobnAuZW50aXR5VHlwZS5pbnZlcnNlRm9yZWlnbktleVByb3BlcnRpZXMsIGRwKTtcclxuICAgIGlmIChucC5yZWxhdGVkRGF0YVByb3BlcnRpZXMpIHtcclxuICAgICAgY29yZS5hcnJheUFkZEl0ZW1VbmlxdWUobnAucmVsYXRlZERhdGFQcm9wZXJ0aWVzLCBkcCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBucC5yZWxhdGVkRGF0YVByb3BlcnRpZXMgPSBbZHBdO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5cclxuLyoqXHJcbkF1dG9HZW5lcmF0ZWRLZXlUeXBlIGlzIGFuICdFbnVtJyBjb250YWluaW5nIGFsbCBvZiB0aGUgdmFsaWQgc3RhdGVzIGZvciBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBrZXkuXHJcbioqL1xyXG5leHBvcnQgY2xhc3MgQXV0b0dlbmVyYXRlZEtleVR5cGUgZXh0ZW5kcyBCcmVlemVFbnVtIHtcclxuXHJcbiAgLyoqXHJcbiAgVGhpcyBlbnRpdHkgZG9lcyBub3QgaGF2ZSBhbiBhdXRvZ2VuZXJhdGVkIGtleS5cclxuICBUaGUgY2xpZW50IG11c3Qgc2V0IHRoZSBrZXkgYmVmb3JlIGFkZGluZyB0aGUgZW50aXR5IHRvIHRoZSBFbnRpdHlNYW5hZ2VyXHJcbiAgKiovXHJcbiAgc3RhdGljIE5vbmUgPSBuZXcgQXV0b0dlbmVyYXRlZEtleVR5cGUoKTtcclxuICAvKiogXHJcbiAgVGhpcyBlbnRpdHkncyBrZXkgaXMgYW4gSWRlbnRpdHkgY29sdW1uIGFuZCBpcyBzZXQgYnkgdGhlIGJhY2tlbmQgZGF0YWJhc2UuXHJcbiAgS2V5cyBmb3IgbmV3IGVudGl0aWVzIHdpbGwgYmUgdGVtcG9yYXJ5IHVudGlsIHRoZSBlbnRpdGllcyBhcmUgc2F2ZWQgYXQgd2hpY2ggcG9pbnQgdGhlIGtleXMgd2lsbFxyXG4gIGJlIGNvbnZlcnRlZCB0byB0aGVpciAncmVhbCcgdmVyc2lvbnMuXHJcbiAgKiovXHJcbiAgc3RhdGljIElkZW50aXR5ID0gbmV3IEF1dG9HZW5lcmF0ZWRLZXlUeXBlKCk7XHJcbiAgLyoqXHJcbiAgVGhpcyBlbnRpdHkncyBrZXkgaXMgZ2VuZXJhdGVkIGJ5IGEgS2V5R2VuZXJhdG9yIGFuZCBpcyBzZXQgYnkgdGhlIGJhY2tlbmQgZGF0YWJhc2UuXHJcbiAgS2V5cyBmb3IgbmV3IGVudGl0aWVzIHdpbGwgYmUgdGVtcG9yYXJ5IHVudGlsIHRoZSBlbnRpdGllcyBhcmUgc2F2ZWQgYXQgd2hpY2ggcG9pbnQgdGhlIGtleXMgd2lsbFxyXG4gIGJlIGNvbnZlcnRlZCB0byB0aGVpciAncmVhbCcgdmVyc2lvbnMuXHJcbiAgKiovXHJcbiAgc3RhdGljIEtleUdlbmVyYXRvciA9IG5ldyBBdXRvR2VuZXJhdGVkS2V5VHlwZSgpO1xyXG5cclxufVxyXG5BdXRvR2VuZXJhdGVkS2V5VHlwZS5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IFwiQXV0b0dlbmVyYXRlZEtleVR5cGVcIjtcclxuRXJyb3JbJ3gnXSA9IEF1dG9HZW5lcmF0ZWRLZXlUeXBlLnJlc29sdmVTeW1ib2xzKCk7XHJcblxyXG5cclxuLy8gbWl4aW4gbWV0aG9kc1xyXG4vKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuZGVjbGFyZSBtb2R1bGUgXCIuL2Fzc2VydC1wYXJhbVwiIHtcclxuICBpbnRlcmZhY2UgUGFyYW0ge1xyXG4gICAgaXNFbnRpdHkoKTogUGFyYW07XHJcbiAgICBpc0VudGl0eVByb3BlcnR5KCk6IFBhcmFtO1xyXG4gIH1cclxufVxyXG5cclxubGV0IHByb3RvID0gUGFyYW0ucHJvdG90eXBlO1xyXG5cclxuLy8gJ3RoaXMnIGJlbG93IGlzIFRTIGFubm90YXRpb24gXHJcbnByb3RvLmlzRW50aXR5ID0gZnVuY3Rpb24gKHRoaXM6IFBhcmFtKSB7XHJcbiAgcmV0dXJuIHRoaXMuX2FkZENvbnRleHQoe1xyXG4gICAgZm46IGlzRW50aXR5LFxyXG4gICAgbXNnOiBcIiBtdXN0IGJlIGFuIGVudGl0eVwiXHJcbiAgfSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpc0VudGl0eShjb250ZXh0OiBhbnksIHY6IGFueSkge1xyXG4gIGlmICh2ID09IG51bGwpIHJldHVybiBmYWxzZTtcclxuICByZXR1cm4gKHYuZW50aXR5VHlwZSAhPT0gdW5kZWZpbmVkKTtcclxufVxyXG5cclxucHJvdG8uaXNFbnRpdHlQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0aGlzOiBQYXJhbSkge1xyXG4gIHJldHVybiB0aGlzLl9hZGRDb250ZXh0KHtcclxuICAgIGZuOiBpc0VudGl0eVByb3BlcnR5LFxyXG4gICAgbXNnOiBcIiBtdXN0IGJlIGVpdGhlciBhIERhdGFQcm9wZXJ0eSBvciBhIE5hdmlnYXRpb25Qcm9wZXJ0eVwiXHJcbiAgfSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBpc0VudGl0eVByb3BlcnR5KGNvbnRleHQ6IGFueSwgdjogYW55KSB7XHJcbiAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xyXG4gIHJldHVybiAodi5pc0RhdGFQcm9wZXJ0eSB8fCB2LmlzTmF2aWdhdGlvblByb3BlcnR5KTtcclxufVxyXG5cclxuLy8gZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIGNsYXNzZXMgcmVsYXRlZCB0byBNZXRhZGF0YVxyXG5cclxuZnVuY3Rpb24gaXNRdWFsaWZpZWRUeXBlTmFtZShlbnRpdHlUeXBlTmFtZTogc3RyaW5nKSB7XHJcbiAgcmV0dXJuIGVudGl0eVR5cGVOYW1lLmluZGV4T2YoXCI6I1wiKSA+PSAwO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcXVhbGlmeVR5cGVOYW1lKHNob3J0TmFtZTogc3RyaW5nLCBucz86IHN0cmluZykge1xyXG4gIGlmIChucyAmJiBucy5sZW5ndGggPiAwKSB7XHJcbiAgICByZXR1cm4gc2hvcnROYW1lICsgXCI6I1wiICsgbnM7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBzaG9ydE5hbWU7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBVc2VkIGJ5IGJvdGggQ29tcGxleFR5cGUgYW5kIEVudGl0eVR5cGVcclxuZnVuY3Rpb24gYWRkUHJvcGVydGllcyhlbnRpdHlUeXBlOiBTdHJ1Y3R1cmFsVHlwZSwgcHJvcE9iajogT2JqZWN0IHwgdW5kZWZpbmVkLCBjdG9yOiBhbnkpIHtcclxuICBpZiAocHJvcE9iaiA9PSBudWxsKSByZXR1cm47XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcE9iaikpIHtcclxuICAgIHByb3BPYmouZm9yRWFjaChlbnRpdHlUeXBlLl9hZGRQcm9wZXJ0eUNvcmUuYmluZChlbnRpdHlUeXBlKSk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgKHByb3BPYmopID09PSAnb2JqZWN0Jykge1xyXG4gICAgZm9yIChsZXQga2V5IGluIHByb3BPYmopIHtcclxuICAgICAgaWYgKGNvcmUuaGFzT3duUHJvcGVydHkocHJvcE9iaiwga2V5KSkge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IHByb3BPYmpba2V5XTtcclxuICAgICAgICB2YWx1ZS5uYW1lID0ga2V5O1xyXG4gICAgICAgIGxldCBwcm9wID0gbmV3IGN0b3IodmFsdWUpO1xyXG4gICAgICAgIGVudGl0eVR5cGUuX2FkZFByb3BlcnR5Q29yZShwcm9wKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ2RhdGFQcm9wZXJ0aWVzJyBvciAnbmF2aWdhdGlvblByb3BlcnRpZXMnIHZhbHVlcyBtdXN0IGJlIGVpdGhlciBhbiBhcnJheSBvZiBkYXRhL25hdiBwcm9wZXJ0aWVzIG9yIGFuIG9iamVjdCB3aGVyZSBlYWNoIHByb3BlcnR5IGRlZmluZXMgYSBkYXRhL25hdiBwcm9wZXJ0eVwiKTtcclxuICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG4iXX0=