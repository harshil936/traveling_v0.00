//#region Copyright, Version, and Description
/*
 * Copyright 2015-2019 IdeaBlade, Inc.  All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the IdeaBlade Breeze license, available at http://www.breezejs.com/license
 *
 * Author: Ward Bell
 * Version: 0.9.5 - Steve Schmitt - convert to TypeScript, migrate to breeze-client repo, add HasEntityGraph and mixinEntityGraph
 * Version: 0.9.4 - Marcel Good - fix UMD module name
 * --------------------------------------------------------------------------------
 * Adds getEntityGraph method to Breeze EntityManager prototype.
 * Call   mixinEntityGraph(EntityManager)   to apply the mixin in a tree-shaking-resistant way.
 * Then   (manager as any).getEntityGraph(entity, "child");
 *
 * Depends on Breeze which it patches
 *
 * For discussion, see:
 * http://www.breezejs.com/documentation/getentitygraph
 *
 * For example usage, see:
 * https://github.com/Breeze/breeze.js.samples/tree/master/net/DocCode/DocCode/tests/getEntityGraphTests.js
 */
//#endregion
import { EntityManager, EntityQuery, EntityState, ExpandClause } from 'breeze-client';
export function mixinEntityGraph(emclass) {
    var proto = EntityManager.prototype;
    if (!proto.getEntityGraph) {
        proto.getEntityGraph = getEntityGraph;
    }
}
mixinEntityGraph(EntityManager);
function getEntityGraph(roots, expand) {
    if (roots instanceof EntityQuery) {
        var newRoots = this.executeQueryLocally(roots);
        return getEntityGraphCore(newRoots, expand || roots.expandClause);
    }
    else {
        return getEntityGraphCore(roots, expand);
    }
}
function getEntityGraphCore(root, expand) {
    var entityGroupMap;
    var graph = [];
    var rootType;
    var roots = Array.isArray(root) ? root : [root];
    addToGraph(roots); // removes dups & nulls
    roots = graph.slice(); // copy of de-duped roots
    if (roots.length) {
        getRootInfo();
        getExpand();
        buildGraph();
    }
    return graph;
    function addToGraph(entities) {
        entities.forEach(function (entity) {
            if (entity && graph.indexOf(entity) < 0) {
                graph.push(entity);
            }
        });
    }
    function getRootInfo() {
        var compatTypes;
        roots.forEach(function (root, ix) {
            var aspect;
            if (!root || !(aspect = root.entityAspect)) {
                throw getRootErr(ix, 'is not an entity');
            }
            if (aspect.entityState === EntityState.Detached) {
                throw getRootErr(ix, 'is a detached entity');
            }
            var em = aspect.entityManager;
            if (entityGroupMap) {
                if (entityGroupMap !== em._entityGroupMap) {
                    throw getRootErr(ix, "has a different 'EntityManager' than other roots");
                }
            }
            else {
                entityGroupMap = em._entityGroupMap;
            }
            getRootType(root, ix);
        });
        function getRootErr(ix, msg) {
            return new Error("'getEntityGraph' root[" + ix + "] " + msg);
        }
        function getRootType(root, ix) {
            var thisType = root.entityType;
            if (!rootType) {
                rootType = thisType;
                return;
            }
            else if (rootType === thisType) {
                return;
            }
            // Types differs. Look for closest common base type
            // does thisType derive from current rootType?
            var baseType = rootType;
            do {
                compatTypes = compatTypes || baseType.getSelfAndSubtypes();
                if (compatTypes.indexOf(thisType) > -1) {
                    rootType = baseType;
                    return;
                }
                baseType = baseType.baseEntityType;
                compatTypes = null;
            } while (baseType);
            // does current rootType derives from thisType?
            baseType = thisType;
            do {
                compatTypes = baseType.getSelfAndSubtypes();
                if (compatTypes.indexOf(rootType) > -1) {
                    rootType = baseType;
                    return;
                }
                baseType = baseType.baseEntityType;
            } while (baseType);
            throw getRootErr(ix, "is not EntityType-compatible with other roots");
        }
    }
    function getExpand() {
        try {
            if (!expand) {
                expand = [];
            }
            else if (typeof expand === 'string') {
                // tricky because Breeze expandClause not exposed publically
                expand = new EntityQuery().expand(expand).expandClause;
            }
            if (expand instanceof ExpandClause && expand.propertyPaths) { // expand clause
                expand = expand.propertyPaths;
            }
            else if (Array.isArray(expand)) {
                if (!expand.every(function (elem) { return typeof elem === 'string'; })) {
                    throw '';
                }
            }
            else {
                throw '';
            }
        }
        catch (_) {
            throw new Error("expand must be an expand string, array of string paths, or a query expand clause");
        }
    }
    function buildGraph() {
        if (expand && expand instanceof Array && expand.length) {
            var fns = expand.map(makePathFn);
            fns.forEach(function (fn) { fn(roots); });
        }
    }
    // Make function to get entities along a single expand path
    // such as 'Orders.OrderDetails.Product'
    function makePathFn(path) {
        var fns = [], segments = path.split('.'), type = rootType;
        for (var i = 0, slen = segments.length; i < slen; i++) {
            var f = makePathSegmentFn(type, segments[i]);
            type = f.navType;
            fns.push(f);
        }
        return function pathFn(entities) {
            for (var j = 0, flen = fns.length; j < flen; j++) {
                var elen = entities.length;
                if (elen === 0) {
                    return;
                } // nothing left to explore
                // fn to get related entities for this path segment
                var fn = fns[j];
                // get entities related by this path segment
                var related = [];
                for (var k = 0; k < elen; k++) {
                    related = related.concat(fn(entities[k]));
                }
                addToGraph(related);
                if (j >= flen - 1) {
                    return;
                } // no more path segments
                // reset entities to deduped related entities
                entities = [];
                for (var l = 0, rlen = related.length; l < rlen; l++) {
                    var r = related[l];
                    if (entities.indexOf(r) < 0) {
                        entities.push(r);
                    }
                }
            }
        };
    }
    // Make function to get entities along a single expand path segment
    // such as the 'OrderDetails' in the 'Orders.OrderDetails.Product' path
    function makePathSegmentFn(baseType, segment) {
        var baseTypeName, fn = undefined, navType;
        try {
            baseTypeName = baseType.name;
            var nav = baseType.getNavigationProperty(segment);
            var fkName_1 = nav.foreignKeyNames[0];
            if (!nav) {
                throw new Error(segment + " is not a navigation property of " + baseTypeName);
            }
            navType = nav.entityType;
            // add derived types
            var navTypes = navType.getSelfAndSubtypes();
            var grps_1 = []; // non-empty groups for these types
            navTypes.forEach(function (t) {
                var grp = entityGroupMap[t.name];
                if (grp && grp._entities.length > 0) {
                    grps_1.push(grp);
                }
            });
            var grpCount_1 = grps_1.length;
            if (grpCount_1 === 0) {
                // no related entities in cache
                fn = function () { return []; };
            }
            else if (fkName_1) {
                fn = function (entity) {
                    var val = null;
                    try {
                        var keyValue = entity.getProperty(fkName_1);
                        for (var i = 0; i < grpCount_1; i += 1) {
                            val = grps_1[i]._entities[grps_1[i]._indexMap[keyValue]];
                            if (val) {
                                break;
                            }
                        }
                    }
                    catch (e) {
                        rethrow(e);
                    }
                    return val;
                };
            }
            else {
                fkName_1 = nav.inverse ?
                    nav.inverse.foreignKeyNames[0] :
                    nav.invForeignKeyNames[0];
                if (!fkName_1) {
                    throw new Error("No inverse keys");
                }
                fn = function (entity) {
                    var vals = [];
                    try {
                        var keyValue_1 = entity.entityAspect.getKey().values[0];
                        grps_1.forEach(function (grp) {
                            vals = vals.concat(grp._entities.filter(function (en) {
                                return en && en.getProperty(fkName_1) === keyValue_1;
                            }));
                        });
                    }
                    catch (e) {
                        rethrow(e);
                    }
                    return vals;
                };
            }
            fn.navType = navType;
            fn.path = segment;
        }
        catch (err) {
            rethrow(err);
        }
        return fn;
        function rethrow(e) {
            var typeName = baseTypeName || baseType;
            var error = new Error("'getEntityGraph' can't expand '" + segment + "' for " + typeName);
            error.innerError = e;
            throw error;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWl4aW4tZ2V0LWVudGl0eS1ncmFwaC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2JyZWV6ZS1jbGllbnQvbWl4aW4tZ2V0LWVudGl0eS1ncmFwaC8iLCJzb3VyY2VzIjpbIm1peGluLWdldC1lbnRpdHktZ3JhcGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNkNBQTZDO0FBQzdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CRztBQUNILFlBQVk7QUFDWixPQUFPLEVBQVUsYUFBYSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQWMsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBc0MxRyxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsT0FBaUM7SUFDaEUsSUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLFNBQVMsQ0FBQztJQUV0QyxJQUFJLENBQUUsS0FBYSxDQUFDLGNBQWMsRUFBRTtRQUNqQyxLQUFhLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztLQUNoRDtBQUNILENBQUM7QUFFRCxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUdoQyxTQUFTLGNBQWMsQ0FBQyxLQUEyQyxFQUFFLE1BQTZDO0lBQ2hILElBQUksS0FBSyxZQUFZLFdBQVcsRUFBRTtRQUNoQyxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0MsT0FBTyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztLQUNuRTtTQUFNO1FBQ0wsT0FBTyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDMUM7QUFDSCxDQUFDO0FBRUQsU0FBUyxrQkFBa0IsQ0FBQyxJQUE0QixFQUFFLE1BQTZDO0lBQ3JHLElBQUksY0FBZ0QsQ0FBQztJQUNyRCxJQUFJLEtBQUssR0FBRyxFQUFtQixDQUFDO0lBQ2hDLElBQUksUUFBb0IsQ0FBQztJQUN6QixJQUFJLEtBQUssR0FBRyxLQUFLLENB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LENBQUMsQ0FBQzthQUNIO1lBQ0EsRUFBVSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7WUFDN0IsRUFBVSxDQUFDLElBQUksR0FBRyxPQUFPLENBQUM7U0FFNUI7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUFFO1FBQy9CLE9BQU8sRUFBRSxDQUFDO1FBRVYsU0FBUyxPQUFPLENBQUMsQ0FBUTtZQUN2QixJQUFJLFFBQVEsR0FBRyxZQUFZLElBQUksUUFBUSxDQUFDO1lBQ3hDLElBQUksS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLGlDQUFpQyxHQUFHLE9BQU8sR0FBRyxRQUFRLEdBQUcsUUFBUSxDQUFDLENBQUM7WUFDeEYsS0FBYSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUM7WUFDOUIsTUFBTSxLQUFLLENBQUM7UUFDZCxDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gQ29weXJpZ2h0LCBWZXJzaW9uLCBhbmQgRGVzY3JpcHRpb25cclxuLypcclxuICogQ29weXJpZ2h0IDIwMTUtMjAxOSBJZGVhQmxhZGUsIEluYy4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqIFVzZSwgcmVwcm9kdWN0aW9uLCBkaXN0cmlidXRpb24sIGFuZCBtb2RpZmljYXRpb24gb2YgdGhpcyBjb2RlIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZFxyXG4gKiBjb25kaXRpb25zIG9mIHRoZSBJZGVhQmxhZGUgQnJlZXplIGxpY2Vuc2UsIGF2YWlsYWJsZSBhdCBodHRwOi8vd3d3LmJyZWV6ZWpzLmNvbS9saWNlbnNlXHJcbiAqXHJcbiAqIEF1dGhvcjogV2FyZCBCZWxsXHJcbiAqIFZlcnNpb246IDAuOS41IC0gU3RldmUgU2NobWl0dCAtIGNvbnZlcnQgdG8gVHlwZVNjcmlwdCwgbWlncmF0ZSB0byBicmVlemUtY2xpZW50IHJlcG8sIGFkZCBIYXNFbnRpdHlHcmFwaCBhbmQgbWl4aW5FbnRpdHlHcmFwaFxyXG4gKiBWZXJzaW9uOiAwLjkuNCAtIE1hcmNlbCBHb29kIC0gZml4IFVNRCBtb2R1bGUgbmFtZVxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gKiBBZGRzIGdldEVudGl0eUdyYXBoIG1ldGhvZCB0byBCcmVlemUgRW50aXR5TWFuYWdlciBwcm90b3R5cGUuXHJcbiAqIENhbGwgICBtaXhpbkVudGl0eUdyYXBoKEVudGl0eU1hbmFnZXIpICAgdG8gYXBwbHkgdGhlIG1peGluIGluIGEgdHJlZS1zaGFraW5nLXJlc2lzdGFudCB3YXkuXHJcbiAqIFRoZW4gICAobWFuYWdlciBhcyBhbnkpLmdldEVudGl0eUdyYXBoKGVudGl0eSwgXCJjaGlsZFwiKTtcclxuICpcclxuICogRGVwZW5kcyBvbiBCcmVlemUgd2hpY2ggaXQgcGF0Y2hlc1xyXG4gKlxyXG4gKiBGb3IgZGlzY3Vzc2lvbiwgc2VlOlxyXG4gKiBodHRwOi8vd3d3LmJyZWV6ZWpzLmNvbS9kb2N1bWVudGF0aW9uL2dldGVudGl0eWdyYXBoXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlIHVzYWdlLCBzZWU6XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9CcmVlemUvYnJlZXplLmpzLnNhbXBsZXMvdHJlZS9tYXN0ZXIvbmV0L0RvY0NvZGUvRG9jQ29kZS90ZXN0cy9nZXRFbnRpdHlHcmFwaFRlc3RzLmpzXHJcbiAqL1xyXG4vLyNlbmRyZWdpb25cclxuaW1wb3J0IHsgRW50aXR5LCBFbnRpdHlNYW5hZ2VyLCBFbnRpdHlRdWVyeSwgRW50aXR5U3RhdGUsIEVudGl0eVR5cGUsIEV4cGFuZENsYXVzZSB9IGZyb20gJ2JyZWV6ZS1jbGllbnQnO1xyXG5cclxuaW50ZXJmYWNlIEVudGl0eUdyb3VwIHtcclxuICBfZW50aXRpZXM6IChFbnRpdHkgfCBudWxsKVtdO1xyXG4gIF9pbmRleE1hcDogeyBbaW5kZXg6IHN0cmluZ106IG51bWJlciB9O1xyXG59XHJcblxyXG4vLyBtb2R1bGUgYXVnbWVudGF0aW9uIGZhaWxlZCB0byBidWlsZCB3aXRoIG5nLXBhY2thZ3IsIHNvIHdlIGhhdmUgYSBzZXBhcmF0ZSBpbnRlcmZhY2VcclxuZXhwb3J0IGludGVyZmFjZSBIYXNFbnRpdHlHcmFwaCBleHRlbmRzIEVudGl0eU1hbmFnZXIge1xyXG4gIC8qKlxyXG4gIEdldCByZWxhdGVkIGVudGl0aWVzIG9mIHJvb3QgZW50aXR5IChvciByb290IGVudGl0aWVzKSBhcyBzcGVjaWZpZWQgYnkgZXhwYW5kLlxyXG4gIEBleGFtcGxlXHJcbiAgICAgIHZhciBncmFwaCA9IGJyZWV6ZS5FbnRpdHlNYW5hZ2VyLmdldEVudGl0eUdyYXBoKGN1c3RvbWVyLCAnT3JkZXJzLk9yZGVyRGV0YWlscycpO1xyXG4gICAgICAvLyBncmFwaCB3aWxsIGJlIHRoZSBjdXN0b21lciwgYWxsIG9mIGl0cyBvcmRlcnMgYW5kIHRoZWlyIGRldGFpbHMgZXZlbiBpZiBkZWxldGVkLlxyXG4gIEBtZXRob2QgZ2V0RW50aXR5R3JhcGhcclxuICBAcGFyYW0gcm9vdHMge0VudGl0eXxBcnJheSBvZiBFbnRpdHl9IFRoZSByb290IGVudGl0eSBvciByb290IGVudGl0aWVzLlxyXG4gIEBwYXJhbSBleHBhbmQge1N0cmluZ3xBcnJheSBvZiBTdHJpbmd8T2JqZWN0fSBhbiBleHBhbmQgc3RyaW5nLCBhIHF1ZXJ5IGV4cGFuZCBjbGF1c2UsIG9yIGFycmF5IG9mIHN0cmluZyBwYXRoc1xyXG4gIEByZXR1cm4ge0FycmF5IG9mIEVudGl0eX0gcm9vdCBlbnRpdGllcyBhbmQgdGhlaXIgcmVsYXRlZCBlbnRpdGllcywgaW5jbHVkaW5nIGRlbGV0ZWQgZW50aXRpZXMuIER1cGxpY2F0ZXMgYXJlIHJlbW92ZWQgYW5kIGVudGl0eSBvcmRlciBpcyBpbmRldGVybWluYXRlLlxyXG4gICoqL1xyXG4gIGdldEVudGl0eUdyYXBoKHJvb3RzOiBFbnRpdHkgfCBBcnJheTxFbnRpdHk+LCBleHBhbmQ6IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfCBFeHBhbmRDbGF1c2UpOiBBcnJheTxFbnRpdHk+O1xyXG5cclxuICAvKipcclxuICBFeGVjdXRlIHF1ZXJ5IGxvY2FsbHkgYW5kIHJldHVybiBib3RoIHRoZSBxdWVyeSByZXN1bHRzIGFuZCB0aGVpciByZWxhdGVkIGVudGl0aWVzIGFzIHNwZWNpZmllZCBieSB0aGUgb3B0aW9uYWwgZXhwYW5kIHBhcmFtZXRlciBvciB0aGUgcXVlcnkncyBleHBhbmQgY2xhdXNlLlxyXG4gIEBleGFtcGxlXHJcbiAgICAgIHZhciBxdWVyeSA9IGJyZWV6ZS5FbnRpdHlRdWVyeS5mcm9tKCdDdXN0b21lcnMnKVxyXG4gICAgICAgICAgICAgICAgICAud2hlcmUoJ0NvbXBhbnlOYW1lJywgJ3N0YXJ0c1dpdGgnLCAnQWxmcmVkJylcclxuICAgICAgICAgICAgICAgICAgLmV4cGFuZCgnT3JkZXJzLk9yZGVyRGV0YWlscycpO1xyXG4gICAgICB2YXIgZ3JhcGggPSBtYW5hZ2VyLmdldEVudGl0eUdyYXBoKHF1ZXJ5KTtcclxuICAgICAgLy8gZ3JhcGggd2lsbCBiZSB0aGUgJ0FsZnJlZCcgY3VzdG9tZXJzLCB0aGVpciBvcmRlcnMgYW5kIHRoZWlyIGRldGFpbHMgZXZlbiBpZiBkZWxldGVkLlxyXG4gIEBtZXRob2QgZ2V0RW50aXR5R3JhcGhcclxuICBAcGFyYW0gcXVlcnkge0VudGl0eVF1ZXJ5fSBBIHF1ZXJ5IHRvIGJlIGV4ZWN1dGVkIGFnYWluc3QgdGhlIG1hbmFnZXIncyBsb2NhbCBjYWNoZS5cclxuICBAcGFyYW0gW2V4cGFuZF0ge1N0cmluZ3xBcnJheSBvZiBTdHJpbmd8T2JqZWN0fSBhbiBleHBhbmQgc3RyaW5nLCBhIHF1ZXJ5IGV4cGFuZCBjbGF1c2UsIG9yIGFycmF5IG9mIHN0cmluZyBwYXRoc1xyXG4gIEByZXR1cm4ge0FycmF5IG9mIEVudGl0eX0gbG9jYWwgcXVlcmllZCByb290IGVudGl0aWVzIGFuZCB0aGVpciByZWxhdGVkIGVudGl0aWVzLCBpbmNsdWRpbmcgZGVsZXRlZCBlbnRpdGllcy4gRHVwbGljYXRlcyBhcmUgcmVtb3ZlZCBhbmQgZW50aXR5IG9yZGVyIGlzIGluZGV0ZXJtaW5hdGUuXHJcbiAgKiovXHJcbiAgZ2V0RW50aXR5R3JhcGgocXVlcnk6IEVudGl0eVF1ZXJ5LCBleHBhbmQ6IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfCBFeHBhbmRDbGF1c2UpOiBBcnJheTxFbnRpdHk+O1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1peGluRW50aXR5R3JhcGgoZW1jbGFzczogeyBuZXcoKTogRW50aXR5TWFuYWdlciB9KSB7XHJcbiAgY29uc3QgcHJvdG8gPSBFbnRpdHlNYW5hZ2VyLnByb3RvdHlwZTtcclxuXHJcbiAgaWYgKCEocHJvdG8gYXMgYW55KS5nZXRFbnRpdHlHcmFwaCkge1xyXG4gICAgKHByb3RvIGFzIGFueSkuZ2V0RW50aXR5R3JhcGggPSBnZXRFbnRpdHlHcmFwaDtcclxuICB9XHJcbn1cclxuXHJcbm1peGluRW50aXR5R3JhcGgoRW50aXR5TWFuYWdlcik7XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0RW50aXR5R3JhcGgocm9vdHM6IEVudGl0eSB8IEFycmF5PEVudGl0eT4gfCBFbnRpdHlRdWVyeSwgZXhwYW5kOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+IHwgRXhwYW5kQ2xhdXNlKSB7XHJcbiAgaWYgKHJvb3RzIGluc3RhbmNlb2YgRW50aXR5UXVlcnkpIHtcclxuICAgIGxldCBuZXdSb290cyA9IHRoaXMuZXhlY3V0ZVF1ZXJ5TG9jYWxseShyb290cyk7XHJcbiAgICByZXR1cm4gZ2V0RW50aXR5R3JhcGhDb3JlKG5ld1Jvb3RzLCBleHBhbmQgfHwgcm9vdHMuZXhwYW5kQ2xhdXNlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGdldEVudGl0eUdyYXBoQ29yZShyb290cywgZXhwYW5kKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEVudGl0eUdyYXBoQ29yZShyb290OiBFbnRpdHkgfCBBcnJheTxFbnRpdHk+LCBleHBhbmQ6IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfCBFeHBhbmRDbGF1c2UpIHtcclxuICBsZXQgZW50aXR5R3JvdXBNYXA6IHsgW2luZGV4OiBzdHJpbmddOiBFbnRpdHlHcm91cCB9O1xyXG4gIGxldCBncmFwaCA9IFtdIGFzIEFycmF5PEVudGl0eT47XHJcbiAgbGV0IHJvb3RUeXBlOiBFbnRpdHlUeXBlO1xyXG4gIGxldCByb290cyA9IEFycmF5LmlzQXJyYXkocm9vdCkgPyByb290IDogW3Jvb3RdO1xyXG4gIGFkZFRvR3JhcGgocm9vdHMpOyAgICAgLy8gcmVtb3ZlcyBkdXBzICYgbnVsbHNcclxuICByb290cyA9IGdyYXBoLnNsaWNlKCk7IC8vIGNvcHkgb2YgZGUtZHVwZWQgcm9vdHNcclxuICBpZiAocm9vdHMubGVuZ3RoKSB7XHJcbiAgICBnZXRSb290SW5mbygpO1xyXG4gICAgZ2V0RXhwYW5kKCk7XHJcbiAgICBidWlsZEdyYXBoKCk7XHJcbiAgfVxyXG4gIHJldHVybiBncmFwaDtcclxuXHJcbiAgZnVuY3Rpb24gYWRkVG9HcmFwaChlbnRpdGllczogQXJyYXk8RW50aXR5Pikge1xyXG4gICAgZW50aXRpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgIGlmIChlbnRpdHkgJiYgZ3JhcGguaW5kZXhPZihlbnRpdHkpIDwgMCkge1xyXG4gICAgICAgIGdyYXBoLnB1c2goZW50aXR5KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRSb290SW5mbygpIHtcclxuICAgIGxldCBjb21wYXRUeXBlczogQXJyYXk8RW50aXR5VHlwZT47XHJcblxyXG4gICAgcm9vdHMuZm9yRWFjaChmdW5jdGlvbiAocm9vdCwgaXgpIHtcclxuICAgICAgbGV0IGFzcGVjdDtcclxuICAgICAgaWYgKCFyb290IHx8ICEoYXNwZWN0ID0gcm9vdC5lbnRpdHlBc3BlY3QpKSB7XHJcbiAgICAgICAgdGhyb3cgZ2V0Um9vdEVycihpeCwgJ2lzIG5vdCBhbiBlbnRpdHknKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYXNwZWN0LmVudGl0eVN0YXRlID09PSBFbnRpdHlTdGF0ZS5EZXRhY2hlZCkge1xyXG4gICAgICAgIHRocm93IGdldFJvb3RFcnIoaXgsICdpcyBhIGRldGFjaGVkIGVudGl0eScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgZW0gPSBhc3BlY3QuZW50aXR5TWFuYWdlcjtcclxuICAgICAgaWYgKGVudGl0eUdyb3VwTWFwKSB7XHJcbiAgICAgICAgaWYgKGVudGl0eUdyb3VwTWFwICE9PSBlbS5fZW50aXR5R3JvdXBNYXApIHtcclxuICAgICAgICAgIHRocm93IGdldFJvb3RFcnIoaXgsIFwiaGFzIGEgZGlmZmVyZW50ICdFbnRpdHlNYW5hZ2VyJyB0aGFuIG90aGVyIHJvb3RzXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbnRpdHlHcm91cE1hcCA9IGVtLl9lbnRpdHlHcm91cE1hcDtcclxuICAgICAgfVxyXG4gICAgICBnZXRSb290VHlwZShyb290LCBpeCk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Um9vdEVycihpeDogbnVtYmVyLCBtc2c6IHN0cmluZykge1xyXG4gICAgICByZXR1cm4gbmV3IEVycm9yKFwiJ2dldEVudGl0eUdyYXBoJyByb290W1wiICsgaXggKyBcIl0gXCIgKyBtc2cpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFJvb3RUeXBlKHJvb3Q6IEVudGl0eSwgaXg6IG51bWJlcikge1xyXG4gICAgICBsZXQgdGhpc1R5cGUgPSByb290LmVudGl0eVR5cGU7XHJcbiAgICAgIGlmICghcm9vdFR5cGUpIHtcclxuICAgICAgICByb290VHlwZSA9IHRoaXNUeXBlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIGlmIChyb290VHlwZSA9PT0gdGhpc1R5cGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gVHlwZXMgZGlmZmVycy4gTG9vayBmb3IgY2xvc2VzdCBjb21tb24gYmFzZSB0eXBlXHJcbiAgICAgIC8vIGRvZXMgdGhpc1R5cGUgZGVyaXZlIGZyb20gY3VycmVudCByb290VHlwZT9cclxuICAgICAgbGV0IGJhc2VUeXBlID0gcm9vdFR5cGU7XHJcbiAgICAgIGRvIHtcclxuICAgICAgICBjb21wYXRUeXBlcyA9IGNvbXBhdFR5cGVzIHx8IGJhc2VUeXBlLmdldFNlbGZBbmRTdWJ0eXBlcygpO1xyXG4gICAgICAgIGlmIChjb21wYXRUeXBlcy5pbmRleE9mKHRoaXNUeXBlKSA+IC0xKSB7XHJcbiAgICAgICAgICByb290VHlwZSA9IGJhc2VUeXBlO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiYXNlVHlwZSA9IGJhc2VUeXBlLmJhc2VFbnRpdHlUeXBlO1xyXG4gICAgICAgIGNvbXBhdFR5cGVzID0gbnVsbDtcclxuICAgICAgfSB3aGlsZSAoYmFzZVR5cGUpO1xyXG5cclxuICAgICAgLy8gZG9lcyBjdXJyZW50IHJvb3RUeXBlIGRlcml2ZXMgZnJvbSB0aGlzVHlwZT9cclxuICAgICAgYmFzZVR5cGUgPSB0aGlzVHlwZTtcclxuICAgICAgZG8ge1xyXG4gICAgICAgIGNvbXBhdFR5cGVzID0gYmFzZVR5cGUuZ2V0U2VsZkFuZFN1YnR5cGVzKCk7XHJcbiAgICAgICAgaWYgKGNvbXBhdFR5cGVzLmluZGV4T2Yocm9vdFR5cGUpID4gLTEpIHtcclxuICAgICAgICAgIHJvb3RUeXBlID0gYmFzZVR5cGU7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJhc2VUeXBlID0gYmFzZVR5cGUuYmFzZUVudGl0eVR5cGU7XHJcbiAgICAgIH0gd2hpbGUgKGJhc2VUeXBlKTtcclxuXHJcbiAgICAgIHRocm93IGdldFJvb3RFcnIoaXgsIFwiaXMgbm90IEVudGl0eVR5cGUtY29tcGF0aWJsZSB3aXRoIG90aGVyIHJvb3RzXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0RXhwYW5kKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFleHBhbmQpIHtcclxuICAgICAgICBleHBhbmQgPSBbXTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwYW5kID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vIHRyaWNreSBiZWNhdXNlIEJyZWV6ZSBleHBhbmRDbGF1c2Ugbm90IGV4cG9zZWQgcHVibGljYWxseVxyXG4gICAgICAgIGV4cGFuZCA9IG5ldyBFbnRpdHlRdWVyeSgpLmV4cGFuZChleHBhbmQpLmV4cGFuZENsYXVzZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXhwYW5kIGluc3RhbmNlb2YgRXhwYW5kQ2xhdXNlICYmIGV4cGFuZC5wcm9wZXJ0eVBhdGhzKSB7IC8vIGV4cGFuZCBjbGF1c2VcclxuICAgICAgICBleHBhbmQgPSBleHBhbmQucHJvcGVydHlQYXRocztcclxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV4cGFuZCkpIHtcclxuICAgICAgICBpZiAoIWV4cGFuZC5ldmVyeShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdHlwZW9mIGVsZW0gPT09ICdzdHJpbmcnOyB9KSkge1xyXG4gICAgICAgICAgdGhyb3cgJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93ICcnO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBcImV4cGFuZCBtdXN0IGJlIGFuIGV4cGFuZCBzdHJpbmcsIGFycmF5IG9mIHN0cmluZyBwYXRocywgb3IgYSBxdWVyeSBleHBhbmQgY2xhdXNlXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYnVpbGRHcmFwaCgpIHtcclxuICAgIGlmIChleHBhbmQgJiYgZXhwYW5kIGluc3RhbmNlb2YgQXJyYXkgJiYgZXhwYW5kLmxlbmd0aCkge1xyXG4gICAgICBsZXQgZm5zID0gZXhwYW5kLm1hcChtYWtlUGF0aEZuKTtcclxuICAgICAgZm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IGZuKHJvb3RzKTsgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBNYWtlIGZ1bmN0aW9uIHRvIGdldCBlbnRpdGllcyBhbG9uZyBhIHNpbmdsZSBleHBhbmQgcGF0aFxyXG4gIC8vIHN1Y2ggYXMgJ09yZGVycy5PcmRlckRldGFpbHMuUHJvZHVjdCdcclxuICBmdW5jdGlvbiBtYWtlUGF0aEZuKHBhdGg6IHN0cmluZykge1xyXG4gICAgbGV0IGZucyA9IFtdIGFzIEFycmF5PEZ1bmN0aW9uPixcclxuICAgICAgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyksXHJcbiAgICAgIHR5cGUgPSByb290VHlwZTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMCwgc2xlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IHNsZW47IGkrKykge1xyXG4gICAgICBsZXQgZiA9IG1ha2VQYXRoU2VnbWVudEZuKHR5cGUsIHNlZ21lbnRzW2ldKTtcclxuICAgICAgdHlwZSA9IChmIGFzIGFueSkubmF2VHlwZTtcclxuICAgICAgZm5zLnB1c2goZik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGhGbihlbnRpdGllczogQXJyYXk8RW50aXR5Pikge1xyXG4gICAgICBmb3IgKGxldCBqID0gMCwgZmxlbiA9IGZucy5sZW5ndGg7IGogPCBmbGVuOyBqKyspIHtcclxuICAgICAgICBsZXQgZWxlbiA9IGVudGl0aWVzLmxlbmd0aDtcclxuICAgICAgICBpZiAoZWxlbiA9PT0gMCkgeyByZXR1cm47IH0gLy8gbm90aGluZyBsZWZ0IHRvIGV4cGxvcmVcclxuICAgICAgICAvLyBmbiB0byBnZXQgcmVsYXRlZCBlbnRpdGllcyBmb3IgdGhpcyBwYXRoIHNlZ21lbnRcclxuICAgICAgICBsZXQgZm4gPSBmbnNbal07XHJcbiAgICAgICAgLy8gZ2V0IGVudGl0aWVzIHJlbGF0ZWQgYnkgdGhpcyBwYXRoIHNlZ21lbnRcclxuICAgICAgICBsZXQgcmVsYXRlZCA9IFtdIGFzIEFycmF5PEVudGl0eT47XHJcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBlbGVuOyBrKyspIHtcclxuICAgICAgICAgIHJlbGF0ZWQgPSByZWxhdGVkLmNvbmNhdChmbihlbnRpdGllc1trXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRUb0dyYXBoKHJlbGF0ZWQpO1xyXG4gICAgICAgIGlmIChqID49IGZsZW4gLSAxKSB7IHJldHVybjsgfSAvLyBubyBtb3JlIHBhdGggc2VnbWVudHNcclxuXHJcbiAgICAgICAgLy8gcmVzZXQgZW50aXRpZXMgdG8gZGVkdXBlZCByZWxhdGVkIGVudGl0aWVzXHJcbiAgICAgICAgZW50aXRpZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBsID0gMCwgcmxlbiA9IHJlbGF0ZWQubGVuZ3RoOyBsIDwgcmxlbjsgbCsrKSB7XHJcbiAgICAgICAgICBsZXQgciA9IHJlbGF0ZWRbbF07XHJcbiAgICAgICAgICBpZiAoZW50aXRpZXMuaW5kZXhPZihyKSA8IDApIHsgZW50aXRpZXMucHVzaChyKTsgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIE1ha2UgZnVuY3Rpb24gdG8gZ2V0IGVudGl0aWVzIGFsb25nIGEgc2luZ2xlIGV4cGFuZCBwYXRoIHNlZ21lbnRcclxuICAvLyBzdWNoIGFzIHRoZSAnT3JkZXJEZXRhaWxzJyBpbiB0aGUgJ09yZGVycy5PcmRlckRldGFpbHMuUHJvZHVjdCcgcGF0aFxyXG4gIGZ1bmN0aW9uIG1ha2VQYXRoU2VnbWVudEZuKGJhc2VUeXBlOiBFbnRpdHlUeXBlLCBzZWdtZW50OiBzdHJpbmcpIHtcclxuICAgIGxldCBiYXNlVHlwZU5hbWU6IHN0cmluZywgZm4gPSB1bmRlZmluZWQsIG5hdlR5cGU7XHJcbiAgICB0cnkge1xyXG4gICAgICBiYXNlVHlwZU5hbWUgPSBiYXNlVHlwZS5uYW1lO1xyXG4gICAgICBsZXQgbmF2ID0gYmFzZVR5cGUuZ2V0TmF2aWdhdGlvblByb3BlcnR5KHNlZ21lbnQpO1xyXG4gICAgICBsZXQgZmtOYW1lID0gbmF2LmZvcmVpZ25LZXlOYW1lc1swXTtcclxuICAgICAgaWYgKCFuYXYpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2VnbWVudCArIFwiIGlzIG5vdCBhIG5hdmlnYXRpb24gcHJvcGVydHkgb2YgXCIgKyBiYXNlVHlwZU5hbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIG5hdlR5cGUgPSBuYXYuZW50aXR5VHlwZTtcclxuICAgICAgLy8gYWRkIGRlcml2ZWQgdHlwZXNcclxuICAgICAgbGV0IG5hdlR5cGVzID0gbmF2VHlwZS5nZXRTZWxmQW5kU3VidHlwZXMoKTtcclxuICAgICAgbGV0IGdycHMgPSBbXSBhcyBBcnJheTxFbnRpdHlHcm91cD47IC8vIG5vbi1lbXB0eSBncm91cHMgZm9yIHRoZXNlIHR5cGVzXHJcbiAgICAgIG5hdlR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBsZXQgZ3JwID0gZW50aXR5R3JvdXBNYXBbdC5uYW1lXTtcclxuICAgICAgICBpZiAoZ3JwICYmIGdycC5fZW50aXRpZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgZ3Jwcy5wdXNoKGdycCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgbGV0IGdycENvdW50ID0gZ3Jwcy5sZW5ndGg7XHJcbiAgICAgIGlmIChncnBDb3VudCA9PT0gMCkge1xyXG4gICAgICAgIC8vIG5vIHJlbGF0ZWQgZW50aXRpZXMgaW4gY2FjaGVcclxuICAgICAgICBmbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIGFzIEFycmF5PEVudGl0eT47IH07XHJcbiAgICAgIH0gZWxzZSBpZiAoZmtOYW1lKSB7XHJcbiAgICAgICAgZm4gPSBmdW5jdGlvbiAoZW50aXR5OiBFbnRpdHkpIHtcclxuICAgICAgICAgIGxldCB2YWwgPSBudWxsO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IGtleVZhbHVlID0gZW50aXR5LmdldFByb3BlcnR5KGZrTmFtZSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JwQ291bnQ7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgIHZhbCA9IGdycHNbaV0uX2VudGl0aWVzW2dycHNbaV0uX2luZGV4TWFwW2tleVZhbHVlXV07XHJcbiAgICAgICAgICAgICAgaWYgKHZhbCkgeyBicmVhazsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7IHJldGhyb3coZSk7IH1cclxuICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBma05hbWUgPSBuYXYuaW52ZXJzZSA/XHJcbiAgICAgICAgICBuYXYuaW52ZXJzZS5mb3JlaWduS2V5TmFtZXNbMF0gOlxyXG4gICAgICAgICAgbmF2LmludkZvcmVpZ25LZXlOYW1lc1swXTtcclxuICAgICAgICBpZiAoIWZrTmFtZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJObyBpbnZlcnNlIGtleXNcIik7IH1cclxuICAgICAgICBmbiA9IGZ1bmN0aW9uIChlbnRpdHk6IEVudGl0eSkge1xyXG4gICAgICAgICAgbGV0IHZhbHMgPSBbXSBhcyBBcnJheTxFbnRpdHk+O1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IGtleVZhbHVlID0gZW50aXR5LmVudGl0eUFzcGVjdC5nZXRLZXkoKS52YWx1ZXNbMF07XHJcbiAgICAgICAgICAgIGdycHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JwKSB7XHJcbiAgICAgICAgICAgICAgdmFscyA9IHZhbHMuY29uY2F0KGdycC5fZW50aXRpZXMuZmlsdGVyKGZ1bmN0aW9uIChlbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuICYmIGVuLmdldFByb3BlcnR5KGZrTmFtZSkgPT09IGtleVZhbHVlO1xyXG4gICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7IHJldGhyb3coZSk7IH1cclxuICAgICAgICAgIHJldHVybiB2YWxzO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgKGZuIGFzIGFueSkubmF2VHlwZSA9IG5hdlR5cGU7XHJcbiAgICAgIChmbiBhcyBhbnkpLnBhdGggPSBzZWdtZW50O1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycikgeyByZXRocm93KGVycik7IH1cclxuICAgIHJldHVybiBmbjtcclxuXHJcbiAgICBmdW5jdGlvbiByZXRocm93KGU6IEVycm9yKSB7XHJcbiAgICAgIGxldCB0eXBlTmFtZSA9IGJhc2VUeXBlTmFtZSB8fCBiYXNlVHlwZTtcclxuICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKFwiJ2dldEVudGl0eUdyYXBoJyBjYW4ndCBleHBhbmQgJ1wiICsgc2VnbWVudCArIFwiJyBmb3IgXCIgKyB0eXBlTmFtZSk7XHJcbiAgICAgIChlcnJvciBhcyBhbnkpLmlubmVyRXJyb3IgPSBlO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcblxyXG4iXX0=