import { __extends } from 'tslib';
import { EntityState, breeze } from 'breeze-client';

function enableSaveQueuing(em, enable) {
    if (enable === void 0) { enable = true; }
    var saveQueuing = em['_saveQueueing'] ||
        (em['_saveQueuing'] = new SaveQueuing(em));
    enable = (enable === undefined) ? true : enable;
    saveQueuing._isEnabled = enable;
    if (enable) {
        // delegate to save changes queuing
        em.saveChanges = saveChangesWithQueuing;
    }
    else {
        // revert to the native EntityManager.saveChanges
        em.saveChanges = em['_saveQueuing'].baseSaveChanges;
    }
}
/**
 * Replacement for EntityManager.saveChanges
 * This version queues saveChanges calls while a real save is in progress
 **/
function saveChangesWithQueuing(entities, saveOptions) {
    try {
        // `this` is an EntityManager
        var saveQueuing = this._saveQueuing;
        if (saveQueuing.isSaving) {
            // save in progress; queue the save for later
            return saveQueuing.queueSaveChanges(entities);
        }
        else {
            // note that save is in progress; then save
            saveQueuing.isSaving = true;
            saveQueuing.saveOptions = saveOptions;
            return saveQueuing.saveChanges(entities, saveOptions);
        }
    }
    catch (err) {
        return Promise.reject(err);
    }
}
///////// SaveQueuing /////////
var SaveQueuing = /** @class */ (function () {
    function SaveQueuing(entityManager) {
        this.entityManager = entityManager;
        this.baseSaveChanges = entityManager.saveChanges;
        this.isSaving = false;
    }
    SaveQueuing.prototype.isEnabled = function () {
        return this._isEnabled;
    };
    SaveQueuing.prototype.getSavedNothingResult = function () {
        return { entities: [], keyMappings: [] };
    };
    SaveQueuing.prototype.queueSaveChanges = function (entities) {
        var self = this; // `this` is a SaveQueuing
        var em = self.entityManager;
        var changes = entities || em.getChanges();
        if (changes.length === 0) {
            return Promise.resolve(this.getSavedNothingResult());
        }
        var valError = em.saveChangesValidateOnClient(changes);
        if (valError) {
            return Promise.reject(valError);
        }
        var saveMemo = self.nextSaveMemo || (self.nextSaveMemo = new SaveMemo());
        memoizeChanges();
        var deferred = self.nextSaveDeferred || (self.nextSaveDeferred = new Deferred());
        return deferred.promise;
        function memoizeChanges() {
            if (changes.length === 0) {
                return;
            }
            var queuedChanges = saveMemo.queuedChanges;
            changes.forEach(function (e) {
                if (!e.entityAspect.isBeingSaved && queuedChanges.indexOf(e) === -1) {
                    queuedChanges.push(e);
                }
            });
            saveMemo.updateEntityMemos(changes);
        }
    };
    SaveQueuing.prototype.saveChanges = function (entities, saveOptions) {
        var self = this; // `this` is a SaveQueuing
        var promise = self.baseSaveChanges.call(self.entityManager, entities, saveOptions || self.saveOptions)
            .then(function (saveResult) { return self.saveSucceeded(saveResult); })
            .then(null, function (error) { console.log(error); return self.saveFailed(error); });
        rememberAddedOriginalValues(entities); // do it after ... so don't send OrigValues to the server
        return promise;
        function rememberAddedOriginalValues(entities) {
            // added entities normally don't have original values but these will now
            var added = entities ?
                entities.filter(function (e) { return e.entityAspect.entityState.isAdded(); }) :
                self.entityManager.getEntities(null, EntityState.Added);
            added.forEach(function (entity) {
                var props = entity.entityType.dataProperties;
                var originalValues = entity.entityAspect.originalValues;
                props.forEach(function (dp) {
                    if (dp.isPartOfKey) {
                        return;
                    }
                    originalValues[dp.name] = entity.getProperty(dp.name);
                });
            });
        }
    };
    SaveQueuing.prototype.saveSucceeded = function (saveResult) {
        var self = this; // `this` is a SaveQueueing
        var activeSaveDeferred = self.activeSaveDeferred;
        var nextSaveDeferred = self.nextSaveDeferred;
        var nextSaveMemo = self.nextSaveMemo;
        // prepare as if nothing queued or left to save
        self.isSaving = false;
        self.activeSaveDeferred = null;
        self.activeSaveMemo = null;
        self.nextSaveDeferred = null;
        self.nextSaveMemo = null;
        if (nextSaveMemo) {
            // a save was queued since last save returned
            nextSaveMemo.pkFixup(saveResult.keyMappings);
            nextSaveMemo.applyToSavedEntities(self.entityManager, saveResult.entities);
            // remove detached entities from queuedChanges
            var queuedChanges = nextSaveMemo.queuedChanges.filter(function (e) {
                return !e.entityAspect.entityState.isDetached();
            });
            if (queuedChanges.length > 0) {
                // save again
                self.isSaving = true;
                // remember the queued changes that triggered this save
                self.activeSaveDeferred = nextSaveDeferred;
                self.activeSaveMemo = nextSaveMemo;
                self.saveChanges(queuedChanges, this.saveOptions);
            }
            else if (nextSaveDeferred) {
                nextSaveDeferred.resolve(this.getSavedNothingResult());
            }
        }
        if (activeSaveDeferred) {
            activeSaveDeferred.resolve(saveResult);
        }
        return saveResult; // for the current promise chain
    };
    SaveQueuing.prototype.saveFailed = function (error) {
        var self = this; // `this` is a SaveQueueing
        error = new QueuedSaveFailedError(error, self);
        var activeSaveDeferred = self.activeSaveDeferred;
        var nextSaveDeferred = self.nextSaveDeferred;
        self.isSaving = false;
        self.activeSaveDeferred = null;
        self.activeSaveMemo = null;
        self.nextSaveDeferred = null;
        self.nextSaveMemo = null;
        if (activeSaveDeferred) {
            activeSaveDeferred.reject(error);
        }
        if (nextSaveDeferred) {
            nextSaveDeferred.reject(error);
        }
        return Promise.reject(error); // let promise chain hear error
    };
    return SaveQueuing;
}());
/// for backward compat with older Promise implementation
var Deferred = /** @class */ (function () {
    function Deferred() {
        this.promise = new Promise(function (resolve, reject) {
            this.resolve = resolve;
            this.reject = reject;
        }.bind(this));
    }
    return Deferred;
}());
////////// QueuedSaveFailedError /////////
// Error sub-class thrown when rejecting queued saves.
var QueuedSaveFailedError = /** @class */ (function (_super) {
    __extends(QueuedSaveFailedError, _super);
    // Error sub-class thrown when rejecting queued saves.
    // `innerError` is the actual save error
    // `failedSaveMemo` is the saveMemo that prompted this save
    // `nextSaveMemo` holds queued changes accumulated since that save.
    // You may try to recover using this info. Good luck with that.
    function QueuedSaveFailedError(errObject, saveQueuing) {
        var _this = _super.call(this) || this;
        _this.name = "QueuedSaveFailedError";
        _this.innerError = errObject;
        _this.message = "Queued save failed: " + errObject.message;
        _this.failedSaveMemo = saveQueuing.activeSaveMemo;
        _this.nextSaveMemo = saveQueuing.nextSaveMemo;
        return _this;
    }
    return QueuedSaveFailedError;
}(Error));
////////// SaveMemo ////////////////
// SaveMemo is a record of changes for a queued save, consisting of:
//   entityMemos:   info about entities that are being saved and
//                  have been changed since the save started
//   queuedChanges: entities that are queued for save but
//                  are not currently being saved
var SaveMemo = /** @class */ (function () {
    function SaveMemo() {
        this.entityMemos = {};
        this.queuedChanges = [];
    }
    SaveMemo.prototype.applyToSavedEntities = function (entityManager, savedEntities) {
        var _this = this;
        var entityMemos = this.entityMemos; // `this` is a SaveMemo
        var queuedChanges = this.queuedChanges;
        var restorePublishing = this.disableManagerPublishing(entityManager);
        try {
            savedEntities.forEach(function (saved) {
                var key = _this.makeEntityMemoKey(saved);
                var entityMemo = entityMemos[key];
                var resave = entityMemo && entityMemo.applyToSavedEntity(saved);
                if (resave) {
                    queuedChanges.push(saved);
                }
            });
        }
        finally {
            restorePublishing();
            // D#2651 hasChanges will be wrong if changes made while save in progress
            var hasChanges = queuedChanges.length > 0;
            // Must use breeze internal method to properly set this flag true
            if (hasChanges) {
                entityManager._setHasChanges(true);
            }
        }
    };
    SaveMemo.prototype.disableManagerPublishing = function (manager) {
        var Event = breeze.Event;
        Event.enable('entityChanged', manager, false);
        Event.enable('hasChangesChanged', manager, false);
        return function restorePublishing() {
            Event.enable('entityChanged', manager, true);
            Event.enable('hasChangesChanged', manager, true);
        };
    };
    SaveMemo.prototype.pkFixup = function (keyMappings) {
        var entityMemos = this.entityMemos; // `this` is a SaveMemo
        keyMappings.forEach(function (km) {
            var type = km.entityTypeName;
            var tempKey = type + '|' + km.tempValue;
            if (entityMemos[tempKey]) {
                entityMemos[type + '|' + km.realValue] = entityMemos[tempKey];
                delete entityMemos[tempKey];
            }
            for (var memoKey in entityMemos) {
                entityMemos[memoKey].fkFixup(km);
            }
        });
    };
    SaveMemo.prototype.makeEntityMemoKey = function (entity) {
        var entityKey = entity.entityAspect.getKey();
        return entityKey.entityType.name + '|' + entityKey.values;
    };
    SaveMemo.prototype.updateEntityMemos = function (changes) {
        var _this = this;
        var entityMemos = this.entityMemos; // `this` is a SaveMemo
        changes.forEach(function (change) {
            // only update entityMemo for entity being save
            if (!change.entityAspect.isBeingSaved) {
                return;
            }
            var key = _this.makeEntityMemoKey(change);
            var entityMemo = entityMemos[key] || (entityMemos[key] = new EntityMemo(change));
            entityMemo.update(change);
        });
    };
    return SaveMemo;
}());
///////// EntityMemo Type ///////////////
// Information about an entity that is being saved
// and which has been changed since that save started
var EntityMemo = /** @class */ (function () {
    function EntityMemo(entity) {
        this.entity = entity;
        this.pendingChanges = {};
    }
    EntityMemo.prototype.applyToSavedEntity = function (saved) {
        var entityMemo = this;
        var aspect = saved.entityAspect;
        if (aspect.entityState.isDetached()) {
            return false;
        }
        else if (entityMemo.isDeleted) {
            aspect.setDeleted();
            return true;
        }
        // treat entity with pending changes as modified
        var props = Object.keys(entityMemo.pendingChanges);
        if (props.length === 0) {
            return false;
        }
        var originalValues = aspect.originalValues;
        props.forEach(function (name) {
            originalValues[name] = saved.getProperty(name);
            saved.setProperty(name, entityMemo.pendingChanges[name]);
        });
        aspect.setModified();
        return true;
    };
    EntityMemo.prototype.fkFixup = function (keyMapping) {
        var entityMemo = this;
        var type = entityMemo.entity.entityType;
        var fkProps = type.foreignKeyProperties;
        fkProps.forEach(function (fkProp) {
            if (fkProp.parentType.name === keyMapping.entityTypeName &&
                entityMemo.pendingChanges[fkProp.name] === keyMapping.tempValue) {
                entityMemo.pendingChanges[fkProp.name] = keyMapping.realValue;
            }
        });
    };
    // update the entityMemo of changes to an entity being saved
    // so that we know how to save it again later
    EntityMemo.prototype.update = function () {
        var entityMemo = this;
        var props;
        var entity = entityMemo.entity;
        var aspect = entity.entityAspect;
        var stateName = aspect.entityState.name;
        switch (stateName) {
            case 'Added':
                var originalValues_1 = aspect.originalValues;
                props = entity.entityType.dataProperties;
                props.forEach(function (dp) {
                    if (dp.isPartOfKey) {
                        return;
                    }
                    var name = dp.name;
                    var value = entity.getProperty(name);
                    if (originalValues_1[name] !== value) {
                        entityMemo.pendingChanges[name] = value;
                    }
                });
                break;
            case 'Deleted':
                entityMemo.isDeleted = true;
                entityMemo.pendingChanges = {};
                break;
            case 'Modified':
                props = Object.keys(aspect.originalValues);
                props.forEach(function (name) {
                    entityMemo.pendingChanges[name] = entity.getProperty(name);
                });
                break;
        }
    };
    return EntityMemo;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { enableSaveQueuing };
//# sourceMappingURL=breeze-client-mixin-save-queuing.js.map
