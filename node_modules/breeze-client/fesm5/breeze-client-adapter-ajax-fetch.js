import { core as core$1, config } from 'breeze-client';

var core = core$1;
/** Breeze AJAX adapter using fetch API
 * See https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
*/
var AjaxFetchAdapter = /** @class */ (function () {
    function AjaxFetchAdapter() {
        this.name = AjaxFetchAdapter.adapterName;
        this.defaultSettings = {};
        this.requestInterceptor = undefined;
    }
    AjaxFetchAdapter.register = function (config$1) {
        config$1 = config$1 || config;
        config$1.registerAdapter("ajax", AjaxFetchAdapter);
        return config$1.initializeAdapterInstance("ajax", AjaxFetchAdapter.adapterName, true);
    };
    AjaxFetchAdapter.prototype.initialize = function () {
    };
    AjaxFetchAdapter.prototype.ajax = function (config) {
        if (!fetch) {
            throw new Error("fetch API not supported in this browser");
        }
        var init = {
            method: config.type,
            mode: 'cors',
            cache: 'no-cache',
            credentials: 'include',
            headers: {
                'Content-Type': config.contentType || 'application/json',
            },
            redirect: 'follow',
            referrer: 'client',
        };
        if (config.type !== "GET" && config.type !== "HEAD") {
            // body data type must match "Content-Type" header
            // let data = config.params || config.data;
            var data = config.data;
            if (typeof (data) !== "string") {
                data = JSON.stringify(data);
            }
            init.body = data;
        }
        var url = config.url;
        if (!core.isEmpty(config.params)) {
            // Hack: Not sure how Fetch handles writing 'search' parameters to the url.
            // so this approach takes over the url param writing completely.
            var delim = (url.indexOf('?') >= 0) ? '&' : '?';
            url = url + delim + encodeParams(config.params);
        }
        if (!core.isEmpty(this.defaultSettings)) {
            var compositeConfig = core.extend({}, this.defaultSettings);
            init = core.extend(compositeConfig, init);
            // extend is shallow; extend headers separately
            var headers = core.extend({}, this.defaultSettings.headers); // copy default headers 1st
            init.headers = core.extend(headers, init.headers);
        }
        var requestInfo = {
            adapter: this,
            config: init,
            dsaConfig: config,
            success: successFn,
            error: errorFn,
        };
        if (core.isFunction(this.requestInterceptor)) {
            var ri = this.requestInterceptor;
            ri(requestInfo);
            if (ri.oneTime) {
                this.requestInterceptor = undefined;
            }
        }
        if (requestInfo.config) { // exists unless requestInterceptor killed it.
            fetch(url, requestInfo.config).then(function (response) {
                if (!response.ok) {
                    response.text().then(function (s) {
                        requestInfo.error(response.status, response.statusText, s, response, null);
                    });
                }
                else {
                    response.json().then(function (j) {
                        requestInfo.success(j, response.statusText, response);
                    });
                }
            }).catch(function (err) {
                requestInfo.error(0, err && err.message || err, null, null, err);
            });
        }
        function encodeParams(obj) {
            var query = '';
            var subValue, innerObj, fullSubName;
            for (var name_1 in obj) {
                if (!obj.hasOwnProperty(name_1)) {
                    continue;
                }
                var value = obj[name_1];
                if (value instanceof Array) {
                    for (var i = 0; i < value.length; ++i) {
                        subValue = value[i];
                        fullSubName = name_1 + '[' + i + ']';
                        innerObj = {};
                        innerObj[fullSubName] = subValue;
                        query += encodeParams(innerObj) + '&';
                    }
                }
                else if (value && value.toISOString) { // a feature of Date-like things
                    query += encodeURIComponent(name_1) + '=' + encodeURIComponent(value.toISOString()) + '&';
                }
                else if (value instanceof Object) {
                    for (var subName in value) {
                        if (obj.hasOwnProperty(name_1)) {
                            subValue = value[subName];
                            fullSubName = name_1 + '[' + subName + ']';
                            innerObj = {};
                            innerObj[fullSubName] = subValue;
                            query += encodeParams(innerObj) + '&';
                        }
                    }
                }
                else if (value === null) {
                    query += encodeURIComponent(name_1) + '=&';
                }
                else if (value !== undefined) {
                    query += encodeURIComponent(name_1) + '=' + encodeURIComponent(value) + '&';
                }
            }
            return query.length ? query.substr(0, query.length - 1) : query;
        }
        function successFn(data, statusText, response) {
            var httpResponse = {
                config: config,
                data: data,
                getHeaders: getHeadersFn(response),
                status: response.status,
                statusText: statusText
            };
            config.success(httpResponse);
        }
        function errorFn(status, statusText, body, response, errorThrown) {
            var httpResponse = {
                config: config,
                data: body,
                error: errorThrown || statusText,
                getHeaders: getHeadersFn(response),
                status: status,
                statusText: statusText
            };
            config.error(httpResponse);
        }
    };
    AjaxFetchAdapter.adapterName = "fetch";
    return AjaxFetchAdapter;
}());
config.registerAdapter("ajax", AjaxFetchAdapter);
function getHeadersFn(response) {
    if (!response || response.status === 0) { // timeout or abort; no headers
        return function (headerName) {
            return (headerName && headerName.length > 0) ? "" : {};
        };
    }
    else {
        return function (headerName) {
            if (headerName && headerName.length > 0) {
                return response.headers.get(headerName);
            }
            var hob = {};
            response.headers.forEach(function (val, key) {
                hob[key] = val;
            });
            return hob;
        };
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { AjaxFetchAdapter };
//# sourceMappingURL=breeze-client-adapter-ajax-fetch.js.map
