import { core } from './core';
import { assertParam } from './assert-param';
import { DataType } from './data-type';
import { EntityAspect } from './entity-aspect';
import { EntityKey } from './entity-key';
import { BreezeEnum } from './enum';
import { DataService } from './data-service';
import { EntityType } from './entity-metadata';
import { QueryOptions } from './query-options';
import { Predicate } from './predicate';
/**
An EntityQuery instance is used to query entities either from a remote datasource or from a local [[EntityManager]].

EntityQueries are immutable - this means that all EntityQuery methods that return an EntityQuery actually create a new EntityQuery.  This means that
EntityQueries can be 'modified' without affecting any current instances.
@dynamic
**/
export class EntityQuery {
    /** Constructor
    >    let query = new EntityQuery("Customers")
  
    Usually this constructor will be followed by calls to filtering, ordering or selection methods
    >      let query = new EntityQuery("Customers")
    >        .where("CompanyName", "startsWith", "C")
    >        .orderBy("Region");
    @param resourceName - either a resource name or a serialized EntityQuery ( created by [[EntityQuery.toJSON]])
    **/
    constructor(resourceName) {
        if (resourceName != null && (typeof resourceName !== 'string')) {
            return fromJSON(this, resourceName);
        }
        // TODO: cast as string below needed for early versions of TypeDoc - but not for regular compile - check later
        this.resourceName = resourceName;
        this.fromEntityType = undefined;
        this.wherePredicate = undefined;
        this.orderByClause = undefined;
        this.selectClause = undefined;
        this.skipCount = undefined;
        this.takeCount = undefined;
        this.expandClause = undefined;
        this.parameters = {};
        this.inlineCountEnabled = false;
        this.noTrackingEnabled = false;
        // default is to get queryOptions and dataService from the entityManager.
        // this.queryOptions = new QueryOptions();
        // this.dataService = new DataService();
        this.entityManager = undefined;
    }
    /**
    Specifies the resource to query for this EntityQuery.
    >      let query = new EntityQuery()
    >        .from("Customers");
  
    is the same as
    >      let query = new EntityQuery("Customers");
    @param resourceName - The resource to query.
    **/
    from(resourceName) {
        // TODO: think about allowing entityType as well
        assertParam(resourceName, "resourceName").isString().check();
        return clone(this, "resourceName", resourceName);
    }
    /**
    This is a static version of the "from" method and it creates a 'base' entityQuery for the specified resource name.
    >      let query = EntityQuery.from("Customers");
  
    is the same as
    >      let query = new EntityQuery("Customers");
    @param resourceName - The resource to query.
    **/
    static from(resourceName) {
        assertParam(resourceName, "resourceName").isString().check();
        return new EntityQuery(resourceName);
    }
    /**
    Specifies the top level EntityType that this query will return.  Only needed when a query returns a json result that does not include type information.
    >      let query = new EntityQuery()
    >        .from("MyCustomMethod")
    >        .toType("Customer")
    @param entityType - The top level EntityType that this query will return.  This method is only needed when a query returns a json result that
    does not include type information.  If the json result consists of more than a simple entity or array of entities, consider using a [[JsonResultsAdapter]] instead.
    **/
    toType(entityType) {
        assertParam(entityType, "entityType").isString().or().isInstanceOf(EntityType).check();
        return clone(this, "resultEntityType", entityType);
    }
    /**
    Returns a new query with an added filter criteria; Can be called multiple times which means to 'and' with any existing
    Predicate or can be called with null to clear all predicates.
    >      let query = new EntityQuery("Customers")
    >          .where("CompanyName", "startsWith", "C");
  
    This can also be expressed using an explicit [[FilterQueryOp]] as
    >      let query = new EntityQuery("Customers")
    >          .where("CompanyName", FilterQueryOp.StartsWith, "C");
  
    or a preconstructed [[Predicate]] may be used
    >      let pred = new Predicate("CompanyName", FilterQueryOp.StartsWith, "C");
    >      let query = new EntityQuery("Customers").where(pred);
  
    Predicates are often useful when you want to combine multiple conditions in a single filter, such as
    >      let pred = Predicate.create("CompanyName", "startswith", "C").and("Region", FilterQueryOp.Equals, null);
    >      let query = new EntityQuery("Customers")
    >          .where(pred);
  
    More complicated queries can make use of nested property paths
    >      let query = new EntityQuery("Products")
    >          .where("Category.CategoryName", "startswith", "S");
  
    or OData functions - A list of valid OData functions can be found within the [[Predicate]] documentation.
    
    >      let query = new EntityQuery("Customers")
    >          .where("toLower(CompanyName)", "startsWith", "c");
  
    or to be even more baroque
    >      let query = new EntityQuery("Customers")
    >          .where("toUpper(substring(CompanyName, 1, 2))", FilterQueryOp.Equals, "OM");
    @param predicate -  Can be either
      - a single [[Predicate]]
  
      - the parameters to create a 'simple' Predicate
      - -  a property name, a property path with '.' as path seperators or a property expression {String}
      - -  an operator - [[FilterQueryOp]] or it's string representation. Case is ignored
      when if a string is provided and any string that matches one of the FilterQueryOp aliases will be accepted.
      - -  a value {Object} - This will be treated as either a property expression or a literal depending on context.
      In general, if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal.
      In most cases this works well, but you can also force the interpretation by making the value argument itself an object
      with a 'value' property and an 'isLiteral' property set to either true or false.
      Breeze also tries to infer the dataType of any literal based on context, if this fails you can force this inference by making the value argument
      an object with a 'value' property and a 'dataType'property set to one of the DataType enumeration instances.
  
      - a null or undefined ( this causes any existing where clause to be removed)
    **/
    where(...args) {
        let wherePredicate;
        if (args.length > 0 && args[0] != null) {
            wherePredicate = Predicate.create(...args);
            if (this.fromEntityType)
                wherePredicate._validate(this.fromEntityType);
            if (this.wherePredicate) {
                wherePredicate = this.wherePredicate.and(wherePredicate);
            }
        }
        return clone(this, "wherePredicate", wherePredicate);
    }
    /**
    Returns a new query that orders the results of the query by property name.  By default sorting occurs is ascending order, but sorting in descending order is supported as well.
    OrderBy clauses may be chained.
    >     let query = new EntityQuery("Customers")
    >        .orderBy("CompanyName");
  
    or to sort across multiple properties
    >     let query = new EntityQuery("Customers")
    >        .orderBy("Region, CompanyName");
  
    Nested property paths are also supported
    >     let query = new EntityQuery("Products")
    >        .orderBy("Category.CategoryName");
  
    Sorting in descending order is supported via the addition of ' desc' to the end of any property path.
    >     let query = new EntityQuery("Customers")
    >        .orderBy("CompanyName desc");
  
    or
    >     let query = new EntityQuery("Customers")
    >        .orderBy("Region desc, CompanyName desc");
    @param propertyPaths - A comma-separated (',') string of property paths or an array of property paths.
    Each property path can optionally end with " desc" to force a descending sort order. If 'propertyPaths' is either null or omitted then all ordering is removed.
    @param isDescending - If specified, overrides all of the embedded 'desc' tags in the previously specified property paths.
    **/
    orderBy(propertyPaths, isDescending) {
        // propertyPaths: can pass in create("A.X,B") or create("A.X desc, B") or create("A.X desc,B", true])
        // isDesc parameter trumps isDesc in propertyName.
        let orderByClause = propertyPaths == null ? null : new OrderByClause(normalizePropertyPaths(propertyPaths), isDescending);
        if (this.orderByClause && orderByClause) {
            orderByClause = new OrderByClause([this.orderByClause, orderByClause]);
        }
        return clone(this, "orderByClause", orderByClause);
    }
    /**
    Returns a new query that orders the results of the query by property name in descending order.
    >     let query = new EntityQuery("Customers")
    >        .orderByDesc("CompanyName");
  
    or to sort across multiple properties
    >     let query = new EntityQuery("Customers")
    >        .orderByDesc("Region, CompanyName");
  
    Nested property paths are also supported
    >     let query = new EntityQuery("Products")
    >        .orderByDesc("Category.CategoryName");
    @param propertyPaths - A comma-separated (',') string of property paths or an array of property paths.
    If 'propertyPaths' is either null or omitted then all ordering is removed.
    **/
    orderByDesc(propertyPaths) {
        return this.orderBy(propertyPaths, true);
    }
    /**
    Returns a new query that selects a list of properties from the results of the original query and returns the values of just these properties. This
    will be referred to as a projection.
    If the result of this selection "projection" contains entities, these entities will automatically be added to EntityManager's cache and will
    be made 'observable'.
    Any simple properties, i.e. strings, numbers or dates within a projection will not be cached are will NOT be made 'observable'.
    
    Simple data properties can be projected
    >     let query = new EntityQuery("Customers")
    >         .where("CompanyName", "startsWith", "C")
    >         .select("CompanyName");
  
    This will return an array of objects each with a single "CompanyName" property of type string.
    A similar query could return a navigation property instead
    >     let query = new EntityQuery("Customers")
    >        .where("CompanyName", "startsWith", "C")
    >        .select("Orders");
  
    where the result would be an array of objects each with a single "Orders" property that would itself be an array of "Order" entities.
    Composite projections are also possible:
    >     let query = new EntityQuery("Customers")
    >        .where("CompanyName", "startsWith", "C")
    >        .select("CompanyName, Orders");
  
    As well as projections involving nested property paths
    >     let query = EntityQuery("Orders")
    >        .where("Customer.CompanyName", "startsWith", "C")
    >        .select("Customer.CompanyName, Customer, OrderDate");
    @param propertyPaths - A comma-separated (',') string of property paths or an array of property paths.
    If 'propertyPaths' is either null or omitted then any existing projection on the query is removed.
    **/
    select(propertyPaths) {
        let selectClause = propertyPaths == null ? null : new SelectClause(normalizePropertyPaths(propertyPaths));
        return clone(this, "selectClause", selectClause);
    }
    /**
    Returns a new query that skips the specified number of entities when returning results.
    Any existing 'skip' can be cleared by calling 'skip' with no arguments.
    >     let query = new EntityQuery("Customers")
    >       .where("CompanyName", "startsWith", "C")
    >       .skip(5);
    @param count - The number of entities to skip over. If omitted or null any existing skip count on the query is removed.
    **/
    skip(count) {
        assertParam(count, "count").isOptional().isNumber().check();
        return clone(this, "skipCount", (count == null) ? null : count);
    }
    /**
    Returns a new query that returns only the specified number of entities when returning results. - Same as 'take'.
    Any existing 'top' can be cleared by calling 'top' with no arguments.
    >     let query = new EntityQuery("Customers")
    >        .top(5);
    @param count - The number of entities to return.
    If 'count' is either null or omitted then any existing 'top' count on the query is removed.
    **/
    top(count) {
        return this.take(count);
    }
    /**
    Returns a new query that returns only the specified number of entities when returning results - Same as 'top'.
    Any existing take can be cleared by calling take with no arguments.
    >     let query = new EntityQuery("Customers")
    >        .take(5);
    @param count - The number of entities to return.
    If 'count' is either null or omitted then any existing 'take' count on the query is removed.
    **/
    take(count) {
        assertParam(count, "count").isOptional().isNumber().check();
        return clone(this, "takeCount", (count == null) ? null : count);
    }
    /**
    Returns a new query that will return related entities nested within its results. The expand method allows you to identify related entities, via navigation property
    names such that a graph of entities may be retrieved with a single request. Any filtering occurs before the results are 'expanded'.
    >     let query = new EntityQuery("Customers")
    >        .where("CompanyName", "startsWith", "C")
    >        .expand("Orders");
  
    will return the filtered customers each with its "Orders" properties fully resolved.
    Multiple paths may be specified by separating the paths by a ','
    >     let query = new EntityQuery("Orders")
    >        .expand("Customer, Employee")
  
    and nested property paths my be specified as well
    >     let query = new EntityQuery("Orders")
    >        .expand("Customer, OrderDetails, OrderDetails.Product")
    @param propertyPaths - A comma-separated list of navigation property names or an array of navigation property names. Each Navigation Property name can be followed
    by a '.' and another navigation property name to enable identifying a multi-level relationship.
    If 'propertyPaths' is either null or omitted then any existing 'expand' clause on the query is removed.
    **/
    expand(propertyPaths) {
        let expandClause = propertyPaths == null ? null : new ExpandClause(normalizePropertyPaths(propertyPaths));
        return clone(this, "expandClause", expandClause);
    }
    /**
    Returns a new query that includes a collection of parameters to pass to the server.
    >     let query = EntityQuery.from("EmployeesFilteredByCountryAndBirthdate")
    >        .withParameters({ BirthDate: "1/1/1960", Country: "USA" });
     
    will call the 'EmployeesFilteredByCountryAndBirthdate' method on the server and pass in 2 parameters. This
    query will be uri encoded as
    >      {serviceApi}/EmployeesFilteredByCountryAndBirthdate?birthDate=1%2F1%2F1960&country=USA
  
    Parameters may also be mixed in with other query criteria.
    >     let query = EntityQuery.from("EmployeesFilteredByCountryAndBirthdate")
    >        .withParameters({ BirthDate: "1/1/1960", Country: "USA" })
    >        .where("LastName", "startsWith", "S")
    >        .orderBy("BirthDate");
    @param parameters - A parameters object where the keys are the parameter names and the values are the parameter values.
    **/
    withParameters(parameters) {
        assertParam(parameters, "parameters").isObject().check();
        return clone(this, "parameters", parameters);
    }
    /**
    Returns a query with the 'inlineCount' capability either enabled or disabled.  With 'inlineCount' enabled, an additional 'inlineCount' property
    will be returned with the query results that will contain the number of entities that would have been returned by this
    query with only the 'where'/'filter' clauses applied, i.e. without any 'skip'/'take' operators applied. For local queries this clause is ignored.
    >     let query = new EntityQuery("Customers")
    >        .take(20)
    >        .orderBy("CompanyName")
    >        .inlineCount(true);
  
    will return the first 20 customers as well as a count of all of the customers in the remote store.
    @param enabled - (default = true) Whether or not inlineCount capability should be enabled. If this parameter is omitted, true is assumed.
    **/
    inlineCount(enabled) {
        assertParam(enabled, "enabled").isBoolean().isOptional().check();
        enabled = (enabled === undefined) ? true : !!enabled;
        return clone(this, "inlineCountEnabled", enabled);
    }
    useNameOnServer(usesNameOnServer) {
        assertParam(usesNameOnServer, "usesNameOnServer").isBoolean().isOptional().check();
        usesNameOnServer = (usesNameOnServer === undefined) ? true : !!usesNameOnServer;
        return clone(this, "usesNameOnServer", usesNameOnServer);
    }
    /**
    Returns a query with the 'noTracking' capability either enabled or disabled.  With 'noTracking' enabled, the results of this query
    will not be coerced into entities but will instead look like raw javascript projections. i.e. simple javascript objects.
    >     let query = new EntityQuery("Customers")
    >         .take(20)
    >         .orderBy("CompanyName")
    >         .noTracking(true);
    @param enabled - (default = true) Whether or not the noTracking capability should be enabled. If this parameter is omitted, true is assumed.
    **/
    noTracking(enabled) {
        assertParam(enabled, "enabled").isBoolean().isOptional().check();
        enabled = (enabled === undefined) ? true : !!enabled;
        return clone(this, "noTrackingEnabled", enabled);
    }
    /**
    Returns a copy of this EntityQuery with the specified [[EntityManager]], [[DataService]],
    [[JsonResultsAdapter]], [[MergeStrategy]] or [[FetchStrategy]] applied.
    >      // 'using' can be used to return a new query with a specified EntityManager.
    >      let em = new EntityManager(serviceName);
    >      let query = new EntityQuery("Orders")
    >        .using(em);
  
    or with a specified [[MergeStrategy]]
    >      let em = new EntityManager(serviceName);
    >      let query = new EntityQuery("Orders")
    >        .using(MergeStrategy.PreserveChanges);
  
    or with a specified [[FetchStrategy]]
    >      let em = new EntityManager(serviceName);
    >      let query = new EntityQuery("Orders")
    >        .using(FetchStrategy.FromLocalCache);
    @param obj - The object to update in creating a new EntityQuery from an existing one.
    **/
    using(obj) {
        if (!obj)
            return this;
        let eq = clone(this);
        processUsing(eq, {
            "entityManager": null,
            "dataService": null,
            "queryOptions": null,
            "fetchStrategy": (eq, val) => {
                eq.queryOptions = (eq.queryOptions || new QueryOptions()).using(val);
            },
            "mergeStrategy": (eq, val) => {
                eq.queryOptions = (eq.queryOptions || new QueryOptions()).using(val);
            },
            "jsonResultsAdapter": (eq, val) => {
                eq.dataService = (eq.dataService || new DataService()).using({ jsonResultsAdapter: val });
            }
        }, obj);
        return eq;
    }
    /**
    Executes this query.  This method requires that an EntityManager has been previously specified via the "using" method.
    
    This method can be called using a 'promises' syntax ( recommended)
    >      let em = new EntityManager(serviceName);
    >      let query = new EntityQuery("Orders").using(em);
    >      query.execute().then( function(data) {
    >          ... query results processed here
    >      }).catch( function(err) {
    >          ... query failure processed here
    >      });
  
    or with callbacks
    >      let em = new EntityManager(serviceName);
    >      let query = new EntityQuery("Orders").using(em);
    >      query.execute(
    >        function(data) {
    >                    let orders = data.results;
    >                    ... query results processed here
    >                },
    >        function(err) {
    >                    ... query failure processed here
    >                });
  
    Either way this method is the same as calling the EntityManager 'execute' method.
    >      let em = new EntityManager(serviceName);
    >      let query = new EntityQuery("Orders");
    >      em.executeQuery(query).then( function(data) {
    >         let orders = data.results;
    >          ... query results processed here
    >      }).catch( function(err) {
    >         ... query failure processed here
    >      });
  
    @param callback -  Function called on success.
    @param errorCallback - Function called on failure.
    @return Promise
    **/
    execute(callback, errorCallback) {
        if (!this.entityManager) {
            throw new Error("An EntityQuery must have its EntityManager property set before calling 'execute'");
        }
        return this.entityManager.executeQuery(this, callback, errorCallback);
    }
    /**
    Executes this query against the local cache.  This method requires that an EntityManager have been previously specified via the "using" method.
    >      // assume em is an entityManager already filled with order entities;
    >      let query = new EntityQuery("Orders").using(em);
    >      let orders = query.executeLocally();
  
    Note that calling this method is the same as calling [[EntityManager.executeQueryLocally]].
    **/
    executeLocally() {
        if (!this.entityManager) {
            throw new Error("An EntityQuery must have its EntityManager property set before calling 'executeLocally'");
        }
        return this.entityManager.executeQueryLocally(this);
    }
    toJSON() {
        return this.toJSONExt();
    }
    /** Typically only for use when building UriBuilderAdapters.
    @hidden @internal
    */
    toJSONExt(context) {
        context = context || {};
        context.entityType = context.entityType || this.fromEntityType;
        context.propertyPathFn = context.toNameOnServer ? context.entityType.clientPropertyPathToServer.bind(context.entityType) : core.identity;
        let toJSONExtFn = function (v) {
            return v ? v.toJSONExt(context) : undefined;
        };
        return core.toJson(this, {
            "from,resourceName": null,
            "toType,resultEntityType": function (v) {
                // resultEntityType can be either a string or an entityType
                return v ? (typeof v === 'string' ? v : v.name) : undefined;
            },
            "where,wherePredicate": toJSONExtFn,
            "orderBy,orderByClause": toJSONExtFn,
            "select,selectClause": toJSONExtFn,
            "expand,expandClause": toJSONExtFn,
            "skip,skipCount": null,
            "take,takeCount": null,
            parameters: function (v) {
                return core.isEmpty(v) ? undefined : v;
            },
            "inlineCount,inlineCountEnabled": false,
            "noTracking,noTrackingEnabled": false,
            queryOptions: null
        });
    }
    /**
    Static method that creates an EntityQuery that will allow 'requerying' an entity or a collection of entities by primary key. This can be useful
    to force a requery of selected entities, or to restrict an existing collection of entities according to some filter.
  
    Works for a single entity or an array of entities of the SAME type.
    Does not work for an array of entities of different types.
    >      // assuming 'customers' is an array of 'Customer' entities retrieved earlier.
    >      let customersQuery = EntityQuery.fromEntities(customers);
  
    The resulting query can, of course, be extended
    >      // assuming 'customers' is an array of 'Customer' entities retrieved earlier.
    >      let customersQuery = EntityQuery.fromEntities(customers)
    >        .where("Region", FilterQueryOp.NotEquals, null);
  
    Single entities can requeried as well.
    >      // assuming 'customer' is a 'Customer' entity retrieved earlier.
    >      let customerQuery = EntityQuery.fromEntities(customer);
  
    will create a query that will return an array containing a single customer entity.
    @param entities - The entities for which we want to create an EntityQuery.
    **/
    static fromEntities(entities) {
        assertParam(entities, "entities").isEntity().or().isNonEmptyArray().isEntity().check();
        let ents = (Array.isArray(entities)) ? entities : [entities];
        let firstEntity = ents[0];
        let type = firstEntity.entityType;
        if (ents.some(function (e) {
            return e.entityType !== type;
        })) {
            throw new Error("All 'fromEntities' must be the same type; at least one is not of type " +
                type.name);
        }
        let q = new EntityQuery(type.defaultResourceName);
        let preds = ents.map(function (entity) {
            return buildPredicate(entity);
        });
        let pred = Predicate.or(preds);
        q = q.where(pred);
        let em = firstEntity.entityAspect.entityManager;
        if (em) {
            q = q.using(em);
        }
        return q;
    }
    /**
    Creates an EntityQuery for the specified [[EntityKey]].
    >      let empType = metadataStore.getEntityType("Employee");
    >      let entityKey = new EntityKey(empType, 1);
    >      let query = EntityQuery.fromEntityKey(entityKey);
  
    or
    >      // 'employee' is a previously queried employee
    >      let entityKey = employee.entityAspect.getKey();
    >      let query = EntityQuery.fromEntityKey(entityKey);
    @param entityKey - The [[EntityKey]] for which a query will be created.
    **/
    static fromEntityKey(entityKey) {
        assertParam(entityKey, "entityKey").isInstanceOf(EntityKey).check();
        let q = new EntityQuery(entityKey.entityType.defaultResourceName);
        let pred = buildKeyPredicate(entityKey);
        q = q.where(pred).toType(entityKey.entityType);
        return q;
    }
    // protected methods
    /** @hidden @internal */
    _getFromEntityType(metadataStore, throwErrorIfNotFound) {
        // Uncomment next two lines if we make this method public.
        // assertParam(metadataStore, "metadataStore").isInstanceOf(MetadataStore).check();
        // assertParam(throwErrorIfNotFound, "throwErrorIfNotFound").isBoolean().isOptional().check();
        let entityType = this.fromEntityType;
        if (entityType)
            return entityType;
        let resourceName = this.resourceName;
        if (!resourceName) {
            throw new Error("There is no resourceName for this query");
        }
        if (metadataStore.isEmpty()) {
            if (throwErrorIfNotFound) {
                throw new Error("There is no metadata available for this query. " +
                    "Are you querying the local cache before you've fetched metadata?");
            }
            else {
                return undefined;
            }
        }
        let entityTypeName = metadataStore.getEntityTypeNameForResourceName(resourceName);
        if (entityTypeName) {
            entityType = metadataStore._getStructuralType(entityTypeName);
        }
        else {
            entityType = this._getToEntityType(metadataStore, true);
        }
        if (!entityType) {
            if (throwErrorIfNotFound) {
                throw new Error(core.formatString("Cannot find an entityType for resourceName: '%1'. "
                    + " Consider adding an 'EntityQuery.toType' call to your query or "
                    + "calling the MetadataStore.setEntityTypeForResourceName method to register an entityType for this resourceName.", resourceName));
            }
            else {
                return undefined;
            }
        }
        this.fromEntityType = entityType;
        return entityType;
    }
    /** @hidden @internal */
    _getToEntityType(metadataStore, skipFromCheck) {
        // skipFromCheck is to avoid recursion if called from _getFromEntityType;
        if (this.resultEntityType instanceof EntityType) {
            return this.resultEntityType;
        }
        else if (this.resultEntityType) {
            // resultEntityType is a string
            this.resultEntityType = metadataStore._getStructuralType(this.resultEntityType, false);
            return this.resultEntityType;
        }
        else {
            // resolve it, if possible, via the resourceName
            // do not cache this value in this case
            // cannot determine the resultEntityType if a selectClause is present.
            // return skipFromCheck ? null : (!this.selectClause) && this._getFromEntityType(metadataStore, false);
            if (skipFromCheck || this.selectClause) {
                return undefined;
            }
            else {
                this._getFromEntityType(metadataStore, false);
            }
        }
    }
    /** @hidden @internal */
    // for testing
    _toUri(em) {
        let ds = DataService.resolve([em.dataService]);
        return ds.uriBuilder.buildUri(this, em.metadataStore);
    }
}
/**
Creates an EntityQuery for the specified entity and [[NavigationProperty]].
>      // 'employee' is a previously queried employee
>      let ordersNavProp = employee.entityType.getProperty("Orders");
>      let query = EntityQuery.fromEntityNavigation(employee, ordersNavProp);

will return a query for the "Orders" of the specified 'employee'.
@param entity - The Entity whose navigation property will be queried.
@param navigationProperty - The [[NavigationProperty]] or name of the NavigationProperty to be queried.
**/
EntityQuery.fromEntityNavigation = function (entity, navigationProperty) {
    assertParam(entity, "entity").isEntity().check();
    let navProperty = entity.entityType._checkNavProperty(navigationProperty);
    let q = new EntityQuery(navProperty.entityType.defaultResourceName);
    let pred = buildNavigationPredicate(entity, navProperty);
    if (pred == null) {
        throw new Error("Unable to create a NavigationQuery for navigationProperty: " + navProperty.name);
    }
    q = q.where(pred);
    let em = entity.entityAspect.entityManager;
    return em ? q.using(em) : q;
};
EntityQuery.prototype._$typeName = "EntityQuery";
// private functions
function fromJSON(eq, json) {
    core.toJson(json, {
        "resourceName,from": null,
        // just the name comes back and will be resolved later
        "resultEntityType,toType": null,
        "wherePredicate,where": function (v) {
            return v ? new Predicate(v) : undefined;
        },
        "orderByClause,orderBy": function (v) {
            return v ? new OrderByClause(v) : undefined;
        },
        "selectClause,select": function (v) {
            return v ? new SelectClause(v) : undefined;
        },
        "expandClause,expand": function (v) {
            return v ? new ExpandClause(v) : undefined;
        },
        "skipCount,skip": null,
        "takeCount,take": null,
        parameters: function (v) {
            return core.isEmpty(v) ? undefined : v;
        },
        "inlineCountEnabled,inlineCount": false,
        "noTrackingEnabled,noTracking": false,
        queryOptions: function (v) {
            return v ? QueryOptions.fromJSON(v) : undefined;
        }
    }, eq);
    return eq;
}
function clone(eq, propName, value) {
    // immutable queries mean that we don't need to clone if no change in value.
    if (propName) {
        if (eq[propName] === value)
            return eq;
    }
    // copying QueryOptions is safe because they are are immutable;
    let copy = core.extend(new EntityQuery(), eq, [
        "resourceName",
        "fromEntityType",
        "wherePredicate",
        "orderByClause",
        "selectClause",
        "skipCount",
        "takeCount",
        "expandClause",
        "inlineCountEnabled",
        "noTrackingEnabled",
        "usesNameOnServer",
        "queryOptions",
        "entityManager",
        "dataService",
        "resultEntityType"
    ]);
    copy.parameters = core.extend({}, eq.parameters);
    if (propName) {
        copy[propName] = value;
    }
    return copy;
}
function processUsing(eq, map, value, propertyName) {
    let typeName = value._$typeName || ((value instanceof BreezeEnum) && value.constructor.name);
    let key = typeName && typeName.substr(0, 1).toLowerCase() + typeName.substr(1);
    if (propertyName && key !== propertyName) {
        throw new Error("Invalid value for property: " + propertyName);
    }
    if (key) {
        let fn = map[key];
        if (fn === undefined) {
            throw new Error("Invalid config property: " + key);
        }
        else if (fn === null) {
            eq[key] = value;
        }
        else {
            fn(eq, value);
        }
    }
    else {
        core.objectForEach(value, (propName, val) => {
            processUsing(eq, map, val, propName);
        });
    }
}
function normalizePropertyPaths(propertyPaths) {
    assertParam(propertyPaths, "propertyPaths").isOptional().isString().or().isArray().isString().check();
    if (typeof propertyPaths === 'string') {
        propertyPaths = propertyPaths.split(",");
    }
    propertyPaths = propertyPaths.map(function (pp) {
        return pp.trim();
    });
    return propertyPaths;
}
function buildPredicate(entity) {
    let entityType = entity.entityType;
    let predParts = entityType.keyProperties.map(function (kp) {
        return Predicate.create(kp.name, FilterQueryOp.Equals, entity.getProperty(kp.name));
    });
    let pred = Predicate.and(predParts);
    return pred;
}
function buildKeyPredicate(entityKey) {
    let keyProps = entityKey.entityType.keyProperties;
    let preds = core.arrayZip(keyProps, entityKey.values, function (kp, v) {
        return Predicate.create(kp.name, FilterQueryOp.Equals, v);
    });
    let pred = Predicate.and(preds);
    return pred;
}
function buildNavigationPredicate(entity, navigationProperty) {
    if (navigationProperty.isScalar) {
        if (navigationProperty.foreignKeyNames.length === 0)
            return null;
        let relatedKeyValues = navigationProperty.foreignKeyNames.map((fkName) => {
            return entity.getProperty(fkName);
        });
        let entityKey = new EntityKey(navigationProperty.entityType, relatedKeyValues);
        return buildKeyPredicate(entityKey);
    }
    else {
        let inverseNp = navigationProperty.inverse;
        let foreignKeyNames = inverseNp ? inverseNp.foreignKeyNames : navigationProperty.invForeignKeyNames;
        if (foreignKeyNames.length === 0)
            return null;
        let keyValues = entity.entityAspect.getKey().values;
        let predParts = core.arrayZip(foreignKeyNames, keyValues, (fkName, kv) => {
            return Predicate.create(fkName, FilterQueryOp.Equals, kv);
        });
        return Predicate.and(predParts);
    }
}
/**
FilterQueryOp is an 'Enum' containing all of the valid  [[Predicate]]
filter operators for an [[EntityQuery]].
**/
export class FilterQueryOp extends BreezeEnum {
}
/** Aliases: "eq", "==" **/
FilterQueryOp.Equals = new FilterQueryOp({ operator: "eq" });
/**  Aliases: "ne", "!="  **/
FilterQueryOp.NotEquals = new FilterQueryOp({ operator: "ne" });
/** Aliases: "gt", ">"   **/
FilterQueryOp.GreaterThan = new FilterQueryOp({ operator: "gt" });
/** Aliases: "lt", "<"  **/
FilterQueryOp.LessThan = new FilterQueryOp({ operator: "lt" });
/**  Aliases: "ge", ">="  **/
FilterQueryOp.GreaterThanOrEqual = new FilterQueryOp({ operator: "ge" });
/**  Aliases: "le", "<="  **/
FilterQueryOp.LessThanOrEqual = new FilterQueryOp({ operator: "le" });
/**  String operation: Is a string a substring of another string.  Aliases: "substringof"   **/
FilterQueryOp.Contains = new FilterQueryOp({ operator: "contains" });
/** No aliases */
FilterQueryOp.StartsWith = new FilterQueryOp({ operator: "startswith" });
/** No aliases */
FilterQueryOp.EndsWith = new FilterQueryOp({ operator: "endswith" });
/**  Aliases: "some"  **/
FilterQueryOp.Any = new FilterQueryOp({ operator: "any" });
/**  Aliases: "every"  **/
FilterQueryOp.All = new FilterQueryOp({ operator: "all" });
/** No aliases */
FilterQueryOp.In = new FilterQueryOp({ operator: "in" });
/** No aliases */
FilterQueryOp.IsTypeOf = new FilterQueryOp({ operator: "isof" });
FilterQueryOp.prototype._$typeName = "FilterQueryOp";
Error['x'] = FilterQueryOp.resolveSymbols();
/**
 BooleanQueryOp is an 'Enum' containing all of the valid  boolean
operators for an [[EntityQuery]].
**/
export class BooleanQueryOp extends BreezeEnum {
}
BooleanQueryOp.And = new BooleanQueryOp({ operator: "and" });
BooleanQueryOp.Or = new BooleanQueryOp({ operator: "or" });
BooleanQueryOp.Not = new BooleanQueryOp({ operator: "not" });
BooleanQueryOp.prototype._$typeName = "BooleanQueryOp";
Error['x'] = BooleanQueryOp.resolveSymbols();
/** For use by breeze plugin authors only.  The class is used in most [[IUriBuilderAdapter]] implementations
@adapter (see [[IUriBuilderAdapter]])
@hidden

An OrderByClause is a description of the properties and direction that the result
of a query should be sorted in.  OrderByClauses are immutable, which means that any
method that would modify an OrderByClause actually returns a new OrderByClause.

For example for an Employee object with properties of 'Company' and 'LastName' the following would be valid expressions:
>     let obc = new OrderByClause("Company.CompanyName, LastName")

or
>     let obc = new OrderByClause("Company.CompanyName desc, LastName")

or
>     let obc = new OrderByClause("Company.CompanyName, LastName", true);
*/
export class OrderByClause {
    constructor(propertyPaths, isDesc) {
        if (propertyPaths.length === 0) {
            throw new Error("OrderByClause cannot be empty");
        }
        // you can also pass in an array of orderByClauses
        if (propertyPaths[0] instanceof OrderByClause) {
            let clauses = propertyPaths;
            this.items = core.arrayFlatMap(clauses, c => c.items);
            // this.items = Array.prototype.concat.apply(clauses[0].items, clauses.slice(1).map(core.pluck("items")));
            // this.items = Array.prototype.concat.apply([], clauses.map(core.pluck("items")));
        }
        else {
            this.items = propertyPaths.map(function (pp) {
                return new OrderByItem(pp, isDesc);
            });
        }
    }
    validate(entityType) {
        if (entityType == null || entityType.isAnonymous)
            return;
        this.items.forEach((item) => {
            item.validate(entityType);
        });
    }
    getComparer(entityType) {
        let orderByFuncs = this.items.map(function (obc) {
            return obc.getComparer(entityType);
        });
        return function (entity1, entity2) {
            for (let i = 0; i < orderByFuncs.length; i++) {
                let result = orderByFuncs[i](entity1, entity2);
                if (result !== 0) {
                    return result;
                }
            }
            return 0;
        };
    }
    toJSONExt(context) {
        return this.items.map(function (item) {
            return context.propertyPathFn(item.propertyPath) + (item.isDesc ? " desc" : "");
        });
    }
}
/** @hidden @internal */
export class OrderByItem {
    constructor(propertyPath, isDesc) {
        if (!(typeof propertyPath === 'string')) {
            throw new Error("propertyPath is not a string");
        }
        propertyPath = propertyPath.trim();
        let parts = propertyPath.split(' ');
        // parts[0] is the propertyPath; [1] would be whether descending or not.
        // if (parts.length > 1 && isDesc !== true && isDesc !== false) {
        if (parts.length > 1 && isDesc == null) {
            isDesc = core.stringStartsWith(parts[1].toLowerCase(), "desc");
            if (!isDesc) {
                // isDesc is false but check to make sure its intended.
                let isAsc = core.stringStartsWith(parts[1].toLowerCase(), "asc");
                if (!isAsc) {
                    throw new Error("the second word in the propertyPath must begin with 'desc' or 'asc'");
                }
            }
        }
        this.propertyPath = parts[0];
        this.isDesc = isDesc || false;
    }
    validate(entityType) {
        if (entityType == null || entityType.isAnonymous)
            return;
        // will throw an exception on bad propertyPath
        this.lastProperty = entityType.getProperty(this.propertyPath, true);
        return this.lastProperty;
    }
    getComparer(entityType) {
        let propDataType;
        let isCaseSensitive;
        if (!this.lastProperty)
            this.validate(entityType);
        if (this.lastProperty) {
            propDataType = this.lastProperty.dataType;
            isCaseSensitive = this.lastProperty.parentType.metadataStore.localQueryComparisonOptions.isCaseSensitive;
        }
        let propertyPath = this.propertyPath;
        let isDesc = this.isDesc;
        return function (entity1, entity2) {
            let value1 = EntityAspect.getPropertyPathValue(entity1, propertyPath);
            let value2 = EntityAspect.getPropertyPathValue(entity2, propertyPath);
            let dataType = propDataType || (value1 && DataType.fromValue(value1)) || DataType.fromValue(value2);
            if (dataType === DataType.String) {
                if (isCaseSensitive) {
                    value1 = value1 || "";
                    value2 = value2 || "";
                }
                else {
                    value1 = (value1 || "").toLowerCase();
                    value2 = (value2 || "").toLowerCase();
                }
            }
            else {
                let normalize = DataType.getComparableFn(dataType);
                value1 = normalize(value1);
                value2 = normalize(value2);
            }
            if (value1 === value2) {
                return 0;
            }
            else if (value1 > value2 || value2 === undefined) {
                return isDesc ? -1 : 1;
            }
            else {
                return isDesc ? 1 : -1;
            }
        };
    }
}
/** For use by breeze plugin authors only.  The class is used in most [[IUriBuilderAdapter]] implementations
@adapter (see [[IUriBuilderAdapter]])
@hidden
**/
export class SelectClause {
    constructor(propertyPaths) {
        this.propertyPaths = propertyPaths;
        this._pathNames = propertyPaths.map(function (pp) {
            return pp.replace(".", "_");
        });
    }
    validate(entityType) {
        if (entityType == null || entityType.isAnonymous)
            return; // can't validate yet
        // will throw an exception on bad propertyPath
        this.propertyPaths.forEach(function (path) {
            entityType.getProperty(path, true);
        });
    }
    toFunction( /* config */) {
        let that = this;
        return function (entity) {
            let result = {};
            that.propertyPaths.forEach(function (path, i) {
                result[that._pathNames[i]] = EntityAspect.getPropertyPathValue(entity, path);
            });
            return result;
        };
    }
    toJSONExt(context) {
        return this.propertyPaths.map(function (pp) {
            return context.propertyPathFn(pp);
        });
    }
}
/** For use by breeze plugin authors only.  The class is used in most [[IUriBuilderAdapter]] implementations
@adapter (see [[IUriBuilderAdapter]])
@hidden
**/
export class ExpandClause {
    constructor(propertyPaths) {
        this.propertyPaths = propertyPaths;
    }
    toJSONExt(context) {
        return this.propertyPaths.map(function (pp) {
            return context.propertyPathFn(pp);
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXR5LXF1ZXJ5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vYnJlZXplLWNsaWVudC8iLCJzb3VyY2VzIjpbInNyYy9lbnRpdHktcXVlcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBMkIsTUFBTSxRQUFRLENBQUM7QUFDdkQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDdkMsT0FBTyxFQUFFLFlBQVksRUFBVSxNQUFNLGlCQUFpQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDekMsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUNwQyxPQUFPLEVBQUUsV0FBVyxFQUFzQixNQUFNLGdCQUFnQixDQUFDO0FBRWpFLE9BQU8sRUFBaUIsVUFBVSxFQUFzQyxNQUFNLG1CQUFtQixDQUFDO0FBQ2xHLE9BQU8sRUFBRSxZQUFZLEVBQWdDLE1BQU0saUJBQWlCLENBQUM7QUFDN0UsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQVd4Qzs7Ozs7O0dBTUc7QUFDSCxNQUFNLE9BQU8sV0FBVztJQXdDdEI7Ozs7Ozs7O09BUUc7SUFDSCxZQUFZLFlBQThCO1FBQ3hDLElBQUksWUFBWSxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sWUFBWSxLQUFLLFFBQVEsQ0FBQyxFQUFFO1lBQzlELE9BQU8sUUFBUSxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztTQUNyQztRQUNELDhHQUE4RztRQUM5RyxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQXNCLENBQUM7UUFDM0MsSUFBSSxDQUFDLGNBQWMsR0FBRyxTQUFTLENBQUM7UUFDaEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxTQUFTLENBQUM7UUFDaEMsSUFBSSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7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QUMsRUFBRSxDQUFDLENBQUM7UUFDckMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sWUFBWTtJQUd2QixZQUFZLGFBQXVCO1FBQ2pDLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO0lBQ3JDLENBQUM7SUFFRCxTQUFTLENBQUMsT0FBK0I7UUFDdkMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUU7WUFDeEMsT0FBTyxPQUFPLENBQUMsY0FBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3JDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUVGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29yZSwgQ2FsbGJhY2ssIEVycm9yQ2FsbGJhY2sgfSBmcm9tICcuL2NvcmUnO1xyXG5pbXBvcnQgeyBhc3NlcnRQYXJhbSB9IGZyb20gJy4vYXNzZXJ0LXBhcmFtJztcclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuL2RhdGEtdHlwZSc7XHJcbmltcG9ydCB7IEVudGl0eUFzcGVjdCwgRW50aXR5IH0gZnJvbSAnLi9lbnRpdHktYXNwZWN0JztcclxuaW1wb3J0IHsgRW50aXR5S2V5IH0gZnJvbSAnLi9lbnRpdHkta2V5JztcclxuaW1wb3J0IHsgQnJlZXplRW51bSB9IGZyb20gJy4vZW51bSc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlLCBKc29uUmVzdWx0c0FkYXB0ZXIgfSBmcm9tICcuL2RhdGEtc2VydmljZSc7XHJcbmltcG9ydCB7IEVudGl0eU1hbmFnZXIsIFF1ZXJ5UmVzdWx0IH0gZnJvbSAnLi9lbnRpdHktbWFuYWdlcic7XHJcbmltcG9ydCB7IE1ldGFkYXRhU3RvcmUsIEVudGl0eVR5cGUsIE5hdmlnYXRpb25Qcm9wZXJ0eSwgRW50aXR5UHJvcGVydHkgfSBmcm9tICcuL2VudGl0eS1tZXRhZGF0YSc7XHJcbmltcG9ydCB7IFF1ZXJ5T3B0aW9ucywgTWVyZ2VTdHJhdGVneSwgRmV0Y2hTdHJhdGVneSB9IGZyb20gJy4vcXVlcnktb3B0aW9ucyc7XHJcbmltcG9ydCB7IFByZWRpY2F0ZSB9IGZyb20gJy4vcHJlZGljYXRlJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmVjdXJzaXZlQXJyYXk8VD4ge1xyXG4gIFtpOiBudW1iZXJdOiBUIHwgUmVjdXJzaXZlQXJyYXk8VD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRW50aXR5UXVlcnlKc29uQ29udGV4dCB7XHJcbiAgZW50aXR5VHlwZT86IEVudGl0eVR5cGU7XHJcbiAgcHJvcGVydHlQYXRoRm4/OiBGdW5jdGlvbjsgLy8gVE9ET1xyXG4gIHRvTmFtZU9uU2VydmVyPzogYm9vbGVhbjtcclxufVxyXG4vKipcclxuQW4gRW50aXR5UXVlcnkgaW5zdGFuY2UgaXMgdXNlZCB0byBxdWVyeSBlbnRpdGllcyBlaXRoZXIgZnJvbSBhIHJlbW90ZSBkYXRhc291cmNlIG9yIGZyb20gYSBsb2NhbCBbW0VudGl0eU1hbmFnZXJdXS5cclxuXHJcbkVudGl0eVF1ZXJpZXMgYXJlIGltbXV0YWJsZSAtIHRoaXMgbWVhbnMgdGhhdCBhbGwgRW50aXR5UXVlcnkgbWV0aG9kcyB0aGF0IHJldHVybiBhbiBFbnRpdHlRdWVyeSBhY3R1YWxseSBjcmVhdGUgYSBuZXcgRW50aXR5UXVlcnkuICBUaGlzIG1lYW5zIHRoYXRcclxuRW50aXR5UXVlcmllcyBjYW4gYmUgJ21vZGlmaWVkJyB3aXRob3V0IGFmZmVjdGluZyBhbnkgY3VycmVudCBpbnN0YW5jZXMuXHJcbkBkeW5hbWljXHJcbioqL1xyXG5leHBvcnQgY2xhc3MgRW50aXR5UXVlcnkge1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF8kdHlwZU5hbWU6IHN0cmluZzsgLy8gYWN0dWFsbHkgcGxhY2VkIG9uIHByb3RvdHlwZVxyXG4gIC8vIHRvcCA9IHRoaXMudGFrZTsgLy8gVE9ETzogY29uc2lkZXJcclxuICAvKiogVGhlIHJlc291cmNlIG5hbWUgdXNlZCBieSB0aGlzIHF1ZXJ5LiBfX1JlYWQgT25seV9fICovXHJcbiAgcmVzb3VyY2VOYW1lPzogc3RyaW5nO1xyXG4gIC8qKiBUaGUgW1tFbnRpdHlUeXBlXV0gdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlICdmcm9tJyBjbGF1c2UgKCByZXNvdXJjZU5hbWUpIG9mIHRoZSBxdWVyeS4gIFRoaXMgaXMgb25seSBndWFyYW50ZWVkIHRvIGJlIGJlIHNldCBBRlRFUiB0aGUgcXVlcnlcclxuICBoYXMgYmVlbiBleGVjdXRlZCBiZWNhdXNlIGl0IGRlcGVuZHMgb24gdGhlIFtbTWV0YWRhdGFTdG9yZV1dIGFzc29jaWF0ZWQgd2l0aCB0aGUgW1tFbnRpdHlNYW5hZ2VyXV0gdGhhdCB0aGUgcXVlcnkgd2FzIGV4ZWN1dGVkIGFnYWluc3QuXHJcbiAgVGhpcyB2YWx1ZSBtYXkgYmUgbnVsbCBpZiB0aGUgZW50aXR5VHlwZSBjYW5ub3QgYmUgYXNzb2NpYXRlZCB3aXRoIGEgcmVzb3VyY2VOYW1lLiBfX1JlYWQgT25seV9fICovXHJcbiAgZnJvbUVudGl0eVR5cGU/OiBFbnRpdHlUeXBlO1xyXG4gIC8qKiBUaGUgJ3doZXJlJyBbW1ByZWRpY2F0ZV1dIHVzZWQgYnkgdGhpcyBxdWVyeS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIHdoZXJlUHJlZGljYXRlOiBQcmVkaWNhdGU7IC8vIFRPRE9cclxuICAvKiogVGhlIFtbT3JkZXJCeUNsYXVzZV1dIHVzZWQgYnkgdGhpcyBxdWVyeS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIG9yZGVyQnlDbGF1c2U/OiBPcmRlckJ5Q2xhdXNlO1xyXG4gIC8qKiBUaGUgW1tFeHBhbmRDbGF1c2VdXSB1c2VkIGJ5IHRoaXMgcXVlcnkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBleHBhbmRDbGF1c2U/OiBFeHBhbmRDbGF1c2U7XHJcbiAgLyoqIFRoZSBbW1NlbGVjdENsYXVzZV1dIHVzZWQgYnkgdGhpcyBxdWVyeS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIHNlbGVjdENsYXVzZT86IFNlbGVjdENsYXVzZTtcclxuICAvKiogVGhlIG51bWJlciBvZiBlbnRpdGllcyB0byAnc2tpcCcgZm9yIHRoaXMgcXVlcnkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBza2lwQ291bnQ/OiBudW1iZXI7XHJcbiAgLyoqIFRoZSBudW1iZXIgb2YgZW50aXRpZXMgdG8gJ3Rha2UnIGZvciB0aGlzIHF1ZXJ5LiBfX1JlYWQgT25seV9fICovXHJcbiAgdGFrZUNvdW50PzogbnVtYmVyO1xyXG4gIC8qKiBBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBhZGRlZCB0byB0aGUgcXVlcnkgdmlhIHRoZSAnd2l0aFBhcmFtZXRlcnMnIG1ldGhvZC4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIHBhcmFtZXRlcnM6IE9iamVjdDtcclxuICAvKiogV2hldGhlciBhbiBpbmxpbmUgY291bnQgaXMgcmV0dXJuZWQgZm9yIHRoaXMgcXVlcnkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBpbmxpbmVDb3VudEVuYWJsZWQ6IGJvb2xlYW47XHJcbiAgLyoqIFdoZXRoZXIgZW50aXR5IHRyYWNraW5nIGhhcyBiZWVuIGRpc2FibGVkIGZvciB0aGlzIHF1ZXJ5LiBfX1JlYWQgT25seV9fICovXHJcbiAgbm9UcmFja2luZ0VuYWJsZWQ6IGJvb2xlYW47XHJcbiAgLyoqIFRoZSBbW1F1ZXJ5T3B0aW9uc11dIGZvciB0aGlzIHF1ZXJ5LiBfX1JlYWQgT25seV9fICAqKi9cclxuICAvLyBkZWZhdWx0IGlzIHRvIGdldCBxdWVyeU9wdGlvbnMgYW5kIGRhdGFTZXJ2aWNlIGZyb20gdGhlIGVudGl0eU1hbmFnZXIuXHJcbiAgcXVlcnlPcHRpb25zPzogUXVlcnlPcHRpb25zO1xyXG4gIC8qKiBUaGUgW1tEYXRhU2VydmljZV1dIGZvciB0aGlzIHF1ZXJ5LiBfX1JlYWQgT25seV9fICAqKi9cclxuICBkYXRhU2VydmljZT86IERhdGFTZXJ2aWNlO1xyXG4gIC8qKiBUaGUgW1tFbnRpdHlNYW5hZ2VyXV0gZm9yIHRoaXMgcXVlcnkuIFRoaXMgbWF5IGJlIG51bGwgYW5kIGNhbiBiZSBzZXQgdmlhIHRoZSAndXNpbmcnIG1ldGhvZC4gICoqL1xyXG4gIGVudGl0eU1hbmFnZXI/OiBFbnRpdHlNYW5hZ2VyO1xyXG4gIC8qKiAgVGhlIGVudGl0eVR5cGUgdGhhdCB3aWxsIGJlIHJldHVybmVkIGJ5IHRoaXMgcXVlcnkuIFxyXG4gIFRoaXMgcHJvcGVydHkgd2lsbCBvbmx5IGJlIHNldCBpZiB0aGUgJ3RvVHlwZScgbWV0aG9kIHdhcyBjYWxsZWQuIF9fUmVhZCBPbmx5X18gKi9cclxuICByZXN1bHRFbnRpdHlUeXBlOiBFbnRpdHlUeXBlIHwgc3RyaW5nO1xyXG4gIHVzZXNOYW1lT25TZXJ2ZXI/OiBib29sZWFuO1xyXG5cclxuICAvKiogQ29uc3RydWN0b3JcclxuICA+ICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKVxyXG5cclxuICBVc3VhbGx5IHRoaXMgY29uc3RydWN0b3Igd2lsbCBiZSBmb2xsb3dlZCBieSBjYWxscyB0byBmaWx0ZXJpbmcsIG9yZGVyaW5nIG9yIHNlbGVjdGlvbiBtZXRob2RzXHJcbiAgPiAgICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKVxyXG4gID4gICAgICAgIC53aGVyZShcIkNvbXBhbnlOYW1lXCIsIFwic3RhcnRzV2l0aFwiLCBcIkNcIilcclxuICA+ICAgICAgICAub3JkZXJCeShcIlJlZ2lvblwiKTtcclxuICBAcGFyYW0gcmVzb3VyY2VOYW1lIC0gZWl0aGVyIGEgcmVzb3VyY2UgbmFtZSBvciBhIHNlcmlhbGl6ZWQgRW50aXR5UXVlcnkgKCBjcmVhdGVkIGJ5IFtbRW50aXR5UXVlcnkudG9KU09OXV0pXHJcbiAgKiovXHJcbiAgY29uc3RydWN0b3IocmVzb3VyY2VOYW1lPzogc3RyaW5nIHwgT2JqZWN0KSB7XHJcbiAgICBpZiAocmVzb3VyY2VOYW1lICE9IG51bGwgJiYgKHR5cGVvZiByZXNvdXJjZU5hbWUgIT09ICdzdHJpbmcnKSkge1xyXG4gICAgICByZXR1cm4gZnJvbUpTT04odGhpcywgcmVzb3VyY2VOYW1lKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE86IGNhc3QgYXMgc3RyaW5nIGJlbG93IG5lZWRlZCBmb3IgZWFybHkgdmVyc2lvbnMgb2YgVHlwZURvYyAtIGJ1dCBub3QgZm9yIHJlZ3VsYXIgY29tcGlsZSAtIGNoZWNrIGxhdGVyXHJcbiAgICB0aGlzLnJlc291cmNlTmFtZSA9IHJlc291cmNlTmFtZSBhcyBzdHJpbmc7XHJcbiAgICB0aGlzLmZyb21FbnRpdHlUeXBlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy53aGVyZVByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMub3JkZXJCeUNsYXVzZSA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuc2VsZWN0Q2xhdXNlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5za2lwQ291bnQgPSB1bmRlZmluZWQ7XHJcbiAgICB0aGlzLnRha2VDb3VudCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMuZXhwYW5kQ2xhdXNlID0gdW5kZWZpbmVkO1xyXG4gICAgdGhpcy5wYXJhbWV0ZXJzID0ge307XHJcbiAgICB0aGlzLmlubGluZUNvdW50RW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5ub1RyYWNraW5nRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgLy8gZGVmYXVsdCBpcyB0byBnZXQgcXVlcnlPcHRpb25zIGFuZCBkYXRhU2VydmljZSBmcm9tIHRoZSBlbnRpdHlNYW5hZ2VyLlxyXG4gICAgLy8gdGhpcy5xdWVyeU9wdGlvbnMgPSBuZXcgUXVlcnlPcHRpb25zKCk7XHJcbiAgICAvLyB0aGlzLmRhdGFTZXJ2aWNlID0gbmV3IERhdGFTZXJ2aWNlKCk7XHJcbiAgICB0aGlzLmVudGl0eU1hbmFnZXIgPSB1bmRlZmluZWQ7XHJcblxyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gIFNwZWNpZmllcyB0aGUgcmVzb3VyY2UgdG8gcXVlcnkgZm9yIHRoaXMgRW50aXR5UXVlcnkuXHJcbiAgPiAgICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeSgpXHJcbiAgPiAgICAgICAgLmZyb20oXCJDdXN0b21lcnNcIik7XHJcblxyXG4gIGlzIHRoZSBzYW1lIGFzXHJcbiAgPiAgICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKTtcclxuICBAcGFyYW0gcmVzb3VyY2VOYW1lIC0gVGhlIHJlc291cmNlIHRvIHF1ZXJ5LlxyXG4gICoqL1xyXG4gIGZyb20ocmVzb3VyY2VOYW1lOiBzdHJpbmcpIHtcclxuICAgIC8vIFRPRE86IHRoaW5rIGFib3V0IGFsbG93aW5nIGVudGl0eVR5cGUgYXMgd2VsbFxyXG4gICAgYXNzZXJ0UGFyYW0ocmVzb3VyY2VOYW1lLCBcInJlc291cmNlTmFtZVwiKS5pc1N0cmluZygpLmNoZWNrKCk7XHJcbiAgICByZXR1cm4gY2xvbmUodGhpcywgXCJyZXNvdXJjZU5hbWVcIiwgcmVzb3VyY2VOYW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFRoaXMgaXMgYSBzdGF0aWMgdmVyc2lvbiBvZiB0aGUgXCJmcm9tXCIgbWV0aG9kIGFuZCBpdCBjcmVhdGVzIGEgJ2Jhc2UnIGVudGl0eVF1ZXJ5IGZvciB0aGUgc3BlY2lmaWVkIHJlc291cmNlIG5hbWUuXHJcbiAgPiAgICAgIGxldCBxdWVyeSA9IEVudGl0eVF1ZXJ5LmZyb20oXCJDdXN0b21lcnNcIik7XHJcblxyXG4gIGlzIHRoZSBzYW1lIGFzXHJcbiAgPiAgICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKTtcclxuICBAcGFyYW0gcmVzb3VyY2VOYW1lIC0gVGhlIHJlc291cmNlIHRvIHF1ZXJ5LlxyXG4gICoqL1xyXG4gIHN0YXRpYyBmcm9tKHJlc291cmNlTmFtZTogc3RyaW5nKSB7XHJcbiAgICBhc3NlcnRQYXJhbShyZXNvdXJjZU5hbWUsIFwicmVzb3VyY2VOYW1lXCIpLmlzU3RyaW5nKCkuY2hlY2soKTtcclxuICAgIHJldHVybiBuZXcgRW50aXR5UXVlcnkocmVzb3VyY2VOYW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFNwZWNpZmllcyB0aGUgdG9wIGxldmVsIEVudGl0eVR5cGUgdGhhdCB0aGlzIHF1ZXJ5IHdpbGwgcmV0dXJuLiAgT25seSBuZWVkZWQgd2hlbiBhIHF1ZXJ5IHJldHVybnMgYSBqc29uIHJlc3VsdCB0aGF0IGRvZXMgbm90IGluY2x1ZGUgdHlwZSBpbmZvcm1hdGlvbi5cclxuICA+ICAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KClcclxuICA+ICAgICAgICAuZnJvbShcIk15Q3VzdG9tTWV0aG9kXCIpXHJcbiAgPiAgICAgICAgLnRvVHlwZShcIkN1c3RvbWVyXCIpXHJcbiAgQHBhcmFtIGVudGl0eVR5cGUgLSBUaGUgdG9wIGxldmVsIEVudGl0eVR5cGUgdGhhdCB0aGlzIHF1ZXJ5IHdpbGwgcmV0dXJuLiAgVGhpcyBtZXRob2QgaXMgb25seSBuZWVkZWQgd2hlbiBhIHF1ZXJ5IHJldHVybnMgYSBqc29uIHJlc3VsdCB0aGF0XHJcbiAgZG9lcyBub3QgaW5jbHVkZSB0eXBlIGluZm9ybWF0aW9uLiAgSWYgdGhlIGpzb24gcmVzdWx0IGNvbnNpc3RzIG9mIG1vcmUgdGhhbiBhIHNpbXBsZSBlbnRpdHkgb3IgYXJyYXkgb2YgZW50aXRpZXMsIGNvbnNpZGVyIHVzaW5nIGEgW1tKc29uUmVzdWx0c0FkYXB0ZXJdXSBpbnN0ZWFkLlxyXG4gICoqL1xyXG4gIHRvVHlwZShlbnRpdHlUeXBlOiBzdHJpbmcgfCBFbnRpdHlUeXBlKSB7XHJcbiAgICBhc3NlcnRQYXJhbShlbnRpdHlUeXBlLCBcImVudGl0eVR5cGVcIikuaXNTdHJpbmcoKS5vcigpLmlzSW5zdGFuY2VPZihFbnRpdHlUeXBlKS5jaGVjaygpO1xyXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIFwicmVzdWx0RW50aXR5VHlwZVwiLCBlbnRpdHlUeXBlKTtcclxuICB9XHJcblxyXG5cclxuICB3aGVyZShwcmVkaWNhdGU/OiBQcmVkaWNhdGUpOiBFbnRpdHlRdWVyeTtcclxuICB3aGVyZShwcmVkaWNhdGU6IE9iamVjdCk6IEVudGl0eVF1ZXJ5O1xyXG4gIHdoZXJlKHByb3BlcnR5OiBzdHJpbmcsIG9wZXJhdG9yOiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBFbnRpdHlRdWVyeTtcclxuICB3aGVyZShwcm9wZXJ0eTogc3RyaW5nLCBvcGVyYXRvcjogRmlsdGVyUXVlcnlPcCwgdmFsdWU6IGFueSk6IEVudGl0eVF1ZXJ5O1xyXG4gIHdoZXJlKHByb3BlcnR5OiBzdHJpbmcsIGZpbHRlcm9wOiBGaWx0ZXJRdWVyeU9wLCBwcm9wZXJ0eTI6IHN0cmluZywgZmlsdGVyb3AyOiBGaWx0ZXJRdWVyeU9wLCB2YWx1ZTogYW55KTogRW50aXR5UXVlcnk7ICAvLyBmb3IgYW55L2FsbCBjbGF1c2VzXHJcbiAgd2hlcmUocHJvcGVydHk6IHN0cmluZywgZmlsdGVyb3A6IHN0cmluZywgcHJvcGVydHkyOiBzdHJpbmcsIGZpbHRlcm9wMjogc3RyaW5nLCB2YWx1ZTogYW55KTogRW50aXR5UXVlcnk7ICAvLyBmb3IgYW55L2FsbCBjbGF1c2VzXHJcbiAgd2hlcmUocHJvcGVydHk6IHN0cmluZywgZmlsdGVyb3A6IHN0cmluZywgcHJvcGVydHkyOiBzdHJpbmcsIGZpbHRlcm9wMjogc3RyaW5nLCBwcm9wZXJ0eTM6IHN0cmluZywgZmlsdGVyb3AzOiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBFbnRpdHlRdWVyeTsgIC8vIGZvciBhbnkvYWxsIGNsYXVzZXNcclxuICB3aGVyZShhbkFycmF5OiBSZWN1cnNpdmVBcnJheTxzdHJpbmcgfCBudW1iZXIgfCBGaWx0ZXJRdWVyeU9wIHwgUHJlZGljYXRlPik6IEVudGl0eVF1ZXJ5O1xyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBuZXcgcXVlcnkgd2l0aCBhbiBhZGRlZCBmaWx0ZXIgY3JpdGVyaWE7IENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2hpY2ggbWVhbnMgdG8gJ2FuZCcgd2l0aCBhbnkgZXhpc3RpbmdcclxuICBQcmVkaWNhdGUgb3IgY2FuIGJlIGNhbGxlZCB3aXRoIG51bGwgdG8gY2xlYXIgYWxsIHByZWRpY2F0ZXMuXHJcbiAgPiAgICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKVxyXG4gID4gICAgICAgICAgLndoZXJlKFwiQ29tcGFueU5hbWVcIiwgXCJzdGFydHNXaXRoXCIsIFwiQ1wiKTtcclxuXHJcbiAgVGhpcyBjYW4gYWxzbyBiZSBleHByZXNzZWQgdXNpbmcgYW4gZXhwbGljaXQgW1tGaWx0ZXJRdWVyeU9wXV0gYXNcclxuICA+ICAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiQ3VzdG9tZXJzXCIpXHJcbiAgPiAgICAgICAgICAud2hlcmUoXCJDb21wYW55TmFtZVwiLCBGaWx0ZXJRdWVyeU9wLlN0YXJ0c1dpdGgsIFwiQ1wiKTtcclxuXHJcbiAgb3IgYSBwcmVjb25zdHJ1Y3RlZCBbW1ByZWRpY2F0ZV1dIG1heSBiZSB1c2VkXHJcbiAgPiAgICAgIGxldCBwcmVkID0gbmV3IFByZWRpY2F0ZShcIkNvbXBhbnlOYW1lXCIsIEZpbHRlclF1ZXJ5T3AuU3RhcnRzV2l0aCwgXCJDXCIpO1xyXG4gID4gICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJDdXN0b21lcnNcIikud2hlcmUocHJlZCk7XHJcblxyXG4gIFByZWRpY2F0ZXMgYXJlIG9mdGVuIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGNvbWJpbmUgbXVsdGlwbGUgY29uZGl0aW9ucyBpbiBhIHNpbmdsZSBmaWx0ZXIsIHN1Y2ggYXNcclxuICA+ICAgICAgbGV0IHByZWQgPSBQcmVkaWNhdGUuY3JlYXRlKFwiQ29tcGFueU5hbWVcIiwgXCJzdGFydHN3aXRoXCIsIFwiQ1wiKS5hbmQoXCJSZWdpb25cIiwgRmlsdGVyUXVlcnlPcC5FcXVhbHMsIG51bGwpO1xyXG4gID4gICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJDdXN0b21lcnNcIilcclxuICA+ICAgICAgICAgIC53aGVyZShwcmVkKTtcclxuXHJcbiAgTW9yZSBjb21wbGljYXRlZCBxdWVyaWVzIGNhbiBtYWtlIHVzZSBvZiBuZXN0ZWQgcHJvcGVydHkgcGF0aHNcclxuICA+ICAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiUHJvZHVjdHNcIilcclxuICA+ICAgICAgICAgIC53aGVyZShcIkNhdGVnb3J5LkNhdGVnb3J5TmFtZVwiLCBcInN0YXJ0c3dpdGhcIiwgXCJTXCIpO1xyXG5cclxuICBvciBPRGF0YSBmdW5jdGlvbnMgLSBBIGxpc3Qgb2YgdmFsaWQgT0RhdGEgZnVuY3Rpb25zIGNhbiBiZSBmb3VuZCB3aXRoaW4gdGhlIFtbUHJlZGljYXRlXV0gZG9jdW1lbnRhdGlvbi5cclxuICBcclxuICA+ICAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiQ3VzdG9tZXJzXCIpXHJcbiAgPiAgICAgICAgICAud2hlcmUoXCJ0b0xvd2VyKENvbXBhbnlOYW1lKVwiLCBcInN0YXJ0c1dpdGhcIiwgXCJjXCIpO1xyXG5cclxuICBvciB0byBiZSBldmVuIG1vcmUgYmFyb3F1ZVxyXG4gID4gICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJDdXN0b21lcnNcIilcclxuICA+ICAgICAgICAgIC53aGVyZShcInRvVXBwZXIoc3Vic3RyaW5nKENvbXBhbnlOYW1lLCAxLCAyKSlcIiwgRmlsdGVyUXVlcnlPcC5FcXVhbHMsIFwiT01cIik7XHJcbiAgQHBhcmFtIHByZWRpY2F0ZSAtICBDYW4gYmUgZWl0aGVyXHJcbiAgICAtIGEgc2luZ2xlIFtbUHJlZGljYXRlXV1cclxuXHJcbiAgICAtIHRoZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhICdzaW1wbGUnIFByZWRpY2F0ZVxyXG4gICAgLSAtICBhIHByb3BlcnR5IG5hbWUsIGEgcHJvcGVydHkgcGF0aCB3aXRoICcuJyBhcyBwYXRoIHNlcGVyYXRvcnMgb3IgYSBwcm9wZXJ0eSBleHByZXNzaW9uIHtTdHJpbmd9XHJcbiAgICAtIC0gIGFuIG9wZXJhdG9yIC0gW1tGaWx0ZXJRdWVyeU9wXV0gb3IgaXQncyBzdHJpbmcgcmVwcmVzZW50YXRpb24uIENhc2UgaXMgaWdub3JlZFxyXG4gICAgd2hlbiBpZiBhIHN0cmluZyBpcyBwcm92aWRlZCBhbmQgYW55IHN0cmluZyB0aGF0IG1hdGNoZXMgb25lIG9mIHRoZSBGaWx0ZXJRdWVyeU9wIGFsaWFzZXMgd2lsbCBiZSBhY2NlcHRlZC5cclxuICAgIC0gLSAgYSB2YWx1ZSB7T2JqZWN0fSAtIFRoaXMgd2lsbCBiZSB0cmVhdGVkIGFzIGVpdGhlciBhIHByb3BlcnR5IGV4cHJlc3Npb24gb3IgYSBsaXRlcmFsIGRlcGVuZGluZyBvbiBjb250ZXh0LiAgXHJcbiAgICBJbiBnZW5lcmFsLCBpZiB0aGUgdmFsdWUgY2FuIGJlIGludGVycHJldGVkIGFzIGEgcHJvcGVydHkgZXhwcmVzc2lvbiBpdCB3aWxsIGJlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgbGl0ZXJhbC5cclxuICAgIEluIG1vc3QgY2FzZXMgdGhpcyB3b3JrcyB3ZWxsLCBidXQgeW91IGNhbiBhbHNvIGZvcmNlIHRoZSBpbnRlcnByZXRhdGlvbiBieSBtYWtpbmcgdGhlIHZhbHVlIGFyZ3VtZW50IGl0c2VsZiBhbiBvYmplY3QgXHJcbiAgICB3aXRoIGEgJ3ZhbHVlJyBwcm9wZXJ0eSBhbmQgYW4gJ2lzTGl0ZXJhbCcgcHJvcGVydHkgc2V0IHRvIGVpdGhlciB0cnVlIG9yIGZhbHNlLlxyXG4gICAgQnJlZXplIGFsc28gdHJpZXMgdG8gaW5mZXIgdGhlIGRhdGFUeXBlIG9mIGFueSBsaXRlcmFsIGJhc2VkIG9uIGNvbnRleHQsIGlmIHRoaXMgZmFpbHMgeW91IGNhbiBmb3JjZSB0aGlzIGluZmVyZW5jZSBieSBtYWtpbmcgdGhlIHZhbHVlIGFyZ3VtZW50IFxyXG4gICAgYW4gb2JqZWN0IHdpdGggYSAndmFsdWUnIHByb3BlcnR5IGFuZCBhICdkYXRhVHlwZSdwcm9wZXJ0eSBzZXQgdG8gb25lIG9mIHRoZSBEYXRhVHlwZSBlbnVtZXJhdGlvbiBpbnN0YW5jZXMuXHJcblxyXG4gICAgLSBhIG51bGwgb3IgdW5kZWZpbmVkICggdGhpcyBjYXVzZXMgYW55IGV4aXN0aW5nIHdoZXJlIGNsYXVzZSB0byBiZSByZW1vdmVkKVxyXG4gICoqL1xyXG4gIHdoZXJlKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBsZXQgd2hlcmVQcmVkaWNhdGU6IFByZWRpY2F0ZSB8IHVuZGVmaW5lZDtcclxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDAgJiYgYXJnc1swXSAhPSBudWxsKSB7XHJcbiAgICAgIHdoZXJlUHJlZGljYXRlID0gUHJlZGljYXRlLmNyZWF0ZSguLi48YW55PmFyZ3MpO1xyXG4gICAgICBpZiAodGhpcy5mcm9tRW50aXR5VHlwZSkgd2hlcmVQcmVkaWNhdGUuX3ZhbGlkYXRlKHRoaXMuZnJvbUVudGl0eVR5cGUpO1xyXG4gICAgICBpZiAodGhpcy53aGVyZVByZWRpY2F0ZSkge1xyXG4gICAgICAgIHdoZXJlUHJlZGljYXRlID0gdGhpcy53aGVyZVByZWRpY2F0ZS5hbmQod2hlcmVQcmVkaWNhdGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xvbmUodGhpcywgXCJ3aGVyZVByZWRpY2F0ZVwiLCB3aGVyZVByZWRpY2F0ZSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgb3JkZXJCeShwcm9wZXJ0eVBhdGhzPzogc3RyaW5nLCBpc0Rlc2NlbmRpbmc/OiBib29sZWFuKTogRW50aXR5UXVlcnk7XHJcbiAgb3JkZXJCeShwcm9wZXJ0eVBhdGhzOiBzdHJpbmdbXSwgaXNEZXNjZW5kaW5nPzogYm9vbGVhbik6IEVudGl0eVF1ZXJ5O1xyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBuZXcgcXVlcnkgdGhhdCBvcmRlcnMgdGhlIHJlc3VsdHMgb2YgdGhlIHF1ZXJ5IGJ5IHByb3BlcnR5IG5hbWUuICBCeSBkZWZhdWx0IHNvcnRpbmcgb2NjdXJzIGlzIGFzY2VuZGluZyBvcmRlciwgYnV0IHNvcnRpbmcgaW4gZGVzY2VuZGluZyBvcmRlciBpcyBzdXBwb3J0ZWQgYXMgd2VsbC5cclxuICBPcmRlckJ5IGNsYXVzZXMgbWF5IGJlIGNoYWluZWQuXHJcbiAgPiAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiQ3VzdG9tZXJzXCIpXHJcbiAgPiAgICAgICAgLm9yZGVyQnkoXCJDb21wYW55TmFtZVwiKTtcclxuXHJcbiAgb3IgdG8gc29ydCBhY3Jvc3MgbXVsdGlwbGUgcHJvcGVydGllc1xyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKVxyXG4gID4gICAgICAgIC5vcmRlckJ5KFwiUmVnaW9uLCBDb21wYW55TmFtZVwiKTtcclxuXHJcbiAgTmVzdGVkIHByb3BlcnR5IHBhdGhzIGFyZSBhbHNvIHN1cHBvcnRlZFxyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIlByb2R1Y3RzXCIpXHJcbiAgPiAgICAgICAgLm9yZGVyQnkoXCJDYXRlZ29yeS5DYXRlZ29yeU5hbWVcIik7XHJcblxyXG4gIFNvcnRpbmcgaW4gZGVzY2VuZGluZyBvcmRlciBpcyBzdXBwb3J0ZWQgdmlhIHRoZSBhZGRpdGlvbiBvZiAnIGRlc2MnIHRvIHRoZSBlbmQgb2YgYW55IHByb3BlcnR5IHBhdGguXHJcbiAgPiAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiQ3VzdG9tZXJzXCIpXHJcbiAgPiAgICAgICAgLm9yZGVyQnkoXCJDb21wYW55TmFtZSBkZXNjXCIpO1xyXG5cclxuICBvclxyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKVxyXG4gID4gICAgICAgIC5vcmRlckJ5KFwiUmVnaW9uIGRlc2MsIENvbXBhbnlOYW1lIGRlc2NcIik7XHJcbiAgQHBhcmFtIHByb3BlcnR5UGF0aHMgLSBBIGNvbW1hLXNlcGFyYXRlZCAoJywnKSBzdHJpbmcgb2YgcHJvcGVydHkgcGF0aHMgb3IgYW4gYXJyYXkgb2YgcHJvcGVydHkgcGF0aHMuXHJcbiAgRWFjaCBwcm9wZXJ0eSBwYXRoIGNhbiBvcHRpb25hbGx5IGVuZCB3aXRoIFwiIGRlc2NcIiB0byBmb3JjZSBhIGRlc2NlbmRpbmcgc29ydCBvcmRlci4gSWYgJ3Byb3BlcnR5UGF0aHMnIGlzIGVpdGhlciBudWxsIG9yIG9taXR0ZWQgdGhlbiBhbGwgb3JkZXJpbmcgaXMgcmVtb3ZlZC5cclxuICBAcGFyYW0gaXNEZXNjZW5kaW5nIC0gSWYgc3BlY2lmaWVkLCBvdmVycmlkZXMgYWxsIG9mIHRoZSBlbWJlZGRlZCAnZGVzYycgdGFncyBpbiB0aGUgcHJldmlvdXNseSBzcGVjaWZpZWQgcHJvcGVydHkgcGF0aHMuXHJcbiAgKiovXHJcbiAgb3JkZXJCeShwcm9wZXJ0eVBhdGhzOiBzdHJpbmcgfCBzdHJpbmdbXSwgaXNEZXNjZW5kaW5nPzogYm9vbGVhbikge1xyXG4gICAgLy8gcHJvcGVydHlQYXRoczogY2FuIHBhc3MgaW4gY3JlYXRlKFwiQS5YLEJcIikgb3IgY3JlYXRlKFwiQS5YIGRlc2MsIEJcIikgb3IgY3JlYXRlKFwiQS5YIGRlc2MsQlwiLCB0cnVlXSlcclxuICAgIC8vIGlzRGVzYyBwYXJhbWV0ZXIgdHJ1bXBzIGlzRGVzYyBpbiBwcm9wZXJ0eU5hbWUuXHJcbiAgICBsZXQgb3JkZXJCeUNsYXVzZSA9IHByb3BlcnR5UGF0aHMgPT0gbnVsbCA/IG51bGwgOiBuZXcgT3JkZXJCeUNsYXVzZShub3JtYWxpemVQcm9wZXJ0eVBhdGhzKHByb3BlcnR5UGF0aHMpLCBpc0Rlc2NlbmRpbmcpO1xyXG4gICAgaWYgKHRoaXMub3JkZXJCeUNsYXVzZSAmJiBvcmRlckJ5Q2xhdXNlKSB7XHJcbiAgICAgIG9yZGVyQnlDbGF1c2UgPSBuZXcgT3JkZXJCeUNsYXVzZShbdGhpcy5vcmRlckJ5Q2xhdXNlLCBvcmRlckJ5Q2xhdXNlXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xvbmUodGhpcywgXCJvcmRlckJ5Q2xhdXNlXCIsIG9yZGVyQnlDbGF1c2UpO1xyXG4gIH1cclxuXHJcblxyXG4gIG9yZGVyQnlEZXNjKHByb3BlcnR5UGF0aHM6IHN0cmluZyk6IEVudGl0eVF1ZXJ5O1xyXG4gIG9yZGVyQnlEZXNjKHByb3BlcnR5UGF0aHM6IHN0cmluZ1tdKTogRW50aXR5UXVlcnk7XHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIG5ldyBxdWVyeSB0aGF0IG9yZGVycyB0aGUgcmVzdWx0cyBvZiB0aGUgcXVlcnkgYnkgcHJvcGVydHkgbmFtZSBpbiBkZXNjZW5kaW5nIG9yZGVyLlxyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKVxyXG4gID4gICAgICAgIC5vcmRlckJ5RGVzYyhcIkNvbXBhbnlOYW1lXCIpO1xyXG5cclxuICBvciB0byBzb3J0IGFjcm9zcyBtdWx0aXBsZSBwcm9wZXJ0aWVzXHJcbiAgPiAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiQ3VzdG9tZXJzXCIpXHJcbiAgPiAgICAgICAgLm9yZGVyQnlEZXNjKFwiUmVnaW9uLCBDb21wYW55TmFtZVwiKTtcclxuXHJcbiAgTmVzdGVkIHByb3BlcnR5IHBhdGhzIGFyZSBhbHNvIHN1cHBvcnRlZFxyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIlByb2R1Y3RzXCIpXHJcbiAgPiAgICAgICAgLm9yZGVyQnlEZXNjKFwiQ2F0ZWdvcnkuQ2F0ZWdvcnlOYW1lXCIpO1xyXG4gIEBwYXJhbSBwcm9wZXJ0eVBhdGhzIC0gQSBjb21tYS1zZXBhcmF0ZWQgKCcsJykgc3RyaW5nIG9mIHByb3BlcnR5IHBhdGhzIG9yIGFuIGFycmF5IG9mIHByb3BlcnR5IHBhdGhzLlxyXG4gIElmICdwcm9wZXJ0eVBhdGhzJyBpcyBlaXRoZXIgbnVsbCBvciBvbWl0dGVkIHRoZW4gYWxsIG9yZGVyaW5nIGlzIHJlbW92ZWQuXHJcbiAgKiovXHJcbiAgb3JkZXJCeURlc2MocHJvcGVydHlQYXRoczogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuICAgIHJldHVybiB0aGlzLm9yZGVyQnkocHJvcGVydHlQYXRocyBhcyBhbnksIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIG5ldyBxdWVyeSB0aGF0IHNlbGVjdHMgYSBsaXN0IG9mIHByb3BlcnRpZXMgZnJvbSB0aGUgcmVzdWx0cyBvZiB0aGUgb3JpZ2luYWwgcXVlcnkgYW5kIHJldHVybnMgdGhlIHZhbHVlcyBvZiBqdXN0IHRoZXNlIHByb3BlcnRpZXMuIFRoaXNcclxuICB3aWxsIGJlIHJlZmVycmVkIHRvIGFzIGEgcHJvamVjdGlvbi5cclxuICBJZiB0aGUgcmVzdWx0IG9mIHRoaXMgc2VsZWN0aW9uIFwicHJvamVjdGlvblwiIGNvbnRhaW5zIGVudGl0aWVzLCB0aGVzZSBlbnRpdGllcyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgYWRkZWQgdG8gRW50aXR5TWFuYWdlcidzIGNhY2hlIGFuZCB3aWxsXHJcbiAgYmUgbWFkZSAnb2JzZXJ2YWJsZScuXHJcbiAgQW55IHNpbXBsZSBwcm9wZXJ0aWVzLCBpLmUuIHN0cmluZ3MsIG51bWJlcnMgb3IgZGF0ZXMgd2l0aGluIGEgcHJvamVjdGlvbiB3aWxsIG5vdCBiZSBjYWNoZWQgYXJlIHdpbGwgTk9UIGJlIG1hZGUgJ29ic2VydmFibGUnLlxyXG4gIFxyXG4gIFNpbXBsZSBkYXRhIHByb3BlcnRpZXMgY2FuIGJlIHByb2plY3RlZFxyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKVxyXG4gID4gICAgICAgICAud2hlcmUoXCJDb21wYW55TmFtZVwiLCBcInN0YXJ0c1dpdGhcIiwgXCJDXCIpXHJcbiAgPiAgICAgICAgIC5zZWxlY3QoXCJDb21wYW55TmFtZVwiKTtcclxuXHJcbiAgVGhpcyB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIGVhY2ggd2l0aCBhIHNpbmdsZSBcIkNvbXBhbnlOYW1lXCIgcHJvcGVydHkgb2YgdHlwZSBzdHJpbmcuXHJcbiAgQSBzaW1pbGFyIHF1ZXJ5IGNvdWxkIHJldHVybiBhIG5hdmlnYXRpb24gcHJvcGVydHkgaW5zdGVhZFxyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKVxyXG4gID4gICAgICAgIC53aGVyZShcIkNvbXBhbnlOYW1lXCIsIFwic3RhcnRzV2l0aFwiLCBcIkNcIilcclxuICA+ICAgICAgICAuc2VsZWN0KFwiT3JkZXJzXCIpO1xyXG5cclxuICB3aGVyZSB0aGUgcmVzdWx0IHdvdWxkIGJlIGFuIGFycmF5IG9mIG9iamVjdHMgZWFjaCB3aXRoIGEgc2luZ2xlIFwiT3JkZXJzXCIgcHJvcGVydHkgdGhhdCB3b3VsZCBpdHNlbGYgYmUgYW4gYXJyYXkgb2YgXCJPcmRlclwiIGVudGl0aWVzLlxyXG4gIENvbXBvc2l0ZSBwcm9qZWN0aW9ucyBhcmUgYWxzbyBwb3NzaWJsZTpcclxuICA+ICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJDdXN0b21lcnNcIilcclxuICA+ICAgICAgICAud2hlcmUoXCJDb21wYW55TmFtZVwiLCBcInN0YXJ0c1dpdGhcIiwgXCJDXCIpXHJcbiAgPiAgICAgICAgLnNlbGVjdChcIkNvbXBhbnlOYW1lLCBPcmRlcnNcIik7XHJcblxyXG4gIEFzIHdlbGwgYXMgcHJvamVjdGlvbnMgaW52b2x2aW5nIG5lc3RlZCBwcm9wZXJ0eSBwYXRoc1xyXG4gID4gICAgIGxldCBxdWVyeSA9IEVudGl0eVF1ZXJ5KFwiT3JkZXJzXCIpXHJcbiAgPiAgICAgICAgLndoZXJlKFwiQ3VzdG9tZXIuQ29tcGFueU5hbWVcIiwgXCJzdGFydHNXaXRoXCIsIFwiQ1wiKVxyXG4gID4gICAgICAgIC5zZWxlY3QoXCJDdXN0b21lci5Db21wYW55TmFtZSwgQ3VzdG9tZXIsIE9yZGVyRGF0ZVwiKTtcclxuICBAcGFyYW0gcHJvcGVydHlQYXRocyAtIEEgY29tbWEtc2VwYXJhdGVkICgnLCcpIHN0cmluZyBvZiBwcm9wZXJ0eSBwYXRocyBvciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBwYXRocy5cclxuICBJZiAncHJvcGVydHlQYXRocycgaXMgZWl0aGVyIG51bGwgb3Igb21pdHRlZCB0aGVuIGFueSBleGlzdGluZyBwcm9qZWN0aW9uIG9uIHRoZSBxdWVyeSBpcyByZW1vdmVkLlxyXG4gICoqL1xyXG4gIHNlbGVjdChwcm9wZXJ0eVBhdGhzPzogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuICAgIGxldCBzZWxlY3RDbGF1c2UgPSBwcm9wZXJ0eVBhdGhzID09IG51bGwgPyBudWxsIDogbmV3IFNlbGVjdENsYXVzZShub3JtYWxpemVQcm9wZXJ0eVBhdGhzKHByb3BlcnR5UGF0aHMpKTtcclxuICAgIHJldHVybiBjbG9uZSh0aGlzLCBcInNlbGVjdENsYXVzZVwiLCBzZWxlY3RDbGF1c2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIG5ldyBxdWVyeSB0aGF0IHNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVudGl0aWVzIHdoZW4gcmV0dXJuaW5nIHJlc3VsdHMuXHJcbiAgQW55IGV4aXN0aW5nICdza2lwJyBjYW4gYmUgY2xlYXJlZCBieSBjYWxsaW5nICdza2lwJyB3aXRoIG5vIGFyZ3VtZW50cy5cclxuICA+ICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJDdXN0b21lcnNcIilcclxuICA+ICAgICAgIC53aGVyZShcIkNvbXBhbnlOYW1lXCIsIFwic3RhcnRzV2l0aFwiLCBcIkNcIilcclxuICA+ICAgICAgIC5za2lwKDUpO1xyXG4gIEBwYXJhbSBjb3VudCAtIFRoZSBudW1iZXIgb2YgZW50aXRpZXMgdG8gc2tpcCBvdmVyLiBJZiBvbWl0dGVkIG9yIG51bGwgYW55IGV4aXN0aW5nIHNraXAgY291bnQgb24gdGhlIHF1ZXJ5IGlzIHJlbW92ZWQuXHJcbiAgKiovXHJcbiAgc2tpcChjb3VudD86IG51bWJlcikge1xyXG4gICAgYXNzZXJ0UGFyYW0oY291bnQsIFwiY291bnRcIikuaXNPcHRpb25hbCgpLmlzTnVtYmVyKCkuY2hlY2soKTtcclxuICAgIHJldHVybiBjbG9uZSh0aGlzLCBcInNraXBDb3VudFwiLCAoY291bnQgPT0gbnVsbCkgPyBudWxsIDogY291bnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIG5ldyBxdWVyeSB0aGF0IHJldHVybnMgb25seSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBlbnRpdGllcyB3aGVuIHJldHVybmluZyByZXN1bHRzLiAtIFNhbWUgYXMgJ3Rha2UnLlxyXG4gIEFueSBleGlzdGluZyAndG9wJyBjYW4gYmUgY2xlYXJlZCBieSBjYWxsaW5nICd0b3AnIHdpdGggbm8gYXJndW1lbnRzLlxyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKVxyXG4gID4gICAgICAgIC50b3AoNSk7XHJcbiAgQHBhcmFtIGNvdW50IC0gVGhlIG51bWJlciBvZiBlbnRpdGllcyB0byByZXR1cm4uXHJcbiAgSWYgJ2NvdW50JyBpcyBlaXRoZXIgbnVsbCBvciBvbWl0dGVkIHRoZW4gYW55IGV4aXN0aW5nICd0b3AnIGNvdW50IG9uIHRoZSBxdWVyeSBpcyByZW1vdmVkLlxyXG4gICoqL1xyXG4gIHRvcChjb3VudD86IG51bWJlcikge1xyXG4gICAgcmV0dXJuIHRoaXMudGFrZShjb3VudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGEgbmV3IHF1ZXJ5IHRoYXQgcmV0dXJucyBvbmx5IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGVudGl0aWVzIHdoZW4gcmV0dXJuaW5nIHJlc3VsdHMgLSBTYW1lIGFzICd0b3AnLlxyXG4gIEFueSBleGlzdGluZyB0YWtlIGNhbiBiZSBjbGVhcmVkIGJ5IGNhbGxpbmcgdGFrZSB3aXRoIG5vIGFyZ3VtZW50cy5cclxuICA+ICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJDdXN0b21lcnNcIilcclxuICA+ICAgICAgICAudGFrZSg1KTtcclxuICBAcGFyYW0gY291bnQgLSBUaGUgbnVtYmVyIG9mIGVudGl0aWVzIHRvIHJldHVybi5cclxuICBJZiAnY291bnQnIGlzIGVpdGhlciBudWxsIG9yIG9taXR0ZWQgdGhlbiBhbnkgZXhpc3RpbmcgJ3Rha2UnIGNvdW50IG9uIHRoZSBxdWVyeSBpcyByZW1vdmVkLlxyXG4gICoqL1xyXG4gIHRha2UoY291bnQ/OiBudW1iZXIpIHtcclxuICAgIGFzc2VydFBhcmFtKGNvdW50LCBcImNvdW50XCIpLmlzT3B0aW9uYWwoKS5pc051bWJlcigpLmNoZWNrKCk7XHJcbiAgICByZXR1cm4gY2xvbmUodGhpcywgXCJ0YWtlQ291bnRcIiwgKGNvdW50ID09IG51bGwpID8gbnVsbCA6IGNvdW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBuZXcgcXVlcnkgdGhhdCB3aWxsIHJldHVybiByZWxhdGVkIGVudGl0aWVzIG5lc3RlZCB3aXRoaW4gaXRzIHJlc3VsdHMuIFRoZSBleHBhbmQgbWV0aG9kIGFsbG93cyB5b3UgdG8gaWRlbnRpZnkgcmVsYXRlZCBlbnRpdGllcywgdmlhIG5hdmlnYXRpb24gcHJvcGVydHlcclxuICBuYW1lcyBzdWNoIHRoYXQgYSBncmFwaCBvZiBlbnRpdGllcyBtYXkgYmUgcmV0cmlldmVkIHdpdGggYSBzaW5nbGUgcmVxdWVzdC4gQW55IGZpbHRlcmluZyBvY2N1cnMgYmVmb3JlIHRoZSByZXN1bHRzIGFyZSAnZXhwYW5kZWQnLlxyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKVxyXG4gID4gICAgICAgIC53aGVyZShcIkNvbXBhbnlOYW1lXCIsIFwic3RhcnRzV2l0aFwiLCBcIkNcIilcclxuICA+ICAgICAgICAuZXhwYW5kKFwiT3JkZXJzXCIpO1xyXG5cclxuICB3aWxsIHJldHVybiB0aGUgZmlsdGVyZWQgY3VzdG9tZXJzIGVhY2ggd2l0aCBpdHMgXCJPcmRlcnNcIiBwcm9wZXJ0aWVzIGZ1bGx5IHJlc29sdmVkLlxyXG4gIE11bHRpcGxlIHBhdGhzIG1heSBiZSBzcGVjaWZpZWQgYnkgc2VwYXJhdGluZyB0aGUgcGF0aHMgYnkgYSAnLCdcclxuICA+ICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJPcmRlcnNcIilcclxuICA+ICAgICAgICAuZXhwYW5kKFwiQ3VzdG9tZXIsIEVtcGxveWVlXCIpXHJcblxyXG4gIGFuZCBuZXN0ZWQgcHJvcGVydHkgcGF0aHMgbXkgYmUgc3BlY2lmaWVkIGFzIHdlbGxcclxuICA+ICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJPcmRlcnNcIilcclxuICA+ICAgICAgICAuZXhwYW5kKFwiQ3VzdG9tZXIsIE9yZGVyRGV0YWlscywgT3JkZXJEZXRhaWxzLlByb2R1Y3RcIilcclxuICBAcGFyYW0gcHJvcGVydHlQYXRocyAtIEEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbmF2aWdhdGlvbiBwcm9wZXJ0eSBuYW1lcyBvciBhbiBhcnJheSBvZiBuYXZpZ2F0aW9uIHByb3BlcnR5IG5hbWVzLiBFYWNoIE5hdmlnYXRpb24gUHJvcGVydHkgbmFtZSBjYW4gYmUgZm9sbG93ZWRcclxuICBieSBhICcuJyBhbmQgYW5vdGhlciBuYXZpZ2F0aW9uIHByb3BlcnR5IG5hbWUgdG8gZW5hYmxlIGlkZW50aWZ5aW5nIGEgbXVsdGktbGV2ZWwgcmVsYXRpb25zaGlwLlxyXG4gIElmICdwcm9wZXJ0eVBhdGhzJyBpcyBlaXRoZXIgbnVsbCBvciBvbWl0dGVkIHRoZW4gYW55IGV4aXN0aW5nICdleHBhbmQnIGNsYXVzZSBvbiB0aGUgcXVlcnkgaXMgcmVtb3ZlZC5cclxuICAqKi9cclxuICBleHBhbmQocHJvcGVydHlQYXRocz86IHN0cmluZyB8IHN0cmluZ1tdKSB7XHJcbiAgICBsZXQgZXhwYW5kQ2xhdXNlID0gcHJvcGVydHlQYXRocyA9PSBudWxsID8gbnVsbCA6IG5ldyBFeHBhbmRDbGF1c2Uobm9ybWFsaXplUHJvcGVydHlQYXRocyhwcm9wZXJ0eVBhdGhzKSk7XHJcbiAgICByZXR1cm4gY2xvbmUodGhpcywgXCJleHBhbmRDbGF1c2VcIiwgZXhwYW5kQ2xhdXNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBuZXcgcXVlcnkgdGhhdCBpbmNsdWRlcyBhIGNvbGxlY3Rpb24gb2YgcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBzZXJ2ZXIuXHJcbiAgPiAgICAgbGV0IHF1ZXJ5ID0gRW50aXR5UXVlcnkuZnJvbShcIkVtcGxveWVlc0ZpbHRlcmVkQnlDb3VudHJ5QW5kQmlydGhkYXRlXCIpXHJcbiAgPiAgICAgICAgLndpdGhQYXJhbWV0ZXJzKHsgQmlydGhEYXRlOiBcIjEvMS8xOTYwXCIsIENvdW50cnk6IFwiVVNBXCIgfSk7XHJcbiAgIFxyXG4gIHdpbGwgY2FsbCB0aGUgJ0VtcGxveWVlc0ZpbHRlcmVkQnlDb3VudHJ5QW5kQmlydGhkYXRlJyBtZXRob2Qgb24gdGhlIHNlcnZlciBhbmQgcGFzcyBpbiAyIHBhcmFtZXRlcnMuIFRoaXNcclxuICBxdWVyeSB3aWxsIGJlIHVyaSBlbmNvZGVkIGFzXHJcbiAgPiAgICAgIHtzZXJ2aWNlQXBpfS9FbXBsb3llZXNGaWx0ZXJlZEJ5Q291bnRyeUFuZEJpcnRoZGF0ZT9iaXJ0aERhdGU9MSUyRjElMkYxOTYwJmNvdW50cnk9VVNBXHJcblxyXG4gIFBhcmFtZXRlcnMgbWF5IGFsc28gYmUgbWl4ZWQgaW4gd2l0aCBvdGhlciBxdWVyeSBjcml0ZXJpYS5cclxuICA+ICAgICBsZXQgcXVlcnkgPSBFbnRpdHlRdWVyeS5mcm9tKFwiRW1wbG95ZWVzRmlsdGVyZWRCeUNvdW50cnlBbmRCaXJ0aGRhdGVcIilcclxuICA+ICAgICAgICAud2l0aFBhcmFtZXRlcnMoeyBCaXJ0aERhdGU6IFwiMS8xLzE5NjBcIiwgQ291bnRyeTogXCJVU0FcIiB9KVxyXG4gID4gICAgICAgIC53aGVyZShcIkxhc3ROYW1lXCIsIFwic3RhcnRzV2l0aFwiLCBcIlNcIilcclxuICA+ICAgICAgICAub3JkZXJCeShcIkJpcnRoRGF0ZVwiKTtcclxuICBAcGFyYW0gcGFyYW1ldGVycyAtIEEgcGFyYW1ldGVycyBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBwYXJhbWV0ZXIgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSBwYXJhbWV0ZXIgdmFsdWVzLlxyXG4gICoqL1xyXG4gIHdpdGhQYXJhbWV0ZXJzKHBhcmFtZXRlcnM6IE9iamVjdCkge1xyXG4gICAgYXNzZXJ0UGFyYW0ocGFyYW1ldGVycywgXCJwYXJhbWV0ZXJzXCIpLmlzT2JqZWN0KCkuY2hlY2soKTtcclxuICAgIHJldHVybiBjbG9uZSh0aGlzLCBcInBhcmFtZXRlcnNcIiwgcGFyYW1ldGVycyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGEgcXVlcnkgd2l0aCB0aGUgJ2lubGluZUNvdW50JyBjYXBhYmlsaXR5IGVpdGhlciBlbmFibGVkIG9yIGRpc2FibGVkLiAgV2l0aCAnaW5saW5lQ291bnQnIGVuYWJsZWQsIGFuIGFkZGl0aW9uYWwgJ2lubGluZUNvdW50JyBwcm9wZXJ0eVxyXG4gIHdpbGwgYmUgcmV0dXJuZWQgd2l0aCB0aGUgcXVlcnkgcmVzdWx0cyB0aGF0IHdpbGwgY29udGFpbiB0aGUgbnVtYmVyIG9mIGVudGl0aWVzIHRoYXQgd291bGQgaGF2ZSBiZWVuIHJldHVybmVkIGJ5IHRoaXNcclxuICBxdWVyeSB3aXRoIG9ubHkgdGhlICd3aGVyZScvJ2ZpbHRlcicgY2xhdXNlcyBhcHBsaWVkLCBpLmUuIHdpdGhvdXQgYW55ICdza2lwJy8ndGFrZScgb3BlcmF0b3JzIGFwcGxpZWQuIEZvciBsb2NhbCBxdWVyaWVzIHRoaXMgY2xhdXNlIGlzIGlnbm9yZWQuXHJcbiAgPiAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiQ3VzdG9tZXJzXCIpXHJcbiAgPiAgICAgICAgLnRha2UoMjApXHJcbiAgPiAgICAgICAgLm9yZGVyQnkoXCJDb21wYW55TmFtZVwiKVxyXG4gID4gICAgICAgIC5pbmxpbmVDb3VudCh0cnVlKTtcclxuXHJcbiAgd2lsbCByZXR1cm4gdGhlIGZpcnN0IDIwIGN1c3RvbWVycyBhcyB3ZWxsIGFzIGEgY291bnQgb2YgYWxsIG9mIHRoZSBjdXN0b21lcnMgaW4gdGhlIHJlbW90ZSBzdG9yZS5cclxuICBAcGFyYW0gZW5hYmxlZCAtIChkZWZhdWx0ID0gdHJ1ZSkgV2hldGhlciBvciBub3QgaW5saW5lQ291bnQgY2FwYWJpbGl0eSBzaG91bGQgYmUgZW5hYmxlZC4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgdHJ1ZSBpcyBhc3N1bWVkLlxyXG4gICoqL1xyXG4gIGlubGluZUNvdW50KGVuYWJsZWQ/OiBib29sZWFuKSB7XHJcbiAgICBhc3NlcnRQYXJhbShlbmFibGVkLCBcImVuYWJsZWRcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcbiAgICBlbmFibGVkID0gKGVuYWJsZWQgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogISFlbmFibGVkO1xyXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIFwiaW5saW5lQ291bnRFbmFibGVkXCIsIGVuYWJsZWQpO1xyXG4gIH1cclxuXHJcbiAgdXNlTmFtZU9uU2VydmVyKHVzZXNOYW1lT25TZXJ2ZXI/OiBib29sZWFuKSB7XHJcbiAgICBhc3NlcnRQYXJhbSh1c2VzTmFtZU9uU2VydmVyLCBcInVzZXNOYW1lT25TZXJ2ZXJcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcbiAgICB1c2VzTmFtZU9uU2VydmVyID0gKHVzZXNOYW1lT25TZXJ2ZXIgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogISF1c2VzTmFtZU9uU2VydmVyO1xyXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIFwidXNlc05hbWVPblNlcnZlclwiLCB1c2VzTmFtZU9uU2VydmVyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBxdWVyeSB3aXRoIHRoZSAnbm9UcmFja2luZycgY2FwYWJpbGl0eSBlaXRoZXIgZW5hYmxlZCBvciBkaXNhYmxlZC4gIFdpdGggJ25vVHJhY2tpbmcnIGVuYWJsZWQsIHRoZSByZXN1bHRzIG9mIHRoaXMgcXVlcnlcclxuICB3aWxsIG5vdCBiZSBjb2VyY2VkIGludG8gZW50aXRpZXMgYnV0IHdpbGwgaW5zdGVhZCBsb29rIGxpa2UgcmF3IGphdmFzY3JpcHQgcHJvamVjdGlvbnMuIGkuZS4gc2ltcGxlIGphdmFzY3JpcHQgb2JqZWN0cy5cclxuICA+ICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJDdXN0b21lcnNcIilcclxuICA+ICAgICAgICAgLnRha2UoMjApXHJcbiAgPiAgICAgICAgIC5vcmRlckJ5KFwiQ29tcGFueU5hbWVcIilcclxuICA+ICAgICAgICAgLm5vVHJhY2tpbmcodHJ1ZSk7XHJcbiAgQHBhcmFtIGVuYWJsZWQgLSAoZGVmYXVsdCA9IHRydWUpIFdoZXRoZXIgb3Igbm90IHRoZSBub1RyYWNraW5nIGNhcGFiaWxpdHkgc2hvdWxkIGJlIGVuYWJsZWQuIElmIHRoaXMgcGFyYW1ldGVyIGlzIG9taXR0ZWQsIHRydWUgaXMgYXNzdW1lZC5cclxuICAqKi9cclxuICBub1RyYWNraW5nKGVuYWJsZWQ/OiBib29sZWFuKSB7XHJcbiAgICBhc3NlcnRQYXJhbShlbmFibGVkLCBcImVuYWJsZWRcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcbiAgICBlbmFibGVkID0gKGVuYWJsZWQgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogISFlbmFibGVkO1xyXG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIFwibm9UcmFja2luZ0VuYWJsZWRcIiwgZW5hYmxlZCk7XHJcbiAgfVxyXG5cclxuICB1c2luZyhvYmo6IEVudGl0eU1hbmFnZXIpOiBFbnRpdHlRdWVyeTtcclxuICB1c2luZyhvYmo6IERhdGFTZXJ2aWNlKTogRW50aXR5UXVlcnk7XHJcbiAgdXNpbmcob2JqOiBKc29uUmVzdWx0c0FkYXB0ZXIpOiBFbnRpdHlRdWVyeTtcclxuICB1c2luZyhvYmo6IFF1ZXJ5T3B0aW9ucyk6IEVudGl0eVF1ZXJ5O1xyXG4gIHVzaW5nKG9iajogTWVyZ2VTdHJhdGVneSk6IEVudGl0eVF1ZXJ5O1xyXG4gIHVzaW5nKG9iajogRmV0Y2hTdHJhdGVneSk6IEVudGl0eVF1ZXJ5O1xyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgRW50aXR5UXVlcnkgd2l0aCB0aGUgc3BlY2lmaWVkIFtbRW50aXR5TWFuYWdlcl1dLCBbW0RhdGFTZXJ2aWNlXV0sXHJcbiAgW1tKc29uUmVzdWx0c0FkYXB0ZXJdXSwgW1tNZXJnZVN0cmF0ZWd5XV0gb3IgW1tGZXRjaFN0cmF0ZWd5XV0gYXBwbGllZC5cclxuICA+ICAgICAgLy8gJ3VzaW5nJyBjYW4gYmUgdXNlZCB0byByZXR1cm4gYSBuZXcgcXVlcnkgd2l0aCBhIHNwZWNpZmllZCBFbnRpdHlNYW5hZ2VyLlxyXG4gID4gICAgICBsZXQgZW0gPSBuZXcgRW50aXR5TWFuYWdlcihzZXJ2aWNlTmFtZSk7XHJcbiAgPiAgICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIk9yZGVyc1wiKVxyXG4gID4gICAgICAgIC51c2luZyhlbSk7XHJcblxyXG4gIG9yIHdpdGggYSBzcGVjaWZpZWQgW1tNZXJnZVN0cmF0ZWd5XV1cclxuICA+ICAgICAgbGV0IGVtID0gbmV3IEVudGl0eU1hbmFnZXIoc2VydmljZU5hbWUpO1xyXG4gID4gICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJPcmRlcnNcIilcclxuICA+ICAgICAgICAudXNpbmcoTWVyZ2VTdHJhdGVneS5QcmVzZXJ2ZUNoYW5nZXMpO1xyXG5cclxuICBvciB3aXRoIGEgc3BlY2lmaWVkIFtbRmV0Y2hTdHJhdGVneV1dXHJcbiAgPiAgICAgIGxldCBlbSA9IG5ldyBFbnRpdHlNYW5hZ2VyKHNlcnZpY2VOYW1lKTtcclxuICA+ICAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiT3JkZXJzXCIpXHJcbiAgPiAgICAgICAgLnVzaW5nKEZldGNoU3RyYXRlZ3kuRnJvbUxvY2FsQ2FjaGUpO1xyXG4gIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IHRvIHVwZGF0ZSBpbiBjcmVhdGluZyBhIG5ldyBFbnRpdHlRdWVyeSBmcm9tIGFuIGV4aXN0aW5nIG9uZS5cclxuICAqKi9cclxuICB1c2luZyhvYmo6IGFueSkge1xyXG4gICAgaWYgKCFvYmopIHJldHVybiB0aGlzO1xyXG4gICAgbGV0IGVxID0gY2xvbmUodGhpcyk7XHJcbiAgICBwcm9jZXNzVXNpbmcoZXEsIHtcclxuICAgICAgXCJlbnRpdHlNYW5hZ2VyXCI6IG51bGwsXHJcbiAgICAgIFwiZGF0YVNlcnZpY2VcIjogbnVsbCxcclxuICAgICAgXCJxdWVyeU9wdGlvbnNcIjogbnVsbCxcclxuICAgICAgXCJmZXRjaFN0cmF0ZWd5XCI6IChlcTogRW50aXR5UXVlcnksIHZhbDogYW55KSA9PiB7XHJcbiAgICAgICAgZXEucXVlcnlPcHRpb25zID0gKGVxLnF1ZXJ5T3B0aW9ucyB8fCBuZXcgUXVlcnlPcHRpb25zKCkpLnVzaW5nKHZhbCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFwibWVyZ2VTdHJhdGVneVwiOiAoZXE6IEVudGl0eVF1ZXJ5LCB2YWw6IGFueSkgPT4ge1xyXG4gICAgICAgIGVxLnF1ZXJ5T3B0aW9ucyA9IChlcS5xdWVyeU9wdGlvbnMgfHwgbmV3IFF1ZXJ5T3B0aW9ucygpKS51c2luZyh2YWwpO1xyXG4gICAgICB9LFxyXG4gICAgICBcImpzb25SZXN1bHRzQWRhcHRlclwiOiAoZXE6IEVudGl0eVF1ZXJ5LCB2YWw6IGFueSkgPT4ge1xyXG4gICAgICAgIGVxLmRhdGFTZXJ2aWNlID0gKGVxLmRhdGFTZXJ2aWNlIHx8IG5ldyBEYXRhU2VydmljZSgpKS51c2luZyh7IGpzb25SZXN1bHRzQWRhcHRlcjogdmFsIH0pO1xyXG4gICAgICB9XHJcbiAgICB9LCBvYmopO1xyXG4gICAgcmV0dXJuIGVxO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgRXhlY3V0ZXMgdGhpcyBxdWVyeS4gIFRoaXMgbWV0aG9kIHJlcXVpcmVzIHRoYXQgYW4gRW50aXR5TWFuYWdlciBoYXMgYmVlbiBwcmV2aW91c2x5IHNwZWNpZmllZCB2aWEgdGhlIFwidXNpbmdcIiBtZXRob2QuXHJcbiAgXHJcbiAgVGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCB1c2luZyBhICdwcm9taXNlcycgc3ludGF4ICggcmVjb21tZW5kZWQpXHJcbiAgPiAgICAgIGxldCBlbSA9IG5ldyBFbnRpdHlNYW5hZ2VyKHNlcnZpY2VOYW1lKTtcclxuICA+ICAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiT3JkZXJzXCIpLnVzaW5nKGVtKTtcclxuICA+ICAgICAgcXVlcnkuZXhlY3V0ZSgpLnRoZW4oIGZ1bmN0aW9uKGRhdGEpIHtcclxuICA+ICAgICAgICAgIC4uLiBxdWVyeSByZXN1bHRzIHByb2Nlc3NlZCBoZXJlXHJcbiAgPiAgICAgIH0pLmNhdGNoKCBmdW5jdGlvbihlcnIpIHtcclxuICA+ICAgICAgICAgIC4uLiBxdWVyeSBmYWlsdXJlIHByb2Nlc3NlZCBoZXJlXHJcbiAgPiAgICAgIH0pO1xyXG5cclxuICBvciB3aXRoIGNhbGxiYWNrc1xyXG4gID4gICAgICBsZXQgZW0gPSBuZXcgRW50aXR5TWFuYWdlcihzZXJ2aWNlTmFtZSk7XHJcbiAgPiAgICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIk9yZGVyc1wiKS51c2luZyhlbSk7XHJcbiAgPiAgICAgIHF1ZXJ5LmV4ZWN1dGUoXHJcbiAgPiAgICAgICAgZnVuY3Rpb24oZGF0YSkge1xyXG4gID4gICAgICAgICAgICAgICAgICAgIGxldCBvcmRlcnMgPSBkYXRhLnJlc3VsdHM7XHJcbiAgPiAgICAgICAgICAgICAgICAgICAgLi4uIHF1ZXJ5IHJlc3VsdHMgcHJvY2Vzc2VkIGhlcmVcclxuICA+ICAgICAgICAgICAgICAgIH0sXHJcbiAgPiAgICAgICAgZnVuY3Rpb24oZXJyKSB7XHJcbiAgPiAgICAgICAgICAgICAgICAgICAgLi4uIHF1ZXJ5IGZhaWx1cmUgcHJvY2Vzc2VkIGhlcmVcclxuICA+ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICBFaXRoZXIgd2F5IHRoaXMgbWV0aG9kIGlzIHRoZSBzYW1lIGFzIGNhbGxpbmcgdGhlIEVudGl0eU1hbmFnZXIgJ2V4ZWN1dGUnIG1ldGhvZC5cclxuICA+ICAgICAgbGV0IGVtID0gbmV3IEVudGl0eU1hbmFnZXIoc2VydmljZU5hbWUpO1xyXG4gID4gICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJPcmRlcnNcIik7XHJcbiAgPiAgICAgIGVtLmV4ZWN1dGVRdWVyeShxdWVyeSkudGhlbiggZnVuY3Rpb24oZGF0YSkge1xyXG4gID4gICAgICAgICBsZXQgb3JkZXJzID0gZGF0YS5yZXN1bHRzO1xyXG4gID4gICAgICAgICAgLi4uIHF1ZXJ5IHJlc3VsdHMgcHJvY2Vzc2VkIGhlcmVcclxuICA+ICAgICAgfSkuY2F0Y2goIGZ1bmN0aW9uKGVycikge1xyXG4gID4gICAgICAgICAuLi4gcXVlcnkgZmFpbHVyZSBwcm9jZXNzZWQgaGVyZVxyXG4gID4gICAgICB9KTtcclxuXHJcbiAgQHBhcmFtIGNhbGxiYWNrIC0gIEZ1bmN0aW9uIGNhbGxlZCBvbiBzdWNjZXNzLlxyXG4gIEBwYXJhbSBlcnJvckNhbGxiYWNrIC0gRnVuY3Rpb24gY2FsbGVkIG9uIGZhaWx1cmUuXHJcbiAgQHJldHVybiBQcm9taXNlXHJcbiAgKiovXHJcbiAgZXhlY3V0ZShjYWxsYmFjaz86IENhbGxiYWNrLCBlcnJvckNhbGxiYWNrPzogRXJyb3JDYWxsYmFjayk6IFByb21pc2U8UXVlcnlSZXN1bHQ+IHtcclxuICAgIGlmICghdGhpcy5lbnRpdHlNYW5hZ2VyKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIEVudGl0eVF1ZXJ5IG11c3QgaGF2ZSBpdHMgRW50aXR5TWFuYWdlciBwcm9wZXJ0eSBzZXQgYmVmb3JlIGNhbGxpbmcgJ2V4ZWN1dGUnXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZW50aXR5TWFuYWdlci5leGVjdXRlUXVlcnkodGhpcywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgRXhlY3V0ZXMgdGhpcyBxdWVyeSBhZ2FpbnN0IHRoZSBsb2NhbCBjYWNoZS4gIFRoaXMgbWV0aG9kIHJlcXVpcmVzIHRoYXQgYW4gRW50aXR5TWFuYWdlciBoYXZlIGJlZW4gcHJldmlvdXNseSBzcGVjaWZpZWQgdmlhIHRoZSBcInVzaW5nXCIgbWV0aG9kLlxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0gaXMgYW4gZW50aXR5TWFuYWdlciBhbHJlYWR5IGZpbGxlZCB3aXRoIG9yZGVyIGVudGl0aWVzO1xyXG4gID4gICAgICBsZXQgcXVlcnkgPSBuZXcgRW50aXR5UXVlcnkoXCJPcmRlcnNcIikudXNpbmcoZW0pO1xyXG4gID4gICAgICBsZXQgb3JkZXJzID0gcXVlcnkuZXhlY3V0ZUxvY2FsbHkoKTtcclxuXHJcbiAgTm90ZSB0aGF0IGNhbGxpbmcgdGhpcyBtZXRob2QgaXMgdGhlIHNhbWUgYXMgY2FsbGluZyBbW0VudGl0eU1hbmFnZXIuZXhlY3V0ZVF1ZXJ5TG9jYWxseV1dLlxyXG4gICoqL1xyXG4gIGV4ZWN1dGVMb2NhbGx5KCkge1xyXG4gICAgaWYgKCF0aGlzLmVudGl0eU1hbmFnZXIpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gRW50aXR5UXVlcnkgbXVzdCBoYXZlIGl0cyBFbnRpdHlNYW5hZ2VyIHByb3BlcnR5IHNldCBiZWZvcmUgY2FsbGluZyAnZXhlY3V0ZUxvY2FsbHknXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZW50aXR5TWFuYWdlci5leGVjdXRlUXVlcnlMb2NhbGx5KHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9KU09ORXh0KCk7XHJcbiAgfVxyXG5cclxuICAvKiogVHlwaWNhbGx5IG9ubHkgZm9yIHVzZSB3aGVuIGJ1aWxkaW5nIFVyaUJ1aWxkZXJBZGFwdGVycy4gIFxyXG4gIEBoaWRkZW4gQGludGVybmFsICBcclxuICAqL1xyXG4gIHRvSlNPTkV4dChjb250ZXh0PzogRW50aXR5UXVlcnlKc29uQ29udGV4dCkge1xyXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwge307XHJcbiAgICBjb250ZXh0LmVudGl0eVR5cGUgPSBjb250ZXh0LmVudGl0eVR5cGUgfHwgdGhpcy5mcm9tRW50aXR5VHlwZTtcclxuICAgIGNvbnRleHQucHJvcGVydHlQYXRoRm4gPSBjb250ZXh0LnRvTmFtZU9uU2VydmVyID8gY29udGV4dC5lbnRpdHlUeXBlIS5jbGllbnRQcm9wZXJ0eVBhdGhUb1NlcnZlci5iaW5kKGNvbnRleHQuZW50aXR5VHlwZSkgOiBjb3JlLmlkZW50aXR5O1xyXG5cclxuICAgIGxldCB0b0pTT05FeHRGbiA9IGZ1bmN0aW9uICh2OiBhbnkpIHtcclxuICAgICAgcmV0dXJuIHYgPyB2LnRvSlNPTkV4dChjb250ZXh0KSA6IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gY29yZS50b0pzb24odGhpcywge1xyXG4gICAgICBcImZyb20scmVzb3VyY2VOYW1lXCI6IG51bGwsXHJcbiAgICAgIFwidG9UeXBlLHJlc3VsdEVudGl0eVR5cGVcIjogZnVuY3Rpb24gKHY6IGFueSkge1xyXG4gICAgICAgIC8vIHJlc3VsdEVudGl0eVR5cGUgY2FuIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBlbnRpdHlUeXBlXHJcbiAgICAgICAgcmV0dXJuIHYgPyAodHlwZW9mIHYgPT09ICdzdHJpbmcnID8gdiA6IHYubmFtZSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIFwid2hlcmUsd2hlcmVQcmVkaWNhdGVcIjogdG9KU09ORXh0Rm4sXHJcbiAgICAgIFwib3JkZXJCeSxvcmRlckJ5Q2xhdXNlXCI6IHRvSlNPTkV4dEZuLFxyXG4gICAgICBcInNlbGVjdCxzZWxlY3RDbGF1c2VcIjogdG9KU09ORXh0Rm4sXHJcbiAgICAgIFwiZXhwYW5kLGV4cGFuZENsYXVzZVwiOiB0b0pTT05FeHRGbixcclxuICAgICAgXCJza2lwLHNraXBDb3VudFwiOiBudWxsLFxyXG4gICAgICBcInRha2UsdGFrZUNvdW50XCI6IG51bGwsXHJcbiAgICAgIHBhcmFtZXRlcnM6IGZ1bmN0aW9uICh2OiBhbnkpIHtcclxuICAgICAgICByZXR1cm4gY29yZS5pc0VtcHR5KHYpID8gdW5kZWZpbmVkIDogdjtcclxuICAgICAgfSxcclxuICAgICAgXCJpbmxpbmVDb3VudCxpbmxpbmVDb3VudEVuYWJsZWRcIjogZmFsc2UsXHJcbiAgICAgIFwibm9UcmFja2luZyxub1RyYWNraW5nRW5hYmxlZFwiOiBmYWxzZSxcclxuICAgICAgcXVlcnlPcHRpb25zOiBudWxsXHJcbiAgICB9KTtcclxuXHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZnJvbUVudGl0aWVzKGVudGl0eTogRW50aXR5KTogRW50aXR5UXVlcnk7XHJcbiAgc3RhdGljIGZyb21FbnRpdGllcyhlbnRpdGllczogRW50aXR5W10pOiBFbnRpdHlRdWVyeTtcclxuICAvKipcclxuICBTdGF0aWMgbWV0aG9kIHRoYXQgY3JlYXRlcyBhbiBFbnRpdHlRdWVyeSB0aGF0IHdpbGwgYWxsb3cgJ3JlcXVlcnlpbmcnIGFuIGVudGl0eSBvciBhIGNvbGxlY3Rpb24gb2YgZW50aXRpZXMgYnkgcHJpbWFyeSBrZXkuIFRoaXMgY2FuIGJlIHVzZWZ1bFxyXG4gIHRvIGZvcmNlIGEgcmVxdWVyeSBvZiBzZWxlY3RlZCBlbnRpdGllcywgb3IgdG8gcmVzdHJpY3QgYW4gZXhpc3RpbmcgY29sbGVjdGlvbiBvZiBlbnRpdGllcyBhY2NvcmRpbmcgdG8gc29tZSBmaWx0ZXIuXHJcblxyXG4gIFdvcmtzIGZvciBhIHNpbmdsZSBlbnRpdHkgb3IgYW4gYXJyYXkgb2YgZW50aXRpZXMgb2YgdGhlIFNBTUUgdHlwZS5cclxuICBEb2VzIG5vdCB3b3JrIGZvciBhbiBhcnJheSBvZiBlbnRpdGllcyBvZiBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgPiAgICAgIC8vIGFzc3VtaW5nICdjdXN0b21lcnMnIGlzIGFuIGFycmF5IG9mICdDdXN0b21lcicgZW50aXRpZXMgcmV0cmlldmVkIGVhcmxpZXIuXHJcbiAgPiAgICAgIGxldCBjdXN0b21lcnNRdWVyeSA9IEVudGl0eVF1ZXJ5LmZyb21FbnRpdGllcyhjdXN0b21lcnMpO1xyXG5cclxuICBUaGUgcmVzdWx0aW5nIHF1ZXJ5IGNhbiwgb2YgY291cnNlLCBiZSBleHRlbmRlZFxyXG4gID4gICAgICAvLyBhc3N1bWluZyAnY3VzdG9tZXJzJyBpcyBhbiBhcnJheSBvZiAnQ3VzdG9tZXInIGVudGl0aWVzIHJldHJpZXZlZCBlYXJsaWVyLlxyXG4gID4gICAgICBsZXQgY3VzdG9tZXJzUXVlcnkgPSBFbnRpdHlRdWVyeS5mcm9tRW50aXRpZXMoY3VzdG9tZXJzKVxyXG4gID4gICAgICAgIC53aGVyZShcIlJlZ2lvblwiLCBGaWx0ZXJRdWVyeU9wLk5vdEVxdWFscywgbnVsbCk7XHJcblxyXG4gIFNpbmdsZSBlbnRpdGllcyBjYW4gcmVxdWVyaWVkIGFzIHdlbGwuXHJcbiAgPiAgICAgIC8vIGFzc3VtaW5nICdjdXN0b21lcicgaXMgYSAnQ3VzdG9tZXInIGVudGl0eSByZXRyaWV2ZWQgZWFybGllci5cclxuICA+ICAgICAgbGV0IGN1c3RvbWVyUXVlcnkgPSBFbnRpdHlRdWVyeS5mcm9tRW50aXRpZXMoY3VzdG9tZXIpO1xyXG5cclxuICB3aWxsIGNyZWF0ZSBhIHF1ZXJ5IHRoYXQgd2lsbCByZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhIHNpbmdsZSBjdXN0b21lciBlbnRpdHkuXHJcbiAgQHBhcmFtIGVudGl0aWVzIC0gVGhlIGVudGl0aWVzIGZvciB3aGljaCB3ZSB3YW50IHRvIGNyZWF0ZSBhbiBFbnRpdHlRdWVyeS5cclxuICAqKi9cclxuICBzdGF0aWMgZnJvbUVudGl0aWVzKGVudGl0aWVzOiBFbnRpdHkgfCBFbnRpdHlbXSkge1xyXG4gICAgYXNzZXJ0UGFyYW0oZW50aXRpZXMsIFwiZW50aXRpZXNcIikuaXNFbnRpdHkoKS5vcigpLmlzTm9uRW1wdHlBcnJheSgpLmlzRW50aXR5KCkuY2hlY2soKTtcclxuICAgIGxldCBlbnRzID0gKEFycmF5LmlzQXJyYXkoZW50aXRpZXMpKSA/IGVudGl0aWVzIDogW2VudGl0aWVzXTtcclxuXHJcbiAgICBsZXQgZmlyc3RFbnRpdHkgPSBlbnRzWzBdO1xyXG4gICAgbGV0IHR5cGUgPSBmaXJzdEVudGl0eS5lbnRpdHlUeXBlO1xyXG4gICAgaWYgKGVudHMuc29tZShmdW5jdGlvbiAoZSkge1xyXG4gICAgICByZXR1cm4gZS5lbnRpdHlUeXBlICE9PSB0eXBlO1xyXG4gICAgfSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxsICdmcm9tRW50aXRpZXMnIG11c3QgYmUgdGhlIHNhbWUgdHlwZTsgYXQgbGVhc3Qgb25lIGlzIG5vdCBvZiB0eXBlIFwiICtcclxuICAgICAgICB0eXBlLm5hbWUpO1xyXG4gICAgfVxyXG4gICAgbGV0IHEgPSBuZXcgRW50aXR5UXVlcnkodHlwZS5kZWZhdWx0UmVzb3VyY2VOYW1lKTtcclxuICAgIGxldCBwcmVkcyA9IGVudHMubWFwKGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgcmV0dXJuIGJ1aWxkUHJlZGljYXRlKGVudGl0eSk7XHJcbiAgICB9KTtcclxuICAgIGxldCBwcmVkID0gUHJlZGljYXRlLm9yKHByZWRzKTtcclxuICAgIHEgPSBxLndoZXJlKHByZWQpO1xyXG4gICAgbGV0IGVtID0gZmlyc3RFbnRpdHkuZW50aXR5QXNwZWN0LmVudGl0eU1hbmFnZXI7XHJcbiAgICBpZiAoZW0pIHtcclxuICAgICAgcSA9IHEudXNpbmcoZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHE7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBDcmVhdGVzIGFuIEVudGl0eVF1ZXJ5IGZvciB0aGUgc3BlY2lmaWVkIFtbRW50aXR5S2V5XV0uXHJcbiAgPiAgICAgIGxldCBlbXBUeXBlID0gbWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiRW1wbG95ZWVcIik7XHJcbiAgPiAgICAgIGxldCBlbnRpdHlLZXkgPSBuZXcgRW50aXR5S2V5KGVtcFR5cGUsIDEpO1xyXG4gID4gICAgICBsZXQgcXVlcnkgPSBFbnRpdHlRdWVyeS5mcm9tRW50aXR5S2V5KGVudGl0eUtleSk7XHJcblxyXG4gIG9yXHJcbiAgPiAgICAgIC8vICdlbXBsb3llZScgaXMgYSBwcmV2aW91c2x5IHF1ZXJpZWQgZW1wbG95ZWVcclxuICA+ICAgICAgbGV0IGVudGl0eUtleSA9IGVtcGxveWVlLmVudGl0eUFzcGVjdC5nZXRLZXkoKTtcclxuICA+ICAgICAgbGV0IHF1ZXJ5ID0gRW50aXR5UXVlcnkuZnJvbUVudGl0eUtleShlbnRpdHlLZXkpO1xyXG4gIEBwYXJhbSBlbnRpdHlLZXkgLSBUaGUgW1tFbnRpdHlLZXldXSBmb3Igd2hpY2ggYSBxdWVyeSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgKiovXHJcbiAgc3RhdGljIGZyb21FbnRpdHlLZXkoZW50aXR5S2V5OiBFbnRpdHlLZXkpIHtcclxuICAgIGFzc2VydFBhcmFtKGVudGl0eUtleSwgXCJlbnRpdHlLZXlcIikuaXNJbnN0YW5jZU9mKEVudGl0eUtleSkuY2hlY2soKTtcclxuICAgIGxldCBxID0gbmV3IEVudGl0eVF1ZXJ5KGVudGl0eUtleS5lbnRpdHlUeXBlLmRlZmF1bHRSZXNvdXJjZU5hbWUpO1xyXG4gICAgbGV0IHByZWQgPSBidWlsZEtleVByZWRpY2F0ZShlbnRpdHlLZXkpO1xyXG4gICAgcSA9IHEud2hlcmUocHJlZCkudG9UeXBlKGVudGl0eUtleS5lbnRpdHlUeXBlKTtcclxuICAgIHJldHVybiBxO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgQ3JlYXRlcyBhbiBFbnRpdHlRdWVyeSBmb3IgdGhlIHNwZWNpZmllZCBlbnRpdHkgYW5kIFtbTmF2aWdhdGlvblByb3BlcnR5XV0uXHJcbiAgPiAgICAgIC8vICdlbXBsb3llZScgaXMgYSBwcmV2aW91c2x5IHF1ZXJpZWQgZW1wbG95ZWVcclxuICA+ICAgICAgbGV0IG9yZGVyc05hdlByb3AgPSBlbXBsb3llZS5lbnRpdHlUeXBlLmdldFByb3BlcnR5KFwiT3JkZXJzXCIpO1xyXG4gID4gICAgICBsZXQgcXVlcnkgPSBFbnRpdHlRdWVyeS5mcm9tRW50aXR5TmF2aWdhdGlvbihlbXBsb3llZSwgb3JkZXJzTmF2UHJvcCk7XHJcblxyXG4gIHdpbGwgcmV0dXJuIGEgcXVlcnkgZm9yIHRoZSBcIk9yZGVyc1wiIG9mIHRoZSBzcGVjaWZpZWQgJ2VtcGxveWVlJy5cclxuICBAcGFyYW0gZW50aXR5IC0gVGhlIEVudGl0eSB3aG9zZSBuYXZpZ2F0aW9uIHByb3BlcnR5IHdpbGwgYmUgcXVlcmllZC5cclxuICBAcGFyYW0gbmF2aWdhdGlvblByb3BlcnR5IC0gVGhlIFtbTmF2aWdhdGlvblByb3BlcnR5XV0gb3IgbmFtZSBvZiB0aGUgTmF2aWdhdGlvblByb3BlcnR5IHRvIGJlIHF1ZXJpZWQuXHJcbiAgKiovXHJcbiAgc3RhdGljIGZyb21FbnRpdHlOYXZpZ2F0aW9uID0gZnVuY3Rpb24gKGVudGl0eTogRW50aXR5LCBuYXZpZ2F0aW9uUHJvcGVydHk6IE5hdmlnYXRpb25Qcm9wZXJ0eSB8IHN0cmluZykge1xyXG4gICAgYXNzZXJ0UGFyYW0oZW50aXR5LCBcImVudGl0eVwiKS5pc0VudGl0eSgpLmNoZWNrKCk7XHJcbiAgICBsZXQgbmF2UHJvcGVydHkgPSBlbnRpdHkuZW50aXR5VHlwZS5fY2hlY2tOYXZQcm9wZXJ0eShuYXZpZ2F0aW9uUHJvcGVydHkpO1xyXG4gICAgbGV0IHEgPSBuZXcgRW50aXR5UXVlcnkobmF2UHJvcGVydHkuZW50aXR5VHlwZS5kZWZhdWx0UmVzb3VyY2VOYW1lKTtcclxuICAgIGxldCBwcmVkID0gYnVpbGROYXZpZ2F0aW9uUHJlZGljYXRlKGVudGl0eSwgbmF2UHJvcGVydHkpO1xyXG4gICAgaWYgKHByZWQgPT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY3JlYXRlIGEgTmF2aWdhdGlvblF1ZXJ5IGZvciBuYXZpZ2F0aW9uUHJvcGVydHk6IFwiICsgbmF2UHJvcGVydHkubmFtZSApO1xyXG4gICAgfVxyXG4gICAgcSA9IHEud2hlcmUocHJlZCk7XHJcbiAgICBsZXQgZW0gPSBlbnRpdHkuZW50aXR5QXNwZWN0LmVudGl0eU1hbmFnZXI7XHJcbiAgICByZXR1cm4gZW0gPyBxLnVzaW5nKGVtKSA6IHE7XHJcbiAgfTtcclxuXHJcbiAgLy8gcHJvdGVjdGVkIG1ldGhvZHNcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfZ2V0RnJvbUVudGl0eVR5cGUobWV0YWRhdGFTdG9yZTogTWV0YWRhdGFTdG9yZSwgdGhyb3dFcnJvcklmTm90Rm91bmQ/OiBib29sZWFuKSB7XHJcbiAgICAvLyBVbmNvbW1lbnQgbmV4dCB0d28gbGluZXMgaWYgd2UgbWFrZSB0aGlzIG1ldGhvZCBwdWJsaWMuXHJcbiAgICAvLyBhc3NlcnRQYXJhbShtZXRhZGF0YVN0b3JlLCBcIm1ldGFkYXRhU3RvcmVcIikuaXNJbnN0YW5jZU9mKE1ldGFkYXRhU3RvcmUpLmNoZWNrKCk7XHJcbiAgICAvLyBhc3NlcnRQYXJhbSh0aHJvd0Vycm9ySWZOb3RGb3VuZCwgXCJ0aHJvd0Vycm9ySWZOb3RGb3VuZFwiKS5pc0Jvb2xlYW4oKS5pc09wdGlvbmFsKCkuY2hlY2soKTtcclxuICAgIGxldCBlbnRpdHlUeXBlID0gdGhpcy5mcm9tRW50aXR5VHlwZTtcclxuICAgIGlmIChlbnRpdHlUeXBlKSByZXR1cm4gZW50aXR5VHlwZTtcclxuXHJcbiAgICBsZXQgcmVzb3VyY2VOYW1lID0gdGhpcy5yZXNvdXJjZU5hbWU7XHJcbiAgICBpZiAoIXJlc291cmNlTmFtZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGVyZSBpcyBubyByZXNvdXJjZU5hbWUgZm9yIHRoaXMgcXVlcnlcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1ldGFkYXRhU3RvcmUuaXNFbXB0eSgpKSB7XHJcbiAgICAgIGlmICh0aHJvd0Vycm9ySWZOb3RGb3VuZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIG1ldGFkYXRhIGF2YWlsYWJsZSBmb3IgdGhpcyBxdWVyeS4gXCIgK1xyXG4gICAgICAgICAgXCJBcmUgeW91IHF1ZXJ5aW5nIHRoZSBsb2NhbCBjYWNoZSBiZWZvcmUgeW91J3ZlIGZldGNoZWQgbWV0YWRhdGE/XCIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgZW50aXR5VHlwZU5hbWUgPSBtZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGVOYW1lRm9yUmVzb3VyY2VOYW1lKHJlc291cmNlTmFtZSk7XHJcbiAgICBpZiAoZW50aXR5VHlwZU5hbWUpIHtcclxuICAgICAgZW50aXR5VHlwZSA9IG1ldGFkYXRhU3RvcmUuX2dldFN0cnVjdHVyYWxUeXBlKGVudGl0eVR5cGVOYW1lKSBhcyBFbnRpdHlUeXBlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZW50aXR5VHlwZSA9IHRoaXMuX2dldFRvRW50aXR5VHlwZShtZXRhZGF0YVN0b3JlLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWVudGl0eVR5cGUpIHtcclxuICAgICAgaWYgKHRocm93RXJyb3JJZk5vdEZvdW5kKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvcmUuZm9ybWF0U3RyaW5nKFwiQ2Fubm90IGZpbmQgYW4gZW50aXR5VHlwZSBmb3IgcmVzb3VyY2VOYW1lOiAnJTEnLiBcIlxyXG4gICAgICAgICAgKyBcIiBDb25zaWRlciBhZGRpbmcgYW4gJ0VudGl0eVF1ZXJ5LnRvVHlwZScgY2FsbCB0byB5b3VyIHF1ZXJ5IG9yIFwiXHJcbiAgICAgICAgICArIFwiY2FsbGluZyB0aGUgTWV0YWRhdGFTdG9yZS5zZXRFbnRpdHlUeXBlRm9yUmVzb3VyY2VOYW1lIG1ldGhvZCB0byByZWdpc3RlciBhbiBlbnRpdHlUeXBlIGZvciB0aGlzIHJlc291cmNlTmFtZS5cIiwgcmVzb3VyY2VOYW1lKSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZnJvbUVudGl0eVR5cGUgPSBlbnRpdHlUeXBlO1xyXG4gICAgcmV0dXJuIGVudGl0eVR5cGU7XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2dldFRvRW50aXR5VHlwZShtZXRhZGF0YVN0b3JlOiBNZXRhZGF0YVN0b3JlLCBza2lwRnJvbUNoZWNrPzogYm9vbGVhbik6IEVudGl0eVR5cGUgfCB1bmRlZmluZWQge1xyXG4gICAgLy8gc2tpcEZyb21DaGVjayBpcyB0byBhdm9pZCByZWN1cnNpb24gaWYgY2FsbGVkIGZyb20gX2dldEZyb21FbnRpdHlUeXBlO1xyXG4gICAgaWYgKHRoaXMucmVzdWx0RW50aXR5VHlwZSBpbnN0YW5jZW9mIEVudGl0eVR5cGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0RW50aXR5VHlwZTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5yZXN1bHRFbnRpdHlUeXBlKSB7XHJcbiAgICAgIC8vIHJlc3VsdEVudGl0eVR5cGUgaXMgYSBzdHJpbmdcclxuICAgICAgdGhpcy5yZXN1bHRFbnRpdHlUeXBlID0gbWV0YWRhdGFTdG9yZS5fZ2V0U3RydWN0dXJhbFR5cGUodGhpcy5yZXN1bHRFbnRpdHlUeXBlLCBmYWxzZSkgYXMgRW50aXR5VHlwZTtcclxuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0RW50aXR5VHlwZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHJlc29sdmUgaXQsIGlmIHBvc3NpYmxlLCB2aWEgdGhlIHJlc291cmNlTmFtZVxyXG4gICAgICAvLyBkbyBub3QgY2FjaGUgdGhpcyB2YWx1ZSBpbiB0aGlzIGNhc2VcclxuICAgICAgLy8gY2Fubm90IGRldGVybWluZSB0aGUgcmVzdWx0RW50aXR5VHlwZSBpZiBhIHNlbGVjdENsYXVzZSBpcyBwcmVzZW50LlxyXG4gICAgICAvLyByZXR1cm4gc2tpcEZyb21DaGVjayA/IG51bGwgOiAoIXRoaXMuc2VsZWN0Q2xhdXNlKSAmJiB0aGlzLl9nZXRGcm9tRW50aXR5VHlwZShtZXRhZGF0YVN0b3JlLCBmYWxzZSk7XHJcbiAgICAgIGlmIChza2lwRnJvbUNoZWNrIHx8IHRoaXMuc2VsZWN0Q2xhdXNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9nZXRGcm9tRW50aXR5VHlwZShtZXRhZGF0YVN0b3JlLCBmYWxzZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICAvLyBmb3IgdGVzdGluZ1xyXG4gIF90b1VyaShlbTogRW50aXR5TWFuYWdlcikge1xyXG4gICAgbGV0IGRzID0gRGF0YVNlcnZpY2UucmVzb2x2ZShbZW0uZGF0YVNlcnZpY2VdKTtcclxuICAgIHJldHVybiBkcyEudXJpQnVpbGRlciEuYnVpbGRVcmkodGhpcywgZW0ubWV0YWRhdGFTdG9yZSk7XHJcbiAgfVxyXG5cclxufVxyXG5FbnRpdHlRdWVyeS5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IFwiRW50aXR5UXVlcnlcIjtcclxuXHJcbi8vIHByaXZhdGUgZnVuY3Rpb25zXHJcblxyXG5mdW5jdGlvbiBmcm9tSlNPTihlcTogRW50aXR5UXVlcnksIGpzb246IE9iamVjdCkge1xyXG4gIGNvcmUudG9Kc29uKGpzb24sIHtcclxuICAgIFwicmVzb3VyY2VOYW1lLGZyb21cIjogbnVsbCxcclxuICAgIC8vIGp1c3QgdGhlIG5hbWUgY29tZXMgYmFjayBhbmQgd2lsbCBiZSByZXNvbHZlZCBsYXRlclxyXG4gICAgXCJyZXN1bHRFbnRpdHlUeXBlLHRvVHlwZVwiOiBudWxsLFxyXG4gICAgXCJ3aGVyZVByZWRpY2F0ZSx3aGVyZVwiOiBmdW5jdGlvbiAodjogYW55KSB7XHJcbiAgICAgIHJldHVybiB2ID8gbmV3IFByZWRpY2F0ZSh2KSA6IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcbiAgICBcIm9yZGVyQnlDbGF1c2Usb3JkZXJCeVwiOiBmdW5jdGlvbiAodjogYW55KSB7XHJcbiAgICAgIHJldHVybiB2ID8gbmV3IE9yZGVyQnlDbGF1c2UodikgOiB1bmRlZmluZWQ7XHJcbiAgICB9LFxyXG4gICAgXCJzZWxlY3RDbGF1c2Usc2VsZWN0XCI6IGZ1bmN0aW9uICh2OiBhbnkpIHtcclxuICAgICAgcmV0dXJuIHYgPyBuZXcgU2VsZWN0Q2xhdXNlKHYpIDogdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuICAgIFwiZXhwYW5kQ2xhdXNlLGV4cGFuZFwiOiBmdW5jdGlvbiAodjogYW55KSB7XHJcbiAgICAgIHJldHVybiB2ID8gbmV3IEV4cGFuZENsYXVzZSh2KSA6IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcbiAgICBcInNraXBDb3VudCxza2lwXCI6IG51bGwsXHJcbiAgICBcInRha2VDb3VudCx0YWtlXCI6IG51bGwsXHJcbiAgICBwYXJhbWV0ZXJzOiBmdW5jdGlvbiAodjogYW55KSB7XHJcbiAgICAgIHJldHVybiBjb3JlLmlzRW1wdHkodikgPyB1bmRlZmluZWQgOiB2O1xyXG4gICAgfSxcclxuICAgIFwiaW5saW5lQ291bnRFbmFibGVkLGlubGluZUNvdW50XCI6IGZhbHNlLFxyXG4gICAgXCJub1RyYWNraW5nRW5hYmxlZCxub1RyYWNraW5nXCI6IGZhbHNlLFxyXG4gICAgcXVlcnlPcHRpb25zOiBmdW5jdGlvbiAodjogYW55KSB7XHJcbiAgICAgIHJldHVybiB2ID8gUXVlcnlPcHRpb25zLmZyb21KU09OKHYpIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gIH0sIGVxKTtcclxuICByZXR1cm4gZXE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb25lKGVxOiBFbnRpdHlRdWVyeSwgcHJvcE5hbWU/OiBzdHJpbmcsIHZhbHVlPzogYW55KSB7XHJcbiAgLy8gaW1tdXRhYmxlIHF1ZXJpZXMgbWVhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gY2xvbmUgaWYgbm8gY2hhbmdlIGluIHZhbHVlLlxyXG4gIGlmIChwcm9wTmFtZSkge1xyXG4gICAgaWYgKGVxW3Byb3BOYW1lXSA9PT0gdmFsdWUpIHJldHVybiBlcTtcclxuICB9XHJcbiAgLy8gY29weWluZyBRdWVyeU9wdGlvbnMgaXMgc2FmZSBiZWNhdXNlIHRoZXkgYXJlIGFyZSBpbW11dGFibGU7XHJcbiAgbGV0IGNvcHkgPSBjb3JlLmV4dGVuZChuZXcgRW50aXR5UXVlcnkoKSwgZXEsIFtcclxuICAgIFwicmVzb3VyY2VOYW1lXCIsXHJcbiAgICBcImZyb21FbnRpdHlUeXBlXCIsXHJcbiAgICBcIndoZXJlUHJlZGljYXRlXCIsXHJcbiAgICBcIm9yZGVyQnlDbGF1c2VcIixcclxuICAgIFwic2VsZWN0Q2xhdXNlXCIsXHJcbiAgICBcInNraXBDb3VudFwiLFxyXG4gICAgXCJ0YWtlQ291bnRcIixcclxuICAgIFwiZXhwYW5kQ2xhdXNlXCIsXHJcbiAgICBcImlubGluZUNvdW50RW5hYmxlZFwiLFxyXG4gICAgXCJub1RyYWNraW5nRW5hYmxlZFwiLFxyXG4gICAgXCJ1c2VzTmFtZU9uU2VydmVyXCIsXHJcbiAgICBcInF1ZXJ5T3B0aW9uc1wiLFxyXG4gICAgXCJlbnRpdHlNYW5hZ2VyXCIsXHJcbiAgICBcImRhdGFTZXJ2aWNlXCIsXHJcbiAgICBcInJlc3VsdEVudGl0eVR5cGVcIlxyXG4gIF0pIGFzIEVudGl0eVF1ZXJ5O1xyXG4gIGNvcHkucGFyYW1ldGVycyA9IGNvcmUuZXh0ZW5kKHt9LCBlcS5wYXJhbWV0ZXJzKTtcclxuICBpZiAocHJvcE5hbWUpIHtcclxuICAgIGNvcHlbcHJvcE5hbWVdID0gdmFsdWU7XHJcbiAgfVxyXG4gIHJldHVybiBjb3B5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzVXNpbmcoZXE6IEVudGl0eVF1ZXJ5LCBtYXA6IE9iamVjdCwgdmFsdWU6IGFueSwgcHJvcGVydHlOYW1lPzogc3RyaW5nKSB7XHJcbiAgbGV0IHR5cGVOYW1lID0gdmFsdWUuXyR0eXBlTmFtZSB8fCAoKHZhbHVlIGluc3RhbmNlb2YgQnJlZXplRW51bSkgJiYgKHZhbHVlLmNvbnN0cnVjdG9yIGFzIGFueSkubmFtZSk7XHJcbiAgbGV0IGtleSA9IHR5cGVOYW1lICYmIHR5cGVOYW1lLnN1YnN0cigwLCAxKS50b0xvd2VyQ2FzZSgpICsgdHlwZU5hbWUuc3Vic3RyKDEpO1xyXG4gIGlmIChwcm9wZXJ0eU5hbWUgJiYga2V5ICE9PSBwcm9wZXJ0eU5hbWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHByb3BlcnR5OiBcIiArIHByb3BlcnR5TmFtZSk7XHJcbiAgfVxyXG4gIGlmIChrZXkpIHtcclxuICAgIGxldCBmbiA9IG1hcFtrZXldO1xyXG4gICAgaWYgKGZuID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb25maWcgcHJvcGVydHk6IFwiICsga2V5KTtcclxuICAgIH0gZWxzZSBpZiAoZm4gPT09IG51bGwpIHtcclxuICAgICAgZXFba2V5XSA9IHZhbHVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm4oZXEsIHZhbHVlKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgY29yZS5vYmplY3RGb3JFYWNoKHZhbHVlLCAocHJvcE5hbWUsIHZhbCkgPT4ge1xyXG4gICAgICBwcm9jZXNzVXNpbmcoZXEsIG1hcCwgdmFsLCBwcm9wTmFtZSk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5UGF0aHMocHJvcGVydHlQYXRoczogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuICBhc3NlcnRQYXJhbShwcm9wZXJ0eVBhdGhzLCBcInByb3BlcnR5UGF0aHNcIikuaXNPcHRpb25hbCgpLmlzU3RyaW5nKCkub3IoKS5pc0FycmF5KCkuaXNTdHJpbmcoKS5jaGVjaygpO1xyXG4gIGlmICh0eXBlb2YgcHJvcGVydHlQYXRocyA9PT0gJ3N0cmluZycpIHtcclxuICAgIHByb3BlcnR5UGF0aHMgPSBwcm9wZXJ0eVBhdGhzLnNwbGl0KFwiLFwiKTtcclxuICB9XHJcblxyXG4gIHByb3BlcnR5UGF0aHMgPSBwcm9wZXJ0eVBhdGhzLm1hcChmdW5jdGlvbiAocHApIHtcclxuICAgIHJldHVybiBwcC50cmltKCk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHByb3BlcnR5UGF0aHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkUHJlZGljYXRlKGVudGl0eTogRW50aXR5KSB7XHJcbiAgbGV0IGVudGl0eVR5cGUgPSBlbnRpdHkuZW50aXR5VHlwZTtcclxuICBsZXQgcHJlZFBhcnRzID0gZW50aXR5VHlwZS5rZXlQcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAoa3ApIHtcclxuICAgIHJldHVybiBQcmVkaWNhdGUuY3JlYXRlKGtwLm5hbWUsIEZpbHRlclF1ZXJ5T3AuRXF1YWxzLCBlbnRpdHkuZ2V0UHJvcGVydHkoa3AubmFtZSkpO1xyXG4gIH0pO1xyXG4gIGxldCBwcmVkID0gUHJlZGljYXRlLmFuZChwcmVkUGFydHMpO1xyXG4gIHJldHVybiBwcmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBidWlsZEtleVByZWRpY2F0ZShlbnRpdHlLZXk6IEVudGl0eUtleSkge1xyXG4gIGxldCBrZXlQcm9wcyA9IGVudGl0eUtleS5lbnRpdHlUeXBlLmtleVByb3BlcnRpZXM7XHJcbiAgbGV0IHByZWRzID0gY29yZS5hcnJheVppcChrZXlQcm9wcywgZW50aXR5S2V5LnZhbHVlcywgZnVuY3Rpb24gKGtwLCB2KSB7XHJcbiAgICByZXR1cm4gUHJlZGljYXRlLmNyZWF0ZShrcC5uYW1lLCBGaWx0ZXJRdWVyeU9wLkVxdWFscywgdik7XHJcbiAgfSk7XHJcbiAgbGV0IHByZWQgPSBQcmVkaWNhdGUuYW5kKHByZWRzKTtcclxuICByZXR1cm4gcHJlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGROYXZpZ2F0aW9uUHJlZGljYXRlKGVudGl0eTogRW50aXR5LCBuYXZpZ2F0aW9uUHJvcGVydHk6IE5hdmlnYXRpb25Qcm9wZXJ0eSkge1xyXG4gIGlmIChuYXZpZ2F0aW9uUHJvcGVydHkuaXNTY2FsYXIpIHtcclxuICAgIGlmIChuYXZpZ2F0aW9uUHJvcGVydHkuZm9yZWlnbktleU5hbWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XHJcbiAgICBsZXQgcmVsYXRlZEtleVZhbHVlcyA9IG5hdmlnYXRpb25Qcm9wZXJ0eS5mb3JlaWduS2V5TmFtZXMubWFwKChma05hbWUpID0+IHtcclxuICAgICAgcmV0dXJuIGVudGl0eS5nZXRQcm9wZXJ0eShma05hbWUpO1xyXG4gICAgfSk7XHJcbiAgICBsZXQgZW50aXR5S2V5ID0gbmV3IEVudGl0eUtleShuYXZpZ2F0aW9uUHJvcGVydHkuZW50aXR5VHlwZSwgcmVsYXRlZEtleVZhbHVlcyk7XHJcbiAgICByZXR1cm4gYnVpbGRLZXlQcmVkaWNhdGUoZW50aXR5S2V5KTtcclxuICB9IGVsc2Uge1xyXG4gICAgbGV0IGludmVyc2VOcCA9IG5hdmlnYXRpb25Qcm9wZXJ0eS5pbnZlcnNlO1xyXG4gICAgbGV0IGZvcmVpZ25LZXlOYW1lcyA9IGludmVyc2VOcCA/IGludmVyc2VOcC5mb3JlaWduS2V5TmFtZXMgOiBuYXZpZ2F0aW9uUHJvcGVydHkuaW52Rm9yZWlnbktleU5hbWVzO1xyXG4gICAgaWYgKGZvcmVpZ25LZXlOYW1lcy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xyXG4gICAgbGV0IGtleVZhbHVlcyA9IGVudGl0eS5lbnRpdHlBc3BlY3QuZ2V0S2V5KCkudmFsdWVzO1xyXG4gICAgbGV0IHByZWRQYXJ0cyA9IGNvcmUuYXJyYXlaaXAoZm9yZWlnbktleU5hbWVzLCBrZXlWYWx1ZXMsIChma05hbWUsIGt2KSA9PiB7XHJcbiAgICAgIHJldHVybiBQcmVkaWNhdGUuY3JlYXRlKGZrTmFtZSwgRmlsdGVyUXVlcnlPcC5FcXVhbHMsIGt2KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIFByZWRpY2F0ZS5hbmQocHJlZFBhcnRzKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKiBCYXNlIGNsYXNzIGZvciBCb29sZWFuUXVlcnlPcCBhbmQgRmlsdGVyUXVlcnlPcCAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5T3Age1xyXG4gIC8qKiBUaGUgb3BlcmF0b3IgZm9yIHRoaXMgZW51bS4gKi9cclxuICBvcGVyYXRvcjogc3RyaW5nO1xyXG59XHJcblxyXG5cclxuXHJcbi8qKlxyXG5GaWx0ZXJRdWVyeU9wIGlzIGFuICdFbnVtJyBjb250YWluaW5nIGFsbCBvZiB0aGUgdmFsaWQgIFtbUHJlZGljYXRlXV1cclxuZmlsdGVyIG9wZXJhdG9ycyBmb3IgYW4gW1tFbnRpdHlRdWVyeV1dLlxyXG4qKi9cclxuZXhwb3J0IGNsYXNzIEZpbHRlclF1ZXJ5T3AgZXh0ZW5kcyBCcmVlemVFbnVtIGltcGxlbWVudHMgUXVlcnlPcCB7XHJcbiAgLyoqIFRoZSBvcGVyYXRvciBmb3IgdGhpcyBlbnVtLiAqL1xyXG4gIG9wZXJhdG9yOiBzdHJpbmc7XHJcblxyXG4gIC8qKiBBbGlhc2VzOiBcImVxXCIsIFwiPT1cIiAqKi9cclxuICBzdGF0aWMgRXF1YWxzID0gbmV3IEZpbHRlclF1ZXJ5T3AoeyBvcGVyYXRvcjogXCJlcVwiIH0pO1xyXG4gIC8qKiAgQWxpYXNlczogXCJuZVwiLCBcIiE9XCIgICoqL1xyXG4gIHN0YXRpYyBOb3RFcXVhbHMgPSBuZXcgRmlsdGVyUXVlcnlPcCh7IG9wZXJhdG9yOiBcIm5lXCIgfSk7XHJcbiAgLyoqIEFsaWFzZXM6IFwiZ3RcIiwgXCI+XCIgICAqKi9cclxuICBzdGF0aWMgR3JlYXRlclRoYW4gPSBuZXcgRmlsdGVyUXVlcnlPcCh7IG9wZXJhdG9yOiBcImd0XCIgfSk7XHJcbiAgLyoqIEFsaWFzZXM6IFwibHRcIiwgXCI8XCIgICoqL1xyXG4gIHN0YXRpYyBMZXNzVGhhbiA9IG5ldyBGaWx0ZXJRdWVyeU9wKHsgb3BlcmF0b3I6IFwibHRcIiB9KTtcclxuICAvKiogIEFsaWFzZXM6IFwiZ2VcIiwgXCI+PVwiICAqKi9cclxuICBzdGF0aWMgR3JlYXRlclRoYW5PckVxdWFsID0gbmV3IEZpbHRlclF1ZXJ5T3AoeyBvcGVyYXRvcjogXCJnZVwiIH0pO1xyXG4gIC8qKiAgQWxpYXNlczogXCJsZVwiLCBcIjw9XCIgICoqL1xyXG4gIHN0YXRpYyBMZXNzVGhhbk9yRXF1YWwgPSBuZXcgRmlsdGVyUXVlcnlPcCh7IG9wZXJhdG9yOiBcImxlXCIgfSk7XHJcbiAgLyoqICBTdHJpbmcgb3BlcmF0aW9uOiBJcyBhIHN0cmluZyBhIHN1YnN0cmluZyBvZiBhbm90aGVyIHN0cmluZy4gIEFsaWFzZXM6IFwic3Vic3RyaW5nb2ZcIiAgICoqL1xyXG4gIHN0YXRpYyBDb250YWlucyA9IG5ldyBGaWx0ZXJRdWVyeU9wKHsgb3BlcmF0b3I6IFwiY29udGFpbnNcIiB9KTtcclxuICAvKiogTm8gYWxpYXNlcyAqL1xyXG4gIHN0YXRpYyBTdGFydHNXaXRoID0gbmV3IEZpbHRlclF1ZXJ5T3AoeyBvcGVyYXRvcjogXCJzdGFydHN3aXRoXCIgfSk7XHJcbiAgLyoqIE5vIGFsaWFzZXMgKi9cclxuICBzdGF0aWMgRW5kc1dpdGggPSBuZXcgRmlsdGVyUXVlcnlPcCh7IG9wZXJhdG9yOiBcImVuZHN3aXRoXCIgfSk7XHJcbiAgLyoqICBBbGlhc2VzOiBcInNvbWVcIiAgKiovXHJcbiAgc3RhdGljIEFueSA9IG5ldyBGaWx0ZXJRdWVyeU9wKHsgb3BlcmF0b3I6IFwiYW55XCIgfSk7XHJcbiAgLyoqICBBbGlhc2VzOiBcImV2ZXJ5XCIgICoqL1xyXG4gIHN0YXRpYyBBbGwgPSBuZXcgRmlsdGVyUXVlcnlPcCh7IG9wZXJhdG9yOiBcImFsbFwiIH0pO1xyXG4gIC8qKiBObyBhbGlhc2VzICovXHJcbiAgc3RhdGljIEluID0gbmV3IEZpbHRlclF1ZXJ5T3AoeyBvcGVyYXRvcjogXCJpblwiIH0pO1xyXG4gIC8qKiBObyBhbGlhc2VzICovXHJcbiAgc3RhdGljIElzVHlwZU9mID0gbmV3IEZpbHRlclF1ZXJ5T3AoeyBvcGVyYXRvcjogXCJpc29mXCIgfSk7XHJcbn1cclxuRmlsdGVyUXVlcnlPcC5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IFwiRmlsdGVyUXVlcnlPcFwiO1xyXG5FcnJvclsneCddID0gRmlsdGVyUXVlcnlPcC5yZXNvbHZlU3ltYm9scygpO1xyXG5cclxuXHJcbi8qKlxyXG4gQm9vbGVhblF1ZXJ5T3AgaXMgYW4gJ0VudW0nIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSB2YWxpZCAgYm9vbGVhblxyXG5vcGVyYXRvcnMgZm9yIGFuIFtbRW50aXR5UXVlcnldXS5cclxuKiovXHJcbmV4cG9ydCBjbGFzcyBCb29sZWFuUXVlcnlPcCBleHRlbmRzIEJyZWV6ZUVudW0gaW1wbGVtZW50cyBRdWVyeU9wIHtcclxuICAvKiogVGhlIG9wZXJhdG9yIGZvciB0aGlzIGVudW0uICovXHJcbiAgb3BlcmF0b3I6IHN0cmluZztcclxuXHJcbiAgc3RhdGljIEFuZCA9IG5ldyBCb29sZWFuUXVlcnlPcCh7IG9wZXJhdG9yOiBcImFuZFwiIH0pO1xyXG4gIHN0YXRpYyBPciA9IG5ldyBCb29sZWFuUXVlcnlPcCh7IG9wZXJhdG9yOiBcIm9yXCIgfSk7XHJcbiAgc3RhdGljIE5vdCA9IG5ldyBCb29sZWFuUXVlcnlPcCh7IG9wZXJhdG9yOiBcIm5vdFwiIH0pO1xyXG5cclxufVxyXG5Cb29sZWFuUXVlcnlPcC5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IFwiQm9vbGVhblF1ZXJ5T3BcIjtcclxuRXJyb3JbJ3gnXSA9IEJvb2xlYW5RdWVyeU9wLnJlc29sdmVTeW1ib2xzKCk7XHJcblxyXG5cclxuLyoqIEZvciB1c2UgYnkgYnJlZXplIHBsdWdpbiBhdXRob3JzIG9ubHkuICBUaGUgY2xhc3MgaXMgdXNlZCBpbiBtb3N0IFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0gaW1wbGVtZW50YXRpb25zXHJcbkBhZGFwdGVyIChzZWUgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSkgICAgXHJcbkBoaWRkZW5cclxuXHJcbkFuIE9yZGVyQnlDbGF1c2UgaXMgYSBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvcGVydGllcyBhbmQgZGlyZWN0aW9uIHRoYXQgdGhlIHJlc3VsdFxyXG5vZiBhIHF1ZXJ5IHNob3VsZCBiZSBzb3J0ZWQgaW4uICBPcmRlckJ5Q2xhdXNlcyBhcmUgaW1tdXRhYmxlLCB3aGljaCBtZWFucyB0aGF0IGFueVxyXG5tZXRob2QgdGhhdCB3b3VsZCBtb2RpZnkgYW4gT3JkZXJCeUNsYXVzZSBhY3R1YWxseSByZXR1cm5zIGEgbmV3IE9yZGVyQnlDbGF1c2UuXHJcblxyXG5Gb3IgZXhhbXBsZSBmb3IgYW4gRW1wbG95ZWUgb2JqZWN0IHdpdGggcHJvcGVydGllcyBvZiAnQ29tcGFueScgYW5kICdMYXN0TmFtZScgdGhlIGZvbGxvd2luZyB3b3VsZCBiZSB2YWxpZCBleHByZXNzaW9uczpcclxuPiAgICAgbGV0IG9iYyA9IG5ldyBPcmRlckJ5Q2xhdXNlKFwiQ29tcGFueS5Db21wYW55TmFtZSwgTGFzdE5hbWVcIilcclxuXHJcbm9yXHJcbj4gICAgIGxldCBvYmMgPSBuZXcgT3JkZXJCeUNsYXVzZShcIkNvbXBhbnkuQ29tcGFueU5hbWUgZGVzYywgTGFzdE5hbWVcIilcclxuXHJcbm9yXHJcbj4gICAgIGxldCBvYmMgPSBuZXcgT3JkZXJCeUNsYXVzZShcIkNvbXBhbnkuQ29tcGFueU5hbWUsIExhc3ROYW1lXCIsIHRydWUpO1xyXG4qL1xyXG5leHBvcnQgY2xhc3MgT3JkZXJCeUNsYXVzZSB7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgaXRlbXM6IE9yZGVyQnlJdGVtW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5UGF0aHM6IHN0cmluZ1tdIHwgT3JkZXJCeUNsYXVzZVtdLCBpc0Rlc2M/OiBib29sZWFuKSB7XHJcbiAgICBpZiAocHJvcGVydHlQYXRocy5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3JkZXJCeUNsYXVzZSBjYW5ub3QgYmUgZW1wdHlcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8geW91IGNhbiBhbHNvIHBhc3MgaW4gYW4gYXJyYXkgb2Ygb3JkZXJCeUNsYXVzZXNcclxuICAgIGlmIChwcm9wZXJ0eVBhdGhzWzBdIGluc3RhbmNlb2YgT3JkZXJCeUNsYXVzZSkge1xyXG4gICAgICBsZXQgY2xhdXNlcyA9IHByb3BlcnR5UGF0aHMgYXMgT3JkZXJCeUNsYXVzZVtdO1xyXG4gICAgICB0aGlzLml0ZW1zID0gY29yZS5hcnJheUZsYXRNYXAoY2xhdXNlcywgYyA9PiBjLml0ZW1zKTtcclxuICAgICAgLy8gdGhpcy5pdGVtcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoY2xhdXNlc1swXS5pdGVtcywgY2xhdXNlcy5zbGljZSgxKS5tYXAoY29yZS5wbHVjayhcIml0ZW1zXCIpKSk7XHJcbiAgICAgIC8vIHRoaXMuaXRlbXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjbGF1c2VzLm1hcChjb3JlLnBsdWNrKFwiaXRlbXNcIikpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaXRlbXMgPSAocHJvcGVydHlQYXRocyBhcyBzdHJpbmdbXSkubWFwKGZ1bmN0aW9uIChwcCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgT3JkZXJCeUl0ZW0ocHAsIGlzRGVzYyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIHZhbGlkYXRlKGVudGl0eVR5cGU6IEVudGl0eVR5cGUpIHtcclxuICAgIGlmIChlbnRpdHlUeXBlID09IG51bGwgfHwgZW50aXR5VHlwZS5pc0Fub255bW91cykgcmV0dXJuO1xyXG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgIGl0ZW0udmFsaWRhdGUoZW50aXR5VHlwZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGdldENvbXBhcmVyKGVudGl0eVR5cGU6IEVudGl0eVR5cGUpIHtcclxuICAgIGxldCBvcmRlckJ5RnVuY3MgPSB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbiAob2JjKSB7XHJcbiAgICAgIHJldHVybiBvYmMuZ2V0Q29tcGFyZXIoZW50aXR5VHlwZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZW50aXR5MTogYW55LCBlbnRpdHkyOiBhbnkpIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlckJ5RnVuY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gb3JkZXJCeUZ1bmNzW2ldKGVudGl0eTEsIGVudGl0eTIpO1xyXG4gICAgICAgIGlmIChyZXN1bHQgIT09IDApIHtcclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHRvSlNPTkV4dChjb250ZXh0OiBFbnRpdHlRdWVyeUpzb25Db250ZXh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIGNvbnRleHQucHJvcGVydHlQYXRoRm4hKGl0ZW0ucHJvcGVydHlQYXRoKSArIChpdGVtLmlzRGVzYyA/IFwiIGRlc2NcIiA6IFwiXCIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbmV4cG9ydCBjbGFzcyBPcmRlckJ5SXRlbSB7XHJcbiAgcHJvcGVydHlQYXRoOiBzdHJpbmc7XHJcbiAgaXNEZXNjOiBib29sZWFuO1xyXG4gIGxhc3RQcm9wZXJ0eTogRW50aXR5UHJvcGVydHk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5UGF0aDogc3RyaW5nLCBpc0Rlc2M/OiBib29sZWFuKSB7XHJcbiAgICBpZiAoISh0eXBlb2YgcHJvcGVydHlQYXRoID09PSAnc3RyaW5nJykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvcGVydHlQYXRoIGlzIG5vdCBhIHN0cmluZ1wiKTtcclxuICAgIH1cclxuICAgIHByb3BlcnR5UGF0aCA9IHByb3BlcnR5UGF0aC50cmltKCk7XHJcblxyXG4gICAgbGV0IHBhcnRzID0gcHJvcGVydHlQYXRoLnNwbGl0KCcgJyk7XHJcbiAgICAvLyBwYXJ0c1swXSBpcyB0aGUgcHJvcGVydHlQYXRoOyBbMV0gd291bGQgYmUgd2hldGhlciBkZXNjZW5kaW5nIG9yIG5vdC5cclxuICAgIC8vIGlmIChwYXJ0cy5sZW5ndGggPiAxICYmIGlzRGVzYyAhPT0gdHJ1ZSAmJiBpc0Rlc2MgIT09IGZhbHNlKSB7XHJcbiAgICBpZiAocGFydHMubGVuZ3RoID4gMSAmJiBpc0Rlc2MgPT0gbnVsbCkge1xyXG4gICAgICBpc0Rlc2MgPSBjb3JlLnN0cmluZ1N0YXJ0c1dpdGgocGFydHNbMV0udG9Mb3dlckNhc2UoKSwgXCJkZXNjXCIpO1xyXG4gICAgICBpZiAoIWlzRGVzYykge1xyXG4gICAgICAgIC8vIGlzRGVzYyBpcyBmYWxzZSBidXQgY2hlY2sgdG8gbWFrZSBzdXJlIGl0cyBpbnRlbmRlZC5cclxuICAgICAgICBsZXQgaXNBc2MgPSBjb3JlLnN0cmluZ1N0YXJ0c1dpdGgocGFydHNbMV0udG9Mb3dlckNhc2UoKSwgXCJhc2NcIik7XHJcbiAgICAgICAgaWYgKCFpc0FzYykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGhlIHNlY29uZCB3b3JkIGluIHRoZSBwcm9wZXJ0eVBhdGggbXVzdCBiZWdpbiB3aXRoICdkZXNjJyBvciAnYXNjJ1wiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLnByb3BlcnR5UGF0aCA9IHBhcnRzWzBdO1xyXG4gICAgdGhpcy5pc0Rlc2MgPSBpc0Rlc2MgfHwgZmFsc2U7XHJcbiAgfVxyXG5cclxuICB2YWxpZGF0ZShlbnRpdHlUeXBlOiBFbnRpdHlUeXBlKTogRW50aXR5UHJvcGVydHkgfCB1bmRlZmluZWQge1xyXG4gICAgaWYgKGVudGl0eVR5cGUgPT0gbnVsbCB8fCBlbnRpdHlUeXBlLmlzQW5vbnltb3VzKSByZXR1cm47XHJcbiAgICAvLyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBvbiBiYWQgcHJvcGVydHlQYXRoXHJcbiAgICB0aGlzLmxhc3RQcm9wZXJ0eSA9IGVudGl0eVR5cGUuZ2V0UHJvcGVydHkodGhpcy5wcm9wZXJ0eVBhdGgsIHRydWUpIGFzIEVudGl0eVByb3BlcnR5O1xyXG4gICAgcmV0dXJuIHRoaXMubGFzdFByb3BlcnR5O1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29tcGFyZXIoZW50aXR5VHlwZTogRW50aXR5VHlwZSkge1xyXG4gICAgbGV0IHByb3BEYXRhVHlwZTogRGF0YVR5cGU7XHJcbiAgICBsZXQgaXNDYXNlU2Vuc2l0aXZlOiBib29sZWFuO1xyXG4gICAgaWYgKCF0aGlzLmxhc3RQcm9wZXJ0eSkgdGhpcy52YWxpZGF0ZShlbnRpdHlUeXBlKTtcclxuICAgIGlmICh0aGlzLmxhc3RQcm9wZXJ0eSkge1xyXG4gICAgICBwcm9wRGF0YVR5cGUgPSAodGhpcy5sYXN0UHJvcGVydHkgYXMgYW55KS5kYXRhVHlwZTtcclxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gdGhpcy5sYXN0UHJvcGVydHkucGFyZW50VHlwZS5tZXRhZGF0YVN0b3JlLmxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucy5pc0Nhc2VTZW5zaXRpdmU7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHByb3BlcnR5UGF0aCA9IHRoaXMucHJvcGVydHlQYXRoO1xyXG4gICAgbGV0IGlzRGVzYyA9IHRoaXMuaXNEZXNjO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoZW50aXR5MTogYW55LCBlbnRpdHkyOiBhbnkpIHtcclxuICAgICAgbGV0IHZhbHVlMSA9IEVudGl0eUFzcGVjdC5nZXRQcm9wZXJ0eVBhdGhWYWx1ZShlbnRpdHkxLCBwcm9wZXJ0eVBhdGgpO1xyXG4gICAgICBsZXQgdmFsdWUyID0gRW50aXR5QXNwZWN0LmdldFByb3BlcnR5UGF0aFZhbHVlKGVudGl0eTIsIHByb3BlcnR5UGF0aCk7XHJcbiAgICAgIGxldCBkYXRhVHlwZSA9IHByb3BEYXRhVHlwZSB8fCAodmFsdWUxICYmIERhdGFUeXBlLmZyb21WYWx1ZSh2YWx1ZTEpKSB8fCBEYXRhVHlwZS5mcm9tVmFsdWUodmFsdWUyKTtcclxuICAgICAgaWYgKGRhdGFUeXBlID09PSBEYXRhVHlwZS5TdHJpbmcpIHtcclxuICAgICAgICBpZiAoaXNDYXNlU2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgICB2YWx1ZTEgPSB2YWx1ZTEgfHwgXCJcIjtcclxuICAgICAgICAgIHZhbHVlMiA9IHZhbHVlMiB8fCBcIlwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YWx1ZTEgPSAodmFsdWUxIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICB2YWx1ZTIgPSAodmFsdWUyIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBub3JtYWxpemUgPSBEYXRhVHlwZS5nZXRDb21wYXJhYmxlRm4oZGF0YVR5cGUpO1xyXG4gICAgICAgIHZhbHVlMSA9IG5vcm1hbGl6ZSh2YWx1ZTEpO1xyXG4gICAgICAgIHZhbHVlMiA9IG5vcm1hbGl6ZSh2YWx1ZTIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh2YWx1ZTEgPT09IHZhbHVlMikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9IGVsc2UgaWYgKHZhbHVlMSA+IHZhbHVlMiB8fCB2YWx1ZTIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBpc0Rlc2MgPyAtMSA6IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGlzRGVzYyA/IDEgOiAtMTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbi8qKiBGb3IgdXNlIGJ5IGJyZWV6ZSBwbHVnaW4gYXV0aG9ycyBvbmx5LiAgVGhlIGNsYXNzIGlzIHVzZWQgaW4gbW9zdCBbW0lVcmlCdWlsZGVyQWRhcHRlcl1dIGltcGxlbWVudGF0aW9uc1xyXG5AYWRhcHRlciAoc2VlIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0pICAgIFxyXG5AaGlkZGVuIFxyXG4qKi9cclxuZXhwb3J0IGNsYXNzIFNlbGVjdENsYXVzZSB7XHJcbiAgcHJvcGVydHlQYXRoczogc3RyaW5nW107XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX3BhdGhOYW1lczogc3RyaW5nW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5UGF0aHM6IHN0cmluZ1tdKSB7XHJcbiAgICB0aGlzLnByb3BlcnR5UGF0aHMgPSBwcm9wZXJ0eVBhdGhzO1xyXG4gICAgdGhpcy5fcGF0aE5hbWVzID0gcHJvcGVydHlQYXRocy5tYXAoZnVuY3Rpb24gKHBwKSB7XHJcbiAgICAgIHJldHVybiBwcC5yZXBsYWNlKFwiLlwiLCBcIl9cIik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHZhbGlkYXRlKGVudGl0eVR5cGU6IEVudGl0eVR5cGUpIHtcclxuICAgIGlmIChlbnRpdHlUeXBlID09IG51bGwgfHwgZW50aXR5VHlwZS5pc0Fub255bW91cykgcmV0dXJuOyAvLyBjYW4ndCB2YWxpZGF0ZSB5ZXRcclxuICAgIC8vIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIG9uIGJhZCBwcm9wZXJ0eVBhdGhcclxuICAgIHRoaXMucHJvcGVydHlQYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgIGVudGl0eVR5cGUuZ2V0UHJvcGVydHkocGF0aCwgdHJ1ZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHRvRnVuY3Rpb24oLyogY29uZmlnICovKSB7XHJcbiAgICBsZXQgdGhhdCA9IHRoaXM7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVudGl0eTogRW50aXR5KSB7XHJcbiAgICAgIGxldCByZXN1bHQgPSB7fTtcclxuICAgICAgdGhhdC5wcm9wZXJ0eVBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgsIGkpIHtcclxuICAgICAgICByZXN1bHRbdGhhdC5fcGF0aE5hbWVzW2ldXSA9IEVudGl0eUFzcGVjdC5nZXRQcm9wZXJ0eVBhdGhWYWx1ZShlbnRpdHksIHBhdGgpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICB0b0pTT05FeHQoY29udGV4dDogRW50aXR5UXVlcnlKc29uQ29udGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXMucHJvcGVydHlQYXRocy5tYXAoZnVuY3Rpb24gKHBwKSB7XHJcbiAgICAgIHJldHVybiBjb250ZXh0LnByb3BlcnR5UGF0aEZuIShwcCk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKiBGb3IgdXNlIGJ5IGJyZWV6ZSBwbHVnaW4gYXV0aG9ycyBvbmx5LiAgVGhlIGNsYXNzIGlzIHVzZWQgaW4gbW9zdCBbW0lVcmlCdWlsZGVyQWRhcHRlcl1dIGltcGxlbWVudGF0aW9uc1xyXG5AYWRhcHRlciAoc2VlIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0pICAgIFxyXG5AaGlkZGVuIFxyXG4qKi9cclxuZXhwb3J0IGNsYXNzIEV4cGFuZENsYXVzZSB7XHJcbiAgcHJvcGVydHlQYXRoczogc3RyaW5nW107XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5UGF0aHM6IHN0cmluZ1tdKSB7XHJcbiAgICB0aGlzLnByb3BlcnR5UGF0aHMgPSBwcm9wZXJ0eVBhdGhzO1xyXG4gIH1cclxuXHJcbiAgdG9KU09ORXh0KGNvbnRleHQ6IEVudGl0eVF1ZXJ5SnNvbkNvbnRleHQpIHtcclxuICAgIHJldHVybiB0aGlzLnByb3BlcnR5UGF0aHMubWFwKGZ1bmN0aW9uIChwcCkge1xyXG4gICAgICByZXR1cm4gY29udGV4dC5wcm9wZXJ0eVBhdGhGbiEocHApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuXHJcbiJdfQ==