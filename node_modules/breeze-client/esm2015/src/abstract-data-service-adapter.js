import { core } from './core';
import { config } from './config';
import { JsonResultsAdapter } from './data-service';
import { MetadataStore } from './entity-metadata';
/** For use by breeze plugin authors only.  The class is used as the base class for most [[IDataServiceAdapter]] implementations
@adapter (see [[IDataServiceAdapter]])
@hidden
*/
export class AbstractDataServiceAdapter {
    constructor() {
        /**
        Returns a constructor function for a "ChangeRequestInterceptor"
        that can tweak the saveBundle both as it is built and when it is completed
        by a concrete DataServiceAdapater.
      
        Initialized with a default, no-op implementation that developers can replace with a
        substantive implementation that changes the individual entity change requests
        or aspects of the entire 'saveBundle' without having to write their own DataService adapters.
        >     let adapter = breeze.config.getAdapterInstance('dataService');
        >     adapter.changeRequestInterceptor = function (saveContext, saveBundle) {
        >         this.getRequest = function (request, entity, index) {
        >            // alter the request that the adapter prepared for this entity
        >            // based on the entity, saveContext, and saveBundle
        >            // e.g., add a custom header or prune the originalValuesMap
        >            return request;
        >        };
        >        this.done = function (requests) {
        >            // alter the array of requests representing the entire change-set
        >            // based on the saveContext and saveBundle
        >        };
        >     }
      
        @param saveContext - The BreezeJS "context" for the save operation.
        @param saveBundle - Contains the array of entities-to-be-saved (AKA, the entity change-set).
        @return Constructor for a "ChangeRequestInterceptor".
        **/
        this.changeRequestInterceptor = DefaultChangeRequestInterceptor;
        this.jsonResultsAdapter = new JsonResultsAdapter({
            name: "noop",
            visitNode: function ( /* node, mappingContext, nodeContext */) {
                return {};
            }
        });
    }
    // TODO use interface
    checkForRecomposition(interfaceInitializedArgs) {
        if (interfaceInitializedArgs.interfaceName === "ajax" && interfaceInitializedArgs.isDefault) {
            this.initialize();
        }
    }
    initialize() {
        this.ajaxImpl = config.getAdapterInstance("ajax");
        // don't cache 'ajax' because then we would need to ".bind" it, and don't want to because of brower support issues.
        if (this.ajaxImpl && this.ajaxImpl.ajax) {
            return;
        }
        throw new Error("Unable to find ajax adapter for dataservice adapter '" + (this.name || '') + "'.");
    }
    fetchMetadata(metadataStore, dataService) {
        let serviceName = dataService.serviceName;
        let url = dataService.qualifyUrl("Metadata");
        let promise = new Promise((resolve, reject) => {
            this.ajaxImpl.ajax({
                type: "GET",
                url: url,
                dataType: 'json',
                success: (httpResponse) => {
                    // might have been fetched by another query
                    if (metadataStore.hasMetadataFor(serviceName)) {
                        return resolve("already fetched");
                    }
                    let data = httpResponse.data;
                    let metadata;
                    try {
                        metadata = typeof (data) === "string" ? JSON.parse(data) : data;
                        metadataStore.importMetadata(metadata);
                    }
                    catch (e) {
                        let errMsg = "Unable to either parse or import metadata: " + e.message;
                        handleHttpError(reject, httpResponse, "Metadata query failed for: " + url + ". " + errMsg);
                    }
                    // import may have brought in the service.
                    if (!metadataStore.hasMetadataFor(serviceName)) {
                        metadataStore.addDataService(dataService);
                    }
                    resolve(metadata);
                },
                error: (httpResponse) => {
                    handleHttpError(reject, httpResponse, "Metadata query failed for: " + url);
                }
            });
        });
        return promise;
    }
    executeQuery(mappingContext) {
        mappingContext.adapter = this;
        let promise = new Promise((resolve, reject) => {
            let url = mappingContext.getUrl();
            let params = {
                type: "GET",
                url: url,
                params: mappingContext.query.parameters,
                dataType: 'json',
                success: function (httpResponse) {
                    let data = httpResponse.data;
                    try {
                        let rData;
                        let results = data && (data.results || data.Results);
                        if (results) {
                            rData = { results: results, inlineCount: data.inlineCount || data.InlineCount,
                                httpResponse: httpResponse, query: mappingContext.query };
                        }
                        else {
                            rData = { results: data, httpResponse: httpResponse, query: mappingContext.query };
                        }
                        resolve(rData);
                    }
                    catch (e) {
                        if (e instanceof Error) {
                            reject(e);
                        }
                        else {
                            handleHttpError(reject, httpResponse);
                        }
                    }
                },
                error: function (httpResponse) {
                    handleHttpError(reject, httpResponse);
                },
                crossDomain: false
            };
            if (mappingContext.dataService.useJsonp) {
                params.dataType = 'jsonp';
                params.crossDomain = true;
            }
            this.ajaxImpl.ajax(params);
        });
        return promise;
    }
    saveChanges(saveContext, saveBundle) {
        let adapter = saveContext.adapter = this;
        let saveBundleSer = adapter._prepareSaveBundle(saveContext, saveBundle);
        let bundle = JSON.stringify(saveBundleSer);
        let url = saveContext.dataService.qualifyUrl(saveContext.resourceName);
        let promise = new Promise((resolve, reject) => {
            this.ajaxImpl.ajax({
                type: "POST",
                url: url,
                dataType: 'json',
                contentType: "application/json",
                data: bundle,
                success: function (httpResponse) {
                    httpResponse.saveContext = saveContext;
                    let data = httpResponse.data;
                    if (data.Errors || data.errors) {
                        handleHttpError(reject, httpResponse);
                    }
                    else {
                        let saveResult = adapter._prepareSaveResult(saveContext, data);
                        saveResult.httpResponse = httpResponse;
                        resolve(saveResult);
                    }
                },
                error: function (httpResponse) {
                    httpResponse.saveContext = saveContext;
                    handleHttpError(reject, httpResponse);
                }
            });
        });
        return promise;
    }
    /** Abstract method that needs to be overwritten in any concrete DataServiceAdapter subclass.
    The return value from this method should be a serializable object that will be sent to the server after calling JSON.stringify on it.
    */
    _prepareSaveBundle(saveContext, saveBundle) {
        // The implementor should call _createChangeRequestInterceptor
        throw new Error("Need a concrete implementation of _prepareSaveBundle");
    }
    /** @hidden @internal */
    _createChangeRequestInterceptor(saveContext, saveBundle) {
        let adapter = saveContext.adapter;
        let cri = adapter.changeRequestInterceptor;
        let isFn = core.isFunction;
        if (isFn(cri)) {
            let pre = adapter.name + " DataServiceAdapter's ChangeRequestInterceptor";
            let post = " is missing or not a function.";
            let interceptor = new cri(saveContext, saveBundle);
            if (!isFn(interceptor.getRequest)) {
                throw new Error(pre + '.getRequest' + post);
            }
            if (!isFn(interceptor.done)) {
                throw new Error(pre + '.done' + post);
            }
            return interceptor;
        }
        else {
            return new DefaultChangeRequestInterceptor(saveContext, saveBundle);
        }
    }
    /** Abstract method that needs to be overwritten in any concrete DataServiceAdapter sublclass.
    This method needs to take the result returned the server and convert it into an ISaveResult.
    */
    _prepareSaveResult(saveContext, data) {
        throw new Error("Need a concrete implementation of _prepareSaveResult");
    }
    /** Utility method that may be used in any concrete DataServiceAdapter sublclass to handle any
    http connection issues.
    */
    // Put this at the bottom of your http error analysis
    static _catchNoConnectionError(err) {
        if (err.status === 0 && err.message == null) {
            err.message = "HTTP response status 0 and no message.  " +
                "Likely did not or could not reach server. Is the server running?";
        }
    }
}
function handleHttpError(reject, httpResponse, messagePrefix) {
    let err = createError(httpResponse);
    AbstractDataServiceAdapter._catchNoConnectionError(err);
    if (messagePrefix) {
        err.message = messagePrefix + "; " + err.message;
    }
    reject(err);
}
function createError(httpResponse) {
    let err = new Error();
    err.httpResponse = httpResponse;
    err.status = httpResponse.status;
    let errObj = httpResponse.data;
    if (!errObj) {
        err.message = httpResponse.error && httpResponse.error.toString();
        return err;
    }
    // some ajax providers will convert errant result into an object (angularjs), others will not (jQuery)
    // if not do it here.
    if (typeof errObj === "string") {
        try {
            errObj = JSON.parse(errObj);
        }
        catch (e) {
            // sometimes httpResponse.data is just the error message itself
            err.message = errObj;
            return err;
        }
    }
    let saveContext = httpResponse.saveContext;
    // if any of the follow properties exist the source is .NET
    let tmp = errObj.Message || errObj.ExceptionMessage || errObj.EntityErrors || errObj.Errors;
    let isDotNet = !!tmp;
    let message, entityErrors;
    if (!isDotNet) {
        message = errObj.message;
        entityErrors = errObj.errors || errObj.entityErrors;
    }
    else {
        let tmp = errObj;
        do {
            // .NET exceptions can provide both ExceptionMessage and Message but ExceptionMethod if it
            // exists has a more detailed message.
            message = tmp.ExceptionMessage || tmp.Message;
            tmp = tmp.InnerException;
        } while (tmp);
        // .EntityErrors will only occur as a result of an EntityErrorsException being deliberately thrown on the server
        entityErrors = errObj.Errors || errObj.EntityErrors;
        entityErrors = entityErrors && entityErrors.map(function (e) {
            return {
                errorName: e.ErrorName,
                entityTypeName: MetadataStore.normalizeTypeName(e.EntityTypeName),
                keyValues: e.KeyValues,
                propertyName: e.PropertyName,
                errorMessage: e.ErrorMessage
            };
        });
    }
    if (saveContext && entityErrors) {
        let propNameFn = saveContext.entityManager.metadataStore.namingConvention.serverPropertyNameToClient;
        entityErrors.forEach(function (e) {
            e.propertyName = e.propertyName && propNameFn(e.propertyName);
        });
        err.entityErrors = entityErrors;
    }
    err.message = message || "Server side errors encountered - see the entityErrors collection on this object for more detail";
    return err;
}
/** This is a default, no-op implementation that developers can replace. */
class DefaultChangeRequestInterceptor {
    constructor(saveContext, saveBundle) {
    }
    getRequest(request, entity, index) {
        return request;
    }
    done(requests) {
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3QtZGF0YS1zZXJ2aWNlLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9icmVlemUtY2xpZW50LyIsInNvdXJjZXMiOlsic3JjL2Fic3RyYWN0LWRhdGEtc2VydmljZS1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDOUIsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUtsQyxPQUFPLEVBQWUsa0JBQWtCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVqRSxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFbEQ7OztFQUdFO0FBQ0YsTUFBTSxPQUFnQiwwQkFBMEI7SUFROUM7UUF3SkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7V0F5Qkc7UUFDSCw2QkFBd0IsR0FBaUMsK0JBQStCLENBQUM7UUEyQ3pGLHVCQUFrQixHQUFHLElBQUksa0JBQWtCLENBQUM7WUFDMUMsSUFBSSxFQUFFLE1BQU07WUFFWixTQUFTLEVBQUUsV0FBVSx1Q0FBdUM7Z0JBQzFELE9BQU8sRUFBRSxDQUFDO1lBQ1osQ0FBQztTQUNGLENBQUMsQ0FBQztJQWxPSCxDQUFDO0lBR0QscUJBQXFCO0lBQ3JCLHFCQUFxQixDQUFDLHdCQUE2QjtRQUNqRCxJQUFJLHdCQUF3QixDQUFDLGFBQWEsS0FBSyxNQUFNLElBQUksd0JBQXdCLENBQUMsU0FBUyxFQUFFO1lBQzNGLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUNuQjtJQUNILENBQUM7SUFFRCxVQUFVO1FBQ1IsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsa0JBQWtCLENBQWMsTUFBTSxDQUFHLENBQUM7UUFFakUsbUhBQW1IO1FBQ25ILElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtZQUN2QyxPQUFPO1NBQ1I7UUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLHVEQUF1RCxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUN0RyxDQUFDO0lBRUQsYUFBYSxDQUFDLGFBQTRCLEVBQUUsV0FBd0I7UUFDbEUsSUFBSSxXQUFXLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQztRQUMxQyxJQUFJLEdBQUcsR0FBRyxXQUFXLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTdDLElBQUksT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBRTVDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO2dCQUNqQixJQUFJLEVBQUUsS0FBSztnQkFDWCxHQUFHLEVBQUUsR0FBRztnQkFDUixRQUFRLEVBQUUsTUFBTTtnQkFDaEIsT0FBTyxFQUFFLENBQUMsWUFBMEIsRUFBRSxFQUFFO29CQUV0QywyQ0FBMkM7b0JBQzNDLElBQUksYUFBYSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsRUFBRTt3QkFDN0MsT0FBTyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztxQkFDbkM7b0JBQ0QsSUFBSSxJQUFJLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQztvQkFDN0IsSUFBSSxRQUFhLENBQUM7b0JBQ2xCLElBQUk7d0JBQ0YsUUFBUSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQzt3QkFDaEUsYUFBYSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztxQkFDeEM7b0JBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQ1YsSUFBSSxNQUFNLEdBQUcsNkNBQTZDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQzt3QkFDdkUsZUFBZSxDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUUsNkJBQTZCLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxNQUFNLENBQUMsQ0FBQztxQkFDNUY7b0JBRUQsMENBQTBDO29CQUMxQyxJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsRUFBRTt3QkFDOUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztxQkFDM0M7b0JBRUQsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUVwQixDQUFDO2dCQUNELEtBQUssRUFBRSxDQUFDLFlBQTBCLEVBQUUsRUFBRTtvQkFDcEMsZUFBZSxDQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUUsNkJBQTZCLEdBQUcsR0FBRyxDQUFDLENBQUM7Z0JBQzdFLENBQUM7YUFDRixDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxZQUFZLENBQUMsY0FBOEI7UUFDekMsY0FBYyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDOUIsSUFBSSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQWMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDekQsSUFBSSxHQUFHLEdBQUcsY0FBYyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBRWxDLElBQUksTUFBTSxHQUFHO2dCQUNYLElBQUksRUFBRSxLQUFLO2dCQUNYLEdBQUcsRUFBRSxHQUFHO2dCQUNSLE1BQU0sRUFBRyxjQUFjLENBQUMsS0FBcUIsQ0FBQyxVQUFVO2dCQUN4RCxRQUFRLEVBQUUsTUFBTTtnQkFDaEIsT0FBTyxFQUFFLFVBQVUsWUFBMEI7b0JBQzNDLElBQUksSUFBSSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUM7b0JBQzdCLElBQUk7d0JBQ0YsSUFBSSxLQUFrQixDQUFDO3dCQUN2QixJQUFJLE9BQU8sR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzt3QkFDckQsSUFBSSxPQUFPLEVBQUU7NEJBQ1gsS0FBSyxHQUFHLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsV0FBVztnQ0FDM0UsWUFBWSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDO3lCQUM3RDs2QkFBTTs0QkFDTCxLQUFLLEdBQUcsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLGNBQWMsQ0FBQyxLQUFLLEVBQUUsQ0FBQzt5QkFDcEY7d0JBRUQsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO3FCQUNoQjtvQkFBQyxPQUFPLENBQUMsRUFBRTt3QkFDVixJQUFJLENBQUMsWUFBWSxLQUFLLEVBQUU7NEJBQ3RCLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDWDs2QkFBTTs0QkFDTCxlQUFlLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO3lCQUN2QztxQkFDRjtnQkFFSCxDQUFDO2dCQUNELEtBQUssRUFBRSxVQUFVLFlBQTBCO29CQUN6QyxlQUFlLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO2dCQUN4QyxDQUFDO2dCQUNELFdBQVcsRUFBRSxLQUFLO2FBQ25CLENBQUM7WUFDRixJQUFJLGNBQWMsQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFO2dCQUN2QyxNQUFNLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztnQkFDMUIsTUFBTSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7YUFDM0I7WUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QixDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxXQUFXLENBQUMsV0FBd0IsRUFBRSxVQUFzQjtRQUMxRCxJQUFJLE9BQU8sR0FBRyxXQUFXLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUV6QyxJQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ3hFLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFM0MsSUFBSSxHQUFHLEdBQUcsV0FBVyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3ZFLElBQUksT0FBTyxHQUFHLElBQUksT0FBTyxDQUFhLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQ3hELElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO2dCQUNqQixJQUFJLEVBQUUsTUFBTTtnQkFDWixHQUFHLEVBQUUsR0FBRztnQkFDUixRQUFRLEVBQUUsTUFBTTtnQkFDaEIsV0FBVyxFQUFFLGtCQUFrQjtnQkFDL0IsSUFBSSxFQUFFLE1BQU07Z0JBQ1osT0FBTyxFQUFFLFVBQVUsWUFBMEI7b0JBQzNDLFlBQVksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO29CQUN2QyxJQUFJLElBQUksR0FBRyxZQUFZLENBQUMsSUFBSSxDQUFDO29CQUM3QixJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTt3QkFDOUIsZUFBZSxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQztxQkFDdkM7eUJBQU07d0JBQ0wsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQzt3QkFDL0QsVUFBVSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7d0JBQ3ZDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztxQkFDckI7Z0JBQ0gsQ0FBQztnQkFDRCxLQUFLLEVBQUUsVUFBVSxZQUEwQjtvQkFDekMsWUFBWSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7b0JBQ3ZDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7Z0JBQ3hDLENBQUM7YUFDRixDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7TUFFRTtJQUNGLGtCQUFrQixDQUFDLFdBQXdCLEVBQUUsVUFBc0I7UUFDakUsOERBQThEO1FBQzlELE1BQU0sSUFBSSxLQUFLLENBQUMsc0RBQXNELENBQUMsQ0FBQztJQUMxRSxDQUFDO0lBOEJELHdCQUF3QjtJQUN4QiwrQkFBK0IsQ0FBQyxXQUF3QixFQUFFLFVBQXNCO1FBQzlFLElBQUksT0FBTyxHQUFHLFdBQVcsQ0FBQyxPQUFRLENBQUM7UUFDbkMsSUFBSSxHQUFHLEdBQUcsT0FBTyxDQUFDLHdCQUF3QixDQUFDO1FBQzNDLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7UUFFM0IsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDYixJQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsSUFBSSxHQUFHLGdEQUFnRCxDQUFDO1lBQzFFLElBQUksSUFBSSxHQUFHLGdDQUFnQyxDQUFDO1lBQzVDLElBQUksV0FBVyxHQUFHLElBQUksR0FBRyxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLEdBQUcsYUFBYSxHQUFHLElBQUksQ0FBQyxDQUFDO2FBQzdDO1lBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQzthQUN2QztZQUNELE9BQU8sV0FBVyxDQUFDO1NBQ3BCO2FBQU07WUFDTCxPQUFPLElBQUksK0JBQStCLENBQUMsV0FBVyxFQUFFLFVBQVUsQ0FBNkIsQ0FBQztTQUNqRztJQUNILENBQUM7SUFFRDs7TUFFRTtJQUNGLGtCQUFrQixDQUFDLFdBQXdCLEVBQUUsSUFBUztRQUNwRCxNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7SUFDMUUsQ0FBQztJQUdEOztNQUVFO0lBQ0YscURBQXFEO0lBQ3JELE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxHQUFnQjtRQUM3QyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxPQUFPLElBQUksSUFBSSxFQUFFO1lBQzNDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsMENBQTBDO2dCQUN0RCxrRUFBa0UsQ0FBQztTQUN0RTtJQUNILENBQUM7Q0FTRjtBQUVELFNBQVMsZUFBZSxDQUFDLE1BQThCLEVBQUUsWUFBMEIsRUFBRSxhQUFzQjtJQUN6RyxJQUFJLEdBQUcsR0FBRyxXQUFXLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDcEMsMEJBQTBCLENBQUMsdUJBQXVCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDeEQsSUFBSSxhQUFhLEVBQUU7UUFDakIsR0FBRyxDQUFDLE9BQU8sR0FBRyxhQUFhLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUM7S0FDbEQ7SUFDRCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDZCxDQUFDO0FBRUQsU0FBUyxXQUFXLENBQUMsWUFBMEI7SUFDN0MsSUFBSSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQWlCLENBQUM7SUFDckMsR0FBRyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7SUFDaEMsR0FBRyxDQUFDLE1BQU0sR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBRWpDLElBQUksTUFBTSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFFL0IsSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUNYLEdBQUcsQ0FBQyxPQUFPLEdBQUcsWUFBWSxDQUFDLEtBQUssSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2xFLE9BQU8sR0FBRyxDQUFDO0tBQ1o7SUFFRCxzR0FBc0c7SUFDdEcscUJBQXFCO0lBQ3JCLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO1FBQzlCLElBQUk7WUFDRixNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUM3QjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsK0RBQStEO1lBQy9ELEdBQUcsQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1lBQ3JCLE9BQU8sR0FBRyxDQUFDO1NBQ1o7S0FDRjtJQUVELElBQUksV0FBVyxHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUM7SUFFM0MsMkRBQTJEO0lBQzNELElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxPQUFPLElBQUksTUFBTSxDQUFDLGdCQUFnQixJQUFJLE1BQU0sQ0FBQyxZQUFZLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUM1RixJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO0lBQ3JCLElBQUksT0FBZSxFQUFFLFlBQW1CLENBQUM7SUFDekMsSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUNiLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDO1FBQ3pCLFlBQVksR0FBRyxNQUFNLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUM7S0FDckQ7U0FBTTtRQUNMLElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQztRQUNqQixHQUFHO1lBQ0QsMEZBQTBGO1lBQzFGLHNDQUFzQztZQUN0QyxPQUFPLEdBQUcsR0FBRyxDQUFDLGdCQUFnQixJQUFJLEdBQUcsQ0FBQyxPQUFPLENBQUM7WUFDOUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxjQUFjLENBQUM7U0FDMUIsUUFBUSxHQUFHLEVBQUU7UUFDZCxnSEFBZ0g7UUFDaEgsWUFBWSxHQUFHLE1BQU0sQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLFlBQVksQ0FBQztRQUNwRCxZQUFZLEdBQUcsWUFBWSxJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDO1lBQ3pELE9BQU87Z0JBQ0wsU0FBUyxFQUFFLENBQUMsQ0FBQyxTQUFTO2dCQUN0QixjQUFjLEVBQUUsYUFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUM7Z0JBQ2pFLFNBQVMsRUFBRSxDQUFDLENBQUMsU0FBUztnQkFDdEIsWUFBWSxFQUFFLENBQUMsQ0FBQyxZQUFZO2dCQUM1QixZQUFZLEVBQUUsQ0FBQyxDQUFDLFlBQVk7YUFDN0IsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO0tBQ0o7SUFFRCxJQUFJLFdBQVcsSUFBSSxZQUFZLEVBQUU7UUFFL0IsSUFBSSxVQUFVLEdBQUcsV0FBVyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsMEJBQTBCLENBQUM7UUFDckcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7WUFDOUIsQ0FBQyxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUMsWUFBWSxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDaEUsQ0FBQyxDQUFDLENBQUM7UUFDRixHQUEyQixDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7S0FDMUQ7SUFFRCxHQUFHLENBQUMsT0FBTyxHQUFHLE9BQU8sSUFBSSxpR0FBaUcsQ0FBQztJQUMzSCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFHRCwyRUFBMkU7QUFDM0UsTUFBTSwrQkFBK0I7SUFDbkMsWUFBWSxXQUF3QixFQUFFLFVBQXNCO0lBRTVELENBQUM7SUFFRCxVQUFVLENBQUMsT0FBWSxFQUFFLE1BQWMsRUFBRSxLQUFhO1FBQ3BELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxJQUFJLENBQUMsUUFBa0I7SUFDdkIsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29yZSB9IGZyb20gJy4vY29yZSc7XHJcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgRW50aXR5UXVlcnkgfSBmcm9tICcuL2VudGl0eS1xdWVyeSc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlQWRhcHRlciwgQWpheEFkYXB0ZXIsIENoYW5nZVJlcXVlc3RJbnRlcmNlcHRvckN0b3IsIENoYW5nZVJlcXVlc3RJbnRlcmNlcHRvciB9IGZyb20gJy4vaW50ZXJmYWNlLXJlZ2lzdHJ5JztcclxuaW1wb3J0IHsgRW50aXR5IH0gZnJvbSAnLi9lbnRpdHktYXNwZWN0JztcclxuaW1wb3J0IHsgTWFwcGluZ0NvbnRleHQgfSBmcm9tICcuL21hcHBpbmctY29udGV4dCc7XHJcbmltcG9ydCB7IERhdGFTZXJ2aWNlLCBKc29uUmVzdWx0c0FkYXB0ZXIgfSBmcm9tICcuL2RhdGEtc2VydmljZSc7XHJcbmltcG9ydCB7IEh0dHBSZXNwb25zZSwgU2F2ZUNvbnRleHQsIFNhdmVCdW5kbGUsIFNlcnZlckVycm9yLCBTYXZlUmVzdWx0LCBTYXZlRXJyb3JGcm9tU2VydmVyLCBRdWVyeVJlc3VsdCB9IGZyb20gJy4vZW50aXR5LW1hbmFnZXInO1xyXG5pbXBvcnQgeyBNZXRhZGF0YVN0b3JlIH0gZnJvbSAnLi9lbnRpdHktbWV0YWRhdGEnO1xyXG5cclxuLyoqIEZvciB1c2UgYnkgYnJlZXplIHBsdWdpbiBhdXRob3JzIG9ubHkuICBUaGUgY2xhc3MgaXMgdXNlZCBhcyB0aGUgYmFzZSBjbGFzcyBmb3IgbW9zdCBbW0lEYXRhU2VydmljZUFkYXB0ZXJdXSBpbXBsZW1lbnRhdGlvbnNcclxuQGFkYXB0ZXIgKHNlZSBbW0lEYXRhU2VydmljZUFkYXB0ZXJdXSkgICAgXHJcbkBoaWRkZW5cclxuKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFic3RyYWN0RGF0YVNlcnZpY2VBZGFwdGVyIGltcGxlbWVudHMgRGF0YVNlcnZpY2VBZGFwdGVyIHtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfJGltcGw/OiBhbnk7XHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgYWRhcHRlci4gKi9cclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBbW0lBamF4QWRhcHRlcl1dIHVzZWQgYnkgdGhpcyBbW0lEYXRhU2VydmljZUFkYXB0ZXJdXS4gKi9cclxuICBhamF4SW1wbDogQWpheEFkYXB0ZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFRPRE8gdXNlIGludGVyZmFjZVxyXG4gIGNoZWNrRm9yUmVjb21wb3NpdGlvbihpbnRlcmZhY2VJbml0aWFsaXplZEFyZ3M6IGFueSkge1xyXG4gICAgaWYgKGludGVyZmFjZUluaXRpYWxpemVkQXJncy5pbnRlcmZhY2VOYW1lID09PSBcImFqYXhcIiAmJiBpbnRlcmZhY2VJbml0aWFsaXplZEFyZ3MuaXNEZWZhdWx0KSB7XHJcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaW5pdGlhbGl6ZSgpIHtcclxuICAgIHRoaXMuYWpheEltcGwgPSBjb25maWcuZ2V0QWRhcHRlckluc3RhbmNlPEFqYXhBZGFwdGVyPihcImFqYXhcIikgITtcclxuXHJcbiAgICAvLyBkb24ndCBjYWNoZSAnYWpheCcgYmVjYXVzZSB0aGVuIHdlIHdvdWxkIG5lZWQgdG8gXCIuYmluZFwiIGl0LCBhbmQgZG9uJ3Qgd2FudCB0byBiZWNhdXNlIG9mIGJyb3dlciBzdXBwb3J0IGlzc3Vlcy5cclxuICAgIGlmICh0aGlzLmFqYXhJbXBsICYmIHRoaXMuYWpheEltcGwuYWpheCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBhamF4IGFkYXB0ZXIgZm9yIGRhdGFzZXJ2aWNlIGFkYXB0ZXIgJ1wiICsgKHRoaXMubmFtZSB8fCAnJykgKyBcIicuXCIpO1xyXG4gIH1cclxuXHJcbiAgZmV0Y2hNZXRhZGF0YShtZXRhZGF0YVN0b3JlOiBNZXRhZGF0YVN0b3JlLCBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UpIHtcclxuICAgIGxldCBzZXJ2aWNlTmFtZSA9IGRhdGFTZXJ2aWNlLnNlcnZpY2VOYW1lO1xyXG4gICAgbGV0IHVybCA9IGRhdGFTZXJ2aWNlLnF1YWxpZnlVcmwoXCJNZXRhZGF0YVwiKTtcclxuXHJcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuXHJcbiAgICAgIHRoaXMuYWpheEltcGwuYWpheCh7XHJcbiAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgIHN1Y2Nlc3M6IChodHRwUmVzcG9uc2U6IEh0dHBSZXNwb25zZSkgPT4ge1xyXG5cclxuICAgICAgICAgIC8vIG1pZ2h0IGhhdmUgYmVlbiBmZXRjaGVkIGJ5IGFub3RoZXIgcXVlcnlcclxuICAgICAgICAgIGlmIChtZXRhZGF0YVN0b3JlLmhhc01ldGFkYXRhRm9yKHNlcnZpY2VOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShcImFscmVhZHkgZmV0Y2hlZFwiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxldCBkYXRhID0gaHR0cFJlc3BvbnNlLmRhdGE7XHJcbiAgICAgICAgICBsZXQgbWV0YWRhdGE6IGFueTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIG1ldGFkYXRhID0gdHlwZW9mIChkYXRhKSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UoZGF0YSkgOiBkYXRhO1xyXG4gICAgICAgICAgICBtZXRhZGF0YVN0b3JlLmltcG9ydE1ldGFkYXRhKG1ldGFkYXRhKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgbGV0IGVyck1zZyA9IFwiVW5hYmxlIHRvIGVpdGhlciBwYXJzZSBvciBpbXBvcnQgbWV0YWRhdGE6IFwiICsgZS5tZXNzYWdlO1xyXG4gICAgICAgICAgICBoYW5kbGVIdHRwRXJyb3IocmVqZWN0LCBodHRwUmVzcG9uc2UsIFwiTWV0YWRhdGEgcXVlcnkgZmFpbGVkIGZvcjogXCIgKyB1cmwgKyBcIi4gXCIgKyBlcnJNc2cpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIGltcG9ydCBtYXkgaGF2ZSBicm91Z2h0IGluIHRoZSBzZXJ2aWNlLlxyXG4gICAgICAgICAgaWYgKCFtZXRhZGF0YVN0b3JlLmhhc01ldGFkYXRhRm9yKHNlcnZpY2VOYW1lKSkge1xyXG4gICAgICAgICAgICBtZXRhZGF0YVN0b3JlLmFkZERhdGFTZXJ2aWNlKGRhdGFTZXJ2aWNlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXNvbHZlKG1ldGFkYXRhKTtcclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcjogKGh0dHBSZXNwb25zZTogSHR0cFJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICBoYW5kbGVIdHRwRXJyb3IocmVqZWN0LCBodHRwUmVzcG9uc2UsIFwiTWV0YWRhdGEgcXVlcnkgZmFpbGVkIGZvcjogXCIgKyB1cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBwcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgZXhlY3V0ZVF1ZXJ5KG1hcHBpbmdDb250ZXh0OiBNYXBwaW5nQ29udGV4dCkge1xyXG4gICAgbWFwcGluZ0NvbnRleHQuYWRhcHRlciA9IHRoaXM7XHJcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFF1ZXJ5UmVzdWx0PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGxldCB1cmwgPSBtYXBwaW5nQ29udGV4dC5nZXRVcmwoKTtcclxuXHJcbiAgICAgIGxldCBwYXJhbXMgPSB7XHJcbiAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICBwYXJhbXM6IChtYXBwaW5nQ29udGV4dC5xdWVyeSBhcyBFbnRpdHlRdWVyeSkucGFyYW1ldGVycyxcclxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChodHRwUmVzcG9uc2U6IEh0dHBSZXNwb25zZSkge1xyXG4gICAgICAgICAgbGV0IGRhdGEgPSBodHRwUmVzcG9uc2UuZGF0YTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCByRGF0YTogUXVlcnlSZXN1bHQ7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHRzID0gZGF0YSAmJiAoZGF0YS5yZXN1bHRzIHx8IGRhdGEuUmVzdWx0cyk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRzKSB7XHJcbiAgICAgICAgICAgICAgckRhdGEgPSB7IHJlc3VsdHM6IHJlc3VsdHMsIGlubGluZUNvdW50OiBkYXRhLmlubGluZUNvdW50IHx8IGRhdGEuSW5saW5lQ291bnQsIFxyXG4gICAgICAgICAgICAgICAgaHR0cFJlc3BvbnNlOiBodHRwUmVzcG9uc2UsIHF1ZXJ5OiBtYXBwaW5nQ29udGV4dC5xdWVyeSB9O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJEYXRhID0geyByZXN1bHRzOiBkYXRhLCBodHRwUmVzcG9uc2U6IGh0dHBSZXNwb25zZSwgcXVlcnk6IG1hcHBpbmdDb250ZXh0LnF1ZXJ5IH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc29sdmUockRhdGEpO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGhhbmRsZUh0dHBFcnJvcihyZWplY3QsIGh0dHBSZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGh0dHBSZXNwb25zZTogSHR0cFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICBoYW5kbGVIdHRwRXJyb3IocmVqZWN0LCBodHRwUmVzcG9uc2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3Jvc3NEb21haW46IGZhbHNlXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChtYXBwaW5nQ29udGV4dC5kYXRhU2VydmljZS51c2VKc29ucCkge1xyXG4gICAgICAgIHBhcmFtcy5kYXRhVHlwZSA9ICdqc29ucCc7XHJcbiAgICAgICAgcGFyYW1zLmNyb3NzRG9tYWluID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFqYXhJbXBsLmFqYXgocGFyYW1zKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHByb21pc2U7XHJcbiAgfVxyXG5cclxuICBzYXZlQ2hhbmdlcyhzYXZlQ29udGV4dDogU2F2ZUNvbnRleHQsIHNhdmVCdW5kbGU6IFNhdmVCdW5kbGUpIHtcclxuICAgIGxldCBhZGFwdGVyID0gc2F2ZUNvbnRleHQuYWRhcHRlciA9IHRoaXM7XHJcblxyXG4gICAgbGV0IHNhdmVCdW5kbGVTZXIgPSBhZGFwdGVyLl9wcmVwYXJlU2F2ZUJ1bmRsZShzYXZlQ29udGV4dCwgc2F2ZUJ1bmRsZSk7XHJcbiAgICBsZXQgYnVuZGxlID0gSlNPTi5zdHJpbmdpZnkoc2F2ZUJ1bmRsZVNlcik7XHJcblxyXG4gICAgbGV0IHVybCA9IHNhdmVDb250ZXh0LmRhdGFTZXJ2aWNlLnF1YWxpZnlVcmwoc2F2ZUNvbnRleHQucmVzb3VyY2VOYW1lKTtcclxuICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2U8U2F2ZVJlc3VsdD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0aGlzLmFqYXhJbXBsLmFqYXgoe1xyXG4gICAgICAgIHR5cGU6IFwiUE9TVFwiLFxyXG4gICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxyXG4gICAgICAgIGRhdGE6IGJ1bmRsZSxcclxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoaHR0cFJlc3BvbnNlOiBIdHRwUmVzcG9uc2UpIHtcclxuICAgICAgICAgIGh0dHBSZXNwb25zZS5zYXZlQ29udGV4dCA9IHNhdmVDb250ZXh0O1xyXG4gICAgICAgICAgbGV0IGRhdGEgPSBodHRwUmVzcG9uc2UuZGF0YTtcclxuICAgICAgICAgIGlmIChkYXRhLkVycm9ycyB8fCBkYXRhLmVycm9ycykge1xyXG4gICAgICAgICAgICBoYW5kbGVIdHRwRXJyb3IocmVqZWN0LCBodHRwUmVzcG9uc2UpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHNhdmVSZXN1bHQgPSBhZGFwdGVyLl9wcmVwYXJlU2F2ZVJlc3VsdChzYXZlQ29udGV4dCwgZGF0YSk7XHJcbiAgICAgICAgICAgIHNhdmVSZXN1bHQuaHR0cFJlc3BvbnNlID0gaHR0cFJlc3BvbnNlO1xyXG4gICAgICAgICAgICByZXNvbHZlKHNhdmVSZXN1bHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChodHRwUmVzcG9uc2U6IEh0dHBSZXNwb25zZSkge1xyXG4gICAgICAgICAgaHR0cFJlc3BvbnNlLnNhdmVDb250ZXh0ID0gc2F2ZUNvbnRleHQ7XHJcbiAgICAgICAgICBoYW5kbGVIdHRwRXJyb3IocmVqZWN0LCBodHRwUmVzcG9uc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcHJvbWlzZTtcclxuICB9XHJcblxyXG4gIC8qKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBuZWVkcyB0byBiZSBvdmVyd3JpdHRlbiBpbiBhbnkgY29uY3JldGUgRGF0YVNlcnZpY2VBZGFwdGVyIHN1YmNsYXNzLiBcclxuICBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGEgc2VyaWFsaXphYmxlIG9iamVjdCB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc2VydmVyIGFmdGVyIGNhbGxpbmcgSlNPTi5zdHJpbmdpZnkgb24gaXQuXHJcbiAgKi9cclxuICBfcHJlcGFyZVNhdmVCdW5kbGUoc2F2ZUNvbnRleHQ6IFNhdmVDb250ZXh0LCBzYXZlQnVuZGxlOiBTYXZlQnVuZGxlKTogYW55IHtcclxuICAgIC8vIFRoZSBpbXBsZW1lbnRvciBzaG91bGQgY2FsbCBfY3JlYXRlQ2hhbmdlUmVxdWVzdEludGVyY2VwdG9yXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZWVkIGEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgX3ByZXBhcmVTYXZlQnVuZGxlXCIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBhIFwiQ2hhbmdlUmVxdWVzdEludGVyY2VwdG9yXCJcclxuICB0aGF0IGNhbiB0d2VhayB0aGUgc2F2ZUJ1bmRsZSBib3RoIGFzIGl0IGlzIGJ1aWx0IGFuZCB3aGVuIGl0IGlzIGNvbXBsZXRlZFxyXG4gIGJ5IGEgY29uY3JldGUgRGF0YVNlcnZpY2VBZGFwYXRlci5cclxuXHJcbiAgSW5pdGlhbGl6ZWQgd2l0aCBhIGRlZmF1bHQsIG5vLW9wIGltcGxlbWVudGF0aW9uIHRoYXQgZGV2ZWxvcGVycyBjYW4gcmVwbGFjZSB3aXRoIGFcclxuICBzdWJzdGFudGl2ZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGNoYW5nZXMgdGhlIGluZGl2aWR1YWwgZW50aXR5IGNoYW5nZSByZXF1ZXN0c1xyXG4gIG9yIGFzcGVjdHMgb2YgdGhlIGVudGlyZSAnc2F2ZUJ1bmRsZScgd2l0aG91dCBoYXZpbmcgdG8gd3JpdGUgdGhlaXIgb3duIERhdGFTZXJ2aWNlIGFkYXB0ZXJzLlxyXG4gID4gICAgIGxldCBhZGFwdGVyID0gYnJlZXplLmNvbmZpZy5nZXRBZGFwdGVySW5zdGFuY2UoJ2RhdGFTZXJ2aWNlJyk7XHJcbiAgPiAgICAgYWRhcHRlci5jaGFuZ2VSZXF1ZXN0SW50ZXJjZXB0b3IgPSBmdW5jdGlvbiAoc2F2ZUNvbnRleHQsIHNhdmVCdW5kbGUpIHtcclxuICA+ICAgICAgICAgdGhpcy5nZXRSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QsIGVudGl0eSwgaW5kZXgpIHtcclxuICA+ICAgICAgICAgICAgLy8gYWx0ZXIgdGhlIHJlcXVlc3QgdGhhdCB0aGUgYWRhcHRlciBwcmVwYXJlZCBmb3IgdGhpcyBlbnRpdHlcclxuICA+ICAgICAgICAgICAgLy8gYmFzZWQgb24gdGhlIGVudGl0eSwgc2F2ZUNvbnRleHQsIGFuZCBzYXZlQnVuZGxlXHJcbiAgPiAgICAgICAgICAgIC8vIGUuZy4sIGFkZCBhIGN1c3RvbSBoZWFkZXIgb3IgcHJ1bmUgdGhlIG9yaWdpbmFsVmFsdWVzTWFwXHJcbiAgPiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG4gID4gICAgICAgIH07XHJcbiAgPiAgICAgICAgdGhpcy5kb25lID0gZnVuY3Rpb24gKHJlcXVlc3RzKSB7XHJcbiAgPiAgICAgICAgICAgIC8vIGFsdGVyIHRoZSBhcnJheSBvZiByZXF1ZXN0cyByZXByZXNlbnRpbmcgdGhlIGVudGlyZSBjaGFuZ2Utc2V0XHJcbiAgPiAgICAgICAgICAgIC8vIGJhc2VkIG9uIHRoZSBzYXZlQ29udGV4dCBhbmQgc2F2ZUJ1bmRsZVxyXG4gID4gICAgICAgIH07XHJcbiAgPiAgICAgfVxyXG5cclxuICBAcGFyYW0gc2F2ZUNvbnRleHQgLSBUaGUgQnJlZXplSlMgXCJjb250ZXh0XCIgZm9yIHRoZSBzYXZlIG9wZXJhdGlvbi5cclxuICBAcGFyYW0gc2F2ZUJ1bmRsZSAtIENvbnRhaW5zIHRoZSBhcnJheSBvZiBlbnRpdGllcy10by1iZS1zYXZlZCAoQUtBLCB0aGUgZW50aXR5IGNoYW5nZS1zZXQpLlxyXG4gIEByZXR1cm4gQ29uc3RydWN0b3IgZm9yIGEgXCJDaGFuZ2VSZXF1ZXN0SW50ZXJjZXB0b3JcIi5cclxuICAqKi9cclxuICBjaGFuZ2VSZXF1ZXN0SW50ZXJjZXB0b3I6IENoYW5nZVJlcXVlc3RJbnRlcmNlcHRvckN0b3IgPSBEZWZhdWx0Q2hhbmdlUmVxdWVzdEludGVyY2VwdG9yO1xyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfY3JlYXRlQ2hhbmdlUmVxdWVzdEludGVyY2VwdG9yKHNhdmVDb250ZXh0OiBTYXZlQ29udGV4dCwgc2F2ZUJ1bmRsZTogU2F2ZUJ1bmRsZSkge1xyXG4gICAgbGV0IGFkYXB0ZXIgPSBzYXZlQ29udGV4dC5hZGFwdGVyITtcclxuICAgIGxldCBjcmkgPSBhZGFwdGVyLmNoYW5nZVJlcXVlc3RJbnRlcmNlcHRvcjtcclxuICAgIGxldCBpc0ZuID0gY29yZS5pc0Z1bmN0aW9uO1xyXG5cclxuICAgIGlmIChpc0ZuKGNyaSkpIHtcclxuICAgICAgbGV0IHByZSA9IGFkYXB0ZXIubmFtZSArIFwiIERhdGFTZXJ2aWNlQWRhcHRlcidzIENoYW5nZVJlcXVlc3RJbnRlcmNlcHRvclwiO1xyXG4gICAgICBsZXQgcG9zdCA9IFwiIGlzIG1pc3Npbmcgb3Igbm90IGEgZnVuY3Rpb24uXCI7XHJcbiAgICAgIGxldCBpbnRlcmNlcHRvciA9IG5ldyBjcmkoc2F2ZUNvbnRleHQsIHNhdmVCdW5kbGUpO1xyXG4gICAgICBpZiAoIWlzRm4oaW50ZXJjZXB0b3IuZ2V0UmVxdWVzdCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlICsgJy5nZXRSZXF1ZXN0JyArIHBvc3QpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaXNGbihpbnRlcmNlcHRvci5kb25lKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmUgKyAnLmRvbmUnICsgcG9zdCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGludGVyY2VwdG9yO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0Q2hhbmdlUmVxdWVzdEludGVyY2VwdG9yKHNhdmVDb250ZXh0LCBzYXZlQnVuZGxlKSBhcyBDaGFuZ2VSZXF1ZXN0SW50ZXJjZXB0b3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogQWJzdHJhY3QgbWV0aG9kIHRoYXQgbmVlZHMgdG8gYmUgb3ZlcndyaXR0ZW4gaW4gYW55IGNvbmNyZXRlIERhdGFTZXJ2aWNlQWRhcHRlciBzdWJsY2xhc3MuIFxyXG4gIFRoaXMgbWV0aG9kIG5lZWRzIHRvIHRha2UgdGhlIHJlc3VsdCByZXR1cm5lZCB0aGUgc2VydmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYW4gSVNhdmVSZXN1bHQuIFxyXG4gICovXHJcbiAgX3ByZXBhcmVTYXZlUmVzdWx0KHNhdmVDb250ZXh0OiBTYXZlQ29udGV4dCwgZGF0YTogYW55KTogU2F2ZVJlc3VsdCB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZWVkIGEgY29uY3JldGUgaW1wbGVtZW50YXRpb24gb2YgX3ByZXBhcmVTYXZlUmVzdWx0XCIpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKiBVdGlsaXR5IG1ldGhvZCB0aGF0IG1heSBiZSB1c2VkIGluIGFueSBjb25jcmV0ZSBEYXRhU2VydmljZUFkYXB0ZXIgc3VibGNsYXNzIHRvIGhhbmRsZSBhbnkgXHJcbiAgaHR0cCBjb25uZWN0aW9uIGlzc3Vlcy4gXHJcbiAgKi9cclxuICAvLyBQdXQgdGhpcyBhdCB0aGUgYm90dG9tIG9mIHlvdXIgaHR0cCBlcnJvciBhbmFseXNpc1xyXG4gIHN0YXRpYyBfY2F0Y2hOb0Nvbm5lY3Rpb25FcnJvcihlcnI6IFNlcnZlckVycm9yKSB7XHJcbiAgICBpZiAoZXJyLnN0YXR1cyA9PT0gMCAmJiBlcnIubWVzc2FnZSA9PSBudWxsKSB7XHJcbiAgICAgIGVyci5tZXNzYWdlID0gXCJIVFRQIHJlc3BvbnNlIHN0YXR1cyAwIGFuZCBubyBtZXNzYWdlLiAgXCIgK1xyXG4gICAgICAgIFwiTGlrZWx5IGRpZCBub3Qgb3IgY291bGQgbm90IHJlYWNoIHNlcnZlci4gSXMgdGhlIHNlcnZlciBydW5uaW5nP1wiO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAganNvblJlc3VsdHNBZGFwdGVyID0gbmV3IEpzb25SZXN1bHRzQWRhcHRlcih7XHJcbiAgICBuYW1lOiBcIm5vb3BcIixcclxuXHJcbiAgICB2aXNpdE5vZGU6IGZ1bmN0aW9uICgvKiBub2RlLCBtYXBwaW5nQ29udGV4dCwgbm9kZUNvbnRleHQgKi8pIHtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVIdHRwRXJyb3IocmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkLCBodHRwUmVzcG9uc2U6IEh0dHBSZXNwb25zZSwgbWVzc2FnZVByZWZpeD86IHN0cmluZykge1xyXG4gIGxldCBlcnIgPSBjcmVhdGVFcnJvcihodHRwUmVzcG9uc2UpO1xyXG4gIEFic3RyYWN0RGF0YVNlcnZpY2VBZGFwdGVyLl9jYXRjaE5vQ29ubmVjdGlvbkVycm9yKGVycik7XHJcbiAgaWYgKG1lc3NhZ2VQcmVmaXgpIHtcclxuICAgIGVyci5tZXNzYWdlID0gbWVzc2FnZVByZWZpeCArIFwiOyBcIiArIGVyci5tZXNzYWdlO1xyXG4gIH1cclxuICByZWplY3QoZXJyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRXJyb3IoaHR0cFJlc3BvbnNlOiBIdHRwUmVzcG9uc2UpIHtcclxuICBsZXQgZXJyID0gbmV3IEVycm9yKCkgYXMgU2VydmVyRXJyb3I7XHJcbiAgZXJyLmh0dHBSZXNwb25zZSA9IGh0dHBSZXNwb25zZTtcclxuICBlcnIuc3RhdHVzID0gaHR0cFJlc3BvbnNlLnN0YXR1cztcclxuXHJcbiAgbGV0IGVyck9iaiA9IGh0dHBSZXNwb25zZS5kYXRhO1xyXG5cclxuICBpZiAoIWVyck9iaikge1xyXG4gICAgZXJyLm1lc3NhZ2UgPSBodHRwUmVzcG9uc2UuZXJyb3IgJiYgaHR0cFJlc3BvbnNlLmVycm9yLnRvU3RyaW5nKCk7XHJcbiAgICByZXR1cm4gZXJyO1xyXG4gIH1cclxuXHJcbiAgLy8gc29tZSBhamF4IHByb3ZpZGVycyB3aWxsIGNvbnZlcnQgZXJyYW50IHJlc3VsdCBpbnRvIGFuIG9iamVjdCAoYW5ndWxhcmpzKSwgb3RoZXJzIHdpbGwgbm90IChqUXVlcnkpXHJcbiAgLy8gaWYgbm90IGRvIGl0IGhlcmUuXHJcbiAgaWYgKHR5cGVvZiBlcnJPYmogPT09IFwic3RyaW5nXCIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGVyck9iaiA9IEpTT04ucGFyc2UoZXJyT2JqKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gc29tZXRpbWVzIGh0dHBSZXNwb25zZS5kYXRhIGlzIGp1c3QgdGhlIGVycm9yIG1lc3NhZ2UgaXRzZWxmXHJcbiAgICAgIGVyci5tZXNzYWdlID0gZXJyT2JqO1xyXG4gICAgICByZXR1cm4gZXJyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbGV0IHNhdmVDb250ZXh0ID0gaHR0cFJlc3BvbnNlLnNhdmVDb250ZXh0O1xyXG5cclxuICAvLyBpZiBhbnkgb2YgdGhlIGZvbGxvdyBwcm9wZXJ0aWVzIGV4aXN0IHRoZSBzb3VyY2UgaXMgLk5FVFxyXG4gIGxldCB0bXAgPSBlcnJPYmouTWVzc2FnZSB8fCBlcnJPYmouRXhjZXB0aW9uTWVzc2FnZSB8fCBlcnJPYmouRW50aXR5RXJyb3JzIHx8IGVyck9iai5FcnJvcnM7XHJcbiAgbGV0IGlzRG90TmV0ID0gISF0bXA7XHJcbiAgbGV0IG1lc3NhZ2U6IHN0cmluZywgZW50aXR5RXJyb3JzOiBhbnlbXTtcclxuICBpZiAoIWlzRG90TmV0KSB7XHJcbiAgICBtZXNzYWdlID0gZXJyT2JqLm1lc3NhZ2U7XHJcbiAgICBlbnRpdHlFcnJvcnMgPSBlcnJPYmouZXJyb3JzIHx8IGVyck9iai5lbnRpdHlFcnJvcnM7XHJcbiAgfSBlbHNlIHtcclxuICAgIGxldCB0bXAgPSBlcnJPYmo7XHJcbiAgICBkbyB7XHJcbiAgICAgIC8vIC5ORVQgZXhjZXB0aW9ucyBjYW4gcHJvdmlkZSBib3RoIEV4Y2VwdGlvbk1lc3NhZ2UgYW5kIE1lc3NhZ2UgYnV0IEV4Y2VwdGlvbk1ldGhvZCBpZiBpdFxyXG4gICAgICAvLyBleGlzdHMgaGFzIGEgbW9yZSBkZXRhaWxlZCBtZXNzYWdlLlxyXG4gICAgICBtZXNzYWdlID0gdG1wLkV4Y2VwdGlvbk1lc3NhZ2UgfHwgdG1wLk1lc3NhZ2U7XHJcbiAgICAgIHRtcCA9IHRtcC5Jbm5lckV4Y2VwdGlvbjtcclxuICAgIH0gd2hpbGUgKHRtcCk7XHJcbiAgICAvLyAuRW50aXR5RXJyb3JzIHdpbGwgb25seSBvY2N1ciBhcyBhIHJlc3VsdCBvZiBhbiBFbnRpdHlFcnJvcnNFeGNlcHRpb24gYmVpbmcgZGVsaWJlcmF0ZWx5IHRocm93biBvbiB0aGUgc2VydmVyXHJcbiAgICBlbnRpdHlFcnJvcnMgPSBlcnJPYmouRXJyb3JzIHx8IGVyck9iai5FbnRpdHlFcnJvcnM7XHJcbiAgICBlbnRpdHlFcnJvcnMgPSBlbnRpdHlFcnJvcnMgJiYgZW50aXR5RXJyb3JzLm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGVycm9yTmFtZTogZS5FcnJvck5hbWUsXHJcbiAgICAgICAgZW50aXR5VHlwZU5hbWU6IE1ldGFkYXRhU3RvcmUubm9ybWFsaXplVHlwZU5hbWUoZS5FbnRpdHlUeXBlTmFtZSksXHJcbiAgICAgICAga2V5VmFsdWVzOiBlLktleVZhbHVlcyxcclxuICAgICAgICBwcm9wZXJ0eU5hbWU6IGUuUHJvcGVydHlOYW1lLFxyXG4gICAgICAgIGVycm9yTWVzc2FnZTogZS5FcnJvck1lc3NhZ2VcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKHNhdmVDb250ZXh0ICYmIGVudGl0eUVycm9ycykge1xyXG5cclxuICAgIGxldCBwcm9wTmFtZUZuID0gc2F2ZUNvbnRleHQuZW50aXR5TWFuYWdlci5tZXRhZGF0YVN0b3JlLm5hbWluZ0NvbnZlbnRpb24uc2VydmVyUHJvcGVydHlOYW1lVG9DbGllbnQ7XHJcbiAgICBlbnRpdHlFcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICBlLnByb3BlcnR5TmFtZSA9IGUucHJvcGVydHlOYW1lICYmIHByb3BOYW1lRm4oZS5wcm9wZXJ0eU5hbWUpO1xyXG4gICAgfSk7XHJcbiAgICAoZXJyIGFzIFNhdmVFcnJvckZyb21TZXJ2ZXIpLmVudGl0eUVycm9ycyA9IGVudGl0eUVycm9ycztcclxuICB9XHJcblxyXG4gIGVyci5tZXNzYWdlID0gbWVzc2FnZSB8fCBcIlNlcnZlciBzaWRlIGVycm9ycyBlbmNvdW50ZXJlZCAtIHNlZSB0aGUgZW50aXR5RXJyb3JzIGNvbGxlY3Rpb24gb24gdGhpcyBvYmplY3QgZm9yIG1vcmUgZGV0YWlsXCI7XHJcbiAgcmV0dXJuIGVycjtcclxufVxyXG5cclxuXHJcbi8qKiBUaGlzIGlzIGEgZGVmYXVsdCwgbm8tb3AgaW1wbGVtZW50YXRpb24gdGhhdCBkZXZlbG9wZXJzIGNhbiByZXBsYWNlLiAqL1xyXG5jbGFzcyBEZWZhdWx0Q2hhbmdlUmVxdWVzdEludGVyY2VwdG9yIHtcclxuICBjb25zdHJ1Y3RvcihzYXZlQ29udGV4dDogU2F2ZUNvbnRleHQsIHNhdmVCdW5kbGU6IFNhdmVCdW5kbGUpIHtcclxuXHJcbiAgfVxyXG5cclxuICBnZXRSZXF1ZXN0KHJlcXVlc3Q6IGFueSwgZW50aXR5OiBFbnRpdHksIGluZGV4OiBudW1iZXIpIHtcclxuICAgIHJldHVybiByZXF1ZXN0O1xyXG4gIH1cclxuXHJcbiAgZG9uZShyZXF1ZXN0czogT2JqZWN0W10pIHtcclxuICB9XHJcbn1cclxuIl19