/** See if this comment will make it into .d.ts */
import { BreezeEnum } from './enum';
let hasOwnProperty = uncurry(Object.prototype.hasOwnProperty);
let arraySlice = uncurry(Array.prototype.slice);
const ɵ0 = function () {
    try {
        return !!(Object.getPrototypeOf && Object.defineProperty({}, 'x', {}));
    }
    catch (e) {
        return false;
    }
};
let isES5Supported = ɵ0();
// iterate over object
function objectForEach(obj, kvFn) {
    for (let key in obj) {
        if (hasOwnProperty(obj, key)) {
            kvFn(key, obj[key]);
        }
    }
}
function objectMap(obj, kvFn) {
    let results = [];
    for (let key in obj) {
        if (hasOwnProperty(obj, key)) {
            let result = kvFn ? kvFn(key, obj[key]) : obj[key];
            if (result !== undefined) {
                results.push(result);
            }
        }
    }
    return results;
}
function objectFirst(obj, kvPredicate) {
    for (let key in obj) {
        if (hasOwnProperty(obj, key)) {
            let value = obj[key];
            if (kvPredicate(key, value)) {
                return { key: key, value: value };
            }
        }
    }
    return null;
}
function arrayFlatMap(arr, mapFn) {
    return Array.prototype.concat.apply([], arr.map(mapFn));
}
function isSettable(obj, propertyName) {
    let pd = getPropDescriptor(obj, propertyName);
    if (pd == null)
        return true;
    return !!(pd.writable || pd.set);
}
function getPropDescriptor(obj, propertyName) {
    if (!isES5Supported)
        return undefined;
    if (obj.hasOwnProperty(propertyName)) {
        return Object.getOwnPropertyDescriptor(obj, propertyName);
    }
    else {
        let nextObj = Object.getPrototypeOf(obj);
        if (nextObj == null)
            return undefined;
        return getPropDescriptor(nextObj, propertyName);
    }
}
// Functional extensions
/** can be used like: persons.filter(propEq("firstName", "John")) */
function propEq(propertyName, value) {
    return function (obj) {
        return obj[propertyName] === value;
    };
}
/** can be used like: persons.filter(propEq("firstName", "FirstName", "John")) */
function propsEq(property1Name, property2Name, value) {
    return function (obj) {
        return obj[property1Name] === value || obj[property2Name] === value;
    };
}
/** can be used like persons.map(pluck("firstName")) */
function pluck(propertyName) {
    return function (obj) {
        return obj[propertyName];
    };
}
// end functional extensions
/** Return an array of property values from source */
function getOwnPropertyValues(source) {
    let result = [];
    for (let name in source) {
        if (hasOwnProperty(source, name)) {
            result.push(source[name]);
        }
    }
    return result;
}
/** Copy properties from source to target. Returns target. */
function extend(target, source, propNames) {
    if (!source)
        return target;
    if (propNames) {
        propNames.forEach(function (propName) {
            target[propName] = source[propName];
        });
    }
    else {
        for (let propName in source) {
            if (hasOwnProperty(source, propName)) {
                target[propName] = source[propName];
            }
        }
    }
    return target;
}
/** Copy properties from defaults iff undefined on target.  Returns target. */
function updateWithDefaults(target, defaults) {
    for (let name in defaults) {
        if (target[name] === undefined) {
            target[name] = defaults[name];
        }
    }
    return target;
}
/** Set ctor.defaultInstance to an instance of ctor with properties from target.
    We want to insure that the object returned by ctor.defaultInstance is always immutable
    Use 'target' as the primary template for the ctor.defaultInstance;
    Use current 'ctor.defaultInstance' as the template for any missing properties
    creates a new instance for ctor.defaultInstance
    returns target unchanged */
function setAsDefault(target, ctor) {
    ctor.defaultInstance = updateWithDefaults(new ctor(target), ctor.defaultInstance);
    return target;
}
/**
    'source' is an object that will be transformed into another
    'template' is a map where the
       keys: are the keys to return
         if a key contains ','s then the key is treated as a delimited string with first of the
         keys being the key to return and the others all valid aliases for this key
       'values' are either
           1) the 'default' value of the key
           2) a function that takes in the source value and should return the value to set
         The value from the source is then set on the target,
         after first passing thru the fn, if provided, UNLESS:
           1) it is the default value
           2) it is undefined ( nulls WILL be set)
    'target' is optional
       - if it exists then properties of the target will be set ( overwritten if the exist)
       - if it does not exist then a new object will be created as filled.
    'target is returned.
*/
function toJson(source, template, target = {}) {
    for (let key in template) {
        let aliases = key.split(",");
        let defaultValue = template[key];
        // using some as a forEach with a 'break'
        aliases.some(function (propName) {
            if (!(propName in source))
                return false;
            let value = source[propName];
            // there is a functional property defined with this alias ( not what we want to replace).
            if (typeof value === 'function')
                return false;
            // '==' is deliberate here - idea is that null or undefined values will never get serialized
            // if default value is set to null.
            // tslint:disable-next-line
            if (value == defaultValue)
                return true;
            if (Array.isArray(value) && value.length === 0)
                return true;
            if (typeof (defaultValue) === "function") {
                value = defaultValue(value);
            }
            else if (typeof (value) === "object") {
                if (value && value instanceof BreezeEnum) {
                    value = value.name;
                }
            }
            if (value === undefined)
                return true;
            target[aliases[0]] = value;
            return true;
        });
    }
    return target;
}
/** Replacer function for toJSONSafe, when serializing entities.  Excludes entityAspect and other internal properties. */
function toJSONSafeReplacer(prop, val) {
    if (prop === "entityAspect" || prop === "complexAspect" || prop === "entityType" || prop === "complexType"
        || prop === "getProperty" || prop === "setProperty"
        || prop === "constructor" || prop.charAt(0) === '_' || prop.charAt(0) === '$')
        return;
    return val;
}
/** Safely perform toJSON logic on objects with cycles. */
function toJSONSafe(obj, replacer) {
    if (obj !== Object(obj))
        return obj; // primitive value
    if (obj._$visited)
        return undefined;
    if (obj.toJSON) {
        let newObj = obj.toJSON();
        if (newObj !== Object(newObj))
            return newObj; // primitive value
        if (newObj !== obj)
            return toJSONSafe(newObj, replacer);
        // toJSON returned the object unchanged.
        obj = newObj;
    }
    obj._$visited = true;
    let result;
    if (obj instanceof Array) {
        result = obj.map(function (o) {
            return toJSONSafe(o, replacer);
        });
    }
    else if (typeof (obj) === "function") {
        result = undefined;
    }
    else {
        result = {};
        for (let prop in obj) {
            if (prop === "_$visited")
                continue;
            let val = obj[prop];
            if (replacer) {
                val = replacer(prop, val);
                if (val === undefined)
                    continue;
            }
            val = toJSONSafe(val, replacer);
            if (val === undefined)
                continue;
            result[prop] = val;
        }
    }
    delete obj._$visited;
    return result;
}
/** Resolves the values of a list of properties by checking each property in multiple sources until a value is found. */
function resolveProperties(sources, propertyNames) {
    let r = {};
    let length = sources.length;
    propertyNames.forEach(function (pn) {
        for (let i = 0; i < length; i++) {
            let src = sources[i];
            if (src) {
                let val = src[pn];
                if (val !== undefined) {
                    r[pn] = val;
                    break;
                }
            }
        }
    });
    return r;
}
// array functions
function toArray(item) {
    if (item == null) {
        return [];
    }
    else if (Array.isArray(item)) {
        return item;
    }
    else {
        return [item];
    }
}
/** a version of Array.map that doesn't require an array, i.e. works on arrays and scalars. */
// function map<T, U>(items: T | T[], fn: (v: T, ix?: number) => U, includeNull?: boolean): U | U[] {
function map(items, fn, includeNull) {
    // whether to return nulls in array of results; default = true;
    includeNull = includeNull == null ? true : includeNull;
    if (items == null)
        return items;
    // let result: U[];
    if (Array.isArray(items)) {
        let result = [];
        items.forEach(function (v, ix) {
            let r = fn(v, ix);
            if (r != null || includeNull) {
                result[ix] = r;
            }
        });
        return result;
    }
    else {
        let result = fn(items);
        return result;
    }
}
function arrayFirst(array, predicate) {
    for (let i = 0, j = array.length; i < j; i++) {
        if (predicate(array[i])) {
            return array[i];
        }
    }
    return null;
}
function arrayIndexOf(array, predicate) {
    for (let i = 0, j = array.length; i < j; i++) {
        if (predicate(array[i]))
            return i;
    }
    return -1;
}
/** Add item if not already in array */
function arrayAddItemUnique(array, item) {
    let ix = array.indexOf(item);
    if (ix === -1)
        array.push(item);
}
/** Remove items from the array
 * @param array
 * @param predicateOrItem - item to remove, or function to determine matching item
 * @param shouldRemoveMultiple - true to keep removing after first match, false otherwise
 */
function arrayRemoveItem(array, predicateOrItem, shouldRemoveMultiple) {
    let predicate = (isFunction(predicateOrItem) ? predicateOrItem : undefined);
    let lastIx = array.length - 1;
    let removed = false;
    for (let i = lastIx; i >= 0; i--) {
        if (predicate ? predicate(array[i]) : (array[i] === predicateOrItem)) {
            array.splice(i, 1);
            removed = true;
            if (!shouldRemoveMultiple) {
                return true;
            }
        }
    }
    return removed;
}
/** Combine array elements using the callback.  Returns array with length == min(a1.length, a2.length) */
function arrayZip(a1, a2, callback) {
    let result = [];
    let n = Math.min(a1.length, a2.length);
    for (let i = 0; i < n; ++i) {
        result.push(callback(a1[i], a2[i]));
    }
    return result;
}
//function arrayDistinct(array) {
//    array = array || [];
//    let result = [];
//    for (let i = 0, j = array.length; i < j; i++) {
//        if (result.indexOf(array[i]) < 0)
//            result.push(array[i]);
//    }
//    return result;
//}
// Not yet needed
//// much faster but only works on array items with a toString method that
//// returns distinct string for distinct objects.  So this is safe for arrays with primitive
//// types but not for arrays with object types, unless toString() has been implemented.
//function arrayDistinctUnsafe(array) {
//    let o = {}, i, l = array.length, r = [];
//    for (i = 0; i < l; i += 1) {
//        let v = array[i];
//        o[v] = v;
//    }
//    for (i in o) r.push(o[i]);
//    return r;
//}
function arrayEquals(a1, a2, equalsFn) {
    //Check if the arrays are undefined/null
    if (!a1 || !a2)
        return false;
    if (a1.length !== a2.length)
        return false;
    //go thru all the vars
    for (let i = 0; i < a1.length; i++) {
        //if the let is an array, we need to make a recursive check
        //otherwise we'll just compare the values
        if (Array.isArray(a1[i])) {
            if (!arrayEquals(a1[i], a2[i]))
                return false;
        }
        else {
            if (equalsFn) {
                if (!equalsFn(a1[i], a2[i]))
                    return false;
            }
            else {
                if (a1[i] !== a2[i])
                    return false;
            }
        }
    }
    return true;
}
// end of array functions
/** Returns an array for a source and a prop, and creates the prop if needed. */
function getArray(source, propName) {
    let arr = source[propName];
    if (!arr) {
        arr = [];
        source[propName] = arr;
    }
    return arr;
}
/** Calls requireLibCore on semicolon-separated libNames */
function requireLib(libNames, errMessage) {
    let arrNames = libNames.split(";");
    for (let i = 0, j = arrNames.length; i < j; i++) {
        let lib = requireLibCore(arrNames[i]);
        if (lib)
            return lib;
    }
    if (errMessage) {
        throw new Error("Unable to initialize " + libNames + ".  " + errMessage);
    }
}
/** Returns the 'libName' module if loaded or else returns undefined */
function requireLibCore(libName) {
    let win = window || (global ? global.window : undefined);
    if (!win)
        return; // Must run in a browser. Todo: add commonjs support
    // get library from browser globals if we can
    let lib = win[libName];
    if (lib)
        return lib;
    // if require exists, maybe require can get it.
    // This method is synchronous so it can't load modules with AMD.
    // It can only obtain modules from require that have already been loaded.
    // Developer should bootstrap such that the breeze module
    // loads after all other libraries that breeze should find with this method
    // See documentation
    let r = win.require;
    if (r) { // if require exists
        if (r.defined) { // require.defined is not standard and may not exist
            // require.defined returns true if module has been loaded
            return r.defined(libName) ? r(libName) : undefined;
        }
        else {
            // require.defined does not exist so we have to call require('libName') directly.
            // The require('libName') overload is synchronous and does not load modules.
            // It throws an exception if the module isn't already loaded.
            try {
                return r(libName);
            }
            catch (e) {
                // require('libName') threw because module not loaded
                return;
            }
        }
    }
}
/** Execute fn while obj has tempValue for property */
function using(obj, property, tempValue, fn) {
    let originalValue = obj[property];
    if (tempValue === originalValue) {
        return fn();
    }
    obj[property] = tempValue;
    try {
        return fn();
    }
    finally {
        if (originalValue === undefined) {
            delete obj[property];
        }
        else {
            obj[property] = originalValue;
        }
    }
}
/** Call state = startFn(), call fn(), call endFn(state) */
function wrapExecution(startFn, endFn, fn) {
    let state;
    try {
        state = startFn();
        return fn();
    }
    catch (e) {
        if (typeof (state) === 'object') {
            state.error = e;
        }
        throw e;
    }
    finally {
        endFn(state);
    }
}
/** Remember & return the value of fn() when it was called with its current args */
function memoize(fn) {
    return function () {
        let args = arraySlice(arguments), hash = "", i = args.length, currentArg = null;
        while (i--) {
            currentArg = args[i];
            hash += (currentArg === Object(currentArg)) ? JSON.stringify(currentArg) : currentArg;
            fn.memoize || (fn.memoize = {});
        }
        return (hash in fn.memoize) ?
            fn.memoize[hash] :
            fn.memoize[hash] = fn.apply(this, args);
    };
}
function getUuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        // tslint:disable-next-line
        let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
function durationToSeconds(duration) {
    // basic algorithm from https://github.com/nezasa/iso8601-js-period
    if (typeof duration !== "string")
        throw new Error("Invalid ISO8601 duration '" + duration + "'");
    // regex splits as follows - grp0, grp1, y, m, d, grp2, h, m, s
    //                           0     1     2  3  4  5     6  7  8
    let struct = /^P((\d+Y)?(\d+M)?(\d+D)?)?(T(\d+H)?(\d+M)?(\d+S)?)?$/.exec(duration);
    if (!struct)
        throw new Error("Invalid ISO8601 duration '" + duration + "'");
    let ymdhmsIndexes = [2, 3, 4, 6, 7, 8]; // -> grp1,y,m,d,grp2,h,m,s
    let factors = [31104000,
        2592000,
        86400,
        3600,
        60,
        1]; // second (1)
    let seconds = 0;
    for (let i = 0; i < 6; i++) {
        let digit = struct[ymdhmsIndexes[i]];
        // remove letters, replace by 0 if not defined
        digit = (digit ? +digit.replace(/[A-Za-z]+/g, '') : 0);
        seconds += digit * factors[i];
    }
    return seconds;
}
// is functions
function noop() {
    // does nothing
}
function identity(x) {
    return x;
}
function classof(o) {
    if (o === null) {
        return "null";
    }
    if (o === undefined) {
        return "undefined";
    }
    return Object.prototype.toString.call(o).slice(8, -1).toLowerCase();
}
function isDate(o) {
    return classof(o) === "date" && !isNaN(o.getTime());
}
function isDateString(s) {
    // let rx = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
    let rx = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/;
    return (typeof s === "string") && rx.test(s);
}
function isFunction(o) {
    return classof(o) === "function";
}
// function isString(o: any) {
//     return (typeof o === "string");
// }
// function isObject(o: any) {
//     return (typeof o === "object");
// }
function isGuid(value) {
    return (typeof value === "string") && /[a-fA-F\d]{8}-(?:[a-fA-F\d]{4}-){3}[a-fA-F\d]{12}/.test(value);
}
function isDuration(value) {
    return (typeof value === "string") && /^(-|)?P[T]?[\d\.,\-]+[YMDTHS]/.test(value);
}
function isEmpty(obj) {
    if (obj === null || obj === undefined) {
        return true;
    }
    for (let key in obj) {
        if (hasOwnProperty(obj, key)) {
            return false;
        }
    }
    return true;
}
function isNumeric(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
// end of is Functions
// string functions
function stringStartsWith(str, prefix) {
    // returns true for empty string or null prefix
    if ((!str))
        return false;
    if (prefix === "" || prefix == null)
        return true;
    return str.indexOf(prefix, 0) === 0;
}
function stringEndsWith(str, suffix) {
    // returns true for empty string or null suffix
    if ((!str))
        return false;
    if (suffix === "" || suffix == null)
        return true;
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
}
// Based on fragment from Dean Edwards' Base 2 library
/** format("a %1 and a %2", "cat", "dog") -> "a cat and a dog" */
function formatString(str, ...params) {
    let args = arguments;
    let pattern = RegExp("%([1-" + (arguments.length - 1) + "])", "g");
    return str.replace(pattern, function (match, index) {
        return args[index];
    });
}
// See http://stackoverflow.com/questions/7225407/convert-camelcasetext-to-camel-case-text
/** Change text to title case with spaces, e.g. 'myPropertyName12' to 'My Property Name 12' */
let camelEdges = /([A-Z](?=[A-Z][a-z])|[^A-Z](?=[A-Z])|[a-zA-Z](?=[^a-zA-Z]))/g;
function titleCaseSpace(text) {
    text = text.replace(camelEdges, '$1 ');
    text = text.charAt(0).toUpperCase() + text.slice(1);
    return text;
}
// end of string functions
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
function uncurry(f) {
    let call = Function.call;
    return function () {
        return call.apply(f, arguments);
    };
}
// shims
if (!Object.create) {
    Object.create = function (parent) {
        let F = function () {
        };
        F.prototype = parent;
        return new F();
    };
}
// // not all methods above are exported
export const core = {
    isES5Supported: isES5Supported,
    hasOwnProperty: hasOwnProperty,
    getOwnPropertyValues: getOwnPropertyValues,
    getPropertyDescriptor: getPropDescriptor,
    objectForEach: objectForEach,
    objectFirst: objectFirst,
    objectMap: objectMap,
    extend: extend,
    propEq: propEq,
    propsEq: propsEq,
    pluck: pluck,
    map: map,
    resolveProperties: resolveProperties,
    setAsDefault: setAsDefault,
    updateWithDefaults: updateWithDefaults,
    getArray: getArray,
    toArray: toArray,
    arrayEquals: arrayEquals,
    arraySlice: arraySlice,
    arrayFirst: arrayFirst,
    arrayIndexOf: arrayIndexOf,
    arrayRemoveItem: arrayRemoveItem,
    arrayZip: arrayZip,
    arrayAddItemUnique: arrayAddItemUnique,
    arrayFlatMap: arrayFlatMap,
    requireLib: requireLib,
    using: using,
    wrapExecution: wrapExecution,
    memoize: memoize,
    getUuid: getUuid,
    durationToSeconds: durationToSeconds,
    isSettable: isSettable,
    isDate: isDate,
    isDateString: isDateString,
    isGuid: isGuid,
    isDuration: isDuration,
    isFunction: isFunction,
    isEmpty: isEmpty,
    isNumeric: isNumeric,
    identity: identity,
    noop: noop,
    stringStartsWith: stringStartsWith,
    stringEndsWith: stringEndsWith,
    formatString: formatString,
    titleCase: titleCaseSpace,
    toJson: toJson,
    toJSONSafe: toJSONSafe,
    toJSONSafeReplacer: toJSONSafeReplacer,
};
export { ɵ0 };
// Unused
/*
// returns true for booleans, numbers, strings and dates
// false for null, and non-date objects, functions, and arrays
function isPrimitive(obj: any) {
    if (obj == null) return false;
    // true for numbers, strings, booleans and null, false for objects
    if (obj != Object(obj)) return true;
    return isDate(obj);
}

*/ 
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29yZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2JyZWV6ZS1jbGllbnQvIiwic291cmNlcyI6WyJzcmMvY29yZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrREFBa0Q7QUFDbEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQWVwQyxJQUFJLGNBQWMsR0FBMEMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDckcsSUFBSSxVQUFVLEdBQXVELE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1dBQ3RFO0lBQzFCLElBQUk7UUFDQSxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxjQUFjLElBQUksTUFBTSxDQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDMUU7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNSLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0FBQ0wsQ0FBQztBQU5ELElBQUksY0FBYyxHQUFZLElBTTFCLENBQUM7QUFFTCxzQkFBc0I7QUFDdEIsU0FBUyxhQUFhLENBQUMsR0FBVyxFQUFFLElBQW9DO0lBQ3BFLEtBQUssSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFO1FBQ2pCLElBQUksY0FBYyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRTtZQUMxQixJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ3ZCO0tBQ0o7QUFDTCxDQUFDO0FBRUQsU0FBUyxTQUFTLENBQUMsR0FBVyxFQUFFLElBQXFDO0lBQ2pFLElBQUksT0FBTyxHQUFVLEVBQUUsQ0FBQztJQUN4QixLQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRTtRQUNqQixJQUFJLGNBQWMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUU7WUFDMUIsSUFBSSxNQUFNLEdBQUcsSUFBSSxD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LEVBQUUsTUFBTTtJQUNkLFlBQVksRUFBRSxZQUFZO0lBQzFCLE1BQU0sRUFBRSxNQUFNO0lBQ2QsVUFBVSxFQUFFLFVBQVU7SUFDdEIsVUFBVSxFQUFFLFVBQVU7SUFDdEIsT0FBTyxFQUFFLE9BQU87SUFDaEIsU0FBUyxFQUFFLFNBQVM7SUFFcEIsUUFBUSxFQUFFLFFBQVE7SUFDbEIsSUFBSSxFQUFFLElBQUk7SUFFVixnQkFBZ0IsRUFBRSxnQkFBZ0I7SUFDbEMsY0FBYyxFQUFFLGNBQWM7SUFDOUIsWUFBWSxFQUFFLFlBQVk7SUFDMUIsU0FBUyxFQUFFLGNBQWM7SUFFekIsTUFBTSxFQUFFLE1BQU07SUFDZCxVQUFVLEVBQUUsVUFBVTtJQUN0QixrQkFBa0IsRUFBRSxrQkFBa0I7Q0FDekMsQ0FBQzs7QUFPRixTQUFTO0FBQ1Q7Ozs7Ozs7Ozs7RUFVRSIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBTZWUgaWYgdGhpcyBjb21tZW50IHdpbGwgbWFrZSBpdCBpbnRvIC5kLnRzICovXHJcbmltcG9ydCB7IEJyZWV6ZUVudW0gfSBmcm9tICcuL2VudW0nO1xyXG5kZWNsYXJlIHZhciBnbG9iYWw6IGFueTtcclxuZGVjbGFyZSB2YXIgd2luZG93OiBhbnk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yQ2FsbGJhY2sge1xyXG4gICAgKGVycm9yOiBFcnJvcik6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2FsbGJhY2sge1xyXG4gICAgKGRhdGE6IGFueSk6IHZvaWQ7XHJcbn1cclxuXHJcbi8vIHR5cGUgUHJlZGljYXRlID0gKGk6IGFueSkgPT4gYm9vbGVhbjtcclxudHlwZSBQcmVkaWNhdGU8VD4gPSAoaTogVCkgPT4gYm9vbGVhbjtcclxuXHJcbmxldCBoYXNPd25Qcm9wZXJ0eTogKG9iajogT2JqZWN0LCBrZXk6IHN0cmluZykgPT4gYm9vbGVhbiA9IHVuY3VycnkoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XHJcbmxldCBhcnJheVNsaWNlOiAoYXI6IGFueVtdLCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyKSA9PiBhbnlbXSA9IHVuY3VycnkoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcclxubGV0IGlzRVM1U3VwcG9ydGVkOiBib29sZWFuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gISEoT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSkpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufSAoKTtcclxuXHJcbi8vIGl0ZXJhdGUgb3ZlciBvYmplY3RcclxuZnVuY3Rpb24gb2JqZWN0Rm9yRWFjaChvYmo6IE9iamVjdCwga3ZGbjogKGtleTogc3RyaW5nLCB2YWw6IGFueSkgPT4gYW55KSB7XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICBrdkZuKGtleSwgb2JqW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gb2JqZWN0TWFwKG9iajogT2JqZWN0LCBrdkZuPzogKGtleTogc3RyaW5nLCB2YWw6IGFueSkgPT4gYW55KTogYW55W10ge1xyXG4gICAgbGV0IHJlc3VsdHM6IGFueVtdID0gW107XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwga2V5KSkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0ga3ZGbiA/IGt2Rm4oa2V5LCBvYmpba2V5XSkgOiBvYmpba2V5XTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvYmplY3RGaXJzdChvYmo6IE9iamVjdCwga3ZQcmVkaWNhdGU6IChrZXk6IHN0cmluZywgdmFsOiBhbnkpID0+IGJvb2xlYW4pOiB7IGtleTogc3RyaW5nLCB2YWx1ZTogYW55IH0gfCBudWxsIHtcclxuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICBpZiAoa3ZQcmVkaWNhdGUoa2V5LCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGtleToga2V5LCB2YWx1ZTogdmFsdWUgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhcnJheUZsYXRNYXA8VCwgVT4oYXJyOiBUW10sIG1hcEZuOiAoYXJnOiBUKSA9PiBVW10pIHtcclxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIubWFwKG1hcEZuKSkgYXMgVVtdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1NldHRhYmxlKG9iajogT2JqZWN0LCBwcm9wZXJ0eU5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgbGV0IHBkID0gZ2V0UHJvcERlc2NyaXB0b3Iob2JqLCBwcm9wZXJ0eU5hbWUpO1xyXG4gICAgaWYgKHBkID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuICEhKHBkLndyaXRhYmxlIHx8IHBkLnNldCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFByb3BEZXNjcmlwdG9yKG9iajogT2JqZWN0LCBwcm9wZXJ0eU5hbWU6IHN0cmluZyk6IFByb3BlcnR5RGVzY3JpcHRvciB8IHVuZGVmaW5lZCB7XHJcbiAgICBpZiAoIWlzRVM1U3VwcG9ydGVkKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcGVydHlOYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGV0IG5leHRPYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcclxuICAgICAgICBpZiAobmV4dE9iaiA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJldHVybiBnZXRQcm9wRGVzY3JpcHRvcihuZXh0T2JqLCBwcm9wZXJ0eU5hbWUpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBGdW5jdGlvbmFsIGV4dGVuc2lvbnNcclxuXHJcbi8qKiBjYW4gYmUgdXNlZCBsaWtlOiBwZXJzb25zLmZpbHRlcihwcm9wRXEoXCJmaXJzdE5hbWVcIiwgXCJKb2huXCIpKSAqL1xyXG5mdW5jdGlvbiBwcm9wRXEocHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpOiAob2JqOiBPYmplY3QpID0+IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmo6IGFueSkge1xyXG4gICAgICAgIHJldHVybiBvYmpbcHJvcGVydHlOYW1lXSA9PT0gdmFsdWU7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKiogY2FuIGJlIHVzZWQgbGlrZTogcGVyc29ucy5maWx0ZXIocHJvcEVxKFwiZmlyc3ROYW1lXCIsIFwiRmlyc3ROYW1lXCIsIFwiSm9oblwiKSkgKi9cclxuZnVuY3Rpb24gcHJvcHNFcShwcm9wZXJ0eTFOYW1lOiBzdHJpbmcsIHByb3BlcnR5Mk5hbWU6IHN0cmluZywgdmFsdWU6IGFueSk6IChvYmo6IE9iamVjdCkgPT4gYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iajogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialtwcm9wZXJ0eTFOYW1lXSA9PT0gdmFsdWUgfHwgb2JqW3Byb3BlcnR5Mk5hbWVdID09PSB2YWx1ZTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKiBjYW4gYmUgdXNlZCBsaWtlIHBlcnNvbnMubWFwKHBsdWNrKFwiZmlyc3ROYW1lXCIpKSAqL1xyXG5mdW5jdGlvbiBwbHVjayhwcm9wZXJ0eU5hbWU6IGFueSk6IChvYmo6IE9iamVjdCkgPT4gYW55IHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqOiBhbnkpIHtcclxuICAgICAgICByZXR1cm4gb2JqW3Byb3BlcnR5TmFtZV07XHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBlbmQgZnVuY3Rpb25hbCBleHRlbnNpb25zXHJcblxyXG4vKiogUmV0dXJuIGFuIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcyBmcm9tIHNvdXJjZSAqL1xyXG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVZhbHVlcyhzb3VyY2U6IE9iamVjdCk6IGFueVtdIHtcclxuICAgIGxldCByZXN1bHQ6IGFueVtdID0gW107XHJcbiAgICBmb3IgKGxldCBuYW1lIGluIHNvdXJjZSkge1xyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShzb3VyY2UsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNvdXJjZVtuYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqIENvcHkgcHJvcGVydGllcyBmcm9tIHNvdXJjZSB0byB0YXJnZXQuIFJldHVybnMgdGFyZ2V0LiAqL1xyXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0OiBPYmplY3QsIHNvdXJjZTogT2JqZWN0LCBwcm9wTmFtZXM/OiBzdHJpbmdbXSk6IE9iamVjdCB7XHJcbiAgICBpZiAoIXNvdXJjZSkgcmV0dXJuIHRhcmdldDtcclxuICAgIGlmIChwcm9wTmFtZXMpIHtcclxuICAgICAgICBwcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcclxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BOYW1lXSA9IHNvdXJjZVtwcm9wTmFtZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAobGV0IHByb3BOYW1lIGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkoc291cmNlLCBwcm9wTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wTmFtZV0gPSBzb3VyY2VbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxuLyoqIENvcHkgcHJvcGVydGllcyBmcm9tIGRlZmF1bHRzIGlmZiB1bmRlZmluZWQgb24gdGFyZ2V0LiAgUmV0dXJucyB0YXJnZXQuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZVdpdGhEZWZhdWx0cyh0YXJnZXQ6IE9iamVjdCwgZGVmYXVsdHM6IE9iamVjdCk6IGFueSB7XHJcbiAgICBmb3IgKGxldCBuYW1lIGluIGRlZmF1bHRzKSB7XHJcbiAgICAgICAgaWYgKHRhcmdldFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGRlZmF1bHRzW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbi8qKiBTZXQgY3Rvci5kZWZhdWx0SW5zdGFuY2UgdG8gYW4gaW5zdGFuY2Ugb2YgY3RvciB3aXRoIHByb3BlcnRpZXMgZnJvbSB0YXJnZXQuXHJcbiAgICBXZSB3YW50IHRvIGluc3VyZSB0aGF0IHRoZSBvYmplY3QgcmV0dXJuZWQgYnkgY3Rvci5kZWZhdWx0SW5zdGFuY2UgaXMgYWx3YXlzIGltbXV0YWJsZVxyXG4gICAgVXNlICd0YXJnZXQnIGFzIHRoZSBwcmltYXJ5IHRlbXBsYXRlIGZvciB0aGUgY3Rvci5kZWZhdWx0SW5zdGFuY2U7XHJcbiAgICBVc2UgY3VycmVudCAnY3Rvci5kZWZhdWx0SW5zdGFuY2UnIGFzIHRoZSB0ZW1wbGF0ZSBmb3IgYW55IG1pc3NpbmcgcHJvcGVydGllc1xyXG4gICAgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBmb3IgY3Rvci5kZWZhdWx0SW5zdGFuY2VcclxuICAgIHJldHVybnMgdGFyZ2V0IHVuY2hhbmdlZCAqL1xyXG5mdW5jdGlvbiBzZXRBc0RlZmF1bHQodGFyZ2V0OiBPYmplY3QsIGN0b3I6IHsgbmV3ICguLi5hcmdzOiBhbnlbXSk6IGFueSwgZGVmYXVsdEluc3RhbmNlPzogYW55IH0pOiBhbnkge1xyXG4gICAgY3Rvci5kZWZhdWx0SW5zdGFuY2UgPSB1cGRhdGVXaXRoRGVmYXVsdHMobmV3IGN0b3IodGFyZ2V0KSwgY3Rvci5kZWZhdWx0SW5zdGFuY2UpO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxuLyoqXHJcbiAgICAnc291cmNlJyBpcyBhbiBvYmplY3QgdGhhdCB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gYW5vdGhlclxyXG4gICAgJ3RlbXBsYXRlJyBpcyBhIG1hcCB3aGVyZSB0aGVcclxuICAgICAgIGtleXM6IGFyZSB0aGUga2V5cyB0byByZXR1cm5cclxuICAgICAgICAgaWYgYSBrZXkgY29udGFpbnMgJywncyB0aGVuIHRoZSBrZXkgaXMgdHJlYXRlZCBhcyBhIGRlbGltaXRlZCBzdHJpbmcgd2l0aCBmaXJzdCBvZiB0aGVcclxuICAgICAgICAga2V5cyBiZWluZyB0aGUga2V5IHRvIHJldHVybiBhbmQgdGhlIG90aGVycyBhbGwgdmFsaWQgYWxpYXNlcyBmb3IgdGhpcyBrZXlcclxuICAgICAgICd2YWx1ZXMnIGFyZSBlaXRoZXJcclxuICAgICAgICAgICAxKSB0aGUgJ2RlZmF1bHQnIHZhbHVlIG9mIHRoZSBrZXlcclxuICAgICAgICAgICAyKSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgaW4gdGhlIHNvdXJjZSB2YWx1ZSBhbmQgc2hvdWxkIHJldHVybiB0aGUgdmFsdWUgdG8gc2V0XHJcbiAgICAgICAgIFRoZSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgaXMgdGhlbiBzZXQgb24gdGhlIHRhcmdldCxcclxuICAgICAgICAgYWZ0ZXIgZmlyc3QgcGFzc2luZyB0aHJ1IHRoZSBmbiwgaWYgcHJvdmlkZWQsIFVOTEVTUzpcclxuICAgICAgICAgICAxKSBpdCBpcyB0aGUgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAgIDIpIGl0IGlzIHVuZGVmaW5lZCAoIG51bGxzIFdJTEwgYmUgc2V0KVxyXG4gICAgJ3RhcmdldCcgaXMgb3B0aW9uYWxcclxuICAgICAgIC0gaWYgaXQgZXhpc3RzIHRoZW4gcHJvcGVydGllcyBvZiB0aGUgdGFyZ2V0IHdpbGwgYmUgc2V0ICggb3ZlcndyaXR0ZW4gaWYgdGhlIGV4aXN0KVxyXG4gICAgICAgLSBpZiBpdCBkb2VzIG5vdCBleGlzdCB0aGVuIGEgbmV3IG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQgYXMgZmlsbGVkLlxyXG4gICAgJ3RhcmdldCBpcyByZXR1cm5lZC5cclxuKi9cclxuZnVuY3Rpb24gdG9Kc29uKHNvdXJjZTogT2JqZWN0LCB0ZW1wbGF0ZTogT2JqZWN0LCB0YXJnZXQ6IE9iamVjdCA9IHt9KTogT2JqZWN0IHtcclxuXHJcbiAgICBmb3IgKGxldCBrZXkgaW4gdGVtcGxhdGUpIHtcclxuICAgICAgICBsZXQgYWxpYXNlcyA9IGtleS5zcGxpdChcIixcIik7XHJcbiAgICAgICAgbGV0IGRlZmF1bHRWYWx1ZSA9IHRlbXBsYXRlW2tleV07XHJcbiAgICAgICAgLy8gdXNpbmcgc29tZSBhcyBhIGZvckVhY2ggd2l0aCBhICdicmVhaydcclxuICAgICAgICBhbGlhc2VzLnNvbWUoZnVuY3Rpb24gKHByb3BOYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghKHByb3BOYW1lIGluIHNvdXJjZSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gc291cmNlW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBmdW5jdGlvbmFsIHByb3BlcnR5IGRlZmluZWQgd2l0aCB0aGlzIGFsaWFzICggbm90IHdoYXQgd2Ugd2FudCB0byByZXBsYWNlKS5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAvLyAnPT0nIGlzIGRlbGliZXJhdGUgaGVyZSAtIGlkZWEgaXMgdGhhdCBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMgd2lsbCBuZXZlciBnZXQgc2VyaWFsaXplZFxyXG4gICAgICAgICAgICAvLyBpZiBkZWZhdWx0IHZhbHVlIGlzIHNldCB0byBudWxsLlxyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09IGRlZmF1bHRWYWx1ZSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChkZWZhdWx0VmFsdWUpID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgQnJlZXplRW51bSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHRhcmdldFthbGlhc2VzWzBdXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbi8qKiBSZXBsYWNlciBmdW5jdGlvbiBmb3IgdG9KU09OU2FmZSwgd2hlbiBzZXJpYWxpemluZyBlbnRpdGllcy4gIEV4Y2x1ZGVzIGVudGl0eUFzcGVjdCBhbmQgb3RoZXIgaW50ZXJuYWwgcHJvcGVydGllcy4gKi9cclxuZnVuY3Rpb24gdG9KU09OU2FmZVJlcGxhY2VyKHByb3A6IHN0cmluZywgdmFsOiBhbnkpIHtcclxuICAgIGlmIChwcm9wID09PSBcImVudGl0eUFzcGVjdFwiIHx8IHByb3AgPT09IFwiY29tcGxleEFzcGVjdFwiIHx8IHByb3AgPT09IFwiZW50aXR5VHlwZVwiIHx8IHByb3AgPT09IFwiY29tcGxleFR5cGVcIlxyXG4gICAgICAgIHx8IHByb3AgPT09IFwiZ2V0UHJvcGVydHlcIiB8fCBwcm9wID09PSBcInNldFByb3BlcnR5XCJcclxuICAgICAgICB8fCBwcm9wID09PSBcImNvbnN0cnVjdG9yXCIgfHwgcHJvcC5jaGFyQXQoMCkgPT09ICdfJyB8fCBwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSByZXR1cm47XHJcbiAgICByZXR1cm4gdmFsO1xyXG59XHJcblxyXG4vKiogU2FmZWx5IHBlcmZvcm0gdG9KU09OIGxvZ2ljIG9uIG9iamVjdHMgd2l0aCBjeWNsZXMuICovXHJcbmZ1bmN0aW9uIHRvSlNPTlNhZmUob2JqOiBhbnksIHJlcGxhY2VyPzogKHByb3A6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55KTogYW55IHtcclxuICAgIGlmIChvYmogIT09IE9iamVjdChvYmopKSByZXR1cm4gb2JqOyAvLyBwcmltaXRpdmUgdmFsdWVcclxuICAgIGlmIChvYmouXyR2aXNpdGVkKSByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgaWYgKG9iai50b0pTT04pIHtcclxuICAgICAgICBsZXQgbmV3T2JqID0gb2JqLnRvSlNPTigpO1xyXG4gICAgICAgIGlmIChuZXdPYmogIT09IE9iamVjdChuZXdPYmopKSByZXR1cm4gbmV3T2JqOyAvLyBwcmltaXRpdmUgdmFsdWVcclxuICAgICAgICBpZiAobmV3T2JqICE9PSBvYmopIHJldHVybiB0b0pTT05TYWZlKG5ld09iaiwgcmVwbGFjZXIpO1xyXG4gICAgICAgIC8vIHRvSlNPTiByZXR1cm5lZCB0aGUgb2JqZWN0IHVuY2hhbmdlZC5cclxuICAgICAgICBvYmogPSBuZXdPYmo7XHJcbiAgICB9XHJcbiAgICBvYmouXyR2aXNpdGVkID0gdHJ1ZTtcclxuICAgIGxldCByZXN1bHQ6IGFueTtcclxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIHJlc3VsdCA9IG9iai5tYXAoZnVuY3Rpb24gKG86IGFueSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9KU09OU2FmZShvLCByZXBsYWNlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiAob2JqKSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHQgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG9iaikge1xyXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJfJHZpc2l0ZWRcIikgY29udGludWU7XHJcbiAgICAgICAgICAgIGxldCB2YWwgPSBvYmpbcHJvcF07XHJcbiAgICAgICAgICAgIGlmIChyZXBsYWNlcikge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gcmVwbGFjZXIocHJvcCwgdmFsKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsID0gdG9KU09OU2FmZSh2YWwsIHJlcGxhY2VyKTtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcclxuICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlbGV0ZSBvYmouXyR2aXNpdGVkO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqIFJlc29sdmVzIHRoZSB2YWx1ZXMgb2YgYSBsaXN0IG9mIHByb3BlcnRpZXMgYnkgY2hlY2tpbmcgZWFjaCBwcm9wZXJ0eSBpbiBtdWx0aXBsZSBzb3VyY2VzIHVudGlsIGEgdmFsdWUgaXMgZm91bmQuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKHNvdXJjZXM6IE9iamVjdFtdLCBwcm9wZXJ0eU5hbWVzOiBzdHJpbmdbXSk6IGFueSB7XHJcbiAgICBsZXQgciA9IHt9O1xyXG4gICAgbGV0IGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xyXG4gICAgcHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwbikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHNyYyA9IHNvdXJjZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChzcmMpIHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBzcmNbcG5dO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcltwbl0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5cclxuLy8gYXJyYXkgZnVuY3Rpb25zXHJcblxyXG5mdW5jdGlvbiB0b0FycmF5KGl0ZW06IGFueSk6IGFueVtdIHtcclxuICAgIGlmIChpdGVtID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtpdGVtXTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqIGEgdmVyc2lvbiBvZiBBcnJheS5tYXAgdGhhdCBkb2Vzbid0IHJlcXVpcmUgYW4gYXJyYXksIGkuZS4gd29ya3Mgb24gYXJyYXlzIGFuZCBzY2FsYXJzLiAqL1xyXG4vLyBmdW5jdGlvbiBtYXA8VCwgVT4oaXRlbXM6IFQgfCBUW10sIGZuOiAodjogVCwgaXg/OiBudW1iZXIpID0+IFUsIGluY2x1ZGVOdWxsPzogYm9vbGVhbik6IFUgfCBVW10ge1xyXG4gZnVuY3Rpb24gbWFwPFQ+KGl0ZW1zOiBUIHwgVFtdLCBmbjogKHY6IFQsIGl4PzogbnVtYmVyKSA9PiBhbnksIGluY2x1ZGVOdWxsPzogYm9vbGVhbik6IGFueSB8IGFueVtdIHtcclxuICAgIC8vIHdoZXRoZXIgdG8gcmV0dXJuIG51bGxzIGluIGFycmF5IG9mIHJlc3VsdHM7IGRlZmF1bHQgPSB0cnVlO1xyXG4gICAgaW5jbHVkZU51bGwgPSBpbmNsdWRlTnVsbCA9PSBudWxsID8gdHJ1ZSA6IGluY2x1ZGVOdWxsO1xyXG4gICAgaWYgKGl0ZW1zID09IG51bGwpIHJldHVybiBpdGVtcztcclxuICAgIC8vIGxldCByZXN1bHQ6IFVbXTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xyXG4gICAgICAgIGxldCByZXN1bHQ6IGFueVtdID0gW107XHJcbiAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAodjogYW55LCBpeDogbnVtYmVyKSB7XHJcbiAgICAgICAgICAgIGxldCByID0gZm4odiwgaXgpO1xyXG4gICAgICAgICAgICBpZiAociAhPSBudWxsIHx8IGluY2x1ZGVOdWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaXhdID0gcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBmbihpdGVtcyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbi8qKiBSZXR1cm4gZmlyc3QgZWxlbWVudCBtYXRjaGluZyBwcmVkaWNhdGUgKi9cclxuZnVuY3Rpb24gYXJyYXlGaXJzdDxUPihhcnJheTogVFtdLCBwcmVkaWNhdGU6IFByZWRpY2F0ZTxhbnk+KTogVDtcclxuZnVuY3Rpb24gYXJyYXlGaXJzdDxUPihhcnJheTogVFtdLCBwcmVkaWNhdGU6IFByZWRpY2F0ZTxUPikge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBhcnJheS5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2ldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKiBSZXR1cm4gaW5kZXggb2YgZmlyc3QgZWxlbWVudCBtYXRjaGluZyBwcmVkaWNhdGUgKi9cclxuZnVuY3Rpb24gYXJyYXlJbmRleE9mPFQ+KGFycmF5OiBUW10sIHByZWRpY2F0ZTogUHJlZGljYXRlPGFueT4pOiBudW1iZXI7XHJcbmZ1bmN0aW9uIGFycmF5SW5kZXhPZjxUPihhcnJheTogVFtdLCBwcmVkaWNhdGU6IFByZWRpY2F0ZTxUPik6IG51bWJlciB7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGFycmF5Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaV0pKSByZXR1cm4gaTtcclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG5cclxuLyoqIEFkZCBpdGVtIGlmIG5vdCBhbHJlYWR5IGluIGFycmF5ICovXHJcbmZ1bmN0aW9uIGFycmF5QWRkSXRlbVVuaXF1ZTxUPihhcnJheTogVFtdLCBpdGVtOiBUKSB7XHJcbiAgICBsZXQgaXggPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xyXG4gICAgaWYgKGl4ID09PSAtMSkgYXJyYXkucHVzaChpdGVtKTtcclxufVxyXG5cclxuLyoqIFJlbW92ZSBpdGVtcyBmcm9tIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0gYXJyYXlcclxuICogQHBhcmFtIHByZWRpY2F0ZU9ySXRlbSAtIGl0ZW0gdG8gcmVtb3ZlLCBvciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgbWF0Y2hpbmcgaXRlbVxyXG4gKiBAcGFyYW0gc2hvdWxkUmVtb3ZlTXVsdGlwbGUgLSB0cnVlIHRvIGtlZXAgcmVtb3ZpbmcgYWZ0ZXIgZmlyc3QgbWF0Y2gsIGZhbHNlIG90aGVyd2lzZVxyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlSZW1vdmVJdGVtPFQ+KGFycmF5OiBUW10sIHByZWRpY2F0ZU9ySXRlbTogVCB8IFByZWRpY2F0ZTxUPiAsIHNob3VsZFJlbW92ZU11bHRpcGxlPzogYm9vbGVhbikge1xyXG4gICAgbGV0IHByZWRpY2F0ZSA9IChpc0Z1bmN0aW9uKHByZWRpY2F0ZU9ySXRlbSkgPyBwcmVkaWNhdGVPckl0ZW0gOiB1bmRlZmluZWQpIGFzIFByZWRpY2F0ZTxUPjtcclxuICAgIGxldCBsYXN0SXggPSBhcnJheS5sZW5ndGggLSAxO1xyXG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcclxuICAgIGZvciAobGV0IGkgPSBsYXN0SXg7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZSA/IHByZWRpY2F0ZShhcnJheVtpXSkgOiAoYXJyYXlbaV0gPT09IHByZWRpY2F0ZU9ySXRlbSkpIHtcclxuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKCFzaG91bGRSZW1vdmVNdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlZDtcclxufVxyXG5cclxuLyoqIENvbWJpbmUgYXJyYXkgZWxlbWVudHMgdXNpbmcgdGhlIGNhbGxiYWNrLiAgUmV0dXJucyBhcnJheSB3aXRoIGxlbmd0aCA9PSBtaW4oYTEubGVuZ3RoLCBhMi5sZW5ndGgpICovXHJcbmZ1bmN0aW9uIGFycmF5WmlwKGExOiBhbnlbXSwgYTI6IGFueVtdLCBjYWxsYmFjazogKHgxOiBhbnksIHgyOiBhbnkpID0+IGFueSk6IGFueVtdIHtcclxuICAgIGxldCByZXN1bHQ6IGFueVtdID0gW107XHJcbiAgICBsZXQgbiA9IE1hdGgubWluKGExLmxlbmd0aCwgYTIubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2soYTFbaV0sIGEyW2ldKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vL2Z1bmN0aW9uIGFycmF5RGlzdGluY3QoYXJyYXkpIHtcclxuLy8gICAgYXJyYXkgPSBhcnJheSB8fCBbXTtcclxuLy8gICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4vLyAgICBmb3IgKGxldCBpID0gMCwgaiA9IGFycmF5Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG4vLyAgICAgICAgaWYgKHJlc3VsdC5pbmRleE9mKGFycmF5W2ldKSA8IDApXHJcbi8vICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xyXG4vLyAgICB9XHJcbi8vICAgIHJldHVybiByZXN1bHQ7XHJcbi8vfVxyXG5cclxuLy8gTm90IHlldCBuZWVkZWRcclxuLy8vLyBtdWNoIGZhc3RlciBidXQgb25seSB3b3JrcyBvbiBhcnJheSBpdGVtcyB3aXRoIGEgdG9TdHJpbmcgbWV0aG9kIHRoYXRcclxuLy8vLyByZXR1cm5zIGRpc3RpbmN0IHN0cmluZyBmb3IgZGlzdGluY3Qgb2JqZWN0cy4gIFNvIHRoaXMgaXMgc2FmZSBmb3IgYXJyYXlzIHdpdGggcHJpbWl0aXZlXHJcbi8vLy8gdHlwZXMgYnV0IG5vdCBmb3IgYXJyYXlzIHdpdGggb2JqZWN0IHR5cGVzLCB1bmxlc3MgdG9TdHJpbmcoKSBoYXMgYmVlbiBpbXBsZW1lbnRlZC5cclxuLy9mdW5jdGlvbiBhcnJheURpc3RpbmN0VW5zYWZlKGFycmF5KSB7XHJcbi8vICAgIGxldCBvID0ge30sIGksIGwgPSBhcnJheS5sZW5ndGgsIHIgPSBbXTtcclxuLy8gICAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gMSkge1xyXG4vLyAgICAgICAgbGV0IHYgPSBhcnJheVtpXTtcclxuLy8gICAgICAgIG9bdl0gPSB2O1xyXG4vLyAgICB9XHJcbi8vICAgIGZvciAoaSBpbiBvKSByLnB1c2gob1tpXSk7XHJcbi8vICAgIHJldHVybiByO1xyXG4vL31cclxuXHJcbmZ1bmN0aW9uIGFycmF5RXF1YWxzKGExOiBhbnlbXSwgYTI6IGFueVtdLCBlcXVhbHNGbj86ICh4MTogYW55LCB4MjogYW55KSA9PiBib29sZWFuKTogYm9vbGVhbiB7XHJcbiAgICAvL0NoZWNrIGlmIHRoZSBhcnJheXMgYXJlIHVuZGVmaW5lZC9udWxsXHJcbiAgICBpZiAoIWExIHx8ICFhMikgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIGlmIChhMS5sZW5ndGggIT09IGEyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIC8vZ28gdGhydSBhbGwgdGhlIHZhcnNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYTEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvL2lmIHRoZSBsZXQgaXMgYW4gYXJyYXksIHdlIG5lZWQgdG8gbWFrZSBhIHJlY3Vyc2l2ZSBjaGVja1xyXG4gICAgICAgIC8vb3RoZXJ3aXNlIHdlJ2xsIGp1c3QgY29tcGFyZSB0aGUgdmFsdWVzXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYTFbaV0pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXJyYXlFcXVhbHMoYTFbaV0sIGEyW2ldKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChlcXVhbHNGbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHNGbihhMVtpXSwgYTJbaV0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYTFbaV0gIT09IGEyW2ldKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuLy8gZW5kIG9mIGFycmF5IGZ1bmN0aW9uc1xyXG5cclxuLyoqIFJldHVybnMgYW4gYXJyYXkgZm9yIGEgc291cmNlIGFuZCBhIHByb3AsIGFuZCBjcmVhdGVzIHRoZSBwcm9wIGlmIG5lZWRlZC4gKi9cclxuZnVuY3Rpb24gZ2V0QXJyYXkoc291cmNlOiBPYmplY3QsIHByb3BOYW1lOiBzdHJpbmcpOiBhbnlbXSB7XHJcbiAgICBsZXQgYXJyID0gc291cmNlW3Byb3BOYW1lXTtcclxuICAgIGlmICghYXJyKSB7XHJcbiAgICAgICAgYXJyID0gW107XHJcbiAgICAgICAgc291cmNlW3Byb3BOYW1lXSA9IGFycjtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnI7XHJcbn1cclxuXHJcbi8qKiBDYWxscyByZXF1aXJlTGliQ29yZSBvbiBzZW1pY29sb24tc2VwYXJhdGVkIGxpYk5hbWVzICovXHJcbmZ1bmN0aW9uIHJlcXVpcmVMaWIobGliTmFtZXM6IHN0cmluZywgZXJyTWVzc2FnZT86IHN0cmluZykge1xyXG4gICAgbGV0IGFyck5hbWVzID0gbGliTmFtZXMuc3BsaXQoXCI7XCIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSBhcnJOYW1lcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICBsZXQgbGliID0gcmVxdWlyZUxpYkNvcmUoYXJyTmFtZXNbaV0pO1xyXG4gICAgICAgIGlmIChsaWIpIHJldHVybiBsaWI7XHJcbiAgICB9XHJcbiAgICBpZiAoZXJyTWVzc2FnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBpbml0aWFsaXplIFwiICsgbGliTmFtZXMgKyBcIi4gIFwiICsgZXJyTWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqIFJldHVybnMgdGhlICdsaWJOYW1lJyBtb2R1bGUgaWYgbG9hZGVkIG9yIGVsc2UgcmV0dXJucyB1bmRlZmluZWQgKi9cclxuZnVuY3Rpb24gcmVxdWlyZUxpYkNvcmUobGliTmFtZTogc3RyaW5nKSB7XHJcbiAgICBsZXQgd2luID0gd2luZG93IHx8IChnbG9iYWwgPyBnbG9iYWwud2luZG93IDogdW5kZWZpbmVkKTtcclxuICAgIGlmICghd2luKSByZXR1cm47IC8vIE11c3QgcnVuIGluIGEgYnJvd3Nlci4gVG9kbzogYWRkIGNvbW1vbmpzIHN1cHBvcnRcclxuXHJcbiAgICAvLyBnZXQgbGlicmFyeSBmcm9tIGJyb3dzZXIgZ2xvYmFscyBpZiB3ZSBjYW5cclxuICAgIGxldCBsaWIgPSB3aW5bbGliTmFtZV07XHJcbiAgICBpZiAobGliKSByZXR1cm4gbGliO1xyXG5cclxuICAgIC8vIGlmIHJlcXVpcmUgZXhpc3RzLCBtYXliZSByZXF1aXJlIGNhbiBnZXQgaXQuXHJcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBzeW5jaHJvbm91cyBzbyBpdCBjYW4ndCBsb2FkIG1vZHVsZXMgd2l0aCBBTUQuXHJcbiAgICAvLyBJdCBjYW4gb25seSBvYnRhaW4gbW9kdWxlcyBmcm9tIHJlcXVpcmUgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBsb2FkZWQuXHJcbiAgICAvLyBEZXZlbG9wZXIgc2hvdWxkIGJvb3RzdHJhcCBzdWNoIHRoYXQgdGhlIGJyZWV6ZSBtb2R1bGVcclxuICAgIC8vIGxvYWRzIGFmdGVyIGFsbCBvdGhlciBsaWJyYXJpZXMgdGhhdCBicmVlemUgc2hvdWxkIGZpbmQgd2l0aCB0aGlzIG1ldGhvZFxyXG4gICAgLy8gU2VlIGRvY3VtZW50YXRpb25cclxuICAgIGxldCByID0gd2luLnJlcXVpcmU7XHJcbiAgICBpZiAocikgeyAvLyBpZiByZXF1aXJlIGV4aXN0c1xyXG4gICAgICAgIGlmIChyLmRlZmluZWQpIHsgLy8gcmVxdWlyZS5kZWZpbmVkIGlzIG5vdCBzdGFuZGFyZCBhbmQgbWF5IG5vdCBleGlzdFxyXG4gICAgICAgICAgICAvLyByZXF1aXJlLmRlZmluZWQgcmV0dXJucyB0cnVlIGlmIG1vZHVsZSBoYXMgYmVlbiBsb2FkZWRcclxuICAgICAgICAgICAgcmV0dXJuIHIuZGVmaW5lZChsaWJOYW1lKSA/IHIobGliTmFtZSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcmVxdWlyZS5kZWZpbmVkIGRvZXMgbm90IGV4aXN0IHNvIHdlIGhhdmUgdG8gY2FsbCByZXF1aXJlKCdsaWJOYW1lJykgZGlyZWN0bHkuXHJcbiAgICAgICAgICAgIC8vIFRoZSByZXF1aXJlKCdsaWJOYW1lJykgb3ZlcmxvYWQgaXMgc3luY2hyb25vdXMgYW5kIGRvZXMgbm90IGxvYWQgbW9kdWxlcy5cclxuICAgICAgICAgICAgLy8gSXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGUgbW9kdWxlIGlzbid0IGFscmVhZHkgbG9hZGVkLlxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHIobGliTmFtZSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmUoJ2xpYk5hbWUnKSB0aHJldyBiZWNhdXNlIG1vZHVsZSBub3QgbG9hZGVkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiBFeGVjdXRlIGZuIHdoaWxlIG9iaiBoYXMgdGVtcFZhbHVlIGZvciBwcm9wZXJ0eSAqL1xyXG5mdW5jdGlvbiB1c2luZyhvYmo6IE9iamVjdCwgcHJvcGVydHk6IHN0cmluZywgdGVtcFZhbHVlOiBhbnksIGZuOiAoKSA9PiBhbnkpIHtcclxuICAgIGxldCBvcmlnaW5hbFZhbHVlID0gb2JqW3Byb3BlcnR5XTtcclxuICAgIGlmICh0ZW1wVmFsdWUgPT09IG9yaWdpbmFsVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZm4oKTtcclxuICAgIH1cclxuICAgIG9ialtwcm9wZXJ0eV0gPSB0ZW1wVmFsdWU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBpZiAob3JpZ2luYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbcHJvcGVydHldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9ialtwcm9wZXJ0eV0gPSBvcmlnaW5hbFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqIENhbGwgc3RhdGUgPSBzdGFydEZuKCksIGNhbGwgZm4oKSwgY2FsbCBlbmRGbihzdGF0ZSkgKi9cclxuZnVuY3Rpb24gd3JhcEV4ZWN1dGlvbihzdGFydEZuOiAoKSA9PiBhbnksIGVuZEZuOiAoc3RhdGU6IGFueSkgPT4gYW55LCBmbjogKCkgPT4gYW55KSB7XHJcbiAgICBsZXQgc3RhdGU6IGFueTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgc3RhdGUgPSBzdGFydEZuKCk7XHJcbiAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoc3RhdGUpID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBzdGF0ZS5lcnJvciA9IGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IGU7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIGVuZEZuKHN0YXRlKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqIFJlbWVtYmVyICYgcmV0dXJuIHRoZSB2YWx1ZSBvZiBmbigpIHdoZW4gaXQgd2FzIGNhbGxlZCB3aXRoIGl0cyBjdXJyZW50IGFyZ3MgKi9cclxuZnVuY3Rpb24gbWVtb2l6ZShmbjogYW55KTogYW55IHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSBhcnJheVNsaWNlKDxhbnk+YXJndW1lbnRzKSxcclxuICAgICAgICAgICAgaGFzaCA9IFwiXCIsXHJcbiAgICAgICAgICAgIGkgPSBhcmdzLmxlbmd0aCxcclxuICAgICAgICAgICAgY3VycmVudEFyZzogYW55ID0gbnVsbDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcmcgPSBhcmdzW2ldO1xyXG4gICAgICAgICAgICBoYXNoICs9IChjdXJyZW50QXJnID09PSBPYmplY3QoY3VycmVudEFyZykpID8gSlNPTi5zdHJpbmdpZnkoY3VycmVudEFyZykgOiBjdXJyZW50QXJnO1xyXG4gICAgICAgICAgICBmbi5tZW1vaXplIHx8IChmbi5tZW1vaXplID0ge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGhhc2ggaW4gZm4ubWVtb2l6ZSkgP1xyXG4gICAgICAgICAgICBmbi5tZW1vaXplW2hhc2hdIDpcclxuICAgICAgICAgICAgZm4ubWVtb2l6ZVtoYXNoXSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VXVpZCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XHJcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGR1cmF0aW9uVG9TZWNvbmRzKGR1cmF0aW9uOiBzdHJpbmcpIHtcclxuICAgIC8vIGJhc2ljIGFsZ29yaXRobSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9uZXphc2EvaXNvODYwMS1qcy1wZXJpb2RcclxuICAgIGlmICh0eXBlb2YgZHVyYXRpb24gIT09IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSVNPODYwMSBkdXJhdGlvbiAnXCIgKyBkdXJhdGlvbiArIFwiJ1wiKTtcclxuXHJcbiAgICAvLyByZWdleCBzcGxpdHMgYXMgZm9sbG93cyAtIGdycDAsIGdycDEsIHksIG0sIGQsIGdycDIsIGgsIG0sIHNcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgMCAgICAgMSAgICAgMiAgMyAgNCAgNSAgICAgNiAgNyAgOFxyXG4gICAgbGV0IHN0cnVjdCA9IC9eUCgoXFxkK1kpPyhcXGQrTSk/KFxcZCtEKT8pPyhUKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT8kLy5leGVjKGR1cmF0aW9uKTtcclxuICAgIGlmICghc3RydWN0KSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIElTTzg2MDEgZHVyYXRpb24gJ1wiICsgZHVyYXRpb24gKyBcIidcIik7XHJcblxyXG4gICAgbGV0IHltZGhtc0luZGV4ZXMgPSBbMiwgMywgNCwgNiwgNywgOF07IC8vIC0+IGdycDEseSxtLGQsZ3JwMixoLG0sc1xyXG4gICAgbGV0IGZhY3RvcnMgPSBbMzExMDQwMDAsIC8vIHllYXIgKDM2MCoyNCo2MCo2MClcclxuICAgICAgICAyNTkyMDAwLCAgICAgICAgICAgICAvLyBtb250aCAoMzAqMjQqNjAqNjApXHJcbiAgICAgICAgODY0MDAsICAgICAgICAgICAgICAgLy8gZGF5ICgyNCo2MCo2MClcclxuICAgICAgICAzNjAwLCAgICAgICAgICAgICAgICAvLyBob3VyICg2MCo2MClcclxuICAgICAgICA2MCwgICAgICAgICAgICAgICAgICAvLyBtaW51dGUgKDYwKVxyXG4gICAgICAgIDFdOyAgICAgICAgICAgICAgICAgIC8vIHNlY29uZCAoMSlcclxuXHJcbiAgICBsZXQgc2Vjb25kcyA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xyXG4gICAgICAgIGxldCBkaWdpdCA9IHN0cnVjdFt5bWRobXNJbmRleGVzW2ldXTtcclxuICAgICAgICAvLyByZW1vdmUgbGV0dGVycywgcmVwbGFjZSBieSAwIGlmIG5vdCBkZWZpbmVkXHJcbiAgICAgICAgZGlnaXQgPSA8YW55PihkaWdpdCA/ICtkaWdpdC5yZXBsYWNlKC9bQS1aYS16XSsvZywgJycpIDogMCk7XHJcbiAgICAgICAgc2Vjb25kcyArPSA8YW55PmRpZ2l0ICogZmFjdG9yc1tpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZWNvbmRzO1xyXG5cclxufVxyXG5cclxuLy8gaXMgZnVuY3Rpb25zXHJcblxyXG5mdW5jdGlvbiBub29wKCkge1xyXG4gICAgLy8gZG9lcyBub3RoaW5nXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlkZW50aXR5KHg6IGFueSk6IGFueSB7XHJcbiAgICByZXR1cm4geDtcclxufVxyXG5cclxuZnVuY3Rpb24gY2xhc3NvZihvOiBhbnkpIHtcclxuICAgIGlmIChvID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xyXG4gICAgfVxyXG4gICAgaWYgKG8gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNEYXRlKG86IGFueSkge1xyXG4gICAgcmV0dXJuIGNsYXNzb2YobykgPT09IFwiZGF0ZVwiICYmICFpc05hTihvLmdldFRpbWUoKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRGF0ZVN0cmluZyhzOiBzdHJpbmcpIHtcclxuICAgIC8vIGxldCByeCA9IC9eKFxcZHs0fXxbK1xcLV1cXGR7Nn0pKD86LShcXGR7Mn0pKD86LShcXGR7Mn0pKT8pPyg/OlQoXFxkezJ9KTooXFxkezJ9KSg/OjooXFxkezJ9KSg/OlxcLihcXGR7M30pKT8pPyg/OihaKXwoWytcXC1dKShcXGR7Mn0pKD86OihcXGR7Mn0pKT8pPyk/JC87XHJcbiAgICBsZXQgcnggPSAvXigoXFxkezR9LVswMV1cXGQtWzAtM11cXGRUWzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGRcXC5cXGQrKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSl8KFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSl8KFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSkpJC87XHJcbiAgICByZXR1cm4gKHR5cGVvZiBzID09PSBcInN0cmluZ1wiKSAmJiByeC50ZXN0KHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG86IGFueSkge1xyXG4gICAgcmV0dXJuIGNsYXNzb2YobykgPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG5cclxuLy8gZnVuY3Rpb24gaXNTdHJpbmcobzogYW55KSB7XHJcbi8vICAgICByZXR1cm4gKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKTtcclxuLy8gfVxyXG5cclxuLy8gZnVuY3Rpb24gaXNPYmplY3QobzogYW55KSB7XHJcbi8vICAgICByZXR1cm4gKHR5cGVvZiBvID09PSBcIm9iamVjdFwiKTtcclxuLy8gfVxyXG5cclxuZnVuY3Rpb24gaXNHdWlkKHZhbHVlOiBhbnkpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSAmJiAvW2EtZkEtRlxcZF17OH0tKD86W2EtZkEtRlxcZF17NH0tKXszfVthLWZBLUZcXGRdezEyfS8udGVzdCh2YWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRHVyYXRpb24odmFsdWU6IGFueSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpICYmIC9eKC18KT9QW1RdP1tcXGRcXC4sXFwtXStbWU1EVEhTXS8udGVzdCh2YWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRW1wdHkob2JqOiBhbnkpIHtcclxuICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNOdW1lcmljKG46IGFueSkge1xyXG4gICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcclxufVxyXG5cclxuXHJcblxyXG4vLyBlbmQgb2YgaXMgRnVuY3Rpb25zXHJcblxyXG4vLyBzdHJpbmcgZnVuY3Rpb25zXHJcblxyXG5mdW5jdGlvbiBzdHJpbmdTdGFydHNXaXRoKHN0cjogc3RyaW5nLCBwcmVmaXg6IHN0cmluZykge1xyXG4gICAgLy8gcmV0dXJucyB0cnVlIGZvciBlbXB0eSBzdHJpbmcgb3IgbnVsbCBwcmVmaXhcclxuICAgIGlmICgoIXN0cikpIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChwcmVmaXggPT09IFwiXCIgfHwgcHJlZml4ID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHByZWZpeCwgMCkgPT09IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ0VuZHNXaXRoKHN0cjogc3RyaW5nLCBzdWZmaXg6IHN0cmluZykge1xyXG4gICAgLy8gcmV0dXJucyB0cnVlIGZvciBlbXB0eSBzdHJpbmcgb3IgbnVsbCBzdWZmaXhcclxuICAgIGlmICgoIXN0cikpIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChzdWZmaXggPT09IFwiXCIgfHwgc3VmZml4ID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcclxufVxyXG5cclxuLy8gQmFzZWQgb24gZnJhZ21lbnQgZnJvbSBEZWFuIEVkd2FyZHMnIEJhc2UgMiBsaWJyYXJ5XHJcbi8qKiBmb3JtYXQoXCJhICUxIGFuZCBhICUyXCIsIFwiY2F0XCIsIFwiZG9nXCIpIC0+IFwiYSBjYXQgYW5kIGEgZG9nXCIgKi9cclxuZnVuY3Rpb24gZm9ybWF0U3RyaW5nKHN0cjogc3RyaW5nLCAuLi5wYXJhbXM6IGFueVtdKSB7XHJcbiAgICBsZXQgYXJncyA9IGFyZ3VtZW50cztcclxuICAgIGxldCBwYXR0ZXJuID0gUmVnRXhwKFwiJShbMS1cIiArIChhcmd1bWVudHMubGVuZ3RoIC0gMSkgKyBcIl0pXCIsIFwiZ1wiKTtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZShwYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsIGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGFyZ3NbaW5kZXhdO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcyMjU0MDcvY29udmVydC1jYW1lbGNhc2V0ZXh0LXRvLWNhbWVsLWNhc2UtdGV4dFxyXG4vKiogQ2hhbmdlIHRleHQgdG8gdGl0bGUgY2FzZSB3aXRoIHNwYWNlcywgZS5nLiAnbXlQcm9wZXJ0eU5hbWUxMicgdG8gJ015IFByb3BlcnR5IE5hbWUgMTInICovXHJcbmxldCBjYW1lbEVkZ2VzID0gLyhbQS1aXSg/PVtBLVpdW2Etel0pfFteQS1aXSg/PVtBLVpdKXxbYS16QS1aXSg/PVteYS16QS1aXSkpL2c7XHJcbmZ1bmN0aW9uIHRpdGxlQ2FzZVNwYWNlKHRleHQ6IHN0cmluZykge1xyXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZShjYW1lbEVkZ2VzLCAnJDEgJyk7XHJcbiAgICB0ZXh0ID0gdGV4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleHQuc2xpY2UoMSk7XHJcbiAgICByZXR1cm4gdGV4dDtcclxufVxyXG5cclxuLy8gZW5kIG9mIHN0cmluZyBmdW5jdGlvbnNcclxuXHJcbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXHJcbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWNvbnZlbnRpb25zOnNhZmVfbWV0YV9wcm9ncmFtbWluZ1xyXG5mdW5jdGlvbiB1bmN1cnJ5KGY6IGFueSkge1xyXG4gICAgbGV0IGNhbGwgPSBGdW5jdGlvbi5jYWxsO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxufVxyXG5cclxuLy8gc2hpbXNcclxuXHJcbmlmICghT2JqZWN0LmNyZWF0ZSkge1xyXG4gICAgT2JqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChwYXJlbnQ6IGFueSkge1xyXG4gICAgICAgIGxldCBGID0gPGFueT5mdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBGLnByb3RvdHlwZSA9IHBhcmVudDtcclxuICAgICAgICByZXR1cm4gbmV3IEYoKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIC8vIG5vdCBhbGwgbWV0aG9kcyBhYm92ZSBhcmUgZXhwb3J0ZWRcclxuZXhwb3J0IGNvbnN0IGNvcmUgPSB7XHJcbiAgICBpc0VTNVN1cHBvcnRlZDogaXNFUzVTdXBwb3J0ZWQsXHJcbiAgICBoYXNPd25Qcm9wZXJ0eTogaGFzT3duUHJvcGVydHksXHJcbiAgICBnZXRPd25Qcm9wZXJ0eVZhbHVlczogZ2V0T3duUHJvcGVydHlWYWx1ZXMsXHJcbiAgICBnZXRQcm9wZXJ0eURlc2NyaXB0b3I6IGdldFByb3BEZXNjcmlwdG9yLFxyXG4gICAgb2JqZWN0Rm9yRWFjaDogb2JqZWN0Rm9yRWFjaCxcclxuICAgIG9iamVjdEZpcnN0OiBvYmplY3RGaXJzdCxcclxuICAgIG9iamVjdE1hcDogb2JqZWN0TWFwLCAvLyBUT0RPOiByZXBsYWNlIHRoaXMgd2l0aCBzb21ldGhpbmcgc3Ryb25nbHkgdHlwZWQuXHJcbiAgICBleHRlbmQ6IGV4dGVuZCxcclxuICAgIHByb3BFcTogcHJvcEVxLFxyXG4gICAgcHJvcHNFcTogcHJvcHNFcSxcclxuICAgIHBsdWNrOiBwbHVjayxcclxuICAgIG1hcDogbWFwLFxyXG4gICAgcmVzb2x2ZVByb3BlcnRpZXM6IHJlc29sdmVQcm9wZXJ0aWVzLFxyXG4gICAgc2V0QXNEZWZhdWx0OiBzZXRBc0RlZmF1bHQsXHJcbiAgICB1cGRhdGVXaXRoRGVmYXVsdHM6IHVwZGF0ZVdpdGhEZWZhdWx0cyxcclxuICAgIGdldEFycmF5OiBnZXRBcnJheSxcclxuICAgIHRvQXJyYXk6IHRvQXJyYXksXHJcbiAgICBhcnJheUVxdWFsczogYXJyYXlFcXVhbHMsXHJcbiAgICBhcnJheVNsaWNlOiBhcnJheVNsaWNlLFxyXG4gICAgYXJyYXlGaXJzdDogYXJyYXlGaXJzdCxcclxuICAgIGFycmF5SW5kZXhPZjogYXJyYXlJbmRleE9mLFxyXG4gICAgYXJyYXlSZW1vdmVJdGVtOiBhcnJheVJlbW92ZUl0ZW0sXHJcbiAgICBhcnJheVppcDogYXJyYXlaaXAsXHJcbiAgICBhcnJheUFkZEl0ZW1VbmlxdWU6IGFycmF5QWRkSXRlbVVuaXF1ZSxcclxuICAgIGFycmF5RmxhdE1hcDogYXJyYXlGbGF0TWFwLFxyXG5cclxuICAgIHJlcXVpcmVMaWI6IHJlcXVpcmVMaWIsXHJcbiAgICB1c2luZzogdXNpbmcsXHJcbiAgICB3cmFwRXhlY3V0aW9uOiB3cmFwRXhlY3V0aW9uLFxyXG5cclxuICAgIG1lbW9pemU6IG1lbW9pemUsXHJcbiAgICBnZXRVdWlkOiBnZXRVdWlkLFxyXG4gICAgZHVyYXRpb25Ub1NlY29uZHM6IGR1cmF0aW9uVG9TZWNvbmRzLFxyXG5cclxuICAgIGlzU2V0dGFibGU6IGlzU2V0dGFibGUsXHJcblxyXG4gICAgaXNEYXRlOiBpc0RhdGUsXHJcbiAgICBpc0RhdGVTdHJpbmc6IGlzRGF0ZVN0cmluZyxcclxuICAgIGlzR3VpZDogaXNHdWlkLFxyXG4gICAgaXNEdXJhdGlvbjogaXNEdXJhdGlvbixcclxuICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXHJcbiAgICBpc0VtcHR5OiBpc0VtcHR5LFxyXG4gICAgaXNOdW1lcmljOiBpc051bWVyaWMsXHJcblxyXG4gICAgaWRlbnRpdHk6IGlkZW50aXR5LFxyXG4gICAgbm9vcDogbm9vcCxcclxuXHJcbiAgICBzdHJpbmdTdGFydHNXaXRoOiBzdHJpbmdTdGFydHNXaXRoLFxyXG4gICAgc3RyaW5nRW5kc1dpdGg6IHN0cmluZ0VuZHNXaXRoLFxyXG4gICAgZm9ybWF0U3RyaW5nOiBmb3JtYXRTdHJpbmcsXHJcbiAgICB0aXRsZUNhc2U6IHRpdGxlQ2FzZVNwYWNlLFxyXG5cclxuICAgIHRvSnNvbjogdG9Kc29uLFxyXG4gICAgdG9KU09OU2FmZTogdG9KU09OU2FmZSxcclxuICAgIHRvSlNPTlNhZmVSZXBsYWNlcjogdG9KU09OU2FmZVJlcGxhY2VyLFxyXG59O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFcnJvckNhbGxiYWNrIHtcclxuICAgIChlcnJvcjogYW55KTogdm9pZDtcclxufVxyXG5cclxuXHJcbi8vIFVudXNlZFxyXG4vKlxyXG4vLyByZXR1cm5zIHRydWUgZm9yIGJvb2xlYW5zLCBudW1iZXJzLCBzdHJpbmdzIGFuZCBkYXRlc1xyXG4vLyBmYWxzZSBmb3IgbnVsbCwgYW5kIG5vbi1kYXRlIG9iamVjdHMsIGZ1bmN0aW9ucywgYW5kIGFycmF5c1xyXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmo6IGFueSkge1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyB0cnVlIGZvciBudW1iZXJzLCBzdHJpbmdzLCBib29sZWFucyBhbmQgbnVsbCwgZmFsc2UgZm9yIG9iamVjdHNcclxuICAgIGlmIChvYmogIT0gT2JqZWN0KG9iaikpIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIGlzRGF0ZShvYmopO1xyXG59XHJcblxyXG4qLyJdfQ==