import { core } from './core';
import { assertParam } from './assert-param';
function publishCore(that, data, errorCallback) {
    let subscribers = that._subscribers;
    if (!subscribers)
        return true;
    // subscribers from outer scope.
    subscribers.forEach(function (s) {
        try {
            s.callback(data);
        }
        catch (e) {
            e.context = "unable to publish on topic: " + that.name;
            if (errorCallback) {
                errorCallback(e);
            }
            else if (that._defaultErrorCallback) {
                that._defaultErrorCallback(e);
            }
            else {
                fallbackErrorHandler(e);
            }
        }
    });
}
function fallbackErrorHandler(e) {
    // TODO: maybe log this
    // for now do nothing;
}
/**
Class to support basic event publication and subscription semantics.
@dynamic
**/
export class BreezeEvent {
    /**
    Constructor for an Event
    >     salaryEvent = new BreezeEvent("salaryEvent", person);
    @param name - The name of the event.
    @param publisher - The object that will be doing the publication. i.e. the object to which this event is attached.
    @param defaultErrorCallback - Function to call when an error occurs during subscription execution.
    If omitted then subscriber notification failures will be ignored.
    **/
    constructor(name, publisher, defaultErrorCallback) {
        /**
        Unsubscribe from this event.
        >      // Assume order is a preexisting 'order' entity
        >      let token = order.entityAspect.propertyChanged.subscribe(function (pcEvent) {
        >              // do something
        >      });
        >      // sometime later
        >      order.entityAspect.propertyChanged.unsubscribe(token);
        @param unsubKey - The value returned from the 'subscribe' method may be used to unsubscribe here.
        @return Whether unsubscription occured. This will return false if already unsubscribed or if the key simply
        cannot be found.
        **/
        this.unsubscribe = function (unsubKey) {
            if (!this._subscribers)
                return false;
            let subs = this._subscribers;
            let ix = core.arrayIndexOf(subs, function (s) {
                return s.unsubKey === unsubKey;
            });
            if (ix !== -1) {
                subs.splice(ix, 1);
                if (subs.length === 0) {
                    this._subscribers = null;
                }
                return true;
            }
            else {
                return false;
            }
        };
        assertParam(name, "eventName").isNonEmptyString().check();
        assertParam(publisher, "publisher").isObject().check();
        this.name = name;
        // register the name
        BreezeEvent.__eventNameMap[name] = true;
        this.publisher = publisher;
        if (defaultErrorCallback) {
            this._defaultErrorCallback = defaultErrorCallback;
        }
    }
    /**
    Publish data for this event.
    >      // Assume 'salaryEvent' is previously constructed Event
    >      salaryEvent.publish( { eventType: "payRaise", amount: 100 });
  
    This event can also be published asychronously
    >      salaryEvent.publish( { eventType: "payRaise", amount: 100 }, true);
  
    And we can add a handler in case the subscriber 'mishandles' the event.
    >      salaryEvent.publish( { eventType: "payRaise", amount: 100 }, true, function(error) {
    >          // do something with the 'error' object
    >      });
    @param data - Data to publish
    @param publishAsync - (default=false) Whether to publish asynchonously or not.
    @param errorCallback - Function to be called for any errors that occur during publication. If omitted,
    errors will be eaten.
    @return false if event is disabled; true otherwise.
    **/
    publish(data, publishAsync = false, errorCallback) {
        if (!BreezeEvent._isEnabled(this.name, this.publisher))
            return false;
        if (publishAsync === true) {
            setTimeout(publishCore, 0, this, data, errorCallback);
        }
        else {
            publishCore(this, data, errorCallback);
        }
        return true;
    }
    /**
    Publish data for this event asynchronously.
    >      // Assume 'salaryEvent' is previously constructed Event
    >      salaryEvent.publishAsync( { eventType: "payRaise", amount: 100 });
  
    And we can add a handler in case the subscriber 'mishandles' the event.
    >      salaryEvent.publishAsync( { eventType: "payRaise", amount: 100 }, function(error) {
    >          // do something with the 'error' object
    >      });
    @param data - Data to publish
    @param errorCallback - Function to be called for any errors that occur during publication. If omitted,
    errors will be eaten.
    **/
    publishAsync(data, errorCallback) {
        this.publish(data, true, errorCallback);
    }
    /**
    Subscribe to this event.
    >      // Assume 'salaryEvent' is previously constructed Event
    >      salaryEvent.subscribe(function (eventArgs) {
    >          if (eventArgs.eventType === "payRaise") {
    >              // do something
    >          }
    >      });
  
    There are several built in Breeze events, such as [[EntityAspect.propertyChanged]], [[EntityAspect.validationErrorsChanged]] as well.
    >      // Assume order is a preexisting 'order' entity
    >      order.entityAspect.propertyChanged.subscribe(function (pcEvent) {
    >          if ( pcEvent.propertyName === "OrderDate") {
    >              // do something
    >          }
    >      });
    @param callback- Function to be called whenever 'data' is published for this event.
    @param callback.data - {Object} Whatever 'data' was published.  This should be documented on the specific event.
    @return This is a key for 'unsubscription'.  It can be passed to the 'unsubscribe' method.
    **/
    subscribe(callback) {
        if (!this._subscribers) {
            this._subscribers = [];
        }
        let unsubKey = BreezeEvent.__nextUnsubKey;
        this._subscribers.push({ unsubKey: unsubKey, callback: callback });
        ++BreezeEvent.__nextUnsubKey;
        return unsubKey;
    }
    /** remove all subscribers */
    clear() {
        this._subscribers = null;
    }
    /** event bubbling - document later. */
    // null or undefined 'getParentFn' means Event does not need to bubble i.e. that it is always enabled - .
    static bubbleEvent(target, getParentFn) {
        target._getEventParent = getParentFn || null;
    }
    /**
    Enables or disables the named event for an object and all of its children.
    >      BreezeEvent.enable(“propertyChanged”, myEntityManager, false)
  
    will disable all EntityAspect.propertyChanged events within a EntityManager.
    >      BreezeEvent.enable(“propertyChanged”, myEntityManager, true)
  
    will enable all EntityAspect.propertyChanged events within a EntityManager.
    >      BreezeEvent.enable(“propertyChanged”, myEntity.entityAspect, false)
  
    will disable EntityAspect.propertyChanged events for a specific entity.
    >      BreezeEvent.enable(“propertyChanged”, myEntity.entityAspect, null)
  
    will removes any enabling / disabling at the entity aspect level so now any 'Event.enable' calls at the EntityManager level,
    made either previously or in the future, will control notification.
    >      BreezeEvent.enable(“validationErrorsChanged”, myEntityManager, function(em) {
    >          return em.customTag === “blue”;
    >      })
  
  
    will either enable or disable myEntityManager based on the current value of a ‘customTag’ property on myEntityManager.
    Note that this is dynamic, changing the customTag value will cause events to be enabled or disabled immediately.
    @param eventName - The name of the event.
    @param target - The object at which enabling or disabling will occur.  All event notifications that occur to this object or
    children of this object will be enabled or disabled.
    @param isEnabled - A boolean, a null or a function that returns either a boolean or a null.
    **/
    static enable(eventName, obj, isEnabled) {
        assertParam(eventName, "eventName").isNonEmptyString().check();
        assertParam(obj, "obj").isObject().check();
        assertParam(isEnabled, "isEnabled").isBoolean().isOptional().or().isFunction().check();
        let ob = obj;
        if (!ob._$eventMap) {
            ob._$eventMap = {};
        }
        ob._$eventMap[eventName] = isEnabled;
    }
    /**
    Returns whether for a specific event and a specific object and its children, notification is enabled or disabled or not set.
    >      BreezeEvent.isEnabled(“propertyChanged”, myEntityManager)
    >
    @param eventName - The name of the event.
    @param target - The object for which we want to know if notifications are enabled.
    @return A null is returned if this value has not been set.
    **/
    static isEnabled(eventName, obj) {
        assertParam(eventName, "eventName").isNonEmptyString().check();
        assertParam(obj, "obj").isObject().check();
        // null is ok - it just means that the object is at the top level.
        if (obj._getEventParent === undefined) {
            throw new Error("This object does not support event enabling/disabling");
        }
        // return ctor._isEnabled(getFullEventName(eventName), obj);
        return BreezeEvent._isEnabled(eventName, 3);
    }
}
/** @hidden @internal */
BreezeEvent.__eventNameMap = {};
/** @hidden @internal */
BreezeEvent.__nextUnsubKey = 1;
/** @hidden @internal */
BreezeEvent._isEnabled = function (eventName, obj) {
    let isEnabled = null;
    let ob = obj;
    let eventMap = ob._$eventMap;
    if (eventMap) {
        isEnabled = eventMap[eventName];
    }
    if (isEnabled != null) {
        if (typeof isEnabled === 'function') {
            return !!isEnabled(obj);
        }
        else {
            return !!isEnabled;
        }
    }
    else {
        let parent = ob._getEventParent && ob._getEventParent();
        if (parent) {
            return !!this._isEnabled(eventName, parent);
        }
        else {
            // default if not explicitly disabled.
            return true;
        }
    }
};
// legacy support - deliberately not typed
core.Event = BreezeEvent;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9icmVlemUtY2xpZW50LyIsInNvdXJjZXMiOlsic3JjL2V2ZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDOUIsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTdDLFNBQVMsV0FBVyxDQUFJLElBQW9CLEVBQUUsSUFBTyxFQUFFLGFBQWlDO0lBQ3RGLElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7SUFDcEMsSUFBSSxDQUFDLFdBQVc7UUFBRSxPQUFPLElBQUksQ0FBQztJQUM5QixnQ0FBZ0M7SUFDaEMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7UUFDN0IsSUFBSTtZQUNGLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDbEI7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLENBQUMsQ0FBQyxPQUFPLEdBQUcsOEJBQThCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN2RCxJQUFJLGFBQWEsRUFBRTtnQkFDakIsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2xCO2lCQUFNLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFO2dCQUNyQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDL0I7aUJBQU07Z0JBQ0wsb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDekI7U0FDRjtJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQVMsb0JBQW9CLENBQUMsQ0FBUTtJQUNwQyx1QkFBdUI7SUFDdkIsc0JBQXNCO0FBQ3hCLENBQUM7QUFTRDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sV0FBVztJQWdCdEI7Ozs7Ozs7T0FPRztJQUNILFlBQVksSUFBWSxFQUFFLFNBQWlCLEVBQUUsb0JBQXdDO1FBMkZyRjs7Ozs7Ozs7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QUM1RCxPQUFPLFdBQVcsQ0FBQyxVQUFVLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzlDLENBQUM7O0FBbE5ELHdCQUF3QjtBQUNqQiwwQkFBYyxHQUFHLEVBQUUsQ0FBQztBQUMzQix3QkFBd0I7QUFDakIsMEJBQWMsR0FBRyxDQUFDLENBQUM7QUFpTjFCLHdCQUF3QjtBQUNqQixzQkFBVSxHQUFHLFVBQVUsU0FBaUIsRUFBRSxHQUFXO0lBQzFELElBQUksU0FBUyxHQUFRLElBQUksQ0FBQztJQUMxQixJQUFJLEVBQUUsR0FBUSxHQUFHLENBQUM7SUFDbEIsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQztJQUM3QixJQUFJLFFBQVEsRUFBRTtRQUNaLFNBQVMsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDakM7SUFDRCxJQUFJLFNBQVMsSUFBSSxJQUFJLEVBQUU7UUFDckIsSUFBSSxPQUFPLFNBQVMsS0FBSyxVQUFVLEVBQUU7WUFDbkMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3pCO2FBQU07WUFDTCxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUM7U0FDcEI7S0FDRjtTQUFNO1FBQ0wsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDLGVBQWUsSUFBSSxFQUFFLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDeEQsSUFBSSxNQUFNLEVBQUU7WUFDVixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUM3QzthQUFNO1lBQ0wsc0NBQXNDO1lBQ3RDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7S0FDRjtBQUNILENBQUMsQ0FBQztBQUtKLDBDQUEwQztBQUN6QyxJQUFZLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvcmUgfSBmcm9tICcuL2NvcmUnO1xyXG5pbXBvcnQgeyBhc3NlcnRQYXJhbSB9IGZyb20gJy4vYXNzZXJ0LXBhcmFtJztcclxuXHJcbmZ1bmN0aW9uIHB1Ymxpc2hDb3JlPFQ+KHRoYXQ6IEJyZWV6ZUV2ZW50PFQ+LCBkYXRhOiBULCBlcnJvckNhbGxiYWNrPzogKGU6IEVycm9yKSA9PiBhbnkpIHtcclxuICBsZXQgc3Vic2NyaWJlcnMgPSB0aGF0Ll9zdWJzY3JpYmVycztcclxuICBpZiAoIXN1YnNjcmliZXJzKSByZXR1cm4gdHJ1ZTtcclxuICAvLyBzdWJzY3JpYmVycyBmcm9tIG91dGVyIHNjb3BlLlxyXG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHMuY2FsbGJhY2soZGF0YSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGUuY29udGV4dCA9IFwidW5hYmxlIHRvIHB1Ymxpc2ggb24gdG9waWM6IFwiICsgdGhhdC5uYW1lO1xyXG4gICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgIGVycm9yQ2FsbGJhY2soZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhhdC5fZGVmYXVsdEVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICB0aGF0Ll9kZWZhdWx0RXJyb3JDYWxsYmFjayhlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmYWxsYmFja0Vycm9ySGFuZGxlcihlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmYWxsYmFja0Vycm9ySGFuZGxlcihlOiBFcnJvcikge1xyXG4gIC8vIFRPRE86IG1heWJlIGxvZyB0aGlzXHJcbiAgLy8gZm9yIG5vdyBkbyBub3RoaW5nO1xyXG59XHJcblxyXG5cclxuLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaXB0aW9uIHtcclxuICB1bnN1YktleTogbnVtYmVyO1xyXG4gIGNhbGxiYWNrOiAoZGF0YTogYW55KSA9PiBhbnk7XHJcbn1cclxuXHJcbi8qKlxyXG5DbGFzcyB0byBzdXBwb3J0IGJhc2ljIGV2ZW50IHB1YmxpY2F0aW9uIGFuZCBzdWJzY3JpcHRpb24gc2VtYW50aWNzLlxyXG5AZHluYW1pY1xyXG4qKi9cclxuZXhwb3J0IGNsYXNzIEJyZWV6ZUV2ZW50PFQ+IHtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgX19ldmVudE5hbWVNYXAgPSB7fTtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgX19uZXh0VW5zdWJLZXkgPSAxO1xyXG4gIC8qKiBUaGUgbmFtZSBvZiB0aGlzIEV2ZW50ICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgb2JqZWN0IGRvaW5nIHRoZSBwdWJsaWNhdGlvbi4gaS5lLiB0aGUgb2JqZWN0IHRvIHdoaWNoIHRoaXMgZXZlbnQgaXMgYXR0YWNoZWQuICovXHJcbiAgcHVibGlzaGVyOiBPYmplY3Q7XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9zdWJzY3JpYmVyczogU3Vic2NyaXB0aW9uW107XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2RlZmF1bHRFcnJvckNhbGxiYWNrOiAoZTogRXJyb3IpID0+IGFueTtcclxuXHJcblxyXG4gIC8qKlxyXG4gIENvbnN0cnVjdG9yIGZvciBhbiBFdmVudFxyXG4gID4gICAgIHNhbGFyeUV2ZW50ID0gbmV3IEJyZWV6ZUV2ZW50KFwic2FsYXJ5RXZlbnRcIiwgcGVyc29uKTtcclxuICBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICBAcGFyYW0gcHVibGlzaGVyIC0gVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgZG9pbmcgdGhlIHB1YmxpY2F0aW9uLiBpLmUuIHRoZSBvYmplY3QgdG8gd2hpY2ggdGhpcyBldmVudCBpcyBhdHRhY2hlZC5cclxuICBAcGFyYW0gZGVmYXVsdEVycm9yQ2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGR1cmluZyBzdWJzY3JpcHRpb24gZXhlY3V0aW9uLiBcclxuICBJZiBvbWl0dGVkIHRoZW4gc3Vic2NyaWJlciBub3RpZmljYXRpb24gZmFpbHVyZXMgd2lsbCBiZSBpZ25vcmVkLlxyXG4gICoqL1xyXG4gIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgcHVibGlzaGVyOiBPYmplY3QsIGRlZmF1bHRFcnJvckNhbGxiYWNrPzogKGU6IEVycm9yKSA9PiBhbnkpIHtcclxuICAgIGFzc2VydFBhcmFtKG5hbWUsIFwiZXZlbnROYW1lXCIpLmlzTm9uRW1wdHlTdHJpbmcoKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0ocHVibGlzaGVyLCBcInB1Ymxpc2hlclwiKS5pc09iamVjdCgpLmNoZWNrKCk7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgIC8vIHJlZ2lzdGVyIHRoZSBuYW1lXHJcbiAgICBCcmVlemVFdmVudC5fX2V2ZW50TmFtZU1hcFtuYW1lXSA9IHRydWU7XHJcbiAgICB0aGlzLnB1Ymxpc2hlciA9IHB1Ymxpc2hlcjtcclxuICAgIGlmIChkZWZhdWx0RXJyb3JDYWxsYmFjaykge1xyXG4gICAgICB0aGlzLl9kZWZhdWx0RXJyb3JDYWxsYmFjayA9IGRlZmF1bHRFcnJvckNhbGxiYWNrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUHVibGlzaCBkYXRhIGZvciB0aGlzIGV2ZW50LlxyXG4gID4gICAgICAvLyBBc3N1bWUgJ3NhbGFyeUV2ZW50JyBpcyBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIEV2ZW50XHJcbiAgPiAgICAgIHNhbGFyeUV2ZW50LnB1Ymxpc2goIHsgZXZlbnRUeXBlOiBcInBheVJhaXNlXCIsIGFtb3VudDogMTAwIH0pO1xyXG5cclxuICBUaGlzIGV2ZW50IGNhbiBhbHNvIGJlIHB1Ymxpc2hlZCBhc3ljaHJvbm91c2x5XHJcbiAgPiAgICAgIHNhbGFyeUV2ZW50LnB1Ymxpc2goIHsgZXZlbnRUeXBlOiBcInBheVJhaXNlXCIsIGFtb3VudDogMTAwIH0sIHRydWUpO1xyXG5cclxuICBBbmQgd2UgY2FuIGFkZCBhIGhhbmRsZXIgaW4gY2FzZSB0aGUgc3Vic2NyaWJlciAnbWlzaGFuZGxlcycgdGhlIGV2ZW50LlxyXG4gID4gICAgICBzYWxhcnlFdmVudC5wdWJsaXNoKCB7IGV2ZW50VHlwZTogXCJwYXlSYWlzZVwiLCBhbW91bnQ6IDEwMCB9LCB0cnVlLCBmdW5jdGlvbihlcnJvcikge1xyXG4gID4gICAgICAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlICdlcnJvcicgb2JqZWN0XHJcbiAgPiAgICAgIH0pO1xyXG4gIEBwYXJhbSBkYXRhIC0gRGF0YSB0byBwdWJsaXNoXHJcbiAgQHBhcmFtIHB1Ymxpc2hBc3luYyAtIChkZWZhdWx0PWZhbHNlKSBXaGV0aGVyIHRvIHB1Ymxpc2ggYXN5bmNob25vdXNseSBvciBub3QuXHJcbiAgQHBhcmFtIGVycm9yQ2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGFueSBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgcHVibGljYXRpb24uIElmIG9taXR0ZWQsXHJcbiAgZXJyb3JzIHdpbGwgYmUgZWF0ZW4uXHJcbiAgQHJldHVybiBmYWxzZSBpZiBldmVudCBpcyBkaXNhYmxlZDsgdHJ1ZSBvdGhlcndpc2UuXHJcbiAgKiovXHJcbiAgcHVibGlzaChkYXRhOiBULCBwdWJsaXNoQXN5bmM6IGJvb2xlYW4gPSBmYWxzZSwgZXJyb3JDYWxsYmFjaz86IChlOiBFcnJvcikgPT4gYW55KSB7XHJcblxyXG4gICAgaWYgKCFCcmVlemVFdmVudC5faXNFbmFibGVkKHRoaXMubmFtZSwgdGhpcy5wdWJsaXNoZXIpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgaWYgKHB1Ymxpc2hBc3luYyA9PT0gdHJ1ZSkge1xyXG4gICAgICBzZXRUaW1lb3V0KHB1Ymxpc2hDb3JlLCAwLCB0aGlzLCBkYXRhLCBlcnJvckNhbGxiYWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHB1Ymxpc2hDb3JlKHRoaXMsIGRhdGEsIGVycm9yQ2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBQdWJsaXNoIGRhdGEgZm9yIHRoaXMgZXZlbnQgYXN5bmNocm9ub3VzbHkuXHJcbiAgPiAgICAgIC8vIEFzc3VtZSAnc2FsYXJ5RXZlbnQnIGlzIHByZXZpb3VzbHkgY29uc3RydWN0ZWQgRXZlbnRcclxuICA+ICAgICAgc2FsYXJ5RXZlbnQucHVibGlzaEFzeW5jKCB7IGV2ZW50VHlwZTogXCJwYXlSYWlzZVwiLCBhbW91bnQ6IDEwMCB9KTtcclxuXHJcbiAgQW5kIHdlIGNhbiBhZGQgYSBoYW5kbGVyIGluIGNhc2UgdGhlIHN1YnNjcmliZXIgJ21pc2hhbmRsZXMnIHRoZSBldmVudC5cclxuICA+ICAgICAgc2FsYXJ5RXZlbnQucHVibGlzaEFzeW5jKCB7IGV2ZW50VHlwZTogXCJwYXlSYWlzZVwiLCBhbW91bnQ6IDEwMCB9LCBmdW5jdGlvbihlcnJvcikge1xyXG4gID4gICAgICAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlICdlcnJvcicgb2JqZWN0XHJcbiAgPiAgICAgIH0pO1xyXG4gIEBwYXJhbSBkYXRhIC0gRGF0YSB0byBwdWJsaXNoXHJcbiAgQHBhcmFtIGVycm9yQ2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGFueSBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgcHVibGljYXRpb24uIElmIG9taXR0ZWQsXHJcbiAgZXJyb3JzIHdpbGwgYmUgZWF0ZW4uXHJcbiAgKiovXHJcbiAgcHVibGlzaEFzeW5jKGRhdGE6IFQsIGVycm9yQ2FsbGJhY2s6IChlOiBFcnJvcikgPT4gYW55KSB7XHJcbiAgICB0aGlzLnB1Ymxpc2goZGF0YSwgdHJ1ZSwgZXJyb3JDYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBTdWJzY3JpYmUgdG8gdGhpcyBldmVudC5cclxuICA+ICAgICAgLy8gQXNzdW1lICdzYWxhcnlFdmVudCcgaXMgcHJldmlvdXNseSBjb25zdHJ1Y3RlZCBFdmVudFxyXG4gID4gICAgICBzYWxhcnlFdmVudC5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50QXJncykge1xyXG4gID4gICAgICAgICAgaWYgKGV2ZW50QXJncy5ldmVudFR5cGUgPT09IFwicGF5UmFpc2VcIikge1xyXG4gID4gICAgICAgICAgICAgIC8vIGRvIHNvbWV0aGluZ1xyXG4gID4gICAgICAgICAgfVxyXG4gID4gICAgICB9KTtcclxuXHJcbiAgVGhlcmUgYXJlIHNldmVyYWwgYnVpbHQgaW4gQnJlZXplIGV2ZW50cywgc3VjaCBhcyBbW0VudGl0eUFzcGVjdC5wcm9wZXJ0eUNoYW5nZWRdXSwgW1tFbnRpdHlBc3BlY3QudmFsaWRhdGlvbkVycm9yc0NoYW5nZWRdXSBhcyB3ZWxsLlxyXG4gID4gICAgICAvLyBBc3N1bWUgb3JkZXIgaXMgYSBwcmVleGlzdGluZyAnb3JkZXInIGVudGl0eVxyXG4gID4gICAgICBvcmRlci5lbnRpdHlBc3BlY3QucHJvcGVydHlDaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbiAocGNFdmVudCkge1xyXG4gID4gICAgICAgICAgaWYgKCBwY0V2ZW50LnByb3BlcnR5TmFtZSA9PT0gXCJPcmRlckRhdGVcIikge1xyXG4gID4gICAgICAgICAgICAgIC8vIGRvIHNvbWV0aGluZ1xyXG4gID4gICAgICAgICAgfVxyXG4gID4gICAgICB9KTtcclxuICBAcGFyYW0gY2FsbGJhY2stIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuZXZlciAnZGF0YScgaXMgcHVibGlzaGVkIGZvciB0aGlzIGV2ZW50LlxyXG4gIEBwYXJhbSBjYWxsYmFjay5kYXRhIC0ge09iamVjdH0gV2hhdGV2ZXIgJ2RhdGEnIHdhcyBwdWJsaXNoZWQuICBUaGlzIHNob3VsZCBiZSBkb2N1bWVudGVkIG9uIHRoZSBzcGVjaWZpYyBldmVudC5cclxuICBAcmV0dXJuIFRoaXMgaXMgYSBrZXkgZm9yICd1bnN1YnNjcmlwdGlvbicuICBJdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSAndW5zdWJzY3JpYmUnIG1ldGhvZC5cclxuICAqKi9cclxuICBzdWJzY3JpYmUoY2FsbGJhY2s6IChkYXRhOiBUKSA9PiBhbnkpIHtcclxuICAgIGlmICghdGhpcy5fc3Vic2NyaWJlcnMpIHtcclxuICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdW5zdWJLZXkgPSBCcmVlemVFdmVudC5fX25leHRVbnN1YktleTtcclxuICAgIHRoaXMuX3N1YnNjcmliZXJzLnB1c2goeyB1bnN1YktleTogdW5zdWJLZXksIGNhbGxiYWNrOiBjYWxsYmFjayB9KTtcclxuICAgICsrQnJlZXplRXZlbnQuX19uZXh0VW5zdWJLZXk7XHJcbiAgICByZXR1cm4gdW5zdWJLZXk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBVbnN1YnNjcmliZSBmcm9tIHRoaXMgZXZlbnQuXHJcbiAgPiAgICAgIC8vIEFzc3VtZSBvcmRlciBpcyBhIHByZWV4aXN0aW5nICdvcmRlcicgZW50aXR5XHJcbiAgPiAgICAgIGxldCB0b2tlbiA9IG9yZGVyLmVudGl0eUFzcGVjdC5wcm9wZXJ0eUNoYW5nZWQuc3Vic2NyaWJlKGZ1bmN0aW9uIChwY0V2ZW50KSB7XHJcbiAgPiAgICAgICAgICAgICAgLy8gZG8gc29tZXRoaW5nXHJcbiAgPiAgICAgIH0pO1xyXG4gID4gICAgICAvLyBzb21ldGltZSBsYXRlclxyXG4gID4gICAgICBvcmRlci5lbnRpdHlBc3BlY3QucHJvcGVydHlDaGFuZ2VkLnVuc3Vic2NyaWJlKHRva2VuKTtcclxuICBAcGFyYW0gdW5zdWJLZXkgLSBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSB0aGUgJ3N1YnNjcmliZScgbWV0aG9kIG1heSBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIGhlcmUuXHJcbiAgQHJldHVybiBXaGV0aGVyIHVuc3Vic2NyaXB0aW9uIG9jY3VyZWQuIFRoaXMgd2lsbCByZXR1cm4gZmFsc2UgaWYgYWxyZWFkeSB1bnN1YnNjcmliZWQgb3IgaWYgdGhlIGtleSBzaW1wbHlcclxuICBjYW5ub3QgYmUgZm91bmQuXHJcbiAgKiovXHJcbiAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodW5zdWJLZXk6IG51bWJlcikge1xyXG4gICAgaWYgKCF0aGlzLl9zdWJzY3JpYmVycykgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IHN1YnMgPSB0aGlzLl9zdWJzY3JpYmVycztcclxuICAgIGxldCBpeCA9IGNvcmUuYXJyYXlJbmRleE9mKHN1YnMsIGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgIHJldHVybiBzLnVuc3ViS2V5ID09PSB1bnN1YktleTtcclxuICAgIH0pO1xyXG4gICAgaWYgKGl4ICE9PSAtMSkge1xyXG4gICAgICBzdWJzLnNwbGljZShpeCwgMSk7XHJcbiAgICAgIGlmIChzdWJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKiogcmVtb3ZlIGFsbCBzdWJzY3JpYmVycyAqL1xyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5fc3Vic2NyaWJlcnMgPSA8YW55Pm51bGw7XHJcbiAgfVxyXG5cclxuICAvKiogZXZlbnQgYnViYmxpbmcgLSBkb2N1bWVudCBsYXRlci4gKi9cclxuXHJcbiAgLy8gbnVsbCBvciB1bmRlZmluZWQgJ2dldFBhcmVudEZuJyBtZWFucyBFdmVudCBkb2VzIG5vdCBuZWVkIHRvIGJ1YmJsZSBpLmUuIHRoYXQgaXQgaXMgYWx3YXlzIGVuYWJsZWQgLSAuXHJcbiAgc3RhdGljIGJ1YmJsZUV2ZW50KHRhcmdldDogYW55LCBnZXRQYXJlbnRGbj86ICgoKSA9PiBhbnkpKSB7XHJcbiAgICB0YXJnZXQuX2dldEV2ZW50UGFyZW50ID0gZ2V0UGFyZW50Rm4gfHwgbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIG5hbWVkIGV2ZW50IGZvciBhbiBvYmplY3QgYW5kIGFsbCBvZiBpdHMgY2hpbGRyZW4uXHJcbiAgPiAgICAgIEJyZWV6ZUV2ZW50LmVuYWJsZSjigJxwcm9wZXJ0eUNoYW5nZWTigJ0sIG15RW50aXR5TWFuYWdlciwgZmFsc2UpXHJcblxyXG4gIHdpbGwgZGlzYWJsZSBhbGwgRW50aXR5QXNwZWN0LnByb3BlcnR5Q2hhbmdlZCBldmVudHMgd2l0aGluIGEgRW50aXR5TWFuYWdlci5cclxuICA+ICAgICAgQnJlZXplRXZlbnQuZW5hYmxlKOKAnHByb3BlcnR5Q2hhbmdlZOKAnSwgbXlFbnRpdHlNYW5hZ2VyLCB0cnVlKVxyXG5cclxuICB3aWxsIGVuYWJsZSBhbGwgRW50aXR5QXNwZWN0LnByb3BlcnR5Q2hhbmdlZCBldmVudHMgd2l0aGluIGEgRW50aXR5TWFuYWdlci5cclxuICA+ICAgICAgQnJlZXplRXZlbnQuZW5hYmxlKOKAnHByb3BlcnR5Q2hhbmdlZOKAnSwgbXlFbnRpdHkuZW50aXR5QXNwZWN0LCBmYWxzZSlcclxuXHJcbiAgd2lsbCBkaXNhYmxlIEVudGl0eUFzcGVjdC5wcm9wZXJ0eUNoYW5nZWQgZXZlbnRzIGZvciBhIHNwZWNpZmljIGVudGl0eS5cclxuICA+ICAgICAgQnJlZXplRXZlbnQuZW5hYmxlKOKAnHByb3BlcnR5Q2hhbmdlZOKAnSwgbXlFbnRpdHkuZW50aXR5QXNwZWN0LCBudWxsKVxyXG5cclxuICB3aWxsIHJlbW92ZXMgYW55IGVuYWJsaW5nIC8gZGlzYWJsaW5nIGF0IHRoZSBlbnRpdHkgYXNwZWN0IGxldmVsIHNvIG5vdyBhbnkgJ0V2ZW50LmVuYWJsZScgY2FsbHMgYXQgdGhlIEVudGl0eU1hbmFnZXIgbGV2ZWwsXHJcbiAgbWFkZSBlaXRoZXIgcHJldmlvdXNseSBvciBpbiB0aGUgZnV0dXJlLCB3aWxsIGNvbnRyb2wgbm90aWZpY2F0aW9uLlxyXG4gID4gICAgICBCcmVlemVFdmVudC5lbmFibGUo4oCcdmFsaWRhdGlvbkVycm9yc0NoYW5nZWTigJ0sIG15RW50aXR5TWFuYWdlciwgZnVuY3Rpb24oZW0pIHtcclxuICA+ICAgICAgICAgIHJldHVybiBlbS5jdXN0b21UYWcgPT09IOKAnGJsdWXigJ07XHJcbiAgPiAgICAgIH0pXHJcblxyXG5cclxuICB3aWxsIGVpdGhlciBlbmFibGUgb3IgZGlzYWJsZSBteUVudGl0eU1hbmFnZXIgYmFzZWQgb24gdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSDigJhjdXN0b21UYWfigJkgcHJvcGVydHkgb24gbXlFbnRpdHlNYW5hZ2VyLlxyXG4gIE5vdGUgdGhhdCB0aGlzIGlzIGR5bmFtaWMsIGNoYW5naW5nIHRoZSBjdXN0b21UYWcgdmFsdWUgd2lsbCBjYXVzZSBldmVudHMgdG8gYmUgZW5hYmxlZCBvciBkaXNhYmxlZCBpbW1lZGlhdGVseS5cclxuICBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gIEBwYXJhbSB0YXJnZXQgLSBUaGUgb2JqZWN0IGF0IHdoaWNoIGVuYWJsaW5nIG9yIGRpc2FibGluZyB3aWxsIG9jY3VyLiAgQWxsIGV2ZW50IG5vdGlmaWNhdGlvbnMgdGhhdCBvY2N1ciB0byB0aGlzIG9iamVjdCBvclxyXG4gIGNoaWxkcmVuIG9mIHRoaXMgb2JqZWN0IHdpbGwgYmUgZW5hYmxlZCBvciBkaXNhYmxlZC5cclxuICBAcGFyYW0gaXNFbmFibGVkIC0gQSBib29sZWFuLCBhIG51bGwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgZWl0aGVyIGEgYm9vbGVhbiBvciBhIG51bGwuXHJcbiAgKiovXHJcbiBzdGF0aWMgZW5hYmxlKGV2ZW50TmFtZTogc3RyaW5nLCBvYmo6IE9iamVjdCwgaXNFbmFibGVkOiBib29sZWFuIHwgKCh4OiBhbnkpID0+IGJvb2xlYW4pKSB7XHJcbiAgICBhc3NlcnRQYXJhbShldmVudE5hbWUsIFwiZXZlbnROYW1lXCIpLmlzTm9uRW1wdHlTdHJpbmcoKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0ob2JqLCBcIm9ialwiKS5pc09iamVjdCgpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShpc0VuYWJsZWQsIFwiaXNFbmFibGVkXCIpLmlzQm9vbGVhbigpLmlzT3B0aW9uYWwoKS5vcigpLmlzRnVuY3Rpb24oKS5jaGVjaygpO1xyXG4gICAgbGV0IG9iID0gPGFueT5vYmo7XHJcbiAgICBpZiAoIW9iLl8kZXZlbnRNYXApIHtcclxuICAgICAgb2IuXyRldmVudE1hcCA9IHt9O1xyXG4gICAgfVxyXG4gICAgb2IuXyRldmVudE1hcFtldmVudE5hbWVdID0gaXNFbmFibGVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyB3aGV0aGVyIGZvciBhIHNwZWNpZmljIGV2ZW50IGFuZCBhIHNwZWNpZmljIG9iamVjdCBhbmQgaXRzIGNoaWxkcmVuLCBub3RpZmljYXRpb24gaXMgZW5hYmxlZCBvciBkaXNhYmxlZCBvciBub3Qgc2V0LlxyXG4gID4gICAgICBCcmVlemVFdmVudC5pc0VuYWJsZWQo4oCccHJvcGVydHlDaGFuZ2Vk4oCdLCBteUVudGl0eU1hbmFnZXIpXHJcbiAgPiBcclxuICBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gIEBwYXJhbSB0YXJnZXQgLSBUaGUgb2JqZWN0IGZvciB3aGljaCB3ZSB3YW50IHRvIGtub3cgaWYgbm90aWZpY2F0aW9ucyBhcmUgZW5hYmxlZC5cclxuICBAcmV0dXJuIEEgbnVsbCBpcyByZXR1cm5lZCBpZiB0aGlzIHZhbHVlIGhhcyBub3QgYmVlbiBzZXQuXHJcbiAgKiovXHJcbiAgc3RhdGljIGlzRW5hYmxlZChldmVudE5hbWU6IHN0cmluZywgb2JqOiBPYmplY3QpIHtcclxuICAgIGFzc2VydFBhcmFtKGV2ZW50TmFtZSwgXCJldmVudE5hbWVcIikuaXNOb25FbXB0eVN0cmluZygpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShvYmosIFwib2JqXCIpLmlzT2JqZWN0KCkuY2hlY2soKTtcclxuICAgIC8vIG51bGwgaXMgb2sgLSBpdCBqdXN0IG1lYW5zIHRoYXQgdGhlIG9iamVjdCBpcyBhdCB0aGUgdG9wIGxldmVsLlxyXG4gICAgaWYgKCg8YW55Pm9iaikuX2dldEV2ZW50UGFyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBvYmplY3QgZG9lcyBub3Qgc3VwcG9ydCBldmVudCBlbmFibGluZy9kaXNhYmxpbmdcIik7XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gY3Rvci5faXNFbmFibGVkKGdldEZ1bGxFdmVudE5hbWUoZXZlbnROYW1lKSwgb2JqKTtcclxuICAgIHJldHVybiBCcmVlemVFdmVudC5faXNFbmFibGVkKGV2ZW50TmFtZSwgMyk7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgX2lzRW5hYmxlZCA9IGZ1bmN0aW9uIChldmVudE5hbWU6IHN0cmluZywgb2JqOiBPYmplY3QpIHtcclxuICAgIGxldCBpc0VuYWJsZWQ6IGFueSA9IG51bGw7XHJcbiAgICBsZXQgb2IgPSA8YW55Pm9iajtcclxuICAgIGxldCBldmVudE1hcCA9IG9iLl8kZXZlbnRNYXA7XHJcbiAgICBpZiAoZXZlbnRNYXApIHtcclxuICAgICAgaXNFbmFibGVkID0gZXZlbnRNYXBbZXZlbnROYW1lXTtcclxuICAgIH1cclxuICAgIGlmIChpc0VuYWJsZWQgIT0gbnVsbCkge1xyXG4gICAgICBpZiAodHlwZW9mIGlzRW5hYmxlZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiAhIWlzRW5hYmxlZChvYmopO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAhIWlzRW5hYmxlZDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IHBhcmVudCA9IG9iLl9nZXRFdmVudFBhcmVudCAmJiBvYi5fZ2V0RXZlbnRQYXJlbnQoKTtcclxuICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2lzRW5hYmxlZChldmVudE5hbWUsIHBhcmVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZGVmYXVsdCBpZiBub3QgZXhwbGljaXRseSBkaXNhYmxlZC5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG5cclxufVxyXG5cclxuLy8gbGVnYWN5IHN1cHBvcnQgLSBkZWxpYmVyYXRlbHkgbm90IHR5cGVkXHJcbihjb3JlIGFzIGFueSkuRXZlbnQgPSBCcmVlemVFdmVudDsiXX0=