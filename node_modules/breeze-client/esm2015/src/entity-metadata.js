import { core } from './core';
import { config } from './config';
import { BreezeEvent } from './event';
import { assertParam, assertConfig, Param } from './assert-param';
import { DataType } from './data-type';
import { EntityAspect, ComplexAspect } from './entity-aspect';
import { EntityKey } from './entity-key';
import { Validator } from './validate';
import { BreezeEnum } from './enum';
import { DataService } from './data-service';
import { NamingConvention } from './naming-convention';
import { CsdlMetadataParser } from './csdl-metadata-parser'; // TODO isolate this later;
import { LocalQueryComparisonOptions } from './local-query-comparison-options';
import { defaultPropertyInterceptor } from './default-property-interceptor';
/**
An instance of the MetadataStore contains all of the metadata about a collection of [[EntityType]]'s.
MetadataStores may be shared across [[EntityManager]]'s.  If an EntityManager is created without an
explicit MetadataStore, the MetadataStore from the MetadataStore.defaultInstance property will be used.
@dynamic
**/
export class MetadataStore {
    /**
    Constructs a new MetadataStore.
    
    >     let ms = new MetadataStore();
  
    The store can then be associated with an EntityManager
    >     let entityManager = new EntityManager( {
    >         serviceName: "breeze/NorthwindIBModel",
    >         metadataStore: ms
    >     });
  
    or for an existing EntityManager
    >    // Assume em1 is an existing EntityManager
    >    em1.setProperties( { metadataStore: ms });
    
    @param config - Configuration settings .
      - namingConvention - (default=NamingConvention.defaultInstance) NamingConvention to be used in mapping property names
    between client and server. Uses the NamingConvention.defaultInstance if not specified.
      - localQueryComparisonOptions - (default=LocalQueryComparisonOptions.defaultInstance) The LocalQueryComparisonOptions to be
    used when performing "local queries" in order to match the semantics of queries against a remote service.
      - serializerFn - A function that is used to mediate the serialization of instances of this type.
    **/
    constructor(config) {
        config = config || {};
        assertConfig(config)
            .whereParam("namingConvention").isOptional().isInstanceOf(NamingConvention).withDefault(NamingConvention.defaultInstance)
            .whereParam("localQueryComparisonOptions").isOptional().isInstanceOf(LocalQueryComparisonOptions).withDefault(LocalQueryComparisonOptions.defaultInstance)
            .whereParam("serializerFn").isOptional().isFunction()
            .applyAll(this);
        this.dataServices = []; // array of dataServices;
        this._resourceEntityTypeMap = {}; // key is resource name - value is qualified entityType name
        this._structuralTypeMap = {}; // key is qualified structuraltype name - value is structuralType. ( structural = entityType or complexType).
        this._shortNameMap = {}; // key is shortName, value is qualified name - does not need to be serialized.
        this._ctorRegistry = {}; // key is either short or qual type name - value is ctor;
        this._incompleteTypeMap = {}; // key is entityTypeName; value is array of nav props
        this._incompleteComplexTypeMap = {}; // key is complexTypeName; value is array of complexType props
        this._id = MetadataStore.__id++;
        this.metadataFetched = new BreezeEvent("metadataFetched", this);
    }
    // for debugging use the line below instead.
    //ctor.normalizeTypeName = function (rawTypeName) { return parseTypeName(rawTypeName).typeName; };
    /**
    General purpose property set method
    
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     em1.metadataStore.setProperties( {
    >         version: "6.1.3",
    >         serializerFn: function(prop, value) {
    >         return (prop.isUnmapped) ? undefined : value;
    >         }
    >     )};
    @param config -  An object containing the selected properties and values to set.
    **/
    setProperties(config) {
        assertConfig(config)
            .whereParam("name").isString().isOptional()
            .whereParam("serializerFn").isFunction().isOptional()
            .applyAll(this);
    }
    /**
    Adds a DataService to this MetadataStore. If a DataService with the same serviceName is already
    in the MetadataStore an exception will be thrown.
    @param dataService - The [[DataService]] to add
    @param shouldOverwrite - (default=false) Permit overwrite of existing DataService rather than throw exception
    **/
    addDataService(dataService, shouldOverwrite) {
        assertParam(dataService, "dataService").isInstanceOf(DataService).check();
        assertParam(shouldOverwrite, "shouldOverwrite").isBoolean().isOptional().check();
        let ix = this._getDataServiceIndex(dataService.serviceName);
        if (ix >= 0) {
            if (!!shouldOverwrite) {
                this.dataServices[ix] = dataService;
            }
            else {
                throw new Error("A dataService with this name '" + dataService.serviceName + "' already exists in this MetadataStore");
            }
        }
        else {
            this.dataServices.push(dataService);
        }
    }
    /** @hidden @internal */
    _getDataServiceIndex(serviceName) {
        return core.arrayIndexOf(this.dataServices, function (ds) {
            return ds.serviceName === serviceName;
        });
    }
    /**
    Adds an EntityType to this MetadataStore.  No additional properties may be added to the EntityType after its has
    been added to the MetadataStore.
    @param structuralType - The EntityType or ComplexType to add
    **/
    addEntityType(stype) {
        let structuralType;
        if (stype instanceof EntityType || stype instanceof ComplexType) {
            structuralType = stype;
        }
        else {
            structuralType = stype.isComplexType ? new ComplexType(stype) : new EntityType(stype);
        }
        // if (!structuralType.isComplexType) { // same as below but isn't a 'type guard'
        if (structuralType instanceof EntityType) {
            if (structuralType.baseTypeName && !structuralType.baseEntityType) {
                let baseEntityType = this._getStructuralType(structuralType.baseTypeName, true);
                // safe cast because we know that baseEntityType must be an EntityType if the structuralType is an EntityType
                structuralType._updateFromBase(baseEntityType);
            }
            if (structuralType.keyProperties.length === 0 && !structuralType.isAbstract) {
                throw new Error("Unable to add " + structuralType.name +
                    " to this MetadataStore.  An EntityType must have at least one property designated as a key property - See the 'DataProperty.isPartOfKey' property.");
            }
        }
        structuralType.metadataStore = this;
        // don't register anon types
        if (!structuralType.isAnonymous) {
            if (this._structuralTypeMap[structuralType.name]) {
                throw new Error("Type " + structuralType.name + " already exists in this MetadataStore.");
            }
            this._structuralTypeMap[structuralType.name] = structuralType;
            this._shortNameMap[structuralType.shortName] = structuralType.name;
        }
        structuralType.getProperties().forEach(p => {
            structuralType._updateNames(p);
            if (!p.isUnmapped) {
                structuralType._mappedPropertiesCount++;
            }
        });
        structuralType._updateCps();
        // 'isEntityType' is a type guard
        if (structuralType instanceof EntityType) {
            structuralType._updateNps();
            // give the type it's base's resource name if it doesn't have its own.
            let defResourceName = structuralType.defaultResourceName || (structuralType.baseEntityType && structuralType.baseEntityType.defaultResourceName);
            if (defResourceName && !this.getEntityTypeNameForResourceName(defResourceName)) {
                this.setEntityTypeForResourceName(defResourceName, structuralType.name);
            }
            structuralType.defaultResourceName = defResourceName;
            // check if this structural type's name, short version or qualified version has a registered ctor.
            structuralType.getEntityCtor();
        }
    }
    /**
    Exports this MetadataStore to a serialized string appropriate for local storage.   This operation is also called
    internally when exporting an EntityManager.
    >      // assume ms is a previously created MetadataStore
    >      let metadataAsString = ms.exportMetadata();
    >      window.localStorage.setItem("metadata", metadataAsString);
    >      // and later, usually in a different session imported
    >      let metadataFromStorage = window.localStorage.getItem("metadata");
    >      let newMetadataStore = new MetadataStore();
    >      newMetadataStore.importMetadata(metadataFromStorage);
    @return A serialized version of this MetadataStore that may be stored locally and later restored.
    **/
    exportMetadata() {
        let result = JSON.stringify({
            "metadataVersion": MetadataStore.metadataVersion,
            "name": this.name,
            "namingConvention": this.namingConvention.name,
            "localQueryComparisonOptions": this.localQueryComparisonOptions.name,
            "dataServices": this.dataServices,
            "structuralTypes": core.objectMap(this._structuralTypeMap),
            "resourceEntityTypeMap": this._resourceEntityTypeMap
        }, null, config.stringifyPad);
        return result;
    }
    /**
    Imports a previously exported serialized MetadataStore into this MetadataStore.
      
    >      // assume ms is a previously created MetadataStore
    >      let metadataAsString = ms.exportMetadata();
    >      window.localStorage.setItem("metadata", metadataAsString);
    >      // and later, usually in a different session
    >      let metadataFromStorage = window.localStorage.getItem("metadata");
    >      let newMetadataStore = new MetadataStore();
    >      newMetadataStore.importMetadata(metadataFromStorage);
    @param exportedMetadata - A previously exported MetadataStore.
    @param allowMerge -  Allows custom metadata to be merged into existing metadata types.
    @return This MetadataStore.
    @chainable
    **/
    importMetadata(exportedMetadata, allowMerge = false) {
        assertParam(allowMerge, "allowMerge").isOptional().isBoolean().check();
        this._deferredTypes = {};
        // insure that we don't mutate incoming exportedMetadata ( if its an object)
        let metadataAsString = (typeof (exportedMetadata) === "string") ? exportedMetadata : JSON.stringify(exportedMetadata);
        const metadataJson = JSON.parse(metadataAsString);
        if (metadataJson.schema) {
            return CsdlMetadataParser.parse(this, metadataJson.schema, metadataJson.altMetadata);
        }
        let json = metadataJson;
        if (json.metadataVersion && json.metadataVersion !== MetadataStore.metadataVersion) {
            let msg = core.formatString("Cannot import metadata with a different 'metadataVersion' (%1) than the current 'MetadataStore.metadataVersion' (%2) ", json.metadataVersion, MetadataStore.metadataVersion);
            throw new Error(msg);
        }
        let ncName = json.namingConvention;
        let lqcoName = json.localQueryComparisonOptions;
        if (this.isEmpty()) {
            this.namingConvention = config._fetchObject(NamingConvention, ncName) || this.namingConvention;
            this.localQueryComparisonOptions = config._fetchObject(LocalQueryComparisonOptions, lqcoName) || this.localQueryComparisonOptions;
        }
        else {
            if (ncName && this.namingConvention.name !== ncName) {
                throw new Error("Cannot import metadata with a different 'namingConvention' from the current MetadataStore");
            }
            if (lqcoName && this.localQueryComparisonOptions.name !== lqcoName) {
                throw new Error("Cannot import metadata with different 'localQueryComparisonOptions' from the current MetadataStore");
            }
        }
        //noinspection JSHint
        json.dataServices && json.dataServices.forEach((ds) => {
            let realDs = DataService.fromJSON(ds);
            this.addDataService(realDs, true);
        });
        json.structuralTypes && json.structuralTypes.forEach((stype) => {
            structuralTypeFromJson(this, stype, allowMerge);
        });
        core.extend(this._resourceEntityTypeMap, json.resourceEntityTypeMap);
        core.extend(this._incompleteTypeMap, json.incompleteTypeMap);
        return this;
    }
    /**
    Creates a new MetadataStore from a previously exported serialized MetadataStore
    >      // assume ms is a previously created MetadataStore
    >      let metadataAsString = ms.exportMetadata();
    >      window.localStorage.setItem("metadata", metadataAsString);
    >      // and later, usually in a different session
    >      let metadataFromStorage = window.localStorage.getItem("metadata");
    >      let newMetadataStore = MetadataStore.importMetadata(metadataFromStorage);
    @param exportedString - A previously exported MetadataStore.
    @return A new MetadataStore.
    **/
    static importMetadata(exportedString) {
        let ms = new MetadataStore();
        ms.importMetadata(exportedString);
        return ms;
    }
    /**
    Returns whether Metadata has been retrieved for a specified service name.
    >      // Assume em1 is an existing EntityManager.
    >      if (!em1.metadataStore.hasMetadataFor("breeze/NorthwindIBModel"))) {
    >          // do something interesting
    >      }
    @param serviceName - The service name.
    @return Whether metadata has already been retrieved for the specified service name.
    **/
    hasMetadataFor(serviceName) {
        return !!this.getDataService(serviceName);
    }
    /**
    Returns the DataService for a specified service name
    >      // Assume em1 is an existing EntityManager.
    >      let ds = em1.metadataStore.getDataService("breeze/NorthwindIBModel");
    >      let adapterName = ds.adapterName; // may be null
    @param serviceName - The service name.
    @return The DataService with the specified name.
    **/
    getDataService(serviceName) {
        assertParam(serviceName, "serviceName").isString().check();
        serviceName = DataService._normalizeServiceName(serviceName);
        return core.arrayFirst(this.dataServices, function (ds) {
            return ds.serviceName === serviceName;
        });
    }
    /**
    Fetches the metadata for a specified 'service'. This method is automatically called
    internally by an EntityManager before its first query against a new service. __Async__
  
    Usually you will not actually process the results of a fetchMetadata call directly, but will instead
    ask for the metadata from the EntityManager after the fetchMetadata call returns.
    >      let ms = new MetadataStore();
    >      // or more commonly
    >      // let ms = anEntityManager.metadataStore;
    >      ms.fetchMetadata("breeze/NorthwindIBModel").then(function(rawMetadata) {
    >            // do something with the metadata
    >      }).catch(function(exception) {
    >          // handle exception here
    >      });
    @param dataService -  Either a DataService or just the name of the DataService to fetch metadata for.
    @param callback - Function called on success.
    @param errorCallback - Function called on failure.
    @return Promise
    **/
    fetchMetadata(dataService, callback, errorCallback) {
        try {
            assertParam(dataService, "dataService").isString().or().isInstanceOf(DataService).check();
            assertParam(callback, "callback").isFunction().isOptional().check();
            assertParam(errorCallback, "errorCallback").isFunction().isOptional().check();
            if (typeof dataService === "string") {
                // use the dataService with a matching name or create a new one.
                dataService = this.getDataService(dataService) || new DataService({ serviceName: dataService });
            }
            dataService = DataService.resolve([dataService]);
            if (this.hasMetadataFor(dataService.serviceName)) {
                throw new Error("Metadata for a specific serviceName may only be fetched once per MetadataStore. ServiceName: " + dataService.serviceName);
            }
            return dataService.adapterInstance.fetchMetadata(this, dataService).then((rawMetadata) => {
                this.metadataFetched.publish({ metadataStore: this, dataService: dataService, rawMetadata: rawMetadata });
                if (callback)
                    callback(rawMetadata);
                return Promise.resolve(rawMetadata);
            }, function (error) {
                if (errorCallback)
                    errorCallback(error);
                return Promise.reject(error);
            });
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    // TODO: strongly type interceptor below.
    /**
    Used to register a constructor for an EntityType that is not known via standard Metadata discovery;
    i.e. an unmapped type.
    @param entityCtor - The constructor function for the 'unmapped' type.
    @param interceptor - An interceptor function
    **/
    trackUnmappedType(entityCtor, interceptor) {
        assertParam(entityCtor, "entityCtor").isFunction().check();
        assertParam(interceptor, "interceptor").isFunction().isOptional().check();
        // TODO: think about adding this to the MetadataStore.
        let entityType = new EntityType(this);
        entityType._setCtor(entityCtor, interceptor);
    }
    /**
    Provides a mechanism to register a 'custom' constructor to be used when creating new instances
    of the specified entity type.  If this call is not made, a default constructor is created for
    the entity as needed.
    This call may be made before or after the corresponding EntityType has been discovered via
    Metadata discovery.
    >      let Customer = function () {
    >              this.miscData = "asdf";
    >          };
    >      Customer.prototype.doFoo() {
    >              ...
    >          }
    >      // assume em1 is a preexisting EntityManager;
    >      em1.metadataStore.registerEntityTypeCtor("Customer", Customer);
    >      // any queries or EntityType.create calls from this point on will call the Customer constructor
    >      // registered above.
    @param structuralTypeName - The name of the EntityType or ComplexType.
    @param aCtor - The constructor for this EntityType or ComplexType; may be null if all you want to do is set the next parameter.
    @param initFn - A function or the name of a function on the entity that is to be executed immediately after the entity has been created
    and populated with any initial values. Called with 'initFn(entity)'
    @param noTrackingFn - A function that is executed immediately after a noTracking entity has been created and whose return
    value will be used in place of the noTracking entity.
    **/
    registerEntityTypeCtor(structuralTypeName, aCtor, initFn, noTrackingFn) {
        assertParam(structuralTypeName, "structuralTypeName").isString().check();
        assertParam(aCtor, "aCtor").isFunction().isOptional().check();
        assertParam(initFn, "initFn").isOptional().isFunction().or().isString().check();
        assertParam(noTrackingFn, "noTrackingFn").isOptional().isFunction().check();
        let qualifiedTypeName = getQualifiedTypeName(this, structuralTypeName, false);
        let typeName = qualifiedTypeName || structuralTypeName;
        if (aCtor) {
            if (aCtor._$typeName && aCtor._$typeName !== typeName) {
                // TODO: wrap this - console and especially console.warn does not exist in all browsers.
                console.warn("Registering a constructor for " + typeName + " that is already used for " + aCtor._$typeName + ".");
            }
            aCtor._$typeName = typeName;
        }
        this._ctorRegistry[typeName] = { ctor: aCtor, initFn: initFn, noTrackingFn: noTrackingFn };
        if (qualifiedTypeName) {
            let stype = this._structuralTypeMap[qualifiedTypeName];
            stype && stype.getCtor(true); // this will complete the registration if avail now.
        }
    }
    /**
    Returns whether this MetadataStore contains any metadata yet.
    >      // assume em1 is a preexisting EntityManager;
    >      if (em1.metadataStore.isEmpty()) {
    >          // do something interesting
    >      }
    **/
    isEmpty() {
        return core.isEmpty(this._structuralTypeMap);
    }
    /**
    Returns an [[EntityType]] or null given its name.
    >      // assume em1 is a preexisting EntityManager
    >      let odType = em1.metadataStore.getAsEntityType("OrderDetail");
  
    or to throw an error if the type is not found
    >      let badType = em1.metadataStore.getAsEntityType("Foo", false);
    >      // badType will not get set and an exception will be thrown.
    @param structuralTypeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    getAsEntityType(typeName, okIfNotFound = false) {
        const st = this.getStructuralType(typeName, okIfNotFound);
        if (st instanceof EntityType) {
            return st;
        }
        else if (okIfNotFound) {
            return null;
        }
        else {
            let msg = core.formatString("Unable to locate an 'EntityType' by the name: '%1'. Be sure to execute a query or call fetchMetadata first.", typeName);
            throw new Error(msg);
        }
    }
    /**
    Returns an [[EntityType]] or null given its name.
    >      // assume em1 is a preexisting EntityManager
    >      let locType = em1.metadataStore.getAsComplexType("Location");
  
    or to throw an error if the type is not found
    >      let badType = em1.metadataStore.getAsComplexType("Foo", false);
    >      // badType will not get set and an exception will be thrown.
    @param structuralTypeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    getAsComplexType(typeName, okIfNotFound = false) {
        const st = this.getStructuralType(typeName, okIfNotFound);
        if (st instanceof ComplexType) {
            return st;
        }
        else if (okIfNotFound) {
            return null;
        }
        else {
            let msg = core.formatString("Unable to locate an 'ComplexType' by the name: '%1'. Be sure to execute a query or call fetchMetadata first.", typeName);
            throw new Error(msg);
        }
    }
    /**
    Returns an [[EntityType]] or a [[ComplexType]] given its name.
    @deprecated Replaced by getStructuralType but ... it is probably more usefull to call either getAsEntityType or getAsComplexType instead
    @param typeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    getEntityType(typeName, okIfNotFound = false) {
        return this.getStructuralType(typeName, okIfNotFound);
    }
    /**
    Returns an [[EntityType]] or a [[ComplexType]] given its name.
    >      // assume em1 is a preexisting EntityManager
    >      let odType = em1.metadataStore.getStructuralType("OrderDetail");
  
    or to throw an error if the type is not found
    >      let badType = em1.metadataStore.getStructuralType("Foo", false);
    >      // badType will not get set and an exception will be thrown.
    @deprecated Preferably use either getAsEntityType or getAsComplexType.  Get
    @param typeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    getStructuralType(typeName, okIfNotFound = false) {
        assertParam(typeName, "typeName").isString().check();
        assertParam(okIfNotFound, "okIfNotFound").isBoolean().isOptional().check(false);
        return this._getStructuralType(typeName, okIfNotFound);
    }
    /** @hidden @internal */
    _getStructuralType(typeName, okIfNotFound = false) {
        let qualTypeName = getQualifiedTypeName(this, typeName, false);
        let type = this._structuralTypeMap[qualTypeName];
        if (!type) {
            if (okIfNotFound)
                return null;
            let msg = core.formatString("Unable to locate a 'Type' by the name: '%1'. Be sure to execute a query or call fetchMetadata first.", typeName);
            throw new Error(msg);
        }
        return type;
    }
    /**
    Returns an array containing all of the [[EntityType]]s or [[ComplexType]]s in this MetadataStore.
    >      // assume em1 is a preexisting EntityManager
    >      let allTypes = em1.metadataStore.getEntityTypes();
    **/
    getEntityTypes() {
        return getTypesFromMap(this._structuralTypeMap);
    }
    getIncompleteNavigationProperties() {
        return core.objectMap(this._incompleteTypeMap, function (key, value) {
            return value;
        });
    }
    /**
    Returns a fully qualified entityTypeName for a specified resource name.  The reverse of this operation
    can be obtained via the  [[EntityType.defaultResourceName]] property
    **/
    getEntityTypeNameForResourceName(resourceName) {
        assertParam(resourceName, "resourceName").isString().check();
        return this._resourceEntityTypeMap[resourceName];
    }
    /**
    Associates a resourceName with an entityType.
  
    This method is only needed in those cases where multiple resources return the same
    entityType.  In this case Metadata discovery will only determine a single resource name for
    each entityType.
    @param resourceName - The resource name
    @param entityTypeOrName - If passing a string either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown. If the entityType has not yet been discovered then a fully qualified name must be used.
    **/
    setEntityTypeForResourceName(resourceName, entityTypeOrName) {
        assertParam(resourceName, "resourceName").isString().check();
        assertParam(entityTypeOrName, "entityTypeOrName").isInstanceOf(EntityType).or().isString().check();
        let entityTypeName;
        if (entityTypeOrName instanceof EntityType) {
            entityTypeName = entityTypeOrName.name;
        }
        else {
            entityTypeName = getQualifiedTypeName(this, entityTypeOrName, true);
        }
        this._resourceEntityTypeMap[resourceName] = entityTypeName;
        let entityType = this._getStructuralType(entityTypeName, true);
        if (entityType && entityType instanceof EntityType && !entityType.defaultResourceName) {
            entityType.defaultResourceName = resourceName;
        }
    }
    /** __Dev Only__ - for use when creating a new MetadataParserAdapter  */
    static parseTypeName(entityTypeName) {
        // TODO: removed 
        // if (!entityTypeName) {
        //   return null;
        // }
        let typeParts = entityTypeName.split(":#");
        if (typeParts.length > 1) {
            return MetadataStore.makeTypeHash(typeParts[0], typeParts[1]);
        }
        if (core.stringStartsWith(entityTypeName, MetadataStore.ANONTYPE_PREFIX)) {
            let typeHash = MetadataStore.makeTypeHash(entityTypeName);
            typeHash.isAnonymous = true;
            return typeHash;
        }
        let entityTypeNameNoAssembly = entityTypeName.split(",")[0];
        typeParts = entityTypeNameNoAssembly.split(".");
        if (typeParts.length > 1) {
            let shortName = typeParts[typeParts.length - 1];
            let namespaceParts = typeParts.slice(0, typeParts.length - 1);
            let ns = namespaceParts.join(".");
            return MetadataStore.makeTypeHash(shortName, ns);
        }
        else {
            return MetadataStore.makeTypeHash(entityTypeName);
        }
    }
    /** __Dev Only__ - for use when creating a new MetadataParserAdapter  */
    static makeTypeHash(shortName, ns) {
        return {
            shortTypeName: shortName,
            namespace: ns,
            typeName: qualifyTypeName(shortName, ns)
        };
    }
    // protected methods
    /** @hidden @internal */
    _checkEntityType(entity) {
        if (entity.entityType)
            return;
        let typeName = entity.prototype._$typeName;
        if (!typeName) {
            throw new Error("This entity has not been registered. See the MetadataStore.registerEntityTypeCtor method");
        }
        // we know that it is an EntityType ( as opposed to a ComplexType)
        let entityType = this._getStructuralType(typeName);
        if (entityType) {
            entity.entityType = entityType;
        }
    }
}
/** @hidden @internal */
MetadataStore.__id = 0;
/** @hidden @internal */
MetadataStore.ANONTYPE_PREFIX = "_IB_";
/** The version of any MetadataStores created by this class */
MetadataStore.metadataVersion = '1.0.5';
// needs to be made avail to dataService.xxx files
MetadataStore.normalizeTypeName = core.memoize(function (rawTypeName) {
    return rawTypeName && MetadataStore.parseTypeName(rawTypeName).typeName;
});
MetadataStore.prototype._$typeName = "MetadataStore";
BreezeEvent.bubbleEvent(MetadataStore.prototype);
function getTypesFromMap(typeMap) {
    let types = [];
    for (let key in typeMap) {
        let value = typeMap[key];
        // skip 'shortName' entries
        if (key === value.name) {
            types.push(typeMap[key]);
        }
    }
    return types;
}
function structuralTypeFromJson(metadataStore, json, allowMerge) {
    let typeName = qualifyTypeName(json.shortName, json.namespace);
    let stype = metadataStore._getStructuralType(typeName, true);
    if (stype) {
        if (allowMerge) {
            return mergeStructuralType(stype, json);
        }
        else {
            // allow it but don't replace anything.
            return stype;
        }
    }
    let config = {
        shortName: json.shortName,
        namespace: json.namespace,
        isAbstract: json.isAbstract,
        autoGeneratedKeyType: AutoGeneratedKeyType.fromName(json.autoGeneratedKeyType),
        defaultResourceName: json.defaultResourceName,
        custom: json.custom
    };
    stype = json.isComplexType ? new ComplexType(config) : new EntityType(config);
    // baseType may not have been imported yet so we need to defer handling this type until later.
    if (json.baseTypeName && stype instanceof EntityType) {
        stype.baseTypeName = json.baseTypeName;
        let baseEntityType = metadataStore._getStructuralType(json.baseTypeName, true);
        if (baseEntityType) {
            completeStructuralTypeFromJson(metadataStore, json, stype);
        }
        else {
            core.getArray(metadataStore._deferredTypes, json.baseTypeName).push({ json: json, stype: stype });
        }
    }
    else {
        completeStructuralTypeFromJson(metadataStore, json, stype);
    }
    // stype may or may not have been added to the metadataStore at this point.
    return stype;
}
function mergeStructuralType(stype, json) {
    if (json.custom) {
        stype.custom = json.custom;
    }
    mergeProps(stype, json.dataProperties);
    mergeProps(stype, json.navigationProperties);
    return stype;
}
function mergeProps(stype, jsonProps) {
    if (!jsonProps)
        return;
    jsonProps.forEach((jsonProp) => {
        let propName = jsonProp.name;
        if (!propName) {
            if (jsonProp.nameOnServer) {
                propName = stype.metadataStore.namingConvention.serverPropertyNameToClient(jsonProp.nameOnServer, {});
            }
            else {
                // backslash-quote works around compiler bug
                const msg = "Unable to complete \'importMetadata\' - cannot locate a \'name\' or \'nameOnServer\' for one of the imported property nodes";
                throw new Error(msg);
            }
        }
        if (jsonProp.custom) {
            let prop = stype.getProperty(propName, true);
            prop.custom = jsonProp.custom;
        }
    });
}
function completeStructuralTypeFromJson(metadataStore, json, stype) {
    // validators from baseType work because validation walks thru base types
    // so no need to copy down.
    if (json.validators) {
        stype.validators = json.validators.map(Validator.fromJSON);
    }
    json.dataProperties.forEach(function (dp) {
        stype._addPropertyCore(DataProperty.fromJSON(dp));
    });
    let isEntityType = !json.isComplexType;
    if (isEntityType) {
        //noinspection JSHint
        json.navigationProperties && json.navigationProperties.forEach(function (np) {
            stype._addPropertyCore(NavigationProperty.fromJSON(np));
        });
    }
    metadataStore.addEntityType(stype);
    let deferredTypes = metadataStore._deferredTypes;
    let deferrals = deferredTypes[stype.name];
    if (deferrals) {
        deferrals.forEach(function (d) {
            completeStructuralTypeFromJson(metadataStore, d.json, d.stype);
        });
        delete deferredTypes[stype.name];
    }
}
function getQualifiedTypeName(metadataStore, structTypeName, throwIfNotFound) {
    if (isQualifiedTypeName(structTypeName))
        return structTypeName;
    let result = metadataStore._shortNameMap[structTypeName];
    if (!result && throwIfNotFound) {
        throw new Error("Unable to locate 'entityTypeName' of: " + structTypeName);
    }
    return result;
}
/** Container for all of the metadata about a specific type of Entity.
**/
export class EntityType {
    /** EntityType constructor
    >      let entityType = new EntityType( {
    >          shortName: "person",
    >          namespace: "myAppNamespace"
    >      });
    @param config - Configuration settings or a MetadataStore.  If this parameter is just a MetadataStore
    then what will be created is an 'anonymous' type that will never be communicated to or from the server. It is purely for
    client side use and will be given an automatically generated name. Normally, however, you will use a configuration object.
    **/
    constructor(config) {
        /** Always false for an EntityType. **/
        this.isComplexType = false;
        /**
        @deprecated Use [[getCtor]] instead.
        */
        this.getEntityCtor = this.getCtor;
        if (arguments.length > 1) {
            throw new Error("The EntityType ctor has a single argument that is either a 'MetadataStore' or a configuration object.");
        }
        // let etConfig =  <EntityTypeConfig> <any> undefined;
        let etConfig = undefined;
        if (config._$typeName === "MetadataStore") {
            this.metadataStore = config;
            this.shortName = "Anon_" + (++EntityType.__nextAnonIx);
            this.namespace = "";
            this.isAnonymous = true;
            // etConfig = undefined;
        }
        else {
            etConfig = config;
            assertConfig(config)
                .whereParam("shortName").isNonEmptyString()
                .whereParam("namespace").isString().isOptional().withDefault("")
                .whereParam("baseTypeName").isString().isOptional()
                .whereParam("isAbstract").isBoolean().isOptional().withDefault(false)
                .whereParam("autoGeneratedKeyType").isEnumOf(AutoGeneratedKeyType).isOptional().withDefault(AutoGeneratedKeyType.None)
                .whereParam("defaultResourceName").isNonEmptyString().isOptional().withDefault(null)
                .whereParam("dataProperties").isOptional()
                .whereParam("navigationProperties").isOptional()
                .whereParam("serializerFn").isOptional().isFunction()
                .whereParam("custom").isOptional()
                .applyAll(this);
        }
        this.name = qualifyTypeName(this.shortName, this.namespace);
        // the defaultResourceName may also be set up either via metadata lookup or first query or via the 'setProperties' method
        this.dataProperties = [];
        this.navigationProperties = [];
        this.complexProperties = [];
        this.keyProperties = [];
        this.foreignKeyProperties = [];
        this.inverseForeignKeyProperties = [];
        this.concurrencyProperties = [];
        this.unmappedProperties = []; // will be updated later.
        this.validators = [];
        this.warnings = [];
        this._mappedPropertiesCount = 0;
        this.subtypes = [];
        // now process any data/nav props
        if (etConfig && etConfig.dataProperties) {
            addProperties(this, etConfig.dataProperties, DataProperty);
        }
        if (etConfig && etConfig.navigationProperties) {
            addProperties(this, etConfig.navigationProperties, NavigationProperty);
        }
    }
    /**
    General purpose property set method
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      custType.setProperties( {
    >          autoGeneratedKeyType: AutoGeneratedKeyType.Identity;
    >          defaultResourceName: "CustomersAndIncludedOrders"
    >      )};
    @param config - a configuration object
    **/
    setProperties(config) {
        assertConfig(config)
            .whereParam("autoGeneratedKeyType").isEnumOf(AutoGeneratedKeyType).isOptional()
            .whereParam("defaultResourceName").isString().isOptional()
            .whereParam("serializerFn").isFunction().isOptional()
            .whereParam("custom").isOptional()
            .applyAll(this);
        if (config.defaultResourceName) {
            this.defaultResourceName = config.defaultResourceName;
        }
    }
    /**
    Returns whether this type is a subtype of a specified type.
    **/
    isSubtypeOf(entityType) {
        assertParam(entityType, "entityType").isInstanceOf(EntityType).check();
        let baseType = this;
        do {
            if (baseType === entityType)
                return true;
            baseType = baseType.baseEntityType;
        } while (baseType);
        return false;
    }
    /**
    Returns an array containing this type and any/all subtypes of this type down thru the hierarchy.
    **/
    getSelfAndSubtypes() {
        let result = [this];
        this.subtypes.forEach(function (st) {
            let subtypes = st.getSelfAndSubtypes();
            result.push.apply(result, subtypes);
        });
        return result;
    }
    getAllValidators() {
        let result = this.validators.slice(0);
        let bt = this.baseEntityType;
        while (bt) {
            result.push.apply(result, bt.validators);
            bt = bt.baseEntityType;
        }
        return result;
    }
    /**
    Adds a  [[DataProperty]] or a [[NavigationProperty]] to this EntityType.
    >      // assume myEntityType is a newly constructed EntityType.
    >      myEntityType.addProperty(dataProperty1);
    >      myEntityType.addProperty(dataProperty2);
    >      myEntityType.addProperty(navigationProperty1);
    **/
    addProperty(property) {
        assertParam(property, "property").isInstanceOf(DataProperty).or().isInstanceOf(NavigationProperty).check();
        // true is 2nd arg to force resolve of any navigation properties.
        let newprop = this._addPropertyCore(property, true);
        if (this.subtypes && this.subtypes.length) {
            let stype = this;
            stype.getSelfAndSubtypes().forEach(function (st) {
                if (st !== stype) {
                    if (property.isNavigationProperty) {
                        st._addPropertyCore(new NavigationProperty(property), true);
                    }
                    else {
                        st._addPropertyCore(new DataProperty(property), true);
                    }
                }
            });
        }
        return newprop;
    }
    /** @hidden @internal */
    _updateFromBase(baseEntityType) {
        this.baseEntityType = baseEntityType;
        if (this.autoGeneratedKeyType === AutoGeneratedKeyType.None) {
            this.autoGeneratedKeyType = baseEntityType.autoGeneratedKeyType;
        }
        baseEntityType.dataProperties.forEach((dp) => {
            let newDp = new DataProperty(dp);
            // don't need to copy validators becaue we will walk the hierarchy to find them
            newDp.validators = [];
            newDp.baseProperty = dp;
            this._addPropertyCore(newDp);
        }, this);
        baseEntityType.navigationProperties.forEach((np) => {
            let newNp = new NavigationProperty(np);
            // don't need to copy validators becaue we will walk the hierarchy to find them
            newNp.validators = [];
            newNp.baseProperty = np;
            this._addPropertyCore(newNp);
        }, this);
        baseEntityType.subtypes.push(this);
    }
    /** @hidden @internal */
    _addPropertyCore(property, shouldResolve = false) {
        if (this.isFrozen) {
            throw new Error("The '" + this.name + "' EntityType/ComplexType has been frozen. You can only add properties to an EntityType/ComplexType before any instances of that type have been created and attached to an entityManager.");
        }
        let parentType = property.parentType;
        if (parentType) {
            if (parentType !== this) {
                throw new Error("This property: " + property.name + " has already been added to " + property.parentType.name);
            }
            else {
                // adding the same property more than once to the same entityType is just ignored.
                return;
            }
        }
        property.parentType = this;
        let ms = this.metadataStore;
        // if (property.isDataProperty) { // modified because doesn't act as a type guard 
        if (property instanceof DataProperty) {
            this._addDataProperty(property);
        }
        else {
            this._addNavigationProperty(property);
            // metadataStore can be undefined if this entityType has not yet been added to a MetadataStore.
            if (shouldResolve && ms) {
                tryResolveNp(property, ms);
            }
        }
        // unmapped properties can be added AFTER entityType has already resolved all property names.
        if (ms && !(property.name && property.nameOnServer)) {
            updateClientServerNames(ms.namingConvention, property, "name");
        }
        // props can be added after entity prototype has already been wrapped.
        if (ms && this._extra) {
            if (this._extra.alreadyWrappedProps) {
                let proto = this._ctor.prototype;
                config.interfaceRegistry.modelLibrary.getDefaultInstance().initializeEntityPrototype(proto);
            }
        }
    }
    /**
    Create a new entity of this type.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getAsEntityType("Customer");
    >      let cust1 = custType.createEntity();
    >      em1.addEntity(cust1);
    @param initialValues- Configuration object of the properties to set immediately after creation.
    @return The new entity.
    **/
    createEntity(initialValues) {
        // ignore the _$eref once the entity is attached to an entityManager.
        if (initialValues && initialValues._$eref && !initialValues._$eref.entityAspect.entityManager)
            return initialValues._$eref;
        let instance = this._createInstanceCore();
        if (initialValues) {
            // only assign an _eref if the object is fully "keyed"
            if (this.keyProperties.every(function (kp) {
                return initialValues[kp.name] != null;
            })) {
                initialValues._$eref = instance;
            }
            this._updateTargetFromRaw(instance, initialValues, getRawValueFromConfig);
            this.navigationProperties.forEach(function (np) {
                let relatedEntity;
                let val = initialValues[np.name];
                if (val != undefined) {
                    let navEntityType = np.entityType;
                    if (np.isScalar) {
                        relatedEntity = val.entityAspect ? val : navEntityType.createEntity(val);
                        instance.setProperty(np.name, relatedEntity);
                    }
                    else {
                        let relatedEntities = instance.getProperty(np.name);
                        val.forEach((v) => {
                            relatedEntity = v.entityAspect ? v : navEntityType.createEntity(v);
                            relatedEntities.push(relatedEntity);
                        });
                    }
                }
            });
        }
        this._initializeInstance(instance);
        return instance;
    }
    /** @hidden @internal */
    _createInstanceCore() {
        let aCtor = this.getCtor();
        let instance = new aCtor();
        new EntityAspect(instance);
        return instance;
    }
    /** @hidden @internal */
    _initializeInstance(instance) {
        if (this.baseEntityType) {
            this.baseEntityType._initializeInstance(instance);
        }
        let initFn = this.initFn;
        if (initFn) {
            let fn = (typeof initFn === "string") ? instance[initFn] : initFn;
            fn(instance);
        }
        this.complexProperties && this.complexProperties.forEach(function (cp) {
            let complexType = cp.dataType;
            let ctInstance = instance.getProperty(cp.name);
            if (Array.isArray(ctInstance)) {
                ctInstance.forEach((ctInst) => {
                    complexType._initializeInstance(ctInst);
                });
            }
            else {
                complexType._initializeInstance(ctInstance);
            }
        });
        // not needed for complexObjects
        if (instance.entityAspect) {
            instance.entityAspect._initialized = true;
        }
    }
    /**
    Returns the constructor for this EntityType.
    @param forceRefresh - Whether to ignore any cached version of this constructor. (default == false)
    @return The constructor for this EntityType.
    **/
    getCtor(forceRefresh = false) {
        if (this._ctor && !forceRefresh)
            return this._ctor;
        let ctorRegistry = this.metadataStore._ctorRegistry;
        let r = ctorRegistry[this.name] || ctorRegistry[this.shortName] || {};
        let aCtor = r.ctor || this._ctor;
        let ctorType = aCtor && aCtor.prototype && (aCtor.prototype.entityType || aCtor.prototype.complexType);
        if (ctorType && ctorType.metadataStore !== this.metadataStore) {
            // We can't risk a mismatch between the ctor and the type info in a specific metadatastore
            // because modelLibraries rely on type info to intercept ctor properties
            throw new Error("Cannot register the same constructor for " + this.name + " in different metadata stores.  Please define a separate constructor for each metadata store.");
        }
        if (r.ctor && forceRefresh) {
            this._extra = undefined;
        }
        if (!aCtor) {
            let createCtor = config.interfaceRegistry.modelLibrary.getDefaultInstance().createCtor;
            aCtor = createCtor ? createCtor(this) : createEmptyCtor(this);
        }
        this.initFn = r.initFn;
        this.noTrackingFn = r.noTrackingFn;
        aCtor.prototype._$typeName = this.name;
        this._setCtor(aCtor);
        return aCtor;
    }
    /** @hidden @internal */
    // May make public later.
    _setCtor(aCtor, interceptor) {
        let instanceProto = aCtor.prototype;
        // place for extra breeze related data
        this._extra = this._extra || {};
        let instance = new aCtor();
        calcUnmappedProperties(this, instance);
        if (this._$typeName === "EntityType") {
            // insure that all of the properties are on the 'template' instance before watching the class.
            instanceProto.entityType = this;
        }
        else {
            instanceProto.complexType = this;
        }
        // defaultPropertyInterceptor is a 'global' (but internal to breeze) function;
        instanceProto._$interceptor = interceptor || defaultPropertyInterceptor;
        config.interfaceRegistry.modelLibrary.getDefaultInstance().initializeEntityPrototype(instanceProto);
        this._ctor = aCtor;
    }
    /**
    Adds either an entity or property level validator to this EntityType.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let countryProp = custType.getProperty("Country");
    >      let valFn = function (v) {
    >              if (v == null) return true;
    >              return (core.stringStartsWith(v, "US"));
    >          };
    >      let countryValidator = new Validator("countryIsUS", valFn,
    >      { displayName: "Country", messageTemplate: "'%displayName%' must start with 'US'" });
    >      custType.addValidator(countryValidator, countryProp);
  
    This is the same as adding an entity level validator via the 'validators' property of DataProperty or NavigationProperty
    >      countryProp.validators.push(countryValidator);
  
    Entity level validators can also be added by omitting the 'property' parameter.
    >      custType.addValidator(someEntityLevelValidator);
  
    or
    >      custType.validators.push(someEntityLevelValidator);
    @param validator - Validator to add.
    @param property - Property to add this validator to.  If omitted, the validator is assumed to be an
    entity level validator and is added to the EntityType's 'validators'.
    **/
    addValidator(validator, property) {
        assertParam(validator, "validator").isInstanceOf(Validator).check();
        assertParam(property, "property").isOptional().isString().or().isEntityProperty().check();
        if (property != null) {
            let prop = (typeof property === 'string') ? this.getProperty(property, true) : property;
            prop.validators.push(validator);
        }
        else {
            this.validators.push(validator);
        }
    }
    /**
    Returns all of the properties ( dataProperties and navigationProperties) for this EntityType.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let arrayOfProps = custType.getProperties();
    @return An array of Data and Navigation properties.
    **/
    getProperties() {
        return this.dataProperties.concat(this.navigationProperties);
    }
    /**
    Returns all of the property names ( for both dataProperties and navigationProperties) for this EntityType.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let arrayOfPropNames = custType.getPropertyNames();
    **/
    getPropertyNames() {
        return this.getProperties().map(core.pluck('name'));
    }
    /**
    Returns a data property with the specified name or null.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let customerNameDataProp = custType.getDataProperty("CustomerName");
    @return A DataProperty or null if not found.
    **/
    getDataProperty(propertyName) {
        return core.arrayFirst(this.dataProperties, core.propEq('name', propertyName));
    }
    /**
    Returns a navigation property with the specified name or null.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let customerOrdersNavProp = custType.getDataProperty("Orders");
    @return A NavigationProperty or null if not found.
    **/
    getNavigationProperty(propertyName) {
        return core.arrayFirst(this.navigationProperties, core.propEq('name', propertyName));
    }
    /**
    Returns either a DataProperty or a NavigationProperty with the specified name or null.
    
    This method also accepts a '.' delimited property path and will return the 'property' at the
    end of the path.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let companyNameProp = custType.getProperty("CompanyName");
  
    This method can also walk a property path to return a property
    >      let orderDetailType = em1.metadataStore.getEntityType("OrderDetail");
    >      let companyNameProp2 = orderDetailType.getProperty("Order.Customer.CompanyName");
    >      // companyNameProp === companyNameProp2
    @param [throwIfNotFound=false] {Boolean} Whether to throw an exception if not found.
    @return A DataProperty or NavigationProperty or null if not found.
    **/
    getProperty(propertyPath, throwIfNotFound = false) {
        let props = this.getPropertiesOnPath(propertyPath, false, throwIfNotFound);
        return (props && props.length > 0) ? props[props.length - 1] : null;
    }
    /** @hidden @internal */
    // TODO: have this return empty array instead of null and fix consumers.
    // TODO: think about renaming with '_' prefix.
    getPropertiesOnPath(propertyPath, useServerName, throwIfNotFound = false) {
        let propertyNames = (Array.isArray(propertyPath)) ? propertyPath : propertyPath.trim().split('.');
        let ok = true;
        let key = useServerName === true ? "nameOnServer" : useServerName === false ? "name" : null;
        let parentType = this;
        const getProps = (propName) => {
            const fn = key === null ? core.propsEq("name", "nameOnServer", propName) : core.propEq(key, propName);
            let prop = core.arrayFirst(parentType.getProperties(), fn);
            if (prop) {
                parentType = (prop instanceof NavigationProperty) ? prop.entityType : prop.dataType;
                // parentType = prop.isNavigationProperty ? prop.entityType : prop.dataType;
            }
            else if (throwIfNotFound) {
                throw new Error("unable to locate property: " + propName + " on entityType: " + parentType.name);
            }
            else {
                ok = false;
            }
            return prop;
        };
        let props = propertyNames.map(getProps);
        return ok ? props : null;
    }
    /** For use in pluggable adapters. */
    // TODO: document use
    clientPropertyPathToServer(propertyPath, delimiter = '.') {
        let propNames;
        if (this.isAnonymous) {
            let fn = this.metadataStore.namingConvention.clientPropertyNameToServer;
            propNames = propertyPath.split(".").map(function (propName) {
                return fn(propName);
            });
        }
        else {
            let props = this.getPropertiesOnPath(propertyPath, false, true);
            propNames = props.map((prop) => prop.nameOnServer);
        }
        return propNames.join(delimiter);
    }
    /** For use in pluggable adapters. */
    // TODO: document use
    getEntityKeyFromRawEntity(rawEntity, rawValueFn) {
        let keyValues = this.keyProperties.map((dp) => {
            let val = rawValueFn(rawEntity, dp);
            return DataType.parseRawValue(val, dp.dataType);
        });
        return new EntityKey(this, keyValues);
    }
    /** @hidden @internal */
    _updateTargetFromRaw(target, raw, rawValueFn) {
        // called recursively for complex properties
        this.dataProperties.forEach((dp) => {
            if (!dp.isSettable)
                return;
            let rawVal = rawValueFn(raw, dp);
            if (rawVal === undefined)
                return;
            let dataType = dp.dataType; // this will be a complexType when dp is a complexProperty
            let oldVal;
            if (dp.isComplexProperty) {
                let complexType = dp.dataType;
                if (rawVal === null)
                    return; // rawVal may be null in nosql dbs where it was never defined for the given row.
                oldVal = target.getProperty(dp.name);
                if (dp.isScalar) {
                    complexType._updateTargetFromRaw(oldVal, rawVal, rawValueFn);
                }
                else {
                    if (Array.isArray(rawVal)) {
                        let newVal = rawVal.map(function (rawCo) {
                            let newCo = complexType._createInstanceCore(target, dp);
                            complexType._updateTargetFromRaw(newCo, rawCo, rawValueFn);
                            complexType._initializeInstance(newCo);
                            return newCo;
                        });
                        if (!core.arrayEquals(oldVal, newVal, coEquals)) {
                            // clear the old array and push new objects into it.
                            oldVal.length = 0;
                            newVal.forEach(function (nv) {
                                oldVal.push(nv);
                            });
                        }
                    }
                    else {
                        oldVal.length = 0;
                    }
                }
            }
            else {
                if (dp.isScalar) {
                    let newVal = DataType.parseRawValue(rawVal, dataType);
                    target.setProperty(dp.name, newVal);
                }
                else {
                    oldVal = target.getProperty(dp.name);
                    if (Array.isArray(rawVal)) {
                        // need to compare values
                        let newVal = rawVal.map((rv) => {
                            return DataType.parseRawValue(rv, dataType);
                        });
                        if (!core.arrayEquals(oldVal, newVal)) {
                            // clear the old array and push new objects into it.
                            oldVal.length = 0;
                            newVal.forEach(function (nv) {
                                oldVal.push(nv);
                            });
                        }
                    }
                    else {
                        oldVal.length = 0;
                    }
                }
            }
        });
        // if merging from an import then raw will have an entityAspect or a complexAspect
        let rawAspect = raw.entityAspect || raw.complexAspect;
        if (rawAspect) {
            let targetAspect = EntityAspect.isEntity(target) ? target.entityAspect : target.complexAspect;
            if (rawAspect.originalValuesMap) {
                targetAspect.originalValues = rawAspect.originalValuesMap;
            }
            if (rawAspect.extraMetadata) {
                targetAspect.extraMetadata = rawAspect.extraMetadata;
            }
        }
    }
    /**
    Returns a string representation of this EntityType.
    **/
    toString() {
        return this.name;
    }
    toJSON() {
        return core.toJson(this, {
            shortName: null,
            namespace: null,
            baseTypeName: null,
            isAbstract: false,
            autoGeneratedKeyType: null,
            defaultResourceName: null,
            dataProperties: localPropsOnly,
            navigationProperties: localPropsOnly,
            validators: null,
            custom: null
        });
    }
    /** @hidden @internal */
    _updateNames(property) {
        let nc = this.metadataStore.namingConvention;
        updateClientServerNames(nc, property, "name");
        if (property.isNavigationProperty) {
            updateClientServerNames(nc, property, "foreignKeyNames");
            updateClientServerNames(nc, property, "invForeignKeyNames");
            // these will get set later via _updateNps
            // this.inverse
            // this.entityType
            // this.relatedDataProperties
            //    dataProperty.relatedNavigationProperty
            //    dataProperty.inverseNavigationProperty
        }
    }
    /** @hidden @internal */
    _checkNavProperty(navigationProperty) {
        // if (navigationProperty.isNavigationProperty) {
        if (navigationProperty instanceof NavigationProperty) {
            if (navigationProperty.parentType !== this) {
                throw new Error(core.formatString("The navigationProperty '%1' is not a property of entity type '%2'", navigationProperty.name, this.name));
            }
            return navigationProperty;
        }
        if (typeof (navigationProperty) === 'string') {
            let np = this.getProperty(navigationProperty);
            // if (np && np.isNavigationProperty) return np;
            if (np && np instanceof NavigationProperty)
                return np;
        }
        throw new Error("The 'navigationProperty' parameter must either be a NavigationProperty or the name of a NavigationProperty");
    }
    /** @hidden @internal */
    _addDataProperty(dp) {
        this.dataProperties.push(dp);
        if (dp.isPartOfKey) {
            this.keyProperties.push(dp);
        }
        if (dp.isComplexProperty) {
            this.complexProperties.push(dp);
        }
        if (dp.concurrencyMode && dp.concurrencyMode !== "None") {
            this.concurrencyProperties.push(dp);
        }
        if (dp.isUnmapped) {
            this.unmappedProperties.push(dp);
        }
    }
    /** @hidden @internal */
    _addNavigationProperty(np) {
        this.navigationProperties.push(np);
        if (!isQualifiedTypeName(np.entityTypeName)) {
            np.entityTypeName = qualifyTypeName(np.entityTypeName, this.namespace);
        }
    }
    /** @hidden @internal */
    _updateCps() {
        let metadataStore = this.metadataStore;
        let incompleteTypeMap = metadataStore._incompleteComplexTypeMap;
        this.complexProperties.forEach(function (cp) {
            if (cp.complexType)
                return;
            if (!resolveCp(cp, metadataStore)) {
                core.getArray(incompleteTypeMap, cp.complexTypeName).push(cp);
            }
        });
        if (this.isComplexType) {
            (incompleteTypeMap[this.name] || []).forEach(function (cp) {
                resolveCp(cp, metadataStore);
            });
            delete incompleteTypeMap[this.name];
        }
    }
    /** @hidden @internal */
    _updateNps() {
        let metadataStore = this.metadataStore;
        // resolve all navProps for this entityType
        this.navigationProperties.forEach(function (np) {
            tryResolveNp(np, metadataStore);
        });
        let incompleteTypeMap = metadataStore._incompleteTypeMap;
        // next resolve all navProp that point to this entityType.
        (incompleteTypeMap[this.name] || []).forEach(function (np) {
            tryResolveNp(np, metadataStore);
        });
        // every navProp that pointed to this type should now be resolved
        delete incompleteTypeMap[this.name];
    }
}
/** @hidden @internal */
EntityType.__nextAnonIx = 0;
/** @hidden @internal */
EntityType.qualifyTypeName = qualifyTypeName;
EntityType.prototype._$typeName = "EntityType";
function getRawValueFromConfig(rawEntity, dp) {
    // 'true' fork can happen if an initializer contains an actaul instance of an already created complex object.
    return (rawEntity.entityAspect || rawEntity.complexAspect) ? rawEntity.getProperty(dp.name) : rawEntity[dp.name];
}
function updateClientServerNames(nc, parent, clientPropName) {
    let serverPropName = clientPropName + "OnServer";
    let clientName = parent[clientPropName];
    if (clientName && clientName.length) {
        // if (parent.isUnmapped) return;
        let serverNames = core.toArray(clientName).map(function (cName) {
            let sName = nc.clientPropertyNameToServer(cName, parent);
            let testName = nc.serverPropertyNameToClient(sName, parent);
            if (cName !== testName) {
                throw new Error("NamingConvention for this client property name does not roundtrip properly:" + cName + "-->" + testName);
            }
            return sName;
        });
        parent[serverPropName] = Array.isArray(clientName) ? serverNames : serverNames[0];
    }
    else {
        let serverName = parent[serverPropName];
        if ((!serverName) || serverName.length === 0)
            return;
        let clientNames = core.toArray(serverName).map(function (sName) {
            let cName = nc.serverPropertyNameToClient(sName, parent);
            let testName = nc.clientPropertyNameToServer(cName, parent);
            if (sName !== testName) {
                throw new Error("NamingConvention for this server property name does not roundtrip properly:" + sName + "-->" + testName);
            }
            return cName;
        });
        parent[clientPropName] = Array.isArray(serverName) ? clientNames : clientNames[0];
    }
}
function createEmptyCtor(type) {
    if (config.noEval) {
        let Entity = function () { };
        return Entity;
    }
    else {
        let name = type.name.replace(/\W/g, '_');
        return Function('return function ' + name + '(){}')();
    }
}
function coEquals(co1, co2) {
    let complexType = co1.complexAspect.parentProperty.dataType;
    let dataProps = complexType.dataProperties;
    let areEqual = dataProps.every(function (dp) {
        if (!dp.isSettable)
            return true;
        let v1 = co1.getProperty(dp.name);
        let v2 = co2.getProperty(dp.name);
        if (dp.isComplexProperty && dp.isScalar) {
            return coEquals(v1, v2);
        }
        else if (dp.isComplexProperty && !dp.isScalar) {
            return core.arrayEquals(v1, v2, coEquals);
        }
        else {
            let dataType = dp.dataType; // this will be a complexType when dp is a complexProperty
            return (v1 === v2 || (dataType && dataType.normalize && v1 && v2 && dataType.normalize(v1) === dataType.normalize(v2)));
        }
    });
    return areEqual;
}
function localPropsOnly(props) {
    return props.filter(function (prop) {
        return prop.baseProperty == null;
    });
}
function resolveCp(cp, metadataStore) {
    let complexType = metadataStore._getStructuralType(cp.complexTypeName, true);
    if (!complexType)
        return false;
    if (!(complexType instanceof ComplexType)) {
        throw new Error("Unable to resolve ComplexType with the name: " + cp.complexTypeName + " for the property: " + cp.name);
    }
    cp.dataType = complexType;
    cp.defaultValue = null;
    return true;
}
function tryResolveNp(np, metadataStore) {
    if (np.entityType)
        return true;
    let entityType = metadataStore._getStructuralType(np.entityTypeName, true);
    if (entityType) {
        np.entityType = entityType;
        np._resolveNp();
        // don't bother removing - _updateNps will do it later.
        // __arrayRemoveItem(incompleteNps, np, false);
    }
    else {
        let incompleteNps = core.getArray(metadataStore._incompleteTypeMap, np.entityTypeName);
        core.arrayAddItemUnique(incompleteNps, np);
    }
    return !!entityType;
}
function calcUnmappedProperties(stype, instance) {
    let metadataPropNames = stype.getPropertyNames();
    let modelLib = config.interfaceRegistry.modelLibrary.getDefaultInstance();
    let trackablePropNames = modelLib.getTrackablePropertyNames(instance);
    trackablePropNames.forEach(function (pn) {
        if (metadataPropNames.indexOf(pn) === -1) {
            let val = instance[pn];
            try {
                if (typeof val === "function")
                    val = val();
            }
            catch (e) {
            }
            let dt = DataType.fromValue(val);
            let newProp = new DataProperty({
                name: pn,
                dataType: dt,
                isNullable: true,
                isUnmapped: true
            });
            newProp.isSettable = core.isSettable(instance, pn);
            if (stype instanceof EntityType && stype.subtypes != null && stype.subtypes.length) {
                stype.getSelfAndSubtypes().forEach((st) => {
                    st._addPropertyCore(new DataProperty(newProp));
                });
            }
            else {
                stype._addPropertyCore(newProp);
            }
        }
    });
}
/**  Container for all of the metadata about a specific type of Complex object.
>     let complexType = new ComplexType( {
>         shortName: "address",
>         namespace: "myAppNamespace"
>     });
@param config - Configuration settings
**/
export class ComplexType {
    constructor(config) {
        /** For polymorphic purpose only - always true here */
        this.isComplexType = true;
        // copy entityType methods onto complexType
        /** See [[EntityType.getCtor]] */
        this.getCtor = EntityType.prototype.getCtor;
        // note the name change.
        this.createInstance = EntityType.prototype.createEntity;
        /** See [EntityType.addValidator] */
        this.addValidator = EntityType.prototype.addValidator;
        this.getProperty = EntityType.prototype.getProperty;
        this.getPropertiesOnPath = EntityType.prototype.getPropertiesOnPath;
        this.getPropertyNames = EntityType.prototype.getPropertyNames;
        /** @hidden @internal */
        this._addPropertyCore = EntityType.prototype._addPropertyCore;
        /** @hidden @internal */
        this._addDataProperty = EntityType.prototype._addDataProperty;
        /** @hidden @internal */
        this._updateNames = EntityType.prototype._updateNames;
        /** @hidden @internal */
        this._updateCps = EntityType.prototype._updateCps;
        /** @hidden @internal */
        this._initializeInstance = EntityType.prototype._initializeInstance;
        /** @hidden @internal */
        this._updateTargetFromRaw = EntityType.prototype._updateTargetFromRaw;
        /** @hidden @internal */
        this._setCtor = EntityType.prototype._setCtor;
        if (arguments.length > 1) {
            throw new Error("The ComplexType ctor has a single argument that is a configuration object.");
        }
        assertConfig(config)
            .whereParam("shortName").isNonEmptyString()
            .whereParam("namespace").isString().isOptional().withDefault("")
            .whereParam("dataProperties").isOptional()
            .whereParam("isComplexType").isOptional().isBoolean() // needed because this ctor can get called from the addEntityType method which needs the isComplexType prop
            .whereParam("custom").isOptional()
            .applyAll(this);
        this.name = qualifyTypeName(this.shortName, this.namespace);
        this.isComplexType = true;
        this.dataProperties = [];
        this.complexProperties = [];
        this.validators = [];
        this.concurrencyProperties = [];
        this.unmappedProperties = [];
        this._mappedPropertiesCount = 0;
        // keyProperties and navigationProperties are not used on complexTypes - but here to allow sharing of code between EntityType and ComplexType.
        this.navigationProperties = [];
        this.keyProperties = []; // may be used later to enforce uniqueness on arrays of complextypes.
        if (config.dataProperties) {
            addProperties(this, config.dataProperties, DataProperty);
        }
    }
    /**
    General purpose property set method
    >      // assume em1 is an EntityManager
    >      let addresstType = em1.metadataStore.getEntityType("Address");
    >      addressType.setProperties( {
    >          custom: { foo: 7, bar: "test" }
    >      });
    @param config - Custom config object
    @param config.custom - {Object}
    **/
    setProperties(config) {
        assertConfig(config)
            .whereParam("custom").isOptional()
            .applyAll(this);
    }
    getAllValidators() {
        // ComplexType inheritance is not YET supported.
        return this.validators;
    }
    /** @hidden @internal */
    _createInstanceCore(parent, parentProperty) {
        let aCtor = this.getCtor();
        let instance = new aCtor();
        new ComplexAspect(instance, parent, parentProperty);
        // initialization occurs during either attach or in createInstance call.
        return instance;
    }
    addProperty(dataProperty) {
        assertParam(dataProperty, "dataProperty").isInstanceOf(DataProperty).check();
        return this._addPropertyCore(dataProperty);
    }
    getProperties() {
        return this.dataProperties;
    }
    toJSON() {
        return core.toJson(this, {
            shortName: null,
            namespace: null,
            isComplexType: null,
            dataProperties: null,
            validators: null,
            custom: null
        });
    }
}
ComplexType.prototype._$typeName = "ComplexType";
/** Creates an instance of this complexType */
ComplexType.prototype.createInstance = EntityType.prototype.createEntity;
/**
A DataProperty describes the metadata for a single property of an  [[EntityType]] that contains simple data.

Instances of the DataProperty class are constructed automatically during Metadata retrieval. However it is also possible to construct them
directly via the constructor.
**/
export class DataProperty {
    /** DataProperty constructor
    >      let lastNameProp = new DataProperty( {
    >          name: "lastName",
    >          dataType: DataType.String,
    >          isNullable: true,
    >          maxLength: 20
    >      });
    >      // assuming personEntityType is a newly constructed EntityType
    >      personEntityType.addProperty(lastNameProperty);
    @param config - A configuration Object or a DataProperty
    */
    constructor(config) {
        /** Is this a DataProperty? - always true here. Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
        this.isDataProperty = true;
        /** Is this a NavigationProperty? - always false here.  Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
        this.isNavigationProperty = false;
        assertConfig(config)
            .whereParam("name").isString().isOptional()
            .whereParam("nameOnServer").isString().isOptional()
            .whereParam("dataType").isEnumOf(DataType).isOptional().or().isString().or().isInstanceOf(ComplexType)
            .whereParam("complexTypeName").isOptional()
            .whereParam("isNullable").isBoolean().isOptional().withDefault(true)
            .whereParam("isScalar").isOptional().withDefault(true) // will be false for some NoSQL databases.
            .whereParam("defaultValue").isOptional()
            .whereParam("isPartOfKey").isBoolean().isOptional()
            .whereParam("isUnmapped").isBoolean().isOptional()
            .whereParam("isSettable").isBoolean().isOptional().withDefault(true)
            .whereParam("concurrencyMode").isString().isOptional()
            .whereParam("maxLength").isNumber().isOptional()
            .whereParam("validators").isInstanceOf(Validator).isArray().isOptional().withDefault([])
            .whereParam("displayName").isOptional()
            .whereParam("enumType").isOptional()
            .whereParam("rawTypeName").isOptional() // occurs with undefined datatypes
            .whereParam("custom").isOptional()
            .applyAll(this);
        let hasName = !!(this.name || this.nameOnServer);
        if (!hasName) {
            throw new Error("A DataProperty must be instantiated with either a 'name' or a 'nameOnServer' property");
        }
        // name/nameOnServer is resolved later when a metadataStore is available.
        if (this.complexTypeName) {
            this.isComplexProperty = true;
            // this.dataType = null; // TODO: would like to remove this line because dataType will be set later.
        }
        else if (typeof (this.dataType) === "string") {
            let dt = DataType.fromName(this.dataType);
            if (!dt) {
                throw new Error("Unable to find a DataType enumeration by the name of: " + this.dataType);
            }
            this.dataType = dt;
        }
        else if (!this.dataType) {
            this.dataType = DataType.String;
        }
        // == as opposed to === is deliberate here.
        if (this.defaultValue == null) {
            if (this.isNullable) {
                this.defaultValue = null;
            }
            else {
                if (this.isComplexProperty) {
                    // what to do? - shouldn't happen from EF - but otherwise ???
                }
                else if (this.dataType === DataType.Binary) {
                    this.defaultValue = "AAAAAAAAJ3U="; // hack for all binary fields but value is specifically valid for timestamp fields - arbitrary valid 8 byte base64 value.
                }
                else {
                    this.defaultValue = this.dataType.defaultValue;
                    if (this.defaultValue == null) {
                        throw new Error("A nonnullable DataProperty cannot have a null defaultValue. Name: " + (this.name || this.nameOnServer));
                    }
                }
            }
        }
        else if (this.dataType.isNumeric) {
            // in case the defaultValue comes in as a string ( which it does in EF6).
            if (typeof (this.defaultValue) === "string") {
                this.defaultValue = parseFloat(this.defaultValue);
            }
        }
        if (this.isComplexProperty) {
            this.isScalar = this.isScalar == null || this.isScalar === true;
        }
    }
    static getRawValueFromServer(rawEntity, dp) {
        if (dp.isUnmapped) {
            return rawEntity[dp.nameOnServer || dp.name];
        }
        else {
            let val = rawEntity[dp.nameOnServer];
            return val !== undefined ? val : dp.defaultValue;
        }
    }
    static getRawValueFromClient(rawEntity, dp) {
        let val = rawEntity[dp.name];
        return val !== undefined ? val : dp.defaultValue;
    }
    resolveProperty(propName) {
        let result = this[propName];
        let baseProp = this.baseProperty;
        while (result == undefined && baseProp != null) {
            result = baseProp[propName];
            baseProp = baseProp.baseProperty;
        }
        return result;
    }
    formatName() {
        return this.parentType.name + "--" + this.name;
    }
    /**
    General purpose property set method
    >      // assume em1 is an EntityManager
    >      let prop = myEntityType.getProperty("myProperty");
    >      prop.setProperties( {
    >          custom: { foo: 7, bar: "test" }
    >      });
    @param config - A configuration object.
    **/
    setProperties(config) {
        assertConfig(config)
            .whereParam("displayName").isOptional()
            .whereParam("custom").isOptional()
            .applyAll(this);
    }
    getAllValidators() {
        let validators = this.validators.slice(0);
        let baseProp = this.baseProperty;
        while (baseProp) {
            validators.push.apply(validators, baseProp.validators);
            baseProp = baseProp.baseProperty;
        }
        return validators;
    }
    toJSON() {
        // do not serialize dataTypes that are complexTypes
        return core.toJson(this, {
            name: null,
            dataType: function (v) {
                return (v && v instanceof DataType) ? v.name : undefined;
            },
            complexTypeName: null,
            isNullable: true,
            defaultValue: null,
            isPartOfKey: false,
            isUnmapped: false,
            isSettable: true,
            concurrencyMode: null,
            maxLength: null,
            validators: null,
            displayName: null,
            enumType: null,
            rawTypeName: null,
            isScalar: true,
            custom: null
        });
    }
    static fromJSON(json) {
        json.dataType = DataType.fromName(json.dataType);
        // Parse default value into correct data type. (dateTime instances require extra work to deserialize properly.)
        if (json.defaultValue && json.dataType && json.dataType.parse) {
            json.defaultValue = json.dataType.parse(json.defaultValue, typeof json.defaultValue);
        }
        if (json.validators) {
            json.validators = json.validators.map(Validator.fromJSON);
        }
        return new DataProperty(json);
    }
}
DataProperty.prototype._$typeName = "DataProperty";
/**   A NavigationProperty describes the metadata for a single property of an [[EntityType]] that return instances of other EntityTypes.

Instances of the NavigationProperty class are constructed automatically during Metadata retrieval.   However it is also possible to construct them
directly via the constructor.
**/
export class NavigationProperty {
    /** NavigationProperty constructor
    >      let homeAddressProp = new NavigationProperty( {
    >          name: "homeAddress",
    >          entityTypeName: "Address:#myNamespace",
    >          isScalar: true,
    >          associationName: "address_person",
    >          foreignKeyNames: ["homeAddressId"]
    >      });
    >      let homeAddressIdProp = new DataProperty( {
    >          name: "homeAddressId"
    >          dataType: DataType.Integer
    >      });
    >      // assuming personEntityType is a newly constructed EntityType
    >      personEntityType.addProperty(homeAddressProp);
    >      personEntityType.addProperty(homeAddressIdProp);
    @param config - A configuration object.
    **/
    constructor(config) {
        /** Is this a DataProperty? - always false here
        Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
        this.isDataProperty = false;
        /** Is this a NavigationProperty? - always true here
        Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
        this.isNavigationProperty = true;
        this.formatName = DataProperty.prototype.formatName;
        this.getAllValidators = DataProperty.prototype.getAllValidators;
        this.resolveProperty = DataProperty.prototype.resolveProperty;
        assertConfig(config)
            .whereParam("name").isString().isOptional()
            .whereParam("nameOnServer").isString().isOptional()
            .whereParam("entityTypeName").isString()
            .whereParam("isScalar").isBoolean().isOptional().withDefault(true)
            .whereParam("associationName").isString().isOptional()
            .whereParam("foreignKeyNames").isArray().isString().isOptional().withDefault([])
            .whereParam("foreignKeyNamesOnServer").isArray().isString().isOptional().withDefault([])
            .whereParam("invForeignKeyNames").isArray().isString().isOptional().withDefault([])
            .whereParam("invForeignKeyNamesOnServer").isArray().isString().isOptional().withDefault([])
            .whereParam("validators").isInstanceOf(Validator).isArray().isOptional().withDefault([])
            .whereParam("displayName").isOptional()
            .whereParam("custom").isOptional()
            .applyAll(this);
        let hasName = !!(this.name || this.nameOnServer);
        if (!hasName) {
            throw new Error("A Navigation property must be instantiated with either a 'name' or a 'nameOnServer' property");
        }
    }
    /**
    General purpose property set method
    >      // assume myEntityType is an EntityType
    >      let prop = myEntityType.getProperty("myProperty");
    >      prop.setProperties( {
    >          custom: { foo: 7, bar: "test" }
    >      });
    @param config - A config object
    **/
    // TODO: create an interface for this.
    setProperties(config) {
        if (!this.parentType) {
            throw new Error("Cannot call NavigationProperty.setProperties until the parent EntityType of the NavigationProperty has been set.");
        }
        let inverse = config.inverse;
        if (inverse)
            delete config.inverse;
        assertConfig(config)
            .whereParam("displayName").isOptional()
            .whereParam("foreignKeyNames").isArray().isString().isOptional().withDefault([])
            .whereParam("invForeignKeyNames").isArray().isString().isOptional().withDefault([])
            .whereParam("custom").isOptional()
            .applyAll(this);
        this.parentType._updateNames(this);
        this._resolveNp();
        if (inverse) {
            this.setInverse(inverse);
        }
    }
    /** The inverse of this NavigationProperty.  The NavigationProperty that represents a navigation in the opposite direction
    to this NavigationProperty. May be undefined for a undirectional NavigationProperty. __Read Only__ */
    get inverse() {
        return this.getInverse();
    }
    /** @hidden @internal */
    getInverse() {
        let np = this;
        while (!np._inverse && np.baseProperty) {
            np = np.baseProperty;
        }
        return np._inverse;
    }
    setInverse(inverseNp) {
        // let invNp: NavigationProperty;
        let invNp = (inverseNp instanceof NavigationProperty) ? inverseNp : this.entityType.getNavigationProperty(inverseNp);
        if (!invNp) {
            throw throwSetInverseError(this, "Unable to find inverse property: " + inverseNp);
        }
        if (this._inverse || invNp._inverse) {
            throwSetInverseError(this, "It has already been set on one side or the other.");
        }
        if (invNp.entityType !== this.parentType) {
            throwSetInverseError(this, invNp.formatName + " is not a valid inverse property for this.");
        }
        if (this.associationName) {
            invNp.associationName = this.associationName;
        }
        else {
            if (!invNp.associationName) {
                invNp.associationName = this.formatName() + "_" + invNp.formatName();
            }
            this.associationName = invNp.associationName;
        }
        this._resolveNp();
        invNp._resolveNp();
    }
    // // In progress - will be used for manual metadata config
    // createInverse(config: any) {
    //   if (!this.entityType) {
    //     throwCreateInverseError(this, "has not yet been defined.");
    //   }
    //   if (this.entityType.isFrozen) {
    //     throwCreateInverseError(this, "is frozen.");
    //   }
    //   let metadataStore = this.entityType.metadataStore;
    //   if (metadataStore == null) {
    //     throwCreateInverseError(this, "has not yet been added to the metadataStore.");
    //   }
    //   config.entityTypeName = this.parentEntityType.name;
    //   config.associationName = this.associationName;
    //   let invNp = new NavigationProperty(config);
    //   this.parentEntityType.addNavigationProperty(invNp);
    //   return invNp;
    // };
    toJSON() {
        return core.toJson(this, {
            name: null,
            entityTypeName: null,
            isScalar: null,
            associationName: null,
            validators: null,
            displayName: null,
            foreignKeyNames: null,
            invForeignKeyNames: null,
            custom: null
        });
    }
    static fromJSON(json) {
        if (json.validators) {
            json.validators = json.validators.map(Validator.fromJSON);
        }
        return new NavigationProperty(json);
    }
    /** @hidden @internal */
    _resolveNp() {
        let np = this;
        let entityType = np.entityType;
        let invNp = core.arrayFirst(entityType.navigationProperties, (altNp) => {
            // Can't do this because of possibility of comparing a base class np with a subclass altNp.
            // return altNp.associationName === np.associationName
            //    && altNp !== np;
            // So use this instead.
            return altNp.associationName === np.associationName &&
                (altNp.name !== np.name || altNp.entityTypeName !== np.entityTypeName);
        });
        np._inverse = invNp || undefined;
        //if (invNp && invNp.inverse == null) {
        //    invNp._resolveNp();
        //}
        if (!invNp) {
            // unidirectional 1-n relationship
            np.invForeignKeyNames.forEach(function (invFkName) {
                let fkProp = entityType.getDataProperty(invFkName);
                if (fkProp == null) {
                    throw new Error("EntityType '" + np.entityTypeName + "' has no foreign key matching '" + invFkName + "'");
                }
                let invEntityType = np.parentType;
                invNp = core.arrayFirst(invEntityType.navigationProperties, (np2) => {
                    return np2.invForeignKeyNames && np2.invForeignKeyNames.indexOf(fkProp.name) >= 0 && np2.entityType === fkProp.parentType;
                });
                fkProp.inverseNavigationProperty = invNp || undefined;
                core.arrayAddItemUnique(entityType.foreignKeyProperties, fkProp);
            });
        }
        resolveRelated(np);
    }
}
NavigationProperty.prototype._$typeName = "NavigationProperty";
function throwSetInverseError(np, message) {
    throw new Error("Cannot set the inverse property for: " + np.formatName() + ". " + message);
}
// Not current used.
// function throwCreateInverseError(np: NavigationProperty, message: string) {
//   throw new Error("Cannot create inverse for: " + np.formatName() + ". The entityType for this navigation property " + message);
// }
// sets navigation property: relatedDataProperties and dataProperty: relatedNavigationProperty
function resolveRelated(np) {
    let fkNames = np.foreignKeyNames;
    if (fkNames.length === 0)
        return;
    let parentEntityType = np.parentType;
    let fkProps = fkNames.map(function (fkName) {
        return parentEntityType.getDataProperty(fkName);
    });
    let fkPropCollection = parentEntityType.foreignKeyProperties;
    fkProps.forEach((dp) => {
        core.arrayAddItemUnique(fkPropCollection, dp);
        dp.relatedNavigationProperty = np;
        // now update the inverse
        core.arrayAddItemUnique(np.entityType.inverseForeignKeyProperties, dp);
        if (np.relatedDataProperties) {
            core.arrayAddItemUnique(np.relatedDataProperties, dp);
        }
        else {
            np.relatedDataProperties = [dp];
        }
    });
}
/**
AutoGeneratedKeyType is an 'Enum' containing all of the valid states for an automatically generated key.
**/
export class AutoGeneratedKeyType extends BreezeEnum {
}
/**
This entity does not have an autogenerated key.
The client must set the key before adding the entity to the EntityManager
**/
AutoGeneratedKeyType.None = new AutoGeneratedKeyType();
/**
This entity's key is an Identity column and is set by the backend database.
Keys for new entities will be temporary until the entities are saved at which point the keys will
be converted to their 'real' versions.
**/
AutoGeneratedKeyType.Identity = new AutoGeneratedKeyType();
/**
This entity's key is generated by a KeyGenerator and is set by the backend database.
Keys for new entities will be temporary until the entities are saved at which point the keys will
be converted to their 'real' versions.
**/
AutoGeneratedKeyType.KeyGenerator = new AutoGeneratedKeyType();
AutoGeneratedKeyType.prototype._$typeName = "AutoGeneratedKeyType";
Error['x'] = AutoGeneratedKeyType.resolveSymbols();
let proto = Param.prototype;
// 'this' below is TS annotation 
proto.isEntity = function () {
    return this._addContext({
        fn: isEntity,
        msg: " must be an entity"
    });
};
function isEntity(context, v) {
    if (v == null)
        return false;
    return (v.entityType !== undefined);
}
proto.isEntityProperty = function () {
    return this._addContext({
        fn: isEntityProperty,
        msg: " must be either a DataProperty or a NavigationProperty"
    });
};
function isEntityProperty(context, v) {
    if (v == null)
        return false;
    return (v.isDataProperty || v.isNavigationProperty);
}
// functions shared between classes related to Metadata
function isQualifiedTypeName(entityTypeName) {
    return entityTypeName.indexOf(":#") >= 0;
}
export function qualifyTypeName(shortName, ns) {
    if (ns && ns.length > 0) {
        return shortName + ":#" + ns;
    }
    else {
        return shortName;
    }
}
// Used by both ComplexType and EntityType
function addProperties(entityType, propObj, ctor) {
    if (propObj == null)
        return;
    if (Array.isArray(propObj)) {
        propObj.forEach(entityType._addPropertyCore.bind(entityType));
    }
    else if (typeof (propObj) === 'object') {
        for (let key in propObj) {
            if (core.hasOwnProperty(propObj, key)) {
                let value = propObj[key];
                value.name = key;
                let prop = new ctor(value);
                entityType._addPropertyCore(prop);
            }
        }
    }
    else {
        throw new Error("The 'dataProperties' or 'navigationProperties' values must be either an array of data/nav properties or an object where each property defines a data/nav property");
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXR5LW1ldGFkYXRhLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYnJlZXplLWNsaWVudC8iLCJzb3VyY2VzIjpbInNyYy9lbnRpdHktbWV0YWRhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxRQUFRLENBQUM7QUFDN0MsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUNsQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sU0FBUyxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2xFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDdkMsT0FBTyxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQTJDLE1BQU0saUJBQWlCLENBQUM7QUFDdkcsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN6QyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDcEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDLENBQUMsMkJBQTJCO0FBQ3hGLE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQy9FLE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBdUM1RTs7Ozs7R0FLRztBQUNILE1BQU0sT0FBTyxhQUFhO0lBcUR4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcUJHO0lBQ0gsWUFBWSxNQUE0QjtRQUN0QyxNQUFNLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQztRQUN0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M0MsQ0FBQztBQUVELE1BQU0sVUFBVSxlQUFlLENBQUMsU0FBaUIsRUFBRSxFQUFXO0lBQzVELElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3ZCLE9BQU8sU0FBUyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7S0FDOUI7U0FBTTtRQUNMLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0FBQ0gsQ0FBQztBQUVELDBDQUEwQztBQUMxQyxTQUFTLGFBQWEsQ0FBQyxVQUEwQixFQUFFLE9BQTJCLEVBQUUsSUFBUztJQUN2RixJQUFJLE9BQU8sSUFBSSxJQUFJO1FBQUUsT0FBTztJQUM1QixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDMUIsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7S0FDL0Q7U0FBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxRQUFRLEVBQUU7UUFDeEMsS0FBSyxJQUFJLEdBQUcsSUFBSSxPQUFPLEVBQUU7WUFDdkIsSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsRUFBRTtnQkFDckMsSUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QixLQUFLLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQztnQkFDakIsSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzNCLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNuQztTQUNGO0tBQ0Y7U0FBTTtRQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsbUtBQW1LLENBQUMsQ0FBQztLQUN0TDtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb3JlLCBFcnJvckNhbGxiYWNrIH0gZnJvbSAnLi9jb3JlJztcclxuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xyXG5pbXBvcnQgeyBCcmVlemVFdmVudCB9IGZyb20gJy4vZXZlbnQnO1xyXG5pbXBvcnQgeyBhc3NlcnRQYXJhbSwgYXNzZXJ0Q29uZmlnLCBQYXJhbSB9IGZyb20gJy4vYXNzZXJ0LXBhcmFtJztcclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuL2RhdGEtdHlwZSc7XHJcbmltcG9ydCB7IEVudGl0eUFzcGVjdCwgQ29tcGxleEFzcGVjdCwgRW50aXR5LCBDb21wbGV4T2JqZWN0LCBTdHJ1Y3R1cmFsT2JqZWN0IH0gZnJvbSAnLi9lbnRpdHktYXNwZWN0JztcclxuaW1wb3J0IHsgRW50aXR5S2V5IH0gZnJvbSAnLi9lbnRpdHkta2V5JztcclxuaW1wb3J0IHsgVmFsaWRhdG9yIH0gZnJvbSAnLi92YWxpZGF0ZSc7XHJcbmltcG9ydCB7IEJyZWV6ZUVudW0gfSBmcm9tICcuL2VudW0nO1xyXG5pbXBvcnQgeyBEYXRhU2VydmljZSB9IGZyb20gJy4vZGF0YS1zZXJ2aWNlJztcclxuaW1wb3J0IHsgTmFtaW5nQ29udmVudGlvbiB9IGZyb20gJy4vbmFtaW5nLWNvbnZlbnRpb24nO1xyXG5pbXBvcnQgeyBDc2RsTWV0YWRhdGFQYXJzZXIgfSBmcm9tICcuL2NzZGwtbWV0YWRhdGEtcGFyc2VyJzsgLy8gVE9ETyBpc29sYXRlIHRoaXMgbGF0ZXI7XHJcbmltcG9ydCB7IExvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucyB9IGZyb20gJy4vbG9jYWwtcXVlcnktY29tcGFyaXNvbi1vcHRpb25zJztcclxuaW1wb3J0IHsgZGVmYXVsdFByb3BlcnR5SW50ZXJjZXB0b3IgfSBmcm9tICcuL2RlZmF1bHQtcHJvcGVydHktaW50ZXJjZXB0b3InO1xyXG5cclxuZXhwb3J0IHR5cGUgRW50aXR5UHJvcGVydHkgPSBEYXRhUHJvcGVydHkgfCBOYXZpZ2F0aW9uUHJvcGVydHk7XHJcbmV4cG9ydCB0eXBlIFN0cnVjdHVyYWxUeXBlID0gRW50aXR5VHlwZSB8IENvbXBsZXhUeXBlO1xyXG5cclxuLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVN0cnVjdHVyYWxUeXBlTWFwIHtcclxuICBbaW5kZXg6IHN0cmluZ106IFN0cnVjdHVyYWxUeXBlO1xyXG59XHJcblxyXG4vLyBUT0RPOiBjb25zaWRlciBleHBvc2luZyBsYXRlclxyXG4vKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBJTWV0YWRhdGFKc29uIHtcclxuICBtZXRhZGF0YVZlcnNpb246IHN0cmluZztcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgbmFtaW5nQ29udmVudGlvbjogc3RyaW5nO1xyXG4gIGxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9uczogc3RyaW5nO1xyXG4gIGRhdGFTZXJ2aWNlczogT2JqZWN0W107IC8vIElEYXRhU2VydmljZUpzb25bXVxyXG4gIHN0cnVjdHVyYWxUeXBlczogT2JqZWN0W107IC8vIElTdHJ1Y3R1cmFsVHlwZUpzb25bXTsgXHJcbiAgcmVzb3VyY2VFbnRpdHlUeXBlTWFwOiBPYmplY3RbXTsgLy8gSVJlc291cmNlRW50aXR5VHlwZUpzb25bXVxyXG4gIGluY29tcGxldGVUeXBlTWFwOiBPYmplY3RbXTtcclxufVxyXG5cclxuLyoqIENvbmZpZ3VyYXRpb24gaW5mbyB0byBiZSBwYXNzZWQgdG8gdGhlIFtbTWV0YWRhdGFTdG9yZV1dIGNvbnN0cnVjdG9yICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGFTdG9yZUNvbmZpZyB7XHJcbiAgLyoqIFRoZSAgW1tOYW1pbmdDb252ZW50aW9uXV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgTWV0YWRhdGFTdG9yZS4gKi9cclxuICBuYW1pbmdDb252ZW50aW9uPzogTmFtaW5nQ29udmVudGlvbjtcclxuICAvKiogVGhlICBbW0xvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9uc11dIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1ldGFkYXRhU3RvcmUuICovXHJcbiAgbG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zPzogTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zO1xyXG4gIHNlcmlhbGl6ZXJGbj86IChwcm9wOiBFbnRpdHlQcm9wZXJ0eSwgdmFsOiBhbnkpID0+IGFueTtcclxuICBuYW1lPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFkYXRhRmV0Y2hlZEV2ZW50QXJncyB7XHJcbiAgbWV0YWRhdGFTdG9yZTogTWV0YWRhdGFTdG9yZTtcclxuICBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UgfCBzdHJpbmc7XHJcbiAgcmF3TWV0YWRhdGE6IGFueTtcclxufVxyXG5cclxuLyoqXHJcbkFuIGluc3RhbmNlIG9mIHRoZSBNZXRhZGF0YVN0b3JlIGNvbnRhaW5zIGFsbCBvZiB0aGUgbWV0YWRhdGEgYWJvdXQgYSBjb2xsZWN0aW9uIG9mIFtbRW50aXR5VHlwZV1dJ3MuXHJcbk1ldGFkYXRhU3RvcmVzIG1heSBiZSBzaGFyZWQgYWNyb3NzIFtbRW50aXR5TWFuYWdlcl1dJ3MuICBJZiBhbiBFbnRpdHlNYW5hZ2VyIGlzIGNyZWF0ZWQgd2l0aG91dCBhblxyXG5leHBsaWNpdCBNZXRhZGF0YVN0b3JlLCB0aGUgTWV0YWRhdGFTdG9yZSBmcm9tIHRoZSBNZXRhZGF0YVN0b3JlLmRlZmF1bHRJbnN0YW5jZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXHJcbkBkeW5hbWljXHJcbioqL1xyXG5leHBvcnQgY2xhc3MgTWV0YWRhdGFTdG9yZSB7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgXyR0eXBlTmFtZTogc3RyaW5nOyAvLyBvbiBwcm90b1xyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgX19pZCA9IDA7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgc3RhdGljIEFOT05UWVBFX1BSRUZJWCA9IFwiX0lCX1wiO1xyXG4gIC8qKiBUaGUgdmVyc2lvbiBvZiBhbnkgTWV0YWRhdGFTdG9yZXMgY3JlYXRlZCBieSB0aGlzIGNsYXNzICovXHJcbiAgc3RhdGljIG1ldGFkYXRhVmVyc2lvbiA9ICcxLjAuNSc7XHJcblxyXG4gIG5hbWU6IHN0cmluZztcclxuICBkYXRhU2VydmljZXM6IERhdGFTZXJ2aWNlW107XHJcblxyXG4gIC8qKiBUaGUgIFtbTmFtaW5nQ29udmVudGlvbl1dIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1ldGFkYXRhU3RvcmUuIF9fUmVhZCBPbmx5X18gKi9cclxuICBuYW1pbmdDb252ZW50aW9uOiBOYW1pbmdDb252ZW50aW9uO1xyXG4gIC8qKiBUaGUgIFtbTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zXV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgTWV0YWRhdGFTdG9yZS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9uczogTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zO1xyXG4gIHNlcmlhbGl6ZXJGbj86IChwcm9wOiBFbnRpdHlQcm9wZXJ0eSwgdmFsOiBhbnkpID0+IGFueTtcclxuICAvKipcclxuICBBbiBbW0JyZWV6ZUV2ZW50XV0gdGhhdCBmaXJlcyBhZnRlciBhIE1ldGFkYXRhU3RvcmUgaGFzIGNvbXBsZXRlZCBmZXRjaGluZyBtZXRhZGF0YSBmcm9tIGEgcmVtb3RlIHNlcnZpY2UuXHJcbiAgXHJcbiAgQGV2ZW50QXJncyAtXHJcbiAgICAtIG1ldGFkYXRhU3RvcmUgLSBUaGUgTWV0YWRhdGFTdG9yZSBpbnRvIHdoaWNoIHRoZSBtZXRhZGF0YSB3YXMgZmV0Y2hlZC5cclxuICAgIC0gZGF0YVNlcnZpY2UgLSBUaGUgW1tEYXRhU2VydmljZV1dIHRoYXQgbWV0YWRhdGEgd2FzIGZldGNoZWQgZnJvbS5cclxuICAgIC0gcmF3TWV0YWRhdGEgLSB7T2JqZWN0fSBUaGUgcmF3IG1ldGFkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZpY2UuIChJdCB3aWxsIGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCBieSB0aGlzIHBvaW50KS5cclxuICA+ICAgICAgbGV0IG1zID0gbXlFbnRpdHlNYW5hZ2VyLm1ldGFkYXRhU3RvcmU7XHJcbiAgPiAgICAgIG1zLm1ldGFkYXRhRmV0Y2hlZC5zdWJzY3JpYmUoZnVuY3Rpb24oYXJncykge1xyXG4gID4gICAgICAgICAgbGV0IG1ldGFkYXRhU3RvcmUgPSBhcmdzLm1ldGFkYXRhU3RvcmU7XHJcbiAgPiAgICAgICAgICBsZXQgZGF0YVNlcnZpY2UgPSBhcmdzLmRhdGFTZXJ2aWNlO1xyXG4gID4gICAgICB9KTtcclxuICBAZXZlbnRcclxuICAqKi9cclxuICBtZXRhZGF0YUZldGNoZWQ6IEJyZWV6ZUV2ZW50PE1ldGFkYXRhRmV0Y2hlZEV2ZW50QXJncz47XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX3Jlc291cmNlRW50aXR5VHlwZU1hcDoge307XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2VudGl0eVR5cGVSZXNvdXJjZU1hcDoge307XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX3N0cnVjdHVyYWxUeXBlTWFwOiBJU3RydWN0dXJhbFR5cGVNYXA7IC8vIGtleSBpcyBxdWFsaWZpZWQgc3RydWN0dXJhbHR5cGUgbmFtZSAtIHZhbHVlIGlzIHN0cnVjdHVyYWxUeXBlLiAoIHN0cnVjdHVyYWwgPSBlbnRpdHlUeXBlIG9yIGNvbXBsZXhUeXBlKS5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKiovXHJcbiAgX3Nob3J0TmFtZU1hcDoge307IC8vIGtleSBpcyBzaG9ydE5hbWUsIHZhbHVlIGlzIHF1YWxpZmllZCBuYW1lIC0gZG9lcyBub3QgbmVlZCB0byBiZSBzZXJpYWxpemVkLlxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqKi9cclxuICBfY3RvclJlZ2lzdHJ5OiB7fTsgLy8ga2V5IGlzIGVpdGhlciBzaG9ydCBvciBxdWFsIHR5cGUgbmFtZSAtIHZhbHVlIGlzIGN0b3I7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICoqL1xyXG4gIF9pbmNvbXBsZXRlVHlwZU1hcDoge307IC8vIGtleSBpcyBlbnRpdHlUeXBlTmFtZTsgdmFsdWUgaXMgYXJyYXkgb2YgbmF2IHByb3BzXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICoqL1xyXG4gIF9pbmNvbXBsZXRlQ29tcGxleFR5cGVNYXA6IHt9OyAvL1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqKi9cclxuICBfZGVmZXJyZWRUeXBlczoge307XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICoqL1xyXG4gIF9pZDogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICBDb25zdHJ1Y3RzIGEgbmV3IE1ldGFkYXRhU3RvcmUuXHJcbiAgXHJcbiAgPiAgICAgbGV0IG1zID0gbmV3IE1ldGFkYXRhU3RvcmUoKTtcclxuXHJcbiAgVGhlIHN0b3JlIGNhbiB0aGVuIGJlIGFzc29jaWF0ZWQgd2l0aCBhbiBFbnRpdHlNYW5hZ2VyXHJcbiAgPiAgICAgbGV0IGVudGl0eU1hbmFnZXIgPSBuZXcgRW50aXR5TWFuYWdlcigge1xyXG4gID4gICAgICAgICBzZXJ2aWNlTmFtZTogXCJicmVlemUvTm9ydGh3aW5kSUJNb2RlbFwiLCBcclxuICA+ICAgICAgICAgbWV0YWRhdGFTdG9yZTogbXMgXHJcbiAgPiAgICAgfSk7XHJcblxyXG4gIG9yIGZvciBhbiBleGlzdGluZyBFbnRpdHlNYW5hZ2VyXHJcbiAgPiAgICAvLyBBc3N1bWUgZW0xIGlzIGFuIGV4aXN0aW5nIEVudGl0eU1hbmFnZXJcclxuICA+ICAgIGVtMS5zZXRQcm9wZXJ0aWVzKCB7IG1ldGFkYXRhU3RvcmU6IG1zIH0pO1xyXG4gIFxyXG4gIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIHNldHRpbmdzIC5cclxuICAgIC0gbmFtaW5nQ29udmVudGlvbiAtIChkZWZhdWx0PU5hbWluZ0NvbnZlbnRpb24uZGVmYXVsdEluc3RhbmNlKSBOYW1pbmdDb252ZW50aW9uIHRvIGJlIHVzZWQgaW4gbWFwcGluZyBwcm9wZXJ0eSBuYW1lc1xyXG4gIGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXIuIFVzZXMgdGhlIE5hbWluZ0NvbnZlbnRpb24uZGVmYXVsdEluc3RhbmNlIGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAtIGxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucyAtIChkZWZhdWx0PUxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucy5kZWZhdWx0SW5zdGFuY2UpIFRoZSBMb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnMgdG8gYmVcclxuICB1c2VkIHdoZW4gcGVyZm9ybWluZyBcImxvY2FsIHF1ZXJpZXNcIiBpbiBvcmRlciB0byBtYXRjaCB0aGUgc2VtYW50aWNzIG9mIHF1ZXJpZXMgYWdhaW5zdCBhIHJlbW90ZSBzZXJ2aWNlLlxyXG4gICAgLSBzZXJpYWxpemVyRm4gLSBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBtZWRpYXRlIHRoZSBzZXJpYWxpemF0aW9uIG9mIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXHJcbiAgKiovXHJcbiAgY29uc3RydWN0b3IoY29uZmlnPzogTWV0YWRhdGFTdG9yZUNvbmZpZykge1xyXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG4gICAgYXNzZXJ0Q29uZmlnKGNvbmZpZylcclxuICAgICAgLndoZXJlUGFyYW0oXCJuYW1pbmdDb252ZW50aW9uXCIpLmlzT3B0aW9uYWwoKS5pc0luc3RhbmNlT2YoTmFtaW5nQ29udmVudGlvbikud2l0aERlZmF1bHQoTmFtaW5nQ29udmVudGlvbi5kZWZhdWx0SW5zdGFuY2UpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwibG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zXCIpLmlzT3B0aW9uYWwoKS5pc0luc3RhbmNlT2YoTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zKS53aXRoRGVmYXVsdChMb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnMuZGVmYXVsdEluc3RhbmNlKVxyXG4gICAgICAud2hlcmVQYXJhbShcInNlcmlhbGl6ZXJGblwiKS5pc09wdGlvbmFsKCkuaXNGdW5jdGlvbigpXHJcbiAgICAgIC5hcHBseUFsbCh0aGlzKTtcclxuICAgIHRoaXMuZGF0YVNlcnZpY2VzID0gW107IC8vIGFycmF5IG9mIGRhdGFTZXJ2aWNlcztcclxuICAgIHRoaXMuX3Jlc291cmNlRW50aXR5VHlwZU1hcCA9IHt9OyAvLyBrZXkgaXMgcmVzb3VyY2UgbmFtZSAtIHZhbHVlIGlzIHF1YWxpZmllZCBlbnRpdHlUeXBlIG5hbWVcclxuICAgIHRoaXMuX3N0cnVjdHVyYWxUeXBlTWFwID0ge307IC8vIGtleSBpcyBxdWFsaWZpZWQgc3RydWN0dXJhbHR5cGUgbmFtZSAtIHZhbHVlIGlzIHN0cnVjdHVyYWxUeXBlLiAoIHN0cnVjdHVyYWwgPSBlbnRpdHlUeXBlIG9yIGNvbXBsZXhUeXBlKS5cclxuICAgIHRoaXMuX3Nob3J0TmFtZU1hcCA9IHt9OyAvLyBrZXkgaXMgc2hvcnROYW1lLCB2YWx1ZSBpcyBxdWFsaWZpZWQgbmFtZSAtIGRvZXMgbm90IG5lZWQgdG8gYmUgc2VyaWFsaXplZC5cclxuICAgIHRoaXMuX2N0b3JSZWdpc3RyeSA9IHt9OyAvLyBrZXkgaXMgZWl0aGVyIHNob3J0IG9yIHF1YWwgdHlwZSBuYW1lIC0gdmFsdWUgaXMgY3RvcjtcclxuXHJcbiAgICB0aGlzLl9pbmNvbXBsZXRlVHlwZU1hcCA9IHt9OyAvLyBrZXkgaXMgZW50aXR5VHlwZU5hbWU7IHZhbHVlIGlzIGFycmF5IG9mIG5hdiBwcm9wc1xyXG4gICAgdGhpcy5faW5jb21wbGV0ZUNvbXBsZXhUeXBlTWFwID0ge307IC8vIGtleSBpcyBjb21wbGV4VHlwZU5hbWU7IHZhbHVlIGlzIGFycmF5IG9mIGNvbXBsZXhUeXBlIHByb3BzXHJcbiAgICB0aGlzLl9pZCA9IE1ldGFkYXRhU3RvcmUuX19pZCsrO1xyXG4gICAgdGhpcy5tZXRhZGF0YUZldGNoZWQgPSBuZXcgQnJlZXplRXZlbnQoXCJtZXRhZGF0YUZldGNoZWRcIiwgdGhpcyk7XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gbmVlZHMgdG8gYmUgbWFkZSBhdmFpbCB0byBkYXRhU2VydmljZS54eHggZmlsZXNcclxuICBzdGF0aWMgbm9ybWFsaXplVHlwZU5hbWUgPSBjb3JlLm1lbW9pemUoZnVuY3Rpb24gKHJhd1R5cGVOYW1lOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiByYXdUeXBlTmFtZSAmJiBNZXRhZGF0YVN0b3JlLnBhcnNlVHlwZU5hbWUocmF3VHlwZU5hbWUpLnR5cGVOYW1lO1xyXG4gIH0pO1xyXG4gIC8vIGZvciBkZWJ1Z2dpbmcgdXNlIHRoZSBsaW5lIGJlbG93IGluc3RlYWQuXHJcbiAgLy9jdG9yLm5vcm1hbGl6ZVR5cGVOYW1lID0gZnVuY3Rpb24gKHJhd1R5cGVOYW1lKSB7IHJldHVybiBwYXJzZVR5cGVOYW1lKHJhd1R5cGVOYW1lKS50eXBlTmFtZTsgfTtcclxuXHJcbiAgLyoqXHJcbiAgR2VuZXJhbCBwdXJwb3NlIHByb3BlcnR5IHNldCBtZXRob2RcclxuICBcclxuICA+ICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXIgY29udGFpbmluZyBhIG51bWJlciBvZiBleGlzdGluZyBlbnRpdGllcy5cclxuICA+ICAgICBlbTEubWV0YWRhdGFTdG9yZS5zZXRQcm9wZXJ0aWVzKCB7XHJcbiAgPiAgICAgICAgIHZlcnNpb246IFwiNi4xLjNcIixcclxuICA+ICAgICAgICAgc2VyaWFsaXplckZuOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xyXG4gID4gICAgICAgICByZXR1cm4gKHByb3AuaXNVbm1hcHBlZCkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcclxuICA+ICAgICAgICAgfVxyXG4gID4gICAgICl9O1xyXG4gIEBwYXJhbSBjb25maWcgLSAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB0byBzZXQuXHJcbiAgKiovXHJcbiAgc2V0UHJvcGVydGllcyhjb25maWc6IE1ldGFkYXRhU3RvcmVDb25maWcpIHtcclxuICAgIGFzc2VydENvbmZpZyhjb25maWcpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwibmFtZVwiKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcInNlcmlhbGl6ZXJGblwiKS5pc0Z1bmN0aW9uKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC5hcHBseUFsbCh0aGlzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIEFkZHMgYSBEYXRhU2VydmljZSB0byB0aGlzIE1ldGFkYXRhU3RvcmUuIElmIGEgRGF0YVNlcnZpY2Ugd2l0aCB0aGUgc2FtZSBzZXJ2aWNlTmFtZSBpcyBhbHJlYWR5XHJcbiAgaW4gdGhlIE1ldGFkYXRhU3RvcmUgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG4gIEBwYXJhbSBkYXRhU2VydmljZSAtIFRoZSBbW0RhdGFTZXJ2aWNlXV0gdG8gYWRkXHJcbiAgQHBhcmFtIHNob3VsZE92ZXJ3cml0ZSAtIChkZWZhdWx0PWZhbHNlKSBQZXJtaXQgb3ZlcndyaXRlIG9mIGV4aXN0aW5nIERhdGFTZXJ2aWNlIHJhdGhlciB0aGFuIHRocm93IGV4Y2VwdGlvblxyXG4gICoqL1xyXG4gIGFkZERhdGFTZXJ2aWNlKGRhdGFTZXJ2aWNlOiBEYXRhU2VydmljZSwgc2hvdWxkT3ZlcndyaXRlPzogYm9vbGVhbikge1xyXG4gICAgYXNzZXJ0UGFyYW0oZGF0YVNlcnZpY2UsIFwiZGF0YVNlcnZpY2VcIikuaXNJbnN0YW5jZU9mKERhdGFTZXJ2aWNlKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0oc2hvdWxkT3ZlcndyaXRlLCBcInNob3VsZE92ZXJ3cml0ZVwiKS5pc0Jvb2xlYW4oKS5pc09wdGlvbmFsKCkuY2hlY2soKTtcclxuICAgIGxldCBpeCA9IHRoaXMuX2dldERhdGFTZXJ2aWNlSW5kZXgoZGF0YVNlcnZpY2Uuc2VydmljZU5hbWUpO1xyXG4gICAgaWYgKGl4ID49IDApIHtcclxuICAgICAgaWYgKCEhc2hvdWxkT3ZlcndyaXRlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhU2VydmljZXNbaXhdID0gZGF0YVNlcnZpY2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBkYXRhU2VydmljZSB3aXRoIHRoaXMgbmFtZSAnXCIgKyBkYXRhU2VydmljZS5zZXJ2aWNlTmFtZSArIFwiJyBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIE1ldGFkYXRhU3RvcmVcIik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGF0YVNlcnZpY2VzLnB1c2goZGF0YVNlcnZpY2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2dldERhdGFTZXJ2aWNlSW5kZXgoc2VydmljZU5hbWU6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIGNvcmUuYXJyYXlJbmRleE9mKHRoaXMuZGF0YVNlcnZpY2VzLCBmdW5jdGlvbiAoZHMpIHtcclxuICAgICAgcmV0dXJuIGRzLnNlcnZpY2VOYW1lID09PSBzZXJ2aWNlTmFtZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgQWRkcyBhbiBFbnRpdHlUeXBlIHRvIHRoaXMgTWV0YWRhdGFTdG9yZS4gIE5vIGFkZGl0aW9uYWwgcHJvcGVydGllcyBtYXkgYmUgYWRkZWQgdG8gdGhlIEVudGl0eVR5cGUgYWZ0ZXIgaXRzIGhhc1xyXG4gIGJlZW4gYWRkZWQgdG8gdGhlIE1ldGFkYXRhU3RvcmUuXHJcbiAgQHBhcmFtIHN0cnVjdHVyYWxUeXBlIC0gVGhlIEVudGl0eVR5cGUgb3IgQ29tcGxleFR5cGUgdG8gYWRkXHJcbiAgKiovXHJcbiAgYWRkRW50aXR5VHlwZShzdHlwZTogU3RydWN0dXJhbFR5cGUgfCBFbnRpdHlUeXBlQ29uZmlnIHwgQ29tcGxleFR5cGVDb25maWcpIHtcclxuICAgIGxldCBzdHJ1Y3R1cmFsVHlwZTogU3RydWN0dXJhbFR5cGU7XHJcbiAgICBpZiAoc3R5cGUgaW5zdGFuY2VvZiBFbnRpdHlUeXBlIHx8IHN0eXBlIGluc3RhbmNlb2YgQ29tcGxleFR5cGUpIHtcclxuICAgICAgc3RydWN0dXJhbFR5cGUgPSBzdHlwZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0cnVjdHVyYWxUeXBlID0gKHN0eXBlIGFzIGFueSkuaXNDb21wbGV4VHlwZSA/IG5ldyBDb21wbGV4VHlwZShzdHlwZSkgOiBuZXcgRW50aXR5VHlwZShzdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaWYgKCFzdHJ1Y3R1cmFsVHlwZS5pc0NvbXBsZXhUeXBlKSB7IC8vIHNhbWUgYXMgYmVsb3cgYnV0IGlzbid0IGEgJ3R5cGUgZ3VhcmQnXHJcbiAgICBpZiAoc3RydWN0dXJhbFR5cGUgaW5zdGFuY2VvZiBFbnRpdHlUeXBlKSB7XHJcbiAgICAgIGlmIChzdHJ1Y3R1cmFsVHlwZS5iYXNlVHlwZU5hbWUgJiYgIXN0cnVjdHVyYWxUeXBlLmJhc2VFbnRpdHlUeXBlKSB7XHJcbiAgICAgICAgbGV0IGJhc2VFbnRpdHlUeXBlID0gdGhpcy5fZ2V0U3RydWN0dXJhbFR5cGUoc3RydWN0dXJhbFR5cGUuYmFzZVR5cGVOYW1lLCB0cnVlKTtcclxuICAgICAgICAvLyBzYWZlIGNhc3QgYmVjYXVzZSB3ZSBrbm93IHRoYXQgYmFzZUVudGl0eVR5cGUgbXVzdCBiZSBhbiBFbnRpdHlUeXBlIGlmIHRoZSBzdHJ1Y3R1cmFsVHlwZSBpcyBhbiBFbnRpdHlUeXBlXHJcbiAgICAgICAgc3RydWN0dXJhbFR5cGUuX3VwZGF0ZUZyb21CYXNlKGJhc2VFbnRpdHlUeXBlIGFzIEVudGl0eVR5cGUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdHJ1Y3R1cmFsVHlwZS5rZXlQcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCAmJiAhc3RydWN0dXJhbFR5cGUuaXNBYnN0cmFjdCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBhZGQgXCIgKyBzdHJ1Y3R1cmFsVHlwZS5uYW1lICtcclxuICAgICAgICAgIFwiIHRvIHRoaXMgTWV0YWRhdGFTdG9yZS4gIEFuIEVudGl0eVR5cGUgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwcm9wZXJ0eSBkZXNpZ25hdGVkIGFzIGEga2V5IHByb3BlcnR5IC0gU2VlIHRoZSAnRGF0YVByb3BlcnR5LmlzUGFydE9mS2V5JyBwcm9wZXJ0eS5cIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdHJ1Y3R1cmFsVHlwZS5tZXRhZGF0YVN0b3JlID0gdGhpcztcclxuICAgIC8vIGRvbid0IHJlZ2lzdGVyIGFub24gdHlwZXNcclxuICAgIGlmICghKHN0cnVjdHVyYWxUeXBlIGFzIGFueSkuaXNBbm9ueW1vdXMpIHtcclxuICAgICAgaWYgKHRoaXMuX3N0cnVjdHVyYWxUeXBlTWFwW3N0cnVjdHVyYWxUeXBlLm5hbWVdKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBcIiArIHN0cnVjdHVyYWxUeXBlLm5hbWUgKyBcIiBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIE1ldGFkYXRhU3RvcmUuXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9zdHJ1Y3R1cmFsVHlwZU1hcFtzdHJ1Y3R1cmFsVHlwZS5uYW1lXSA9IHN0cnVjdHVyYWxUeXBlO1xyXG4gICAgICB0aGlzLl9zaG9ydE5hbWVNYXBbc3RydWN0dXJhbFR5cGUuc2hvcnROYW1lXSA9IHN0cnVjdHVyYWxUeXBlLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgc3RydWN0dXJhbFR5cGUuZ2V0UHJvcGVydGllcygpLmZvckVhY2gocCA9PiB7XHJcbiAgICAgIHN0cnVjdHVyYWxUeXBlLl91cGRhdGVOYW1lcyhwKTtcclxuICAgICAgaWYgKCFwLmlzVW5tYXBwZWQpIHtcclxuICAgICAgICBzdHJ1Y3R1cmFsVHlwZS5fbWFwcGVkUHJvcGVydGllc0NvdW50Kys7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHN0cnVjdHVyYWxUeXBlLl91cGRhdGVDcHMoKTtcclxuXHJcbiAgICAvLyAnaXNFbnRpdHlUeXBlJyBpcyBhIHR5cGUgZ3VhcmRcclxuICAgIGlmIChzdHJ1Y3R1cmFsVHlwZSBpbnN0YW5jZW9mIEVudGl0eVR5cGUpIHtcclxuICAgICAgc3RydWN0dXJhbFR5cGUuX3VwZGF0ZU5wcygpO1xyXG4gICAgICAvLyBnaXZlIHRoZSB0eXBlIGl0J3MgYmFzZSdzIHJlc291cmNlIG5hbWUgaWYgaXQgZG9lc24ndCBoYXZlIGl0cyBvd24uXHJcbiAgICAgIGxldCBkZWZSZXNvdXJjZU5hbWUgPSBzdHJ1Y3R1cmFsVHlwZS5kZWZhdWx0UmVzb3VyY2VOYW1lIHx8IChzdHJ1Y3R1cmFsVHlwZS5iYXNlRW50aXR5VHlwZSAmJiBzdHJ1Y3R1cmFsVHlwZS5iYXNlRW50aXR5VHlwZS5kZWZhdWx0UmVzb3VyY2VOYW1lKTtcclxuICAgICAgaWYgKGRlZlJlc291cmNlTmFtZSAmJiAhdGhpcy5nZXRFbnRpdHlUeXBlTmFtZUZvclJlc291cmNlTmFtZShkZWZSZXNvdXJjZU5hbWUpKSB7XHJcbiAgICAgICAgdGhpcy5zZXRFbnRpdHlUeXBlRm9yUmVzb3VyY2VOYW1lKGRlZlJlc291cmNlTmFtZSwgc3RydWN0dXJhbFR5cGUubmFtZSk7XHJcbiAgICAgIH1cclxuICAgICAgc3RydWN0dXJhbFR5cGUuZGVmYXVsdFJlc291cmNlTmFtZSA9IGRlZlJlc291cmNlTmFtZTtcclxuICAgICAgLy8gY2hlY2sgaWYgdGhpcyBzdHJ1Y3R1cmFsIHR5cGUncyBuYW1lLCBzaG9ydCB2ZXJzaW9uIG9yIHF1YWxpZmllZCB2ZXJzaW9uIGhhcyBhIHJlZ2lzdGVyZWQgY3Rvci5cclxuICAgICAgc3RydWN0dXJhbFR5cGUuZ2V0RW50aXR5Q3RvcigpO1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICBFeHBvcnRzIHRoaXMgTWV0YWRhdGFTdG9yZSB0byBhIHNlcmlhbGl6ZWQgc3RyaW5nIGFwcHJvcHJpYXRlIGZvciBsb2NhbCBzdG9yYWdlLiAgIFRoaXMgb3BlcmF0aW9uIGlzIGFsc28gY2FsbGVkXHJcbiAgaW50ZXJuYWxseSB3aGVuIGV4cG9ydGluZyBhbiBFbnRpdHlNYW5hZ2VyLlxyXG4gID4gICAgICAvLyBhc3N1bWUgbXMgaXMgYSBwcmV2aW91c2x5IGNyZWF0ZWQgTWV0YWRhdGFTdG9yZVxyXG4gID4gICAgICBsZXQgbWV0YWRhdGFBc1N0cmluZyA9IG1zLmV4cG9ydE1ldGFkYXRhKCk7XHJcbiAgPiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm1ldGFkYXRhXCIsIG1ldGFkYXRhQXNTdHJpbmcpO1xyXG4gID4gICAgICAvLyBhbmQgbGF0ZXIsIHVzdWFsbHkgaW4gYSBkaWZmZXJlbnQgc2Vzc2lvbiBpbXBvcnRlZFxyXG4gID4gICAgICBsZXQgbWV0YWRhdGFGcm9tU3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm1ldGFkYXRhXCIpO1xyXG4gID4gICAgICBsZXQgbmV3TWV0YWRhdGFTdG9yZSA9IG5ldyBNZXRhZGF0YVN0b3JlKCk7XHJcbiAgPiAgICAgIG5ld01ldGFkYXRhU3RvcmUuaW1wb3J0TWV0YWRhdGEobWV0YWRhdGFGcm9tU3RvcmFnZSk7XHJcbiAgQHJldHVybiBBIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGlzIE1ldGFkYXRhU3RvcmUgdGhhdCBtYXkgYmUgc3RvcmVkIGxvY2FsbHkgYW5kIGxhdGVyIHJlc3RvcmVkLlxyXG4gICoqL1xyXG4gIGV4cG9ydE1ldGFkYXRhKCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgXCJtZXRhZGF0YVZlcnNpb25cIjogTWV0YWRhdGFTdG9yZS5tZXRhZGF0YVZlcnNpb24sXHJcbiAgICAgIFwibmFtZVwiOiB0aGlzLm5hbWUsXHJcbiAgICAgIFwibmFtaW5nQ29udmVudGlvblwiOiB0aGlzLm5hbWluZ0NvbnZlbnRpb24ubmFtZSxcclxuICAgICAgXCJsb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnNcIjogdGhpcy5sb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnMubmFtZSxcclxuICAgICAgXCJkYXRhU2VydmljZXNcIjogdGhpcy5kYXRhU2VydmljZXMsXHJcbiAgICAgIFwic3RydWN0dXJhbFR5cGVzXCI6IGNvcmUub2JqZWN0TWFwKHRoaXMuX3N0cnVjdHVyYWxUeXBlTWFwKSxcclxuICAgICAgXCJyZXNvdXJjZUVudGl0eVR5cGVNYXBcIjogdGhpcy5fcmVzb3VyY2VFbnRpdHlUeXBlTWFwXHJcbiAgICB9LCBudWxsLCBjb25maWcuc3RyaW5naWZ5UGFkKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBJbXBvcnRzIGEgcHJldmlvdXNseSBleHBvcnRlZCBzZXJpYWxpemVkIE1ldGFkYXRhU3RvcmUgaW50byB0aGlzIE1ldGFkYXRhU3RvcmUuXHJcbiAgICBcclxuICA+ICAgICAgLy8gYXNzdW1lIG1zIGlzIGEgcHJldmlvdXNseSBjcmVhdGVkIE1ldGFkYXRhU3RvcmVcclxuICA+ICAgICAgbGV0IG1ldGFkYXRhQXNTdHJpbmcgPSBtcy5leHBvcnRNZXRhZGF0YSgpO1xyXG4gID4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJtZXRhZGF0YVwiLCBtZXRhZGF0YUFzU3RyaW5nKTtcclxuICA+ICAgICAgLy8gYW5kIGxhdGVyLCB1c3VhbGx5IGluIGEgZGlmZmVyZW50IHNlc3Npb25cclxuICA+ICAgICAgbGV0IG1ldGFkYXRhRnJvbVN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJtZXRhZGF0YVwiKTtcclxuICA+ICAgICAgbGV0IG5ld01ldGFkYXRhU3RvcmUgPSBuZXcgTWV0YWRhdGFTdG9yZSgpO1xyXG4gID4gICAgICBuZXdNZXRhZGF0YVN0b3JlLmltcG9ydE1ldGFkYXRhKG1ldGFkYXRhRnJvbVN0b3JhZ2UpO1xyXG4gIEBwYXJhbSBleHBvcnRlZE1ldGFkYXRhIC0gQSBwcmV2aW91c2x5IGV4cG9ydGVkIE1ldGFkYXRhU3RvcmUuXHJcbiAgQHBhcmFtIGFsbG93TWVyZ2UgLSAgQWxsb3dzIGN1c3RvbSBtZXRhZGF0YSB0byBiZSBtZXJnZWQgaW50byBleGlzdGluZyBtZXRhZGF0YSB0eXBlcy5cclxuICBAcmV0dXJuIFRoaXMgTWV0YWRhdGFTdG9yZS5cclxuICBAY2hhaW5hYmxlXHJcbiAgKiovXHJcbiAgaW1wb3J0TWV0YWRhdGEoZXhwb3J0ZWRNZXRhZGF0YTogc3RyaW5nIHwgT2JqZWN0LCBhbGxvd01lcmdlOiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgIGFzc2VydFBhcmFtKGFsbG93TWVyZ2UsIFwiYWxsb3dNZXJnZVwiKS5pc09wdGlvbmFsKCkuaXNCb29sZWFuKCkuY2hlY2soKTtcclxuICAgIHRoaXMuX2RlZmVycmVkVHlwZXMgPSB7fTtcclxuICAgIC8vIGluc3VyZSB0aGF0IHdlIGRvbid0IG11dGF0ZSBpbmNvbWluZyBleHBvcnRlZE1ldGFkYXRhICggaWYgaXRzIGFuIG9iamVjdClcclxuICAgIGxldCBtZXRhZGF0YUFzU3RyaW5nID0gKHR5cGVvZiAoZXhwb3J0ZWRNZXRhZGF0YSkgPT09IFwic3RyaW5nXCIpID8gZXhwb3J0ZWRNZXRhZGF0YSA6IEpTT04uc3RyaW5naWZ5KGV4cG9ydGVkTWV0YWRhdGEpO1xyXG4gICAgY29uc3QgbWV0YWRhdGFKc29uID0gSlNPTi5wYXJzZShtZXRhZGF0YUFzU3RyaW5nKTtcclxuXHJcbiAgICBpZiAobWV0YWRhdGFKc29uLnNjaGVtYSkge1xyXG4gICAgICByZXR1cm4gQ3NkbE1ldGFkYXRhUGFyc2VyLnBhcnNlKHRoaXMsIG1ldGFkYXRhSnNvbi5zY2hlbWEsIG1ldGFkYXRhSnNvbi5hbHRNZXRhZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGpzb24gPSBtZXRhZGF0YUpzb24gYXMgSU1ldGFkYXRhSnNvbjtcclxuICAgIGlmIChqc29uLm1ldGFkYXRhVmVyc2lvbiAmJiBqc29uLm1ldGFkYXRhVmVyc2lvbiAhPT0gTWV0YWRhdGFTdG9yZS5tZXRhZGF0YVZlcnNpb24pIHtcclxuICAgICAgbGV0IG1zZyA9IGNvcmUuZm9ybWF0U3RyaW5nKFwiQ2Fubm90IGltcG9ydCBtZXRhZGF0YSB3aXRoIGEgZGlmZmVyZW50ICdtZXRhZGF0YVZlcnNpb24nICglMSkgdGhhbiB0aGUgY3VycmVudCAnTWV0YWRhdGFTdG9yZS5tZXRhZGF0YVZlcnNpb24nICglMikgXCIsXHJcbiAgICAgICAganNvbi5tZXRhZGF0YVZlcnNpb24sIE1ldGFkYXRhU3RvcmUubWV0YWRhdGFWZXJzaW9uKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG5jTmFtZSA9IGpzb24ubmFtaW5nQ29udmVudGlvbjtcclxuICAgIGxldCBscWNvTmFtZSA9IGpzb24ubG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zO1xyXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XHJcbiAgICAgIHRoaXMubmFtaW5nQ29udmVudGlvbiA9IGNvbmZpZy5fZmV0Y2hPYmplY3QoTmFtaW5nQ29udmVudGlvbiwgbmNOYW1lKSB8fCB0aGlzLm5hbWluZ0NvbnZlbnRpb247XHJcbiAgICAgIHRoaXMubG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zID0gY29uZmlnLl9mZXRjaE9iamVjdChMb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnMsIGxxY29OYW1lKSB8fCB0aGlzLmxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChuY05hbWUgJiYgdGhpcy5uYW1pbmdDb252ZW50aW9uLm5hbWUgIT09IG5jTmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbXBvcnQgbWV0YWRhdGEgd2l0aCBhIGRpZmZlcmVudCAnbmFtaW5nQ29udmVudGlvbicgZnJvbSB0aGUgY3VycmVudCBNZXRhZGF0YVN0b3JlXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChscWNvTmFtZSAmJiB0aGlzLmxvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucy5uYW1lICE9PSBscWNvTmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbXBvcnQgbWV0YWRhdGEgd2l0aCBkaWZmZXJlbnQgJ2xvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucycgZnJvbSB0aGUgY3VycmVudCBNZXRhZGF0YVN0b3JlXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9ub2luc3BlY3Rpb24gSlNIaW50XHJcbiAgICBqc29uLmRhdGFTZXJ2aWNlcyAmJiBqc29uLmRhdGFTZXJ2aWNlcy5mb3JFYWNoKChkcykgPT4ge1xyXG4gICAgICBsZXQgcmVhbERzID0gRGF0YVNlcnZpY2UuZnJvbUpTT04oZHMpO1xyXG4gICAgICB0aGlzLmFkZERhdGFTZXJ2aWNlKHJlYWxEcywgdHJ1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBqc29uLnN0cnVjdHVyYWxUeXBlcyAmJiBqc29uLnN0cnVjdHVyYWxUeXBlcy5mb3JFYWNoKChzdHlwZSkgPT4ge1xyXG4gICAgICBzdHJ1Y3R1cmFsVHlwZUZyb21Kc29uKHRoaXMsIHN0eXBlLCBhbGxvd01lcmdlKTtcclxuICAgIH0pO1xyXG4gICAgY29yZS5leHRlbmQodGhpcy5fcmVzb3VyY2VFbnRpdHlUeXBlTWFwLCBqc29uLnJlc291cmNlRW50aXR5VHlwZU1hcCk7XHJcbiAgICBjb3JlLmV4dGVuZCh0aGlzLl9pbmNvbXBsZXRlVHlwZU1hcCwganNvbi5pbmNvbXBsZXRlVHlwZU1hcCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBDcmVhdGVzIGEgbmV3IE1ldGFkYXRhU3RvcmUgZnJvbSBhIHByZXZpb3VzbHkgZXhwb3J0ZWQgc2VyaWFsaXplZCBNZXRhZGF0YVN0b3JlXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBtcyBpcyBhIHByZXZpb3VzbHkgY3JlYXRlZCBNZXRhZGF0YVN0b3JlXHJcbiAgPiAgICAgIGxldCBtZXRhZGF0YUFzU3RyaW5nID0gbXMuZXhwb3J0TWV0YWRhdGEoKTtcclxuICA+ICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibWV0YWRhdGFcIiwgbWV0YWRhdGFBc1N0cmluZyk7XHJcbiAgPiAgICAgIC8vIGFuZCBsYXRlciwgdXN1YWxseSBpbiBhIGRpZmZlcmVudCBzZXNzaW9uXHJcbiAgPiAgICAgIGxldCBtZXRhZGF0YUZyb21TdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibWV0YWRhdGFcIik7XHJcbiAgPiAgICAgIGxldCBuZXdNZXRhZGF0YVN0b3JlID0gTWV0YWRhdGFTdG9yZS5pbXBvcnRNZXRhZGF0YShtZXRhZGF0YUZyb21TdG9yYWdlKTtcclxuICBAcGFyYW0gZXhwb3J0ZWRTdHJpbmcgLSBBIHByZXZpb3VzbHkgZXhwb3J0ZWQgTWV0YWRhdGFTdG9yZS5cclxuICBAcmV0dXJuIEEgbmV3IE1ldGFkYXRhU3RvcmUuXHJcbiAgKiovXHJcbiAgc3RhdGljIGltcG9ydE1ldGFkYXRhKGV4cG9ydGVkU3RyaW5nOiBzdHJpbmcpIHtcclxuICAgIGxldCBtcyA9IG5ldyBNZXRhZGF0YVN0b3JlKCk7XHJcbiAgICBtcy5pbXBvcnRNZXRhZGF0YShleHBvcnRlZFN0cmluZyk7XHJcbiAgICByZXR1cm4gbXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIHdoZXRoZXIgTWV0YWRhdGEgaGFzIGJlZW4gcmV0cmlldmVkIGZvciBhIHNwZWNpZmllZCBzZXJ2aWNlIG5hbWUuXHJcbiAgPiAgICAgIC8vIEFzc3VtZSBlbTEgaXMgYW4gZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICA+ICAgICAgaWYgKCFlbTEubWV0YWRhdGFTdG9yZS5oYXNNZXRhZGF0YUZvcihcImJyZWV6ZS9Ob3J0aHdpbmRJQk1vZGVsXCIpKSkge1xyXG4gID4gICAgICAgICAgLy8gZG8gc29tZXRoaW5nIGludGVyZXN0aW5nXHJcbiAgPiAgICAgIH1cclxuICBAcGFyYW0gc2VydmljZU5hbWUgLSBUaGUgc2VydmljZSBuYW1lLlxyXG4gIEByZXR1cm4gV2hldGhlciBtZXRhZGF0YSBoYXMgYWxyZWFkeSBiZWVuIHJldHJpZXZlZCBmb3IgdGhlIHNwZWNpZmllZCBzZXJ2aWNlIG5hbWUuXHJcbiAgKiovXHJcbiAgaGFzTWV0YWRhdGFGb3Ioc2VydmljZU5hbWU6IHN0cmluZykge1xyXG4gICAgcmV0dXJuICEhdGhpcy5nZXREYXRhU2VydmljZShzZXJ2aWNlTmFtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIHRoZSBEYXRhU2VydmljZSBmb3IgYSBzcGVjaWZpZWQgc2VydmljZSBuYW1lXHJcbiAgPiAgICAgIC8vIEFzc3VtZSBlbTEgaXMgYW4gZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICA+ICAgICAgbGV0IGRzID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RGF0YVNlcnZpY2UoXCJicmVlemUvTm9ydGh3aW5kSUJNb2RlbFwiKTtcclxuICA+ICAgICAgbGV0IGFkYXB0ZXJOYW1lID0gZHMuYWRhcHRlck5hbWU7IC8vIG1heSBiZSBudWxsXHJcbiAgQHBhcmFtIHNlcnZpY2VOYW1lIC0gVGhlIHNlcnZpY2UgbmFtZS5cclxuICBAcmV0dXJuIFRoZSBEYXRhU2VydmljZSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAqKi9cclxuICBnZXREYXRhU2VydmljZShzZXJ2aWNlTmFtZTogc3RyaW5nKSB7XHJcbiAgICBhc3NlcnRQYXJhbShzZXJ2aWNlTmFtZSwgXCJzZXJ2aWNlTmFtZVwiKS5pc1N0cmluZygpLmNoZWNrKCk7XHJcblxyXG4gICAgc2VydmljZU5hbWUgPSBEYXRhU2VydmljZS5fbm9ybWFsaXplU2VydmljZU5hbWUoc2VydmljZU5hbWUpO1xyXG4gICAgcmV0dXJuIGNvcmUuYXJyYXlGaXJzdCh0aGlzLmRhdGFTZXJ2aWNlcywgZnVuY3Rpb24gKGRzOiBEYXRhU2VydmljZSkge1xyXG4gICAgICByZXR1cm4gZHMuc2VydmljZU5hbWUgPT09IHNlcnZpY2VOYW1lO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBGZXRjaGVzIHRoZSBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpZWQgJ3NlcnZpY2UnLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZFxyXG4gIGludGVybmFsbHkgYnkgYW4gRW50aXR5TWFuYWdlciBiZWZvcmUgaXRzIGZpcnN0IHF1ZXJ5IGFnYWluc3QgYSBuZXcgc2VydmljZS4gX19Bc3luY19fXHJcblxyXG4gIFVzdWFsbHkgeW91IHdpbGwgbm90IGFjdHVhbGx5IHByb2Nlc3MgdGhlIHJlc3VsdHMgb2YgYSBmZXRjaE1ldGFkYXRhIGNhbGwgZGlyZWN0bHksIGJ1dCB3aWxsIGluc3RlYWRcclxuICBhc2sgZm9yIHRoZSBtZXRhZGF0YSBmcm9tIHRoZSBFbnRpdHlNYW5hZ2VyIGFmdGVyIHRoZSBmZXRjaE1ldGFkYXRhIGNhbGwgcmV0dXJucy5cclxuICA+ICAgICAgbGV0IG1zID0gbmV3IE1ldGFkYXRhU3RvcmUoKTtcclxuICA+ICAgICAgLy8gb3IgbW9yZSBjb21tb25seVxyXG4gID4gICAgICAvLyBsZXQgbXMgPSBhbkVudGl0eU1hbmFnZXIubWV0YWRhdGFTdG9yZTtcclxuICA+ICAgICAgbXMuZmV0Y2hNZXRhZGF0YShcImJyZWV6ZS9Ob3J0aHdpbmRJQk1vZGVsXCIpLnRoZW4oZnVuY3Rpb24ocmF3TWV0YWRhdGEpIHtcclxuICA+ICAgICAgICAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIG1ldGFkYXRhXHJcbiAgPiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xyXG4gID4gICAgICAgICAgLy8gaGFuZGxlIGV4Y2VwdGlvbiBoZXJlXHJcbiAgPiAgICAgIH0pO1xyXG4gIEBwYXJhbSBkYXRhU2VydmljZSAtICBFaXRoZXIgYSBEYXRhU2VydmljZSBvciBqdXN0IHRoZSBuYW1lIG9mIHRoZSBEYXRhU2VydmljZSB0byBmZXRjaCBtZXRhZGF0YSBmb3IuXHJcbiAgQHBhcmFtIGNhbGxiYWNrIC0gRnVuY3Rpb24gY2FsbGVkIG9uIHN1Y2Nlc3MuXHJcbiAgQHBhcmFtIGVycm9yQ2FsbGJhY2sgLSBGdW5jdGlvbiBjYWxsZWQgb24gZmFpbHVyZS5cclxuICBAcmV0dXJuIFByb21pc2VcclxuICAqKi9cclxuICBmZXRjaE1ldGFkYXRhKGRhdGFTZXJ2aWNlOiBzdHJpbmcgfCBEYXRhU2VydmljZSwgY2FsbGJhY2s/OiAoc2NoZW1hOiBhbnkpID0+IHZvaWQsIGVycm9yQ2FsbGJhY2s/OiBFcnJvckNhbGxiYWNrKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBhc3NlcnRQYXJhbShkYXRhU2VydmljZSwgXCJkYXRhU2VydmljZVwiKS5pc1N0cmluZygpLm9yKCkuaXNJbnN0YW5jZU9mKERhdGFTZXJ2aWNlKS5jaGVjaygpO1xyXG4gICAgICBhc3NlcnRQYXJhbShjYWxsYmFjaywgXCJjYWxsYmFja1wiKS5pc0Z1bmN0aW9uKCkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcbiAgICAgIGFzc2VydFBhcmFtKGVycm9yQ2FsbGJhY2ssIFwiZXJyb3JDYWxsYmFja1wiKS5pc0Z1bmN0aW9uKCkuaXNPcHRpb25hbCgpLmNoZWNrKCk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGRhdGFTZXJ2aWNlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgLy8gdXNlIHRoZSBkYXRhU2VydmljZSB3aXRoIGEgbWF0Y2hpbmcgbmFtZSBvciBjcmVhdGUgYSBuZXcgb25lLlxyXG4gICAgICAgIGRhdGFTZXJ2aWNlID0gdGhpcy5nZXREYXRhU2VydmljZShkYXRhU2VydmljZSkgfHwgbmV3IERhdGFTZXJ2aWNlKHsgc2VydmljZU5hbWU6IGRhdGFTZXJ2aWNlIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkYXRhU2VydmljZSA9IERhdGFTZXJ2aWNlLnJlc29sdmUoW2RhdGFTZXJ2aWNlXSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5oYXNNZXRhZGF0YUZvcihkYXRhU2VydmljZS5zZXJ2aWNlTmFtZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyBzZXJ2aWNlTmFtZSBtYXkgb25seSBiZSBmZXRjaGVkIG9uY2UgcGVyIE1ldGFkYXRhU3RvcmUuIFNlcnZpY2VOYW1lOiBcIiArIGRhdGFTZXJ2aWNlLnNlcnZpY2VOYW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGRhdGFTZXJ2aWNlLmFkYXB0ZXJJbnN0YW5jZSEuZmV0Y2hNZXRhZGF0YSh0aGlzLCBkYXRhU2VydmljZSkudGhlbigocmF3TWV0YWRhdGE6IGFueSkgPT4ge1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGFGZXRjaGVkLnB1Ymxpc2goeyBtZXRhZGF0YVN0b3JlOiB0aGlzLCBkYXRhU2VydmljZTogZGF0YVNlcnZpY2UsIHJhd01ldGFkYXRhOiByYXdNZXRhZGF0YSB9KTtcclxuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHJhd01ldGFkYXRhKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJhd01ldGFkYXRhKTtcclxuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yOiBhbnkpIHtcclxuICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykgZXJyb3JDYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBUT0RPOiBzdHJvbmdseSB0eXBlIGludGVyY2VwdG9yIGJlbG93LlxyXG4gIC8qKlxyXG4gIFVzZWQgdG8gcmVnaXN0ZXIgYSBjb25zdHJ1Y3RvciBmb3IgYW4gRW50aXR5VHlwZSB0aGF0IGlzIG5vdCBrbm93biB2aWEgc3RhbmRhcmQgTWV0YWRhdGEgZGlzY292ZXJ5O1xyXG4gIGkuZS4gYW4gdW5tYXBwZWQgdHlwZS5cclxuICBAcGFyYW0gZW50aXR5Q3RvciAtIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlICd1bm1hcHBlZCcgdHlwZS5cclxuICBAcGFyYW0gaW50ZXJjZXB0b3IgLSBBbiBpbnRlcmNlcHRvciBmdW5jdGlvblxyXG4gICoqL1xyXG4gIHRyYWNrVW5tYXBwZWRUeXBlKGVudGl0eUN0b3I6IGFueSwgaW50ZXJjZXB0b3I6IGFueSkge1xyXG4gICAgYXNzZXJ0UGFyYW0oZW50aXR5Q3RvciwgXCJlbnRpdHlDdG9yXCIpLmlzRnVuY3Rpb24oKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0oaW50ZXJjZXB0b3IsIFwiaW50ZXJjZXB0b3JcIikuaXNGdW5jdGlvbigpLmlzT3B0aW9uYWwoKS5jaGVjaygpO1xyXG4gICAgLy8gVE9ETzogdGhpbmsgYWJvdXQgYWRkaW5nIHRoaXMgdG8gdGhlIE1ldGFkYXRhU3RvcmUuXHJcbiAgICBsZXQgZW50aXR5VHlwZSA9IG5ldyBFbnRpdHlUeXBlKHRoaXMpO1xyXG4gICAgZW50aXR5VHlwZS5fc2V0Q3RvcihlbnRpdHlDdG9yLCBpbnRlcmNlcHRvcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBQcm92aWRlcyBhIG1lY2hhbmlzbSB0byByZWdpc3RlciBhICdjdXN0b20nIGNvbnN0cnVjdG9yIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXHJcbiAgb2YgdGhlIHNwZWNpZmllZCBlbnRpdHkgdHlwZS4gIElmIHRoaXMgY2FsbCBpcyBub3QgbWFkZSwgYSBkZWZhdWx0IGNvbnN0cnVjdG9yIGlzIGNyZWF0ZWQgZm9yXHJcbiAgdGhlIGVudGl0eSBhcyBuZWVkZWQuXHJcbiAgVGhpcyBjYWxsIG1heSBiZSBtYWRlIGJlZm9yZSBvciBhZnRlciB0aGUgY29ycmVzcG9uZGluZyBFbnRpdHlUeXBlIGhhcyBiZWVuIGRpc2NvdmVyZWQgdmlhXHJcbiAgTWV0YWRhdGEgZGlzY292ZXJ5LlxyXG4gID4gICAgICBsZXQgQ3VzdG9tZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgPiAgICAgICAgICAgICAgdGhpcy5taXNjRGF0YSA9IFwiYXNkZlwiO1xyXG4gID4gICAgICAgICAgfTtcclxuICA+ICAgICAgQ3VzdG9tZXIucHJvdG90eXBlLmRvRm9vKCkge1xyXG4gID4gICAgICAgICAgICAgIC4uLlxyXG4gID4gICAgICAgICAgfVxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlcjtcclxuICA+ICAgICAgZW0xLm1ldGFkYXRhU3RvcmUucmVnaXN0ZXJFbnRpdHlUeXBlQ3RvcihcIkN1c3RvbWVyXCIsIEN1c3RvbWVyKTtcclxuICA+ICAgICAgLy8gYW55IHF1ZXJpZXMgb3IgRW50aXR5VHlwZS5jcmVhdGUgY2FsbHMgZnJvbSB0aGlzIHBvaW50IG9uIHdpbGwgY2FsbCB0aGUgQ3VzdG9tZXIgY29uc3RydWN0b3JcclxuICA+ICAgICAgLy8gcmVnaXN0ZXJlZCBhYm92ZS5cclxuICBAcGFyYW0gc3RydWN0dXJhbFR5cGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEVudGl0eVR5cGUgb3IgQ29tcGxleFR5cGUuXHJcbiAgQHBhcmFtIGFDdG9yIC0gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGlzIEVudGl0eVR5cGUgb3IgQ29tcGxleFR5cGU7IG1heSBiZSBudWxsIGlmIGFsbCB5b3Ugd2FudCB0byBkbyBpcyBzZXQgdGhlIG5leHQgcGFyYW1ldGVyLlxyXG4gIEBwYXJhbSBpbml0Rm4gLSBBIGZ1bmN0aW9uIG9yIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gb24gdGhlIGVudGl0eSB0aGF0IGlzIHRvIGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBlbnRpdHkgaGFzIGJlZW4gY3JlYXRlZFxyXG4gIGFuZCBwb3B1bGF0ZWQgd2l0aCBhbnkgaW5pdGlhbCB2YWx1ZXMuIENhbGxlZCB3aXRoICdpbml0Rm4oZW50aXR5KSdcclxuICBAcGFyYW0gbm9UcmFja2luZ0ZuIC0gQSBmdW5jdGlvbiB0aGF0IGlzIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGFmdGVyIGEgbm9UcmFja2luZyBlbnRpdHkgaGFzIGJlZW4gY3JlYXRlZCBhbmQgd2hvc2UgcmV0dXJuXHJcbiAgdmFsdWUgd2lsbCBiZSB1c2VkIGluIHBsYWNlIG9mIHRoZSBub1RyYWNraW5nIGVudGl0eS5cclxuICAqKi9cclxuICByZWdpc3RlckVudGl0eVR5cGVDdG9yKHN0cnVjdHVyYWxUeXBlTmFtZTogc3RyaW5nLCBhQ3Rvcj86IGFueSwgaW5pdEZuPzogRnVuY3Rpb24gfCBzdHJpbmcsIG5vVHJhY2tpbmdGbj86IEZ1bmN0aW9uKSB7XHJcbiAgICBhc3NlcnRQYXJhbShzdHJ1Y3R1cmFsVHlwZU5hbWUsIFwic3RydWN0dXJhbFR5cGVOYW1lXCIpLmlzU3RyaW5nKCkuY2hlY2soKTtcclxuICAgIGFzc2VydFBhcmFtKGFDdG9yLCBcImFDdG9yXCIpLmlzRnVuY3Rpb24oKS5pc09wdGlvbmFsKCkuY2hlY2soKTtcclxuICAgIGFzc2VydFBhcmFtKGluaXRGbiwgXCJpbml0Rm5cIikuaXNPcHRpb25hbCgpLmlzRnVuY3Rpb24oKS5vcigpLmlzU3RyaW5nKCkuY2hlY2soKTtcclxuICAgIGFzc2VydFBhcmFtKG5vVHJhY2tpbmdGbiwgXCJub1RyYWNraW5nRm5cIikuaXNPcHRpb25hbCgpLmlzRnVuY3Rpb24oKS5jaGVjaygpO1xyXG5cclxuICAgIGxldCBxdWFsaWZpZWRUeXBlTmFtZSA9IGdldFF1YWxpZmllZFR5cGVOYW1lKHRoaXMsIHN0cnVjdHVyYWxUeXBlTmFtZSwgZmFsc2UpO1xyXG4gICAgbGV0IHR5cGVOYW1lID0gcXVhbGlmaWVkVHlwZU5hbWUgfHwgc3RydWN0dXJhbFR5cGVOYW1lO1xyXG5cclxuICAgIGlmIChhQ3Rvcikge1xyXG4gICAgICBpZiAoYUN0b3IuXyR0eXBlTmFtZSAmJiBhQ3Rvci5fJHR5cGVOYW1lICE9PSB0eXBlTmFtZSkge1xyXG4gICAgICAgIC8vIFRPRE86IHdyYXAgdGhpcyAtIGNvbnNvbGUgYW5kIGVzcGVjaWFsbHkgY29uc29sZS53YXJuIGRvZXMgbm90IGV4aXN0IGluIGFsbCBicm93c2Vycy5cclxuICAgICAgICBjb25zb2xlLndhcm4oXCJSZWdpc3RlcmluZyBhIGNvbnN0cnVjdG9yIGZvciBcIiArIHR5cGVOYW1lICsgXCIgdGhhdCBpcyBhbHJlYWR5IHVzZWQgZm9yIFwiICsgYUN0b3IuXyR0eXBlTmFtZSArIFwiLlwiKTtcclxuICAgICAgfVxyXG4gICAgICBhQ3Rvci5fJHR5cGVOYW1lID0gdHlwZU5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY3RvclJlZ2lzdHJ5W3R5cGVOYW1lXSA9IHsgY3RvcjogYUN0b3IsIGluaXRGbjogaW5pdEZuLCBub1RyYWNraW5nRm46IG5vVHJhY2tpbmdGbiB9O1xyXG4gICAgaWYgKHF1YWxpZmllZFR5cGVOYW1lKSB7XHJcbiAgICAgIGxldCBzdHlwZSA9IHRoaXMuX3N0cnVjdHVyYWxUeXBlTWFwW3F1YWxpZmllZFR5cGVOYW1lXTtcclxuICAgICAgc3R5cGUgJiYgc3R5cGUuZ2V0Q3Rvcih0cnVlKTsgLy8gdGhpcyB3aWxsIGNvbXBsZXRlIHRoZSByZWdpc3RyYXRpb24gaWYgYXZhaWwgbm93LlxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgd2hldGhlciB0aGlzIE1ldGFkYXRhU3RvcmUgY29udGFpbnMgYW55IG1ldGFkYXRhIHlldC5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXI7XHJcbiAgPiAgICAgIGlmIChlbTEubWV0YWRhdGFTdG9yZS5pc0VtcHR5KCkpIHtcclxuICA+ICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyBpbnRlcmVzdGluZ1xyXG4gID4gICAgICB9XHJcbiAgKiovXHJcbiAgaXNFbXB0eSgpIHtcclxuICAgIHJldHVybiBjb3JlLmlzRW1wdHkodGhpcy5fc3RydWN0dXJhbFR5cGVNYXApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhbiBbW0VudGl0eVR5cGVdXSBvciBudWxsIGdpdmVuIGl0cyBuYW1lLlxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlclxyXG4gID4gICAgICBsZXQgb2RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0QXNFbnRpdHlUeXBlKFwiT3JkZXJEZXRhaWxcIik7XHJcblxyXG4gIG9yIHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSB0eXBlIGlzIG5vdCBmb3VuZFxyXG4gID4gICAgICBsZXQgYmFkVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEFzRW50aXR5VHlwZShcIkZvb1wiLCBmYWxzZSk7XHJcbiAgPiAgICAgIC8vIGJhZFR5cGUgd2lsbCBub3QgZ2V0IHNldCBhbmQgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG4gIEBwYXJhbSBzdHJ1Y3R1cmFsVHlwZU5hbWUgLSBFaXRoZXIgdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9yIGEgc2hvcnQgbmFtZSBtYXkgYmUgdXNlZC4gSWYgYSBzaG9ydCBuYW1lIGlzIHNwZWNpZmllZCBhbmQgbXVsdGlwbGUgdHlwZXMgc2hhcmVcclxuICB0aGF0IHNhbWUgc2hvcnQgbmFtZSBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcbiAgQHBhcmFtIG9rSWZOb3RGb3VuZCAtIChkZWZhdWx0PWZhbHNlKSBXaGV0aGVyIHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSBzcGVjaWZpZWQgRW50aXR5VHlwZSBpcyBub3QgZm91bmQuXHJcbiAgQHJldHVybiBUaGUgRW50aXR5VHlwZS4gQ29tcGxleFR5cGUgb3IgJ251bGwnIGlmIG5vdCBub3QgZm91bmQuXHJcbiAgKiovXHJcbiAgZ2V0QXNFbnRpdHlUeXBlKHR5cGVOYW1lOiBzdHJpbmcsIG9rSWZOb3RGb3VuZDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBzdCA9IHRoaXMuZ2V0U3RydWN0dXJhbFR5cGUodHlwZU5hbWUsIG9rSWZOb3RGb3VuZCk7XHJcbiAgICBpZiAoc3QgaW5zdGFuY2VvZiBFbnRpdHlUeXBlKSB7XHJcbiAgICAgIHJldHVybiBzdCBhcyBFbnRpdHlUeXBlO1xyXG4gICAgfSBlbHNlIGlmIChva0lmTm90Rm91bmQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgbXNnID0gY29yZS5mb3JtYXRTdHJpbmcoXCJVbmFibGUgdG8gbG9jYXRlIGFuICdFbnRpdHlUeXBlJyBieSB0aGUgbmFtZTogJyUxJy4gQmUgc3VyZSB0byBleGVjdXRlIGEgcXVlcnkgb3IgY2FsbCBmZXRjaE1ldGFkYXRhIGZpcnN0LlwiLCB0eXBlTmFtZSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhbiBbW0VudGl0eVR5cGVdXSBvciBudWxsIGdpdmVuIGl0cyBuYW1lLlxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlclxyXG4gID4gICAgICBsZXQgbG9jVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEFzQ29tcGxleFR5cGUoXCJMb2NhdGlvblwiKTtcclxuXHJcbiAgb3IgdG8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHR5cGUgaXMgbm90IGZvdW5kXHJcbiAgPiAgICAgIGxldCBiYWRUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0QXNDb21wbGV4VHlwZShcIkZvb1wiLCBmYWxzZSk7XHJcbiAgPiAgICAgIC8vIGJhZFR5cGUgd2lsbCBub3QgZ2V0IHNldCBhbmQgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxyXG4gIEBwYXJhbSBzdHJ1Y3R1cmFsVHlwZU5hbWUgLSBFaXRoZXIgdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9yIGEgc2hvcnQgbmFtZSBtYXkgYmUgdXNlZC4gSWYgYSBzaG9ydCBuYW1lIGlzIHNwZWNpZmllZCBhbmQgbXVsdGlwbGUgdHlwZXMgc2hhcmVcclxuICB0aGF0IHNhbWUgc2hvcnQgbmFtZSBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcbiAgQHBhcmFtIG9rSWZOb3RGb3VuZCAtIChkZWZhdWx0PWZhbHNlKSBXaGV0aGVyIHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSBzcGVjaWZpZWQgRW50aXR5VHlwZSBpcyBub3QgZm91bmQuXHJcbiAgQHJldHVybiBUaGUgRW50aXR5VHlwZS4gQ29tcGxleFR5cGUgb3IgJ251bGwnIGlmIG5vdCBub3QgZm91bmQuXHJcbiAgKiovXHJcbiBnZXRBc0NvbXBsZXhUeXBlKHR5cGVOYW1lOiBzdHJpbmcsIG9rSWZOb3RGb3VuZDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgY29uc3Qgc3QgPSB0aGlzLmdldFN0cnVjdHVyYWxUeXBlKHR5cGVOYW1lLCBva0lmTm90Rm91bmQpO1xyXG4gIGlmIChzdCBpbnN0YW5jZW9mIENvbXBsZXhUeXBlKSB7XHJcbiAgICByZXR1cm4gc3QgYXMgQ29tcGxleFR5cGU7XHJcbiAgfSBlbHNlIGlmIChva0lmTm90Rm91bmQpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgbXNnID0gY29yZS5mb3JtYXRTdHJpbmcoXCJVbmFibGUgdG8gbG9jYXRlIGFuICdDb21wbGV4VHlwZScgYnkgdGhlIG5hbWU6ICclMScuIEJlIHN1cmUgdG8gZXhlY3V0ZSBhIHF1ZXJ5IG9yIGNhbGwgZmV0Y2hNZXRhZGF0YSBmaXJzdC5cIiwgdHlwZU5hbWUpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGFuIFtbRW50aXR5VHlwZV1dIG9yIGEgW1tDb21wbGV4VHlwZV1dIGdpdmVuIGl0cyBuYW1lLlxyXG4gIEBkZXByZWNhdGVkIFJlcGxhY2VkIGJ5IGdldFN0cnVjdHVyYWxUeXBlIGJ1dCAuLi4gaXQgaXMgcHJvYmFibHkgbW9yZSB1c2VmdWxsIHRvIGNhbGwgZWl0aGVyIGdldEFzRW50aXR5VHlwZSBvciBnZXRBc0NvbXBsZXhUeXBlIGluc3RlYWRcclxuICBAcGFyYW0gdHlwZU5hbWUgLSBFaXRoZXIgdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9yIGEgc2hvcnQgbmFtZSBtYXkgYmUgdXNlZC4gSWYgYSBzaG9ydCBuYW1lIGlzIHNwZWNpZmllZCBhbmQgbXVsdGlwbGUgdHlwZXMgc2hhcmVcclxuICB0aGF0IHNhbWUgc2hvcnQgbmFtZSBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcbiAgQHBhcmFtIG9rSWZOb3RGb3VuZCAtIChkZWZhdWx0PWZhbHNlKSBXaGV0aGVyIHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSBzcGVjaWZpZWQgRW50aXR5VHlwZSBpcyBub3QgZm91bmQuXHJcbiAgQHJldHVybiBUaGUgRW50aXR5VHlwZS4gQ29tcGxleFR5cGUgb3IgJ251bGwnIGlmIG5vdCBub3QgZm91bmQuXHJcbiAgKiovXHJcbiAgZ2V0RW50aXR5VHlwZSh0eXBlTmFtZTogc3RyaW5nLCBva0lmTm90Rm91bmQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RydWN0dXJhbFR5cGUodHlwZU5hbWUsIG9rSWZOb3RGb3VuZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGFuIFtbRW50aXR5VHlwZV1dIG9yIGEgW1tDb21wbGV4VHlwZV1dIGdpdmVuIGl0cyBuYW1lLlxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlclxyXG4gID4gICAgICBsZXQgb2RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0U3RydWN0dXJhbFR5cGUoXCJPcmRlckRldGFpbFwiKTtcclxuXHJcbiAgb3IgdG8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHR5cGUgaXMgbm90IGZvdW5kXHJcbiAgPiAgICAgIGxldCBiYWRUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0U3RydWN0dXJhbFR5cGUoXCJGb29cIiwgZmFsc2UpO1xyXG4gID4gICAgICAvLyBiYWRUeXBlIHdpbGwgbm90IGdldCBzZXQgYW5kIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cclxuICBAZGVwcmVjYXRlZCBQcmVmZXJhYmx5IHVzZSBlaXRoZXIgZ2V0QXNFbnRpdHlUeXBlIG9yIGdldEFzQ29tcGxleFR5cGUuICBHZXRcclxuICBAcGFyYW0gdHlwZU5hbWUgLSBFaXRoZXIgdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9yIGEgc2hvcnQgbmFtZSBtYXkgYmUgdXNlZC4gSWYgYSBzaG9ydCBuYW1lIGlzIHNwZWNpZmllZCBhbmQgbXVsdGlwbGUgdHlwZXMgc2hhcmVcclxuICB0aGF0IHNhbWUgc2hvcnQgbmFtZSBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXHJcbiAgQHBhcmFtIG9rSWZOb3RGb3VuZCAtIChkZWZhdWx0PWZhbHNlKSBXaGV0aGVyIHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSBzcGVjaWZpZWQgRW50aXR5VHlwZSBpcyBub3QgZm91bmQuXHJcbiAgQHJldHVybiBUaGUgRW50aXR5VHlwZS4gQ29tcGxleFR5cGUgb3IgJ251bGwnIGlmIG5vdCBub3QgZm91bmQuXHJcbiAgKiovXHJcbiAgZ2V0U3RydWN0dXJhbFR5cGUodHlwZU5hbWU6IHN0cmluZywgb2tJZk5vdEZvdW5kOiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgIGFzc2VydFBhcmFtKHR5cGVOYW1lLCBcInR5cGVOYW1lXCIpLmlzU3RyaW5nKCkuY2hlY2soKTtcclxuICAgIGFzc2VydFBhcmFtKG9rSWZOb3RGb3VuZCwgXCJva0lmTm90Rm91bmRcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpLmNoZWNrKGZhbHNlKTtcclxuICAgIHJldHVybiB0aGlzLl9nZXRTdHJ1Y3R1cmFsVHlwZSh0eXBlTmFtZSwgb2tJZk5vdEZvdW5kKTtcclxuICB9XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9nZXRTdHJ1Y3R1cmFsVHlwZSh0eXBlTmFtZTogc3RyaW5nLCBva0lmTm90Rm91bmQ6IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgbGV0IHF1YWxUeXBlTmFtZSA9IGdldFF1YWxpZmllZFR5cGVOYW1lKHRoaXMsIHR5cGVOYW1lLCBmYWxzZSk7XHJcbiAgICBsZXQgdHlwZSA9IHRoaXMuX3N0cnVjdHVyYWxUeXBlTWFwW3F1YWxUeXBlTmFtZV07XHJcbiAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgaWYgKG9rSWZOb3RGb3VuZCkgcmV0dXJuIG51bGw7XHJcbiAgICAgIGxldCBtc2cgPSBjb3JlLmZvcm1hdFN0cmluZyhcIlVuYWJsZSB0byBsb2NhdGUgYSAnVHlwZScgYnkgdGhlIG5hbWU6ICclMScuIEJlIHN1cmUgdG8gZXhlY3V0ZSBhIHF1ZXJ5IG9yIGNhbGwgZmV0Y2hNZXRhZGF0YSBmaXJzdC5cIiwgdHlwZU5hbWUpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGUgW1tFbnRpdHlUeXBlXV1zIG9yIFtbQ29tcGxleFR5cGVdXXMgaW4gdGhpcyBNZXRhZGF0YVN0b3JlLlxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlclxyXG4gID4gICAgICBsZXQgYWxsVHlwZXMgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlcygpO1xyXG4gICoqL1xyXG4gIGdldEVudGl0eVR5cGVzKCkge1xyXG4gICAgcmV0dXJuIGdldFR5cGVzRnJvbU1hcCh0aGlzLl9zdHJ1Y3R1cmFsVHlwZU1hcCk7XHJcbiAgfVxyXG5cclxuICBnZXRJbmNvbXBsZXRlTmF2aWdhdGlvblByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4gY29yZS5vYmplY3RNYXAodGhpcy5faW5jb21wbGV0ZVR5cGVNYXAsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIGZ1bGx5IHF1YWxpZmllZCBlbnRpdHlUeXBlTmFtZSBmb3IgYSBzcGVjaWZpZWQgcmVzb3VyY2UgbmFtZS4gIFRoZSByZXZlcnNlIG9mIHRoaXMgb3BlcmF0aW9uXHJcbiAgY2FuIGJlIG9idGFpbmVkIHZpYSB0aGUgIFtbRW50aXR5VHlwZS5kZWZhdWx0UmVzb3VyY2VOYW1lXV0gcHJvcGVydHlcclxuICAqKi9cclxuICBnZXRFbnRpdHlUeXBlTmFtZUZvclJlc291cmNlTmFtZShyZXNvdXJjZU5hbWU6IHN0cmluZykge1xyXG4gICAgYXNzZXJ0UGFyYW0ocmVzb3VyY2VOYW1lLCBcInJlc291cmNlTmFtZVwiKS5pc1N0cmluZygpLmNoZWNrKCk7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VFbnRpdHlUeXBlTWFwW3Jlc291cmNlTmFtZV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBBc3NvY2lhdGVzIGEgcmVzb3VyY2VOYW1lIHdpdGggYW4gZW50aXR5VHlwZS5cclxuXHJcbiAgVGhpcyBtZXRob2QgaXMgb25seSBuZWVkZWQgaW4gdGhvc2UgY2FzZXMgd2hlcmUgbXVsdGlwbGUgcmVzb3VyY2VzIHJldHVybiB0aGUgc2FtZVxyXG4gIGVudGl0eVR5cGUuICBJbiB0aGlzIGNhc2UgTWV0YWRhdGEgZGlzY292ZXJ5IHdpbGwgb25seSBkZXRlcm1pbmUgYSBzaW5nbGUgcmVzb3VyY2UgbmFtZSBmb3JcclxuICBlYWNoIGVudGl0eVR5cGUuXHJcbiAgQHBhcmFtIHJlc291cmNlTmFtZSAtIFRoZSByZXNvdXJjZSBuYW1lXHJcbiAgQHBhcmFtIGVudGl0eVR5cGVPck5hbWUgLSBJZiBwYXNzaW5nIGEgc3RyaW5nIGVpdGhlciB0aGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgb3IgYSBzaG9ydCBuYW1lIG1heSBiZSB1c2VkLiBJZiBhIHNob3J0IG5hbWUgaXMgc3BlY2lmaWVkIGFuZCBtdWx0aXBsZSB0eXBlcyBzaGFyZVxyXG4gIHRoYXQgc2FtZSBzaG9ydCBuYW1lIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi4gSWYgdGhlIGVudGl0eVR5cGUgaGFzIG5vdCB5ZXQgYmVlbiBkaXNjb3ZlcmVkIHRoZW4gYSBmdWxseSBxdWFsaWZpZWQgbmFtZSBtdXN0IGJlIHVzZWQuXHJcbiAgKiovXHJcbiAgc2V0RW50aXR5VHlwZUZvclJlc291cmNlTmFtZShyZXNvdXJjZU5hbWU6IHN0cmluZywgZW50aXR5VHlwZU9yTmFtZTogRW50aXR5VHlwZSB8IHN0cmluZykge1xyXG4gICAgYXNzZXJ0UGFyYW0ocmVzb3VyY2VOYW1lLCBcInJlc291cmNlTmFtZVwiKS5pc1N0cmluZygpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShlbnRpdHlUeXBlT3JOYW1lLCBcImVudGl0eVR5cGVPck5hbWVcIikuaXNJbnN0YW5jZU9mKEVudGl0eVR5cGUpLm9yKCkuaXNTdHJpbmcoKS5jaGVjaygpO1xyXG5cclxuICAgIGxldCBlbnRpdHlUeXBlTmFtZTogc3RyaW5nO1xyXG4gICAgaWYgKGVudGl0eVR5cGVPck5hbWUgaW5zdGFuY2VvZiBFbnRpdHlUeXBlKSB7XHJcbiAgICAgIGVudGl0eVR5cGVOYW1lID0gZW50aXR5VHlwZU9yTmFtZS5uYW1lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZW50aXR5VHlwZU5hbWUgPSBnZXRRdWFsaWZpZWRUeXBlTmFtZSh0aGlzLCBlbnRpdHlUeXBlT3JOYW1lLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9yZXNvdXJjZUVudGl0eVR5cGVNYXBbcmVzb3VyY2VOYW1lXSA9IGVudGl0eVR5cGVOYW1lO1xyXG4gICAgbGV0IGVudGl0eVR5cGUgPSB0aGlzLl9nZXRTdHJ1Y3R1cmFsVHlwZShlbnRpdHlUeXBlTmFtZSwgdHJ1ZSk7XHJcbiAgICBpZiAoZW50aXR5VHlwZSAmJiBlbnRpdHlUeXBlIGluc3RhbmNlb2YgRW50aXR5VHlwZSAmJiAhZW50aXR5VHlwZS5kZWZhdWx0UmVzb3VyY2VOYW1lKSB7XHJcbiAgICAgIGVudGl0eVR5cGUuZGVmYXVsdFJlc291cmNlTmFtZSA9IHJlc291cmNlTmFtZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBfX0RldiBPbmx5X18gLSBmb3IgdXNlIHdoZW4gY3JlYXRpbmcgYSBuZXcgTWV0YWRhdGFQYXJzZXJBZGFwdGVyICAqL1xyXG4gIHN0YXRpYyBwYXJzZVR5cGVOYW1lKGVudGl0eVR5cGVOYW1lOiBzdHJpbmcpIHtcclxuICAgIC8vIFRPRE86IHJlbW92ZWQgXHJcbiAgICAvLyBpZiAoIWVudGl0eVR5cGVOYW1lKSB7XHJcbiAgICAvLyAgIHJldHVybiBudWxsO1xyXG4gICAgLy8gfVxyXG5cclxuICAgIGxldCB0eXBlUGFydHMgPSBlbnRpdHlUeXBlTmFtZS5zcGxpdChcIjojXCIpO1xyXG4gICAgaWYgKHR5cGVQYXJ0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHJldHVybiBNZXRhZGF0YVN0b3JlLm1ha2VUeXBlSGFzaCh0eXBlUGFydHNbMF0sIHR5cGVQYXJ0c1sxXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvcmUuc3RyaW5nU3RhcnRzV2l0aChlbnRpdHlUeXBlTmFtZSwgTWV0YWRhdGFTdG9yZS5BTk9OVFlQRV9QUkVGSVgpKSB7XHJcbiAgICAgIGxldCB0eXBlSGFzaCA9IE1ldGFkYXRhU3RvcmUubWFrZVR5cGVIYXNoKGVudGl0eVR5cGVOYW1lKTtcclxuICAgICAgKHR5cGVIYXNoIGFzIGFueSkuaXNBbm9ueW1vdXMgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gdHlwZUhhc2g7XHJcbiAgICB9XHJcbiAgICBsZXQgZW50aXR5VHlwZU5hbWVOb0Fzc2VtYmx5ID0gZW50aXR5VHlwZU5hbWUuc3BsaXQoXCIsXCIpWzBdO1xyXG4gICAgdHlwZVBhcnRzID0gZW50aXR5VHlwZU5hbWVOb0Fzc2VtYmx5LnNwbGl0KFwiLlwiKTtcclxuICAgIGlmICh0eXBlUGFydHMubGVuZ3RoID4gMSkge1xyXG4gICAgICBsZXQgc2hvcnROYW1lID0gdHlwZVBhcnRzW3R5cGVQYXJ0cy5sZW5ndGggLSAxXTtcclxuICAgICAgbGV0IG5hbWVzcGFjZVBhcnRzID0gdHlwZVBhcnRzLnNsaWNlKDAsIHR5cGVQYXJ0cy5sZW5ndGggLSAxKTtcclxuICAgICAgbGV0IG5zID0gbmFtZXNwYWNlUGFydHMuam9pbihcIi5cIik7XHJcbiAgICAgIHJldHVybiBNZXRhZGF0YVN0b3JlLm1ha2VUeXBlSGFzaChzaG9ydE5hbWUsIG5zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBNZXRhZGF0YVN0b3JlLm1ha2VUeXBlSGFzaChlbnRpdHlUeXBlTmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogX19EZXYgT25seV9fIC0gZm9yIHVzZSB3aGVuIGNyZWF0aW5nIGEgbmV3IE1ldGFkYXRhUGFyc2VyQWRhcHRlciAgKi9cclxuICBzdGF0aWMgbWFrZVR5cGVIYXNoKHNob3J0TmFtZTogc3RyaW5nLCBucz86IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2hvcnRUeXBlTmFtZTogc2hvcnROYW1lLFxyXG4gICAgICBuYW1lc3BhY2U6IG5zLFxyXG4gICAgICB0eXBlTmFtZTogcXVhbGlmeVR5cGVOYW1lKHNob3J0TmFtZSwgbnMpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gcHJvdGVjdGVkIG1ldGhvZHNcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfY2hlY2tFbnRpdHlUeXBlKGVudGl0eTogRW50aXR5KSB7XHJcbiAgICBpZiAoZW50aXR5LmVudGl0eVR5cGUpIHJldHVybjtcclxuICAgIGxldCB0eXBlTmFtZSA9IGVudGl0eS5wcm90b3R5cGUuXyR0eXBlTmFtZTtcclxuICAgIGlmICghdHlwZU5hbWUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnRpdHkgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuIFNlZSB0aGUgTWV0YWRhdGFTdG9yZS5yZWdpc3RlckVudGl0eVR5cGVDdG9yIG1ldGhvZFwiKTtcclxuICAgIH1cclxuICAgIC8vIHdlIGtub3cgdGhhdCBpdCBpcyBhbiBFbnRpdHlUeXBlICggYXMgb3Bwb3NlZCB0byBhIENvbXBsZXhUeXBlKVxyXG4gICAgbGV0IGVudGl0eVR5cGUgPSB0aGlzLl9nZXRTdHJ1Y3R1cmFsVHlwZSh0eXBlTmFtZSkgYXMgRW50aXR5VHlwZTtcclxuICAgIGlmIChlbnRpdHlUeXBlKSB7XHJcbiAgICAgIGVudGl0eS5lbnRpdHlUeXBlID0gZW50aXR5VHlwZTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxufVxyXG5NZXRhZGF0YVN0b3JlLnByb3RvdHlwZS5fJHR5cGVOYW1lID0gXCJNZXRhZGF0YVN0b3JlXCI7XHJcblxyXG5CcmVlemVFdmVudC5idWJibGVFdmVudChNZXRhZGF0YVN0b3JlLnByb3RvdHlwZSk7XHJcblxyXG5mdW5jdGlvbiBnZXRUeXBlc0Zyb21NYXAodHlwZU1hcDogSVN0cnVjdHVyYWxUeXBlTWFwKSB7XHJcbiAgbGV0IHR5cGVzOiAoU3RydWN0dXJhbFR5cGUpW10gPSBbXTtcclxuICBmb3IgKGxldCBrZXkgaW4gdHlwZU1hcCkge1xyXG4gICAgbGV0IHZhbHVlID0gdHlwZU1hcFtrZXldO1xyXG4gICAgLy8gc2tpcCAnc2hvcnROYW1lJyBlbnRyaWVzXHJcbiAgICBpZiAoa2V5ID09PSB2YWx1ZS5uYW1lKSB7XHJcbiAgICAgIHR5cGVzLnB1c2godHlwZU1hcFtrZXldKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHR5cGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJ1Y3R1cmFsVHlwZUZyb21Kc29uKG1ldGFkYXRhU3RvcmU6IE1ldGFkYXRhU3RvcmUsIGpzb246IGFueSwgYWxsb3dNZXJnZTogYm9vbGVhbikge1xyXG4gIGxldCB0eXBlTmFtZSA9IHF1YWxpZnlUeXBlTmFtZShqc29uLnNob3J0TmFtZSwganNvbi5uYW1lc3BhY2UpO1xyXG4gIGxldCBzdHlwZSA9IG1ldGFkYXRhU3RvcmUuX2dldFN0cnVjdHVyYWxUeXBlKHR5cGVOYW1lLCB0cnVlKTtcclxuICBpZiAoc3R5cGUpIHtcclxuICAgIGlmIChhbGxvd01lcmdlKSB7XHJcbiAgICAgIHJldHVybiBtZXJnZVN0cnVjdHVyYWxUeXBlKHN0eXBlLCBqc29uKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGFsbG93IGl0IGJ1dCBkb24ndCByZXBsYWNlIGFueXRoaW5nLlxyXG4gICAgICByZXR1cm4gc3R5cGU7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGxldCBjb25maWcgPSB7XHJcbiAgICBzaG9ydE5hbWU6IGpzb24uc2hvcnROYW1lLFxyXG4gICAgbmFtZXNwYWNlOiBqc29uLm5hbWVzcGFjZSxcclxuICAgIGlzQWJzdHJhY3Q6IGpzb24uaXNBYnN0cmFjdCxcclxuICAgIGF1dG9HZW5lcmF0ZWRLZXlUeXBlOiBBdXRvR2VuZXJhdGVkS2V5VHlwZS5mcm9tTmFtZShqc29uLmF1dG9HZW5lcmF0ZWRLZXlUeXBlKSxcclxuICAgIGRlZmF1bHRSZXNvdXJjZU5hbWU6IGpzb24uZGVmYXVsdFJlc291cmNlTmFtZSxcclxuICAgIGN1c3RvbToganNvbi5jdXN0b21cclxuICB9O1xyXG5cclxuICBzdHlwZSA9IGpzb24uaXNDb21wbGV4VHlwZSA/IG5ldyBDb21wbGV4VHlwZShjb25maWcpIDogbmV3IEVudGl0eVR5cGUoY29uZmlnKTtcclxuXHJcbiAgLy8gYmFzZVR5cGUgbWF5IG5vdCBoYXZlIGJlZW4gaW1wb3J0ZWQgeWV0IHNvIHdlIG5lZWQgdG8gZGVmZXIgaGFuZGxpbmcgdGhpcyB0eXBlIHVudGlsIGxhdGVyLlxyXG4gIGlmIChqc29uLmJhc2VUeXBlTmFtZSAmJiBzdHlwZSBpbnN0YW5jZW9mIEVudGl0eVR5cGUpIHtcclxuICAgIHN0eXBlLmJhc2VUeXBlTmFtZSA9IGpzb24uYmFzZVR5cGVOYW1lO1xyXG4gICAgbGV0IGJhc2VFbnRpdHlUeXBlID0gbWV0YWRhdGFTdG9yZS5fZ2V0U3RydWN0dXJhbFR5cGUoanNvbi5iYXNlVHlwZU5hbWUsIHRydWUpO1xyXG4gICAgaWYgKGJhc2VFbnRpdHlUeXBlKSB7XHJcbiAgICAgIGNvbXBsZXRlU3RydWN0dXJhbFR5cGVGcm9tSnNvbihtZXRhZGF0YVN0b3JlLCBqc29uLCBzdHlwZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb3JlLmdldEFycmF5KG1ldGFkYXRhU3RvcmUuX2RlZmVycmVkVHlwZXMsIGpzb24uYmFzZVR5cGVOYW1lKS5wdXNoKHsganNvbjoganNvbiwgc3R5cGU6IHN0eXBlIH0pO1xyXG5cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgY29tcGxldGVTdHJ1Y3R1cmFsVHlwZUZyb21Kc29uKG1ldGFkYXRhU3RvcmUsIGpzb24sIHN0eXBlKTtcclxuICB9XHJcblxyXG4gIC8vIHN0eXBlIG1heSBvciBtYXkgbm90IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgbWV0YWRhdGFTdG9yZSBhdCB0aGlzIHBvaW50LlxyXG4gIHJldHVybiBzdHlwZTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VTdHJ1Y3R1cmFsVHlwZShzdHlwZTogU3RydWN0dXJhbFR5cGUsIGpzb246IGFueSkge1xyXG4gIGlmIChqc29uLmN1c3RvbSkge1xyXG4gICAgc3R5cGUuY3VzdG9tID0ganNvbi5jdXN0b207XHJcbiAgfVxyXG5cclxuICBtZXJnZVByb3BzKHN0eXBlLCBqc29uLmRhdGFQcm9wZXJ0aWVzKTtcclxuICBtZXJnZVByb3BzKHN0eXBlLCBqc29uLm5hdmlnYXRpb25Qcm9wZXJ0aWVzKTtcclxuICByZXR1cm4gc3R5cGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMoc3R5cGU6IFN0cnVjdHVyYWxUeXBlLCBqc29uUHJvcHM6IGFueVtdKSB7XHJcbiAgaWYgKCFqc29uUHJvcHMpIHJldHVybjtcclxuICBqc29uUHJvcHMuZm9yRWFjaCgoanNvblByb3ApID0+IHtcclxuICAgIGxldCBwcm9wTmFtZSA9IGpzb25Qcm9wLm5hbWU7XHJcbiAgICBpZiAoIXByb3BOYW1lKSB7XHJcbiAgICAgIGlmIChqc29uUHJvcC5uYW1lT25TZXJ2ZXIpIHtcclxuICAgICAgICBwcm9wTmFtZSA9IHN0eXBlLm1ldGFkYXRhU3RvcmUubmFtaW5nQ29udmVudGlvbi5zZXJ2ZXJQcm9wZXJ0eU5hbWVUb0NsaWVudChqc29uUHJvcC5uYW1lT25TZXJ2ZXIsIHt9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBiYWNrc2xhc2gtcXVvdGUgd29ya3MgYXJvdW5kIGNvbXBpbGVyIGJ1Z1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IFwiVW5hYmxlIHRvIGNvbXBsZXRlIFxcJ2ltcG9ydE1ldGFkYXRhXFwnIC0gY2Fubm90IGxvY2F0ZSBhIFxcJ25hbWVcXCcgb3IgXFwnbmFtZU9uU2VydmVyXFwnIGZvciBvbmUgb2YgdGhlIGltcG9ydGVkIHByb3BlcnR5IG5vZGVzXCI7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqc29uUHJvcC5jdXN0b20pIHtcclxuICAgICAgbGV0IHByb3AgPSBzdHlwZS5nZXRQcm9wZXJ0eShwcm9wTmFtZSwgdHJ1ZSk7XHJcbiAgICAgIHByb3AhLmN1c3RvbSA9IGpzb25Qcm9wLmN1c3RvbTtcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGxldGVTdHJ1Y3R1cmFsVHlwZUZyb21Kc29uKG1ldGFkYXRhU3RvcmU6IE1ldGFkYXRhU3RvcmUsIGpzb246IGFueSwgc3R5cGU6IGFueSkge1xyXG5cclxuICAvLyB2YWxpZGF0b3JzIGZyb20gYmFzZVR5cGUgd29yayBiZWNhdXNlIHZhbGlkYXRpb24gd2Fsa3MgdGhydSBiYXNlIHR5cGVzXHJcbiAgLy8gc28gbm8gbmVlZCB0byBjb3B5IGRvd24uXHJcbiAgaWYgKGpzb24udmFsaWRhdG9ycykge1xyXG4gICAgc3R5cGUudmFsaWRhdG9ycyA9IGpzb24udmFsaWRhdG9ycy5tYXAoVmFsaWRhdG9yLmZyb21KU09OKTtcclxuICB9XHJcblxyXG4gIGpzb24uZGF0YVByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoZHA6IE9iamVjdCkge1xyXG4gICAgc3R5cGUuX2FkZFByb3BlcnR5Q29yZShEYXRhUHJvcGVydHkuZnJvbUpTT04oZHApKTtcclxuICB9KTtcclxuXHJcblxyXG4gIGxldCBpc0VudGl0eVR5cGUgPSAhanNvbi5pc0NvbXBsZXhUeXBlO1xyXG4gIGlmIChpc0VudGl0eVR5cGUpIHtcclxuICAgIC8vbm9pbnNwZWN0aW9uIEpTSGludFxyXG4gICAganNvbi5uYXZpZ2F0aW9uUHJvcGVydGllcyAmJiBqc29uLm5hdmlnYXRpb25Qcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKG5wOiBPYmplY3QpIHtcclxuICAgICAgc3R5cGUuX2FkZFByb3BlcnR5Q29yZShOYXZpZ2F0aW9uUHJvcGVydHkuZnJvbUpTT04obnApKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgbWV0YWRhdGFTdG9yZS5hZGRFbnRpdHlUeXBlKHN0eXBlKTtcclxuXHJcbiAgbGV0IGRlZmVycmVkVHlwZXMgPSBtZXRhZGF0YVN0b3JlLl9kZWZlcnJlZFR5cGVzO1xyXG4gIGxldCBkZWZlcnJhbHMgPSBkZWZlcnJlZFR5cGVzW3N0eXBlLm5hbWVdO1xyXG4gIGlmIChkZWZlcnJhbHMpIHtcclxuICAgIGRlZmVycmFscy5mb3JFYWNoKGZ1bmN0aW9uIChkOiBhbnkpIHtcclxuICAgICAgY29tcGxldGVTdHJ1Y3R1cmFsVHlwZUZyb21Kc29uKG1ldGFkYXRhU3RvcmUsIGQuanNvbiwgZC5zdHlwZSk7XHJcbiAgICB9KTtcclxuICAgIGRlbGV0ZSBkZWZlcnJlZFR5cGVzW3N0eXBlLm5hbWVdO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UXVhbGlmaWVkVHlwZU5hbWUobWV0YWRhdGFTdG9yZTogTWV0YWRhdGFTdG9yZSwgc3RydWN0VHlwZU5hbWU6IHN0cmluZywgdGhyb3dJZk5vdEZvdW5kPzogYm9vbGVhbikge1xyXG4gIGlmIChpc1F1YWxpZmllZFR5cGVOYW1lKHN0cnVjdFR5cGVOYW1lKSkgcmV0dXJuIHN0cnVjdFR5cGVOYW1lO1xyXG4gIGxldCByZXN1bHQgPSBtZXRhZGF0YVN0b3JlLl9zaG9ydE5hbWVNYXBbc3RydWN0VHlwZU5hbWVdO1xyXG4gIGlmICghcmVzdWx0ICYmIHRocm93SWZOb3RGb3VuZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvY2F0ZSAnZW50aXR5VHlwZU5hbWUnIG9mOiBcIiArIHN0cnVjdFR5cGVOYW1lKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqIENvbmZpZ3VyYXRpb24gaW5mbyB0byBiZSBwYXNzZWQgdG8gdGhlIFtbRW50aXR5VHlwZV1dIGNvbnN0cnVjdG9yICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRW50aXR5VHlwZUNvbmZpZyB7XHJcbiAgc2hvcnROYW1lPzogc3RyaW5nO1xyXG4gIG5hbWVzcGFjZT86IHN0cmluZztcclxuICBiYXNlVHlwZU5hbWU/OiBzdHJpbmc7XHJcbiAgaXNBYnN0cmFjdD86IGJvb2xlYW47XHJcbiAgYXV0b0dlbmVyYXRlZEtleVR5cGU/OiBBdXRvR2VuZXJhdGVkS2V5VHlwZTtcclxuICBkZWZhdWx0UmVzb3VyY2VOYW1lPzogc3RyaW5nO1xyXG4gIGRhdGFQcm9wZXJ0aWVzPzogRGF0YVByb3BlcnR5W10gfCBPYmplY3RbXSB8IE9iamVjdDsgIC8vIFRPRE86IHNlZSBpZiB3ZSBjYW4ndCBxdWFsaWZ5IE9iamVjdFtdIGEgbGl0dGxlIGJldHRlci5cclxuICBuYXZpZ2F0aW9uUHJvcGVydGllcz86IE5hdmlnYXRpb25Qcm9wZXJ0eVtdIHwgT2JqZWN0W10gfCBPYmplY3Q7XHJcbiAgc2VyaWFsaXplckZuPzogKHByb3A6IEVudGl0eVByb3BlcnR5LCB2YWw6IGFueSkgPT4gYW55O1xyXG4gIGN1c3RvbT86IE9iamVjdDtcclxufVxyXG5cclxuLyoqIENvbmZpZ3VyYXRpb24gaW5mbyB0byBiZSBwYXNzZWQgdG8gdGhlIFtbRW50aXR5VHlwZS5zZXRQcm9wZXJ0aWVzXV0gbWV0aG9kICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRW50aXR5VHlwZVNldENvbmZpZyB7XHJcbiAgYXV0b0dlbmVyYXRlZEtleVR5cGU/OiBBdXRvR2VuZXJhdGVkS2V5VHlwZTtcclxuICBkZWZhdWx0UmVzb3VyY2VOYW1lPzogc3RyaW5nO1xyXG4gIHNlcmlhbGl6ZXJGbj86IChwcm9wOiBFbnRpdHlQcm9wZXJ0eSwgdmFsOiBhbnkpID0+IGFueTtcclxuICBjdXN0b20/OiBPYmplY3Q7XHJcbn1cclxuXHJcbi8qKiBDb250YWluZXIgZm9yIGFsbCBvZiB0aGUgbWV0YWRhdGEgYWJvdXQgYSBzcGVjaWZpYyB0eXBlIG9mIEVudGl0eS5cclxuKiovXHJcbmV4cG9ydCBjbGFzcyBFbnRpdHlUeXBlIHtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfJHR5cGVOYW1lOiBzdHJpbmc7IC8vIG9uIHByb3RvXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgc3RhdGljIF9fbmV4dEFub25JeCA9IDA7XHJcbiAgLyoqIEFsd2F5cyBmYWxzZSBmb3IgYW4gRW50aXR5VHlwZS4gKiovXHJcbiAgaXNDb21wbGV4VHlwZSA9IGZhbHNlO1xyXG4gIC8qKiBUaGUgW1tNZXRhZGF0YVN0b3JlXV0gdGhhdCBjb250YWlucyB0aGlzIEVudGl0eVR5cGUuIF9fUmVhZCBPbmx5X18gKiovXHJcbiAgbWV0YWRhdGFTdG9yZTogTWV0YWRhdGFTdG9yZTtcclxuICAvKiogVGhlIERhdGFQcm9wZXJ0aWVzIChzZWUgW1tEYXRhUHJvcGVydHldXSBhc3NvY2lhdGVkIHdpdGggdGhpcyBFbnRpdHlUeXBlLiBfX1JlYWQgT25seV9fICAqKi9cclxuICBkYXRhUHJvcGVydGllczogRGF0YVByb3BlcnR5W107XHJcbiAgLyoqICBUaGUgTmF2aWdhdGlvblByb3BlcnRpZXMgKHNlZSBbW05hdmlnYXRpb25Qcm9wZXJ0eV1dIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eVR5cGUuIF9fUmVhZCBPbmx5X18gICoqL1xyXG4gIG5hdmlnYXRpb25Qcm9wZXJ0aWVzOiBOYXZpZ2F0aW9uUHJvcGVydHlbXTtcclxuICAvKipcclxuICBUaGUgRGF0YVByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5VHlwZSB0aGF0IG1ha2UgdXAgaXQncyBbW0VudGl0eUtleV1dLiBfX1JlYWQgT25seV9fICoqL1xyXG4gIGtleVByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG4gIC8qKiBUaGUgRGF0YVByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5VHlwZSB0aGF0IGFyZSBmb3JlaWduIGtleSBwcm9wZXJ0aWVzLiBfX1JlYWQgT25seV9fICoqL1xyXG4gIGZvcmVpZ25LZXlQcm9wZXJ0aWVzOiBEYXRhUHJvcGVydHlbXTtcclxuICBpbnZlcnNlRm9yZWlnbktleVByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG4gIC8qKiAgVGhlIERhdGFQcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eVR5cGUgdGhhdCBhcmUgY29uY3VycmVuY3kgcHJvcGVydGllcy4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBjb25jdXJyZW5jeVByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG4gIC8qKiBUaGUgRGF0YVByb3BlcnRpZXMgZm9yIHRoaXMgRW50aXR5VHlwZSB0aGF0IGNvbnRhaW4gaW5zdGFuY2VzIG9mIGEgW1tDb21wbGV4VHlwZV1dLiBfX1JlYWQgT25seV9fICAgKiovXHJcbiAgY29tcGxleFByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG4gIC8qKiBUaGUgRGF0YVByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRW50aXR5VHlwZSB0aGF0IGFyZSBub3QgbWFwcGVkIHRvIGFueSBiYWNrZW5kIGRhdGFzdG9yZS4gVGhlc2UgYXJlIGVmZmVjdGl2ZWx5IGZyZWUgc3RhbmRpbmdcclxuICBwcm9wZXJ0aWVzLiBfX1JlYWQgT25seV9fICoqL1xyXG4gIHVubWFwcGVkUHJvcGVydGllczogRGF0YVByb3BlcnR5W107XHJcblxyXG4gIC8qKiBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgb2YgdGhpcyBFbnRpdHlUeXBlLiBfX1JlYWQgT25seV9fICAqKi9cclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBzaG9ydCwgdW5xdWFsaWZpZWQsIG5hbWUgZm9yIHRoaXMgRW50aXR5VHlwZS4gX19SZWFkIE9ubHlfXyAgKiovXHJcbiAgc2hvcnROYW1lOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBuYW1lc3BhY2UgZm9yIHRoaXMgRW50aXR5VHlwZS4gX19SZWFkIE9ubHlfXyAgKiovXHJcbiAgbmFtZXNwYWNlOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgRW50aXR5VHlwZSdzIGJhc2UgRW50aXR5VHlwZSAgKGlmIGFueSkgKi9cclxuICBiYXNlVHlwZU5hbWU/OiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBiYXNlIEVudGl0eVR5cGUgKGlmIGFueSkgZm9yIHRoaXMgRW50aXR5VHlwZS4gX19SZWFkIE9ubHlfXyAgICoqL1xyXG4gIGJhc2VFbnRpdHlUeXBlOiBFbnRpdHlUeXBlO1xyXG4gIHN1YnR5cGVzOiBFbnRpdHlUeXBlW107XHJcblxyXG4gIC8qKiAgV2hldGhlciB0aGlzIEVudGl0eVR5cGUgaXMgYWJzdHJhY3QuIF9fUmVhZCBPbmx5X18gKiovXHJcbiAgaXNBYnN0cmFjdDogYm9vbGVhbjtcclxuICAvKiogIFdoZXRoZXIgdGhpcyBFbnRpdHlUeXBlIGlzIGFub255bW91cy4gQW5vbnltb3VzIHR5cGVzIHdpbGwgbmV2ZXIgYmUgY29tbXVuaWNhdGVkIHRvIG9yIGZyb20gdGhlIHNlcnZlci4gVGhleSBhcmUgcHVyZWx5IGZvclxyXG4gIGNsaWVudCBzaWRlIHVzZSBhbmQgYXJlIGdpdmVuIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIG5hbWUuICBfX1JlYWQgT25seV9fICoqL1xyXG4gIGlzQW5vbnltb3VzOiBib29sZWFuO1xyXG4gIC8qKiBXaGV0aGVyIHRoaXMgRW50aXR5VHlwZSBoYXMgYmVlbiAnZnJvemVuJy4gIEVudGl0eVR5cGVzIGJlY29tZSBmcm96ZW4gYWZ0ZXIgdGhlIGZpcnN0IGluc3RhbmNlIFxyXG4gIG9mIHRoYXQgdHlwZSBoYXMgYmVlbiBjcmVhdGVkIGFuZCBhdHRhY2hlZCB0byBhbiBFbnRpdHlNYW5hZ2VyLiAqL1xyXG4gIGlzRnJvemVuOiBib29sZWFuO1xyXG5cclxuICAvKiogVGhlIFtbQXV0b0dlbmVyYXRlZEtleVR5cGVdXSBmb3IgdGhpcyBFbnRpdHlUeXBlLiBfX1JlYWQgT25seV9fICoqL1xyXG4gIGF1dG9HZW5lcmF0ZWRLZXlUeXBlOiBBdXRvR2VuZXJhdGVkS2V5VHlwZTtcclxuICAvKiogICBUaGUgZGVmYXVsdCByZXNvdXJjZSBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVudGl0eVR5cGUuICBBbiBFbnRpdHlUeXBlIG1heSBiZSBxdWVyaWVkIHZpYSBhIHZhcmlldHkgb2YgJ3Jlc291cmNlIG5hbWVzJyBidXQgdGhpcyBvbmVcclxuICBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0IHdoZW4gbm8gcmVzb3VyY2UgbmFtZSBpcyBwcm92aWRlZC4gIFRoaXMgd2lsbCBvY2N1ciB3aGVuIGNhbGxpbmcgW1tFbnRpdHlBc3BlY3QubG9hZE5hdmlnYXRpb25Qcm9wZXJ0eV1dXHJcbiAgb3Igd2hlbiBleGVjdXRpbmcgYW55IFtbRW50aXR5UXVlcnldXSB0aGF0IHdhcyBjcmVhdGVkIHZpYSBhbiBbW0VudGl0eUtleV1dLiBfX1JlYWQgT25seV9fICoqL1xyXG4gIGRlZmF1bHRSZXNvdXJjZU5hbWU6IHN0cmluZztcclxuICAvKiogQSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gY3VzdG9taXplIHRoZSBzZXJpYWxpemF0aW9uIG9mIGFueSBFbnRpdHlQcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZS4gKi9cclxuICBzZXJpYWxpemVyRm4/OiAocHJvcDogRW50aXR5UHJvcGVydHksIHZhbDogYW55KSA9PiBhbnk7XHJcbiAgLyoqICBBIGZyZWUgZm9ybSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgYW55IGN1c3RvbSBtZXRhZGF0YSBmb3IgdGhpcyBFbnRpdHlUeXBlLiBfX1JlYWQgT25seV9fICAqKi9cclxuICBjdXN0b20/OiBPYmplY3Q7XHJcbiAgLyoqIFRoZSBlbnRpdHkgbGV2ZWwgdmFsaWRhdG9ycyBhc3NvY2lhdGVkIHdpdGggdGhpcyBFbnRpdHlUeXBlLiBWYWxpZGF0b3JzIGNhbiBiZSBhZGRlZCBhbmRcclxuICByZW1vdmVkIGZyb20gdGhpcyBjb2xsZWN0aW9uLiBfX1JlYWQgT25seV9fLiAgICoqL1xyXG4gIHZhbGlkYXRvcnM6IFZhbGlkYXRvcltdO1xyXG5cclxuICB3YXJuaW5nczogYW55W107XHJcbiAgaW5pdEZuOiBGdW5jdGlvbiB8IHN0cmluZztcclxuICBub1RyYWNraW5nRm46IEZ1bmN0aW9uO1xyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfZXh0cmE6IGFueTtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfY3RvcjogeyBuZXcgKCk6IFN0cnVjdHVyYWxPYmplY3QgfTtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfbWFwcGVkUHJvcGVydGllc0NvdW50OiBudW1iZXI7XHJcblxyXG4gIC8qKiBcclxuICBAZGVwcmVjYXRlZCBVc2UgW1tnZXRDdG9yXV0gaW5zdGVhZC4gICBcclxuICAqL1xyXG4gIGdldEVudGl0eUN0b3IgPSB0aGlzLmdldEN0b3I7XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIHN0YXRpYyBxdWFsaWZ5VHlwZU5hbWUgPSBxdWFsaWZ5VHlwZU5hbWU7XHJcblxyXG5cclxuICAvKiogRW50aXR5VHlwZSBjb25zdHJ1Y3RvciAgXHJcbiAgPiAgICAgIGxldCBlbnRpdHlUeXBlID0gbmV3IEVudGl0eVR5cGUoIHtcclxuICA+ICAgICAgICAgIHNob3J0TmFtZTogXCJwZXJzb25cIixcclxuICA+ICAgICAgICAgIG5hbWVzcGFjZTogXCJteUFwcE5hbWVzcGFjZVwiXHJcbiAgPiAgICAgIH0pO1xyXG4gIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIHNldHRpbmdzIG9yIGEgTWV0YWRhdGFTdG9yZS4gIElmIHRoaXMgcGFyYW1ldGVyIGlzIGp1c3QgYSBNZXRhZGF0YVN0b3JlXHJcbiAgdGhlbiB3aGF0IHdpbGwgYmUgY3JlYXRlZCBpcyBhbiAnYW5vbnltb3VzJyB0eXBlIHRoYXQgd2lsbCBuZXZlciBiZSBjb21tdW5pY2F0ZWQgdG8gb3IgZnJvbSB0aGUgc2VydmVyLiBJdCBpcyBwdXJlbHkgZm9yXHJcbiAgY2xpZW50IHNpZGUgdXNlIGFuZCB3aWxsIGJlIGdpdmVuIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIG5hbWUuIE5vcm1hbGx5LCBob3dldmVyLCB5b3Ugd2lsbCB1c2UgYSBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAqKi9cclxuICBjb25zdHJ1Y3Rvcihjb25maWc6IE1ldGFkYXRhU3RvcmUgfCBFbnRpdHlUeXBlQ29uZmlnKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIEVudGl0eVR5cGUgY3RvciBoYXMgYSBzaW5nbGUgYXJndW1lbnQgdGhhdCBpcyBlaXRoZXIgYSAnTWV0YWRhdGFTdG9yZScgb3IgYSBjb25maWd1cmF0aW9uIG9iamVjdC5cIik7XHJcbiAgICB9XHJcbiAgICAvLyBsZXQgZXRDb25maWcgPSAgPEVudGl0eVR5cGVDb25maWc+IDxhbnk+IHVuZGVmaW5lZDtcclxuICAgIGxldCBldENvbmZpZzogRW50aXR5VHlwZUNvbmZpZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAoKGNvbmZpZyBhcyBhbnkpLl8kdHlwZU5hbWUgPT09IFwiTWV0YWRhdGFTdG9yZVwiKSB7XHJcbiAgICAgIHRoaXMubWV0YWRhdGFTdG9yZSA9IGNvbmZpZyBhcyBNZXRhZGF0YVN0b3JlO1xyXG4gICAgICB0aGlzLnNob3J0TmFtZSA9IFwiQW5vbl9cIiArICgrK0VudGl0eVR5cGUuX19uZXh0QW5vbkl4KTtcclxuICAgICAgdGhpcy5uYW1lc3BhY2UgPSBcIlwiO1xyXG4gICAgICB0aGlzLmlzQW5vbnltb3VzID0gdHJ1ZTtcclxuICAgICAgLy8gZXRDb25maWcgPSB1bmRlZmluZWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBldENvbmZpZyA9IGNvbmZpZyBhcyBFbnRpdHlUeXBlQ29uZmlnO1xyXG4gICAgICBhc3NlcnRDb25maWcoY29uZmlnKVxyXG4gICAgICAgIC53aGVyZVBhcmFtKFwic2hvcnROYW1lXCIpLmlzTm9uRW1wdHlTdHJpbmcoKVxyXG4gICAgICAgIC53aGVyZVBhcmFtKFwibmFtZXNwYWNlXCIpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KFwiXCIpXHJcbiAgICAgICAgLndoZXJlUGFyYW0oXCJiYXNlVHlwZU5hbWVcIikuaXNTdHJpbmcoKS5pc09wdGlvbmFsKClcclxuICAgICAgICAud2hlcmVQYXJhbShcImlzQWJzdHJhY3RcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KGZhbHNlKVxyXG4gICAgICAgIC53aGVyZVBhcmFtKFwiYXV0b0dlbmVyYXRlZEtleVR5cGVcIikuaXNFbnVtT2YoQXV0b0dlbmVyYXRlZEtleVR5cGUpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChBdXRvR2VuZXJhdGVkS2V5VHlwZS5Ob25lKVxyXG4gICAgICAgIC53aGVyZVBhcmFtKFwiZGVmYXVsdFJlc291cmNlTmFtZVwiKS5pc05vbkVtcHR5U3RyaW5nKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KG51bGwpXHJcbiAgICAgICAgLndoZXJlUGFyYW0oXCJkYXRhUHJvcGVydGllc1wiKS5pc09wdGlvbmFsKClcclxuICAgICAgICAud2hlcmVQYXJhbShcIm5hdmlnYXRpb25Qcm9wZXJ0aWVzXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAgIC53aGVyZVBhcmFtKFwic2VyaWFsaXplckZuXCIpLmlzT3B0aW9uYWwoKS5pc0Z1bmN0aW9uKClcclxuICAgICAgICAud2hlcmVQYXJhbShcImN1c3RvbVwiKS5pc09wdGlvbmFsKClcclxuICAgICAgICAuYXBwbHlBbGwodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5uYW1lID0gcXVhbGlmeVR5cGVOYW1lKHRoaXMuc2hvcnROYW1lLCB0aGlzLm5hbWVzcGFjZSk7XHJcblxyXG4gICAgLy8gdGhlIGRlZmF1bHRSZXNvdXJjZU5hbWUgbWF5IGFsc28gYmUgc2V0IHVwIGVpdGhlciB2aWEgbWV0YWRhdGEgbG9va3VwIG9yIGZpcnN0IHF1ZXJ5IG9yIHZpYSB0aGUgJ3NldFByb3BlcnRpZXMnIG1ldGhvZFxyXG4gICAgdGhpcy5kYXRhUHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy5uYXZpZ2F0aW9uUHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy5jb21wbGV4UHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy5rZXlQcm9wZXJ0aWVzID0gW107XHJcbiAgICB0aGlzLmZvcmVpZ25LZXlQcm9wZXJ0aWVzID0gW107XHJcbiAgICB0aGlzLmludmVyc2VGb3JlaWduS2V5UHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy5jb25jdXJyZW5jeVByb3BlcnRpZXMgPSBbXTtcclxuICAgIHRoaXMudW5tYXBwZWRQcm9wZXJ0aWVzID0gW107IC8vIHdpbGwgYmUgdXBkYXRlZCBsYXRlci5cclxuICAgIHRoaXMudmFsaWRhdG9ycyA9IFtdO1xyXG4gICAgdGhpcy53YXJuaW5ncyA9IFtdO1xyXG4gICAgdGhpcy5fbWFwcGVkUHJvcGVydGllc0NvdW50ID0gMDtcclxuICAgIHRoaXMuc3VidHlwZXMgPSBbXTtcclxuICAgIC8vIG5vdyBwcm9jZXNzIGFueSBkYXRhL25hdiBwcm9wc1xyXG4gICAgaWYgKGV0Q29uZmlnICYmIGV0Q29uZmlnLmRhdGFQcm9wZXJ0aWVzKSB7XHJcbiAgICAgIGFkZFByb3BlcnRpZXModGhpcywgZXRDb25maWcuZGF0YVByb3BlcnRpZXMsIERhdGFQcm9wZXJ0eSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZXRDb25maWcgJiYgZXRDb25maWcubmF2aWdhdGlvblByb3BlcnRpZXMpIHtcclxuICAgICAgYWRkUHJvcGVydGllcyh0aGlzLCBldENvbmZpZy5uYXZpZ2F0aW9uUHJvcGVydGllcywgTmF2aWdhdGlvblByb3BlcnR5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIEdlbmVyYWwgcHVycG9zZSBwcm9wZXJ0eSBzZXQgbWV0aG9kXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgPiAgICAgIGN1c3RUeXBlLnNldFByb3BlcnRpZXMoIHtcclxuICA+ICAgICAgICAgIGF1dG9HZW5lcmF0ZWRLZXlUeXBlOiBBdXRvR2VuZXJhdGVkS2V5VHlwZS5JZGVudGl0eTtcclxuICA+ICAgICAgICAgIGRlZmF1bHRSZXNvdXJjZU5hbWU6IFwiQ3VzdG9tZXJzQW5kSW5jbHVkZWRPcmRlcnNcIlxyXG4gID4gICAgICApfTtcclxuICBAcGFyYW0gY29uZmlnIC0gYSBjb25maWd1cmF0aW9uIG9iamVjdFxyXG4gICoqL1xyXG4gIHNldFByb3BlcnRpZXMoY29uZmlnOiBFbnRpdHlUeXBlU2V0Q29uZmlnKSB7XHJcbiAgICBhc3NlcnRDb25maWcoY29uZmlnKVxyXG4gICAgICAud2hlcmVQYXJhbShcImF1dG9HZW5lcmF0ZWRLZXlUeXBlXCIpLmlzRW51bU9mKEF1dG9HZW5lcmF0ZWRLZXlUeXBlKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJkZWZhdWx0UmVzb3VyY2VOYW1lXCIpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwic2VyaWFsaXplckZuXCIpLmlzRnVuY3Rpb24oKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJjdXN0b21cIikuaXNPcHRpb25hbCgpXHJcbiAgICAgIC5hcHBseUFsbCh0aGlzKTtcclxuICAgIGlmIChjb25maWcuZGVmYXVsdFJlc291cmNlTmFtZSkge1xyXG4gICAgICB0aGlzLmRlZmF1bHRSZXNvdXJjZU5hbWUgPSBjb25maWcuZGVmYXVsdFJlc291cmNlTmFtZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgd2hldGhlciB0aGlzIHR5cGUgaXMgYSBzdWJ0eXBlIG9mIGEgc3BlY2lmaWVkIHR5cGUuXHJcbiAgKiovXHJcbiAgaXNTdWJ0eXBlT2YoZW50aXR5VHlwZTogRW50aXR5VHlwZSkge1xyXG4gICAgYXNzZXJ0UGFyYW0oZW50aXR5VHlwZSwgXCJlbnRpdHlUeXBlXCIpLmlzSW5zdGFuY2VPZihFbnRpdHlUeXBlKS5jaGVjaygpO1xyXG4gICAgbGV0IGJhc2VUeXBlOiBFbnRpdHlUeXBlID0gdGhpcztcclxuICAgIGRvIHtcclxuICAgICAgaWYgKGJhc2VUeXBlID09PSBlbnRpdHlUeXBlKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgYmFzZVR5cGUgPSBiYXNlVHlwZS5iYXNlRW50aXR5VHlwZTtcclxuICAgIH0gd2hpbGUgKGJhc2VUeXBlKTtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGlzIHR5cGUgYW5kIGFueS9hbGwgc3VidHlwZXMgb2YgdGhpcyB0eXBlIGRvd24gdGhydSB0aGUgaGllcmFyY2h5LlxyXG4gICoqL1xyXG4gIGdldFNlbGZBbmRTdWJ0eXBlcygpIHtcclxuICAgIGxldCByZXN1bHQgPSBbdGhpc107XHJcbiAgICB0aGlzLnN1YnR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHN0KSB7XHJcbiAgICAgIGxldCBzdWJ0eXBlcyA9IHN0LmdldFNlbGZBbmRTdWJ0eXBlcygpO1xyXG4gICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHN1YnR5cGVzKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIGdldEFsbFZhbGlkYXRvcnMoKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy52YWxpZGF0b3JzLnNsaWNlKDApO1xyXG4gICAgbGV0IGJ0ID0gdGhpcy5iYXNlRW50aXR5VHlwZTtcclxuICAgIHdoaWxlIChidCkge1xyXG4gICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGJ0LnZhbGlkYXRvcnMpO1xyXG4gICAgICBidCA9IGJ0LmJhc2VFbnRpdHlUeXBlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIEFkZHMgYSAgW1tEYXRhUHJvcGVydHldXSBvciBhIFtbTmF2aWdhdGlvblByb3BlcnR5XV0gdG8gdGhpcyBFbnRpdHlUeXBlLlxyXG4gID4gICAgICAvLyBhc3N1bWUgbXlFbnRpdHlUeXBlIGlzIGEgbmV3bHkgY29uc3RydWN0ZWQgRW50aXR5VHlwZS5cclxuICA+ICAgICAgbXlFbnRpdHlUeXBlLmFkZFByb3BlcnR5KGRhdGFQcm9wZXJ0eTEpO1xyXG4gID4gICAgICBteUVudGl0eVR5cGUuYWRkUHJvcGVydHkoZGF0YVByb3BlcnR5Mik7XHJcbiAgPiAgICAgIG15RW50aXR5VHlwZS5hZGRQcm9wZXJ0eShuYXZpZ2F0aW9uUHJvcGVydHkxKTtcclxuICAqKi9cclxuICBhZGRQcm9wZXJ0eShwcm9wZXJ0eTogRW50aXR5UHJvcGVydHkpIHtcclxuICAgIGFzc2VydFBhcmFtKHByb3BlcnR5LCBcInByb3BlcnR5XCIpLmlzSW5zdGFuY2VPZihEYXRhUHJvcGVydHkpLm9yKCkuaXNJbnN0YW5jZU9mKE5hdmlnYXRpb25Qcm9wZXJ0eSkuY2hlY2soKTtcclxuXHJcbiAgICAvLyB0cnVlIGlzIDJuZCBhcmcgdG8gZm9yY2UgcmVzb2x2ZSBvZiBhbnkgbmF2aWdhdGlvbiBwcm9wZXJ0aWVzLlxyXG4gICAgbGV0IG5ld3Byb3AgPSB0aGlzLl9hZGRQcm9wZXJ0eUNvcmUocHJvcGVydHksIHRydWUpO1xyXG5cclxuICAgIGlmICh0aGlzLnN1YnR5cGVzICYmIHRoaXMuc3VidHlwZXMubGVuZ3RoKSB7XHJcbiAgICAgIGxldCBzdHlwZSA9IHRoaXM7XHJcbiAgICAgIHN0eXBlLmdldFNlbGZBbmRTdWJ0eXBlcygpLmZvckVhY2goZnVuY3Rpb24gKHN0KSB7XHJcbiAgICAgICAgaWYgKHN0ICE9PSBzdHlwZSkge1xyXG4gICAgICAgICAgaWYgKHByb3BlcnR5LmlzTmF2aWdhdGlvblByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHN0Ll9hZGRQcm9wZXJ0eUNvcmUobmV3IE5hdmlnYXRpb25Qcm9wZXJ0eShwcm9wZXJ0eSksIHRydWUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3QuX2FkZFByb3BlcnR5Q29yZShuZXcgRGF0YVByb3BlcnR5KHByb3BlcnR5IGFzIERhdGFQcm9wZXJ0eSksIHRydWUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3cHJvcDtcclxuICB9XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF91cGRhdGVGcm9tQmFzZShiYXNlRW50aXR5VHlwZTogRW50aXR5VHlwZSkge1xyXG4gICAgdGhpcy5iYXNlRW50aXR5VHlwZSA9IGJhc2VFbnRpdHlUeXBlO1xyXG4gICAgaWYgKHRoaXMuYXV0b0dlbmVyYXRlZEtleVR5cGUgPT09IEF1dG9HZW5lcmF0ZWRLZXlUeXBlLk5vbmUpIHtcclxuICAgICAgdGhpcy5hdXRvR2VuZXJhdGVkS2V5VHlwZSA9IGJhc2VFbnRpdHlUeXBlLmF1dG9HZW5lcmF0ZWRLZXlUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIGJhc2VFbnRpdHlUeXBlLmRhdGFQcm9wZXJ0aWVzLmZvckVhY2goKGRwKSA9PiB7XHJcbiAgICAgIGxldCBuZXdEcCA9IG5ldyBEYXRhUHJvcGVydHkoZHApO1xyXG4gICAgICAvLyBkb24ndCBuZWVkIHRvIGNvcHkgdmFsaWRhdG9ycyBiZWNhdWUgd2Ugd2lsbCB3YWxrIHRoZSBoaWVyYXJjaHkgdG8gZmluZCB0aGVtXHJcbiAgICAgIG5ld0RwLnZhbGlkYXRvcnMgPSBbXTtcclxuICAgICAgbmV3RHAuYmFzZVByb3BlcnR5ID0gZHA7XHJcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5Q29yZShuZXdEcCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIGJhc2VFbnRpdHlUeXBlLm5hdmlnYXRpb25Qcm9wZXJ0aWVzLmZvckVhY2goKG5wKSA9PiB7XHJcbiAgICAgIGxldCBuZXdOcCA9IG5ldyBOYXZpZ2F0aW9uUHJvcGVydHkobnApO1xyXG4gICAgICAvLyBkb24ndCBuZWVkIHRvIGNvcHkgdmFsaWRhdG9ycyBiZWNhdWUgd2Ugd2lsbCB3YWxrIHRoZSBoaWVyYXJjaHkgdG8gZmluZCB0aGVtXHJcbiAgICAgIG5ld05wLnZhbGlkYXRvcnMgPSBbXTtcclxuICAgICAgbmV3TnAuYmFzZVByb3BlcnR5ID0gbnA7XHJcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5Q29yZShuZXdOcCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIGJhc2VFbnRpdHlUeXBlLnN1YnR5cGVzLnB1c2godGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfYWRkUHJvcGVydHlDb3JlKHByb3BlcnR5OiBFbnRpdHlQcm9wZXJ0eSwgc2hvdWxkUmVzb2x2ZTogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICBpZiAodGhpcy5pc0Zyb3plbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ1wiICsgdGhpcy5uYW1lICsgXCInIEVudGl0eVR5cGUvQ29tcGxleFR5cGUgaGFzIGJlZW4gZnJvemVuLiBZb3UgY2FuIG9ubHkgYWRkIHByb3BlcnRpZXMgdG8gYW4gRW50aXR5VHlwZS9Db21wbGV4VHlwZSBiZWZvcmUgYW55IGluc3RhbmNlcyBvZiB0aGF0IHR5cGUgaGF2ZSBiZWVuIGNyZWF0ZWQgYW5kIGF0dGFjaGVkIHRvIGFuIGVudGl0eU1hbmFnZXIuXCIpO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhcmVudFR5cGUgPSBwcm9wZXJ0eS5wYXJlbnRUeXBlO1xyXG4gICAgaWYgKHBhcmVudFR5cGUpIHtcclxuICAgICAgaWYgKHBhcmVudFR5cGUgIT09IHRoaXMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHByb3BlcnR5OiBcIiArIHByb3BlcnR5Lm5hbWUgKyBcIiBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIFwiICsgcHJvcGVydHkucGFyZW50VHlwZS5uYW1lKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBhZGRpbmcgdGhlIHNhbWUgcHJvcGVydHkgbW9yZSB0aGFuIG9uY2UgdG8gdGhlIHNhbWUgZW50aXR5VHlwZSBpcyBqdXN0IGlnbm9yZWQuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9wZXJ0eS5wYXJlbnRUeXBlID0gdGhpcztcclxuICAgIGxldCBtcyA9IHRoaXMubWV0YWRhdGFTdG9yZTtcclxuICAgIC8vIGlmIChwcm9wZXJ0eS5pc0RhdGFQcm9wZXJ0eSkgeyAvLyBtb2RpZmllZCBiZWNhdXNlIGRvZXNuJ3QgYWN0IGFzIGEgdHlwZSBndWFyZCBcclxuICAgIGlmIChwcm9wZXJ0eSBpbnN0YW5jZW9mIERhdGFQcm9wZXJ0eSkge1xyXG4gICAgICB0aGlzLl9hZGREYXRhUHJvcGVydHkocHJvcGVydHkpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fYWRkTmF2aWdhdGlvblByb3BlcnR5KHByb3BlcnR5KTtcclxuICAgICAgLy8gbWV0YWRhdGFTdG9yZSBjYW4gYmUgdW5kZWZpbmVkIGlmIHRoaXMgZW50aXR5VHlwZSBoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIGEgTWV0YWRhdGFTdG9yZS5cclxuICAgICAgaWYgKHNob3VsZFJlc29sdmUgJiYgbXMpIHtcclxuICAgICAgICB0cnlSZXNvbHZlTnAocHJvcGVydHksIG1zKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdW5tYXBwZWQgcHJvcGVydGllcyBjYW4gYmUgYWRkZWQgQUZURVIgZW50aXR5VHlwZSBoYXMgYWxyZWFkeSByZXNvbHZlZCBhbGwgcHJvcGVydHkgbmFtZXMuXHJcbiAgICBpZiAobXMgJiYgIShwcm9wZXJ0eS5uYW1lICYmIHByb3BlcnR5Lm5hbWVPblNlcnZlcikpIHtcclxuICAgICAgdXBkYXRlQ2xpZW50U2VydmVyTmFtZXMobXMubmFtaW5nQ29udmVudGlvbiwgcHJvcGVydHksIFwibmFtZVwiKTtcclxuICAgIH1cclxuICAgIC8vIHByb3BzIGNhbiBiZSBhZGRlZCBhZnRlciBlbnRpdHkgcHJvdG90eXBlIGhhcyBhbHJlYWR5IGJlZW4gd3JhcHBlZC5cclxuICAgIGlmIChtcyAmJiB0aGlzLl9leHRyYSkge1xyXG4gICAgICBpZiAodGhpcy5fZXh0cmEuYWxyZWFkeVdyYXBwZWRQcm9wcykge1xyXG4gICAgICAgIGxldCBwcm90byA9IHRoaXMuX2N0b3IucHJvdG90eXBlO1xyXG4gICAgICAgIGNvbmZpZy5pbnRlcmZhY2VSZWdpc3RyeS5tb2RlbExpYnJhcnkuZ2V0RGVmYXVsdEluc3RhbmNlKCkuaW5pdGlhbGl6ZUVudGl0eVByb3RvdHlwZShwcm90byk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIENyZWF0ZSBhIG5ldyBlbnRpdHkgb2YgdGhpcyB0eXBlLlxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXIgY29udGFpbmluZyBhIG51bWJlciBvZiBleGlzdGluZyBlbnRpdGllcy5cclxuICA+ICAgICAgbGV0IGN1c3RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0QXNFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgPiAgICAgIGxldCBjdXN0MSA9IGN1c3RUeXBlLmNyZWF0ZUVudGl0eSgpO1xyXG4gID4gICAgICBlbTEuYWRkRW50aXR5KGN1c3QxKTtcclxuICBAcGFyYW0gaW5pdGlhbFZhbHVlcy0gQ29uZmlndXJhdGlvbiBvYmplY3Qgb2YgdGhlIHByb3BlcnRpZXMgdG8gc2V0IGltbWVkaWF0ZWx5IGFmdGVyIGNyZWF0aW9uLlxyXG4gIEByZXR1cm4gVGhlIG5ldyBlbnRpdHkuXHJcbiAgKiovXHJcbiAgY3JlYXRlRW50aXR5KGluaXRpYWxWYWx1ZXM/OiBhbnkpOiBhbnkge1xyXG4gICAgLy8gaWdub3JlIHRoZSBfJGVyZWYgb25jZSB0aGUgZW50aXR5IGlzIGF0dGFjaGVkIHRvIGFuIGVudGl0eU1hbmFnZXIuXHJcbiAgICBpZiAoaW5pdGlhbFZhbHVlcyAmJiBpbml0aWFsVmFsdWVzLl8kZXJlZiAmJiAhaW5pdGlhbFZhbHVlcy5fJGVyZWYuZW50aXR5QXNwZWN0LmVudGl0eU1hbmFnZXIpIHJldHVybiBpbml0aWFsVmFsdWVzLl8kZXJlZjtcclxuXHJcbiAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9jcmVhdGVJbnN0YW5jZUNvcmUoKTtcclxuXHJcbiAgICBpZiAoaW5pdGlhbFZhbHVlcykge1xyXG4gICAgICAvLyBvbmx5IGFzc2lnbiBhbiBfZXJlZiBpZiB0aGUgb2JqZWN0IGlzIGZ1bGx5IFwia2V5ZWRcIlxyXG4gICAgICBpZiAodGhpcy5rZXlQcm9wZXJ0aWVzLmV2ZXJ5KGZ1bmN0aW9uIChrcCkge1xyXG4gICAgICAgIHJldHVybiBpbml0aWFsVmFsdWVzW2twLm5hbWVdICE9IG51bGw7XHJcbiAgICAgIH0pKSB7XHJcbiAgICAgICAgaW5pdGlhbFZhbHVlcy5fJGVyZWYgPSBpbnN0YW5jZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fdXBkYXRlVGFyZ2V0RnJvbVJhdyhpbnN0YW5jZSwgaW5pdGlhbFZhbHVlcywgZ2V0UmF3VmFsdWVGcm9tQ29uZmlnKTtcclxuXHJcbiAgICAgIHRoaXMubmF2aWdhdGlvblByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAobnApIHtcclxuICAgICAgICBsZXQgcmVsYXRlZEVudGl0eTogYW55O1xyXG4gICAgICAgIGxldCB2YWwgPSBpbml0aWFsVmFsdWVzW25wLm5hbWVdO1xyXG4gICAgICAgIGlmICh2YWwgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBsZXQgbmF2RW50aXR5VHlwZSA9IG5wLmVudGl0eVR5cGU7XHJcbiAgICAgICAgICBpZiAobnAuaXNTY2FsYXIpIHtcclxuICAgICAgICAgICAgcmVsYXRlZEVudGl0eSA9IHZhbC5lbnRpdHlBc3BlY3QgPyB2YWwgOiBuYXZFbnRpdHlUeXBlLmNyZWF0ZUVudGl0eSh2YWwpO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRQcm9wZXJ0eShucC5uYW1lLCByZWxhdGVkRW50aXR5KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCByZWxhdGVkRW50aXRpZXMgPSBpbnN0YW5jZS5nZXRQcm9wZXJ0eShucC5uYW1lKTtcclxuICAgICAgICAgICAgdmFsLmZvckVhY2goKHY6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgIHJlbGF0ZWRFbnRpdHkgPSB2LmVudGl0eUFzcGVjdCA/IHYgOiBuYXZFbnRpdHlUeXBlLmNyZWF0ZUVudGl0eSh2KTtcclxuICAgICAgICAgICAgICByZWxhdGVkRW50aXRpZXMucHVzaChyZWxhdGVkRW50aXR5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9pbml0aWFsaXplSW5zdGFuY2UoaW5zdGFuY2UpO1xyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2NyZWF0ZUluc3RhbmNlQ29yZSgpIHtcclxuICAgIGxldCBhQ3RvciA9IHRoaXMuZ2V0Q3RvcigpO1xyXG4gICAgbGV0IGluc3RhbmNlID0gbmV3IGFDdG9yKCk7XHJcbiAgICBuZXcgRW50aXR5QXNwZWN0KGluc3RhbmNlIGFzIEVudGl0eSk7XHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfaW5pdGlhbGl6ZUluc3RhbmNlKGluc3RhbmNlOiBhbnkpIHtcclxuICAgIGlmICh0aGlzLmJhc2VFbnRpdHlUeXBlKSB7XHJcbiAgICAgIHRoaXMuYmFzZUVudGl0eVR5cGUuX2luaXRpYWxpemVJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBsZXQgaW5pdEZuID0gdGhpcy5pbml0Rm47XHJcbiAgICBpZiAoaW5pdEZuKSB7XHJcbiAgICAgIGxldCBmbiA9ICh0eXBlb2YgaW5pdEZuID09PSBcInN0cmluZ1wiKSA/IGluc3RhbmNlW2luaXRGbl0gOiBpbml0Rm47XHJcbiAgICAgIGZuKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIHRoaXMuY29tcGxleFByb3BlcnRpZXMgJiYgdGhpcy5jb21wbGV4UHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChjcCkge1xyXG4gICAgICBsZXQgY29tcGxleFR5cGUgPSBjcC5kYXRhVHlwZSBhcyBDb21wbGV4VHlwZTtcclxuICAgICAgbGV0IGN0SW5zdGFuY2UgPSBpbnN0YW5jZS5nZXRQcm9wZXJ0eShjcC5uYW1lKTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3RJbnN0YW5jZSkpIHtcclxuICAgICAgICBjdEluc3RhbmNlLmZvckVhY2goKGN0SW5zdCkgPT4ge1xyXG4gICAgICAgICAgY29tcGxleFR5cGUuX2luaXRpYWxpemVJbnN0YW5jZShjdEluc3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbXBsZXhUeXBlLl9pbml0aWFsaXplSW5zdGFuY2UoY3RJbnN0YW5jZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gbm90IG5lZWRlZCBmb3IgY29tcGxleE9iamVjdHNcclxuICAgIGlmIChpbnN0YW5jZS5lbnRpdHlBc3BlY3QpIHtcclxuICAgICAgaW5zdGFuY2UuZW50aXR5QXNwZWN0Ll9pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhpcyBFbnRpdHlUeXBlLlxyXG4gIEBwYXJhbSBmb3JjZVJlZnJlc2ggLSBXaGV0aGVyIHRvIGlnbm9yZSBhbnkgY2FjaGVkIHZlcnNpb24gb2YgdGhpcyBjb25zdHJ1Y3Rvci4gKGRlZmF1bHQgPT0gZmFsc2UpXHJcbiAgQHJldHVybiBUaGUgY29uc3RydWN0b3IgZm9yIHRoaXMgRW50aXR5VHlwZS5cclxuICAqKi9cclxuICBnZXRDdG9yKGZvcmNlUmVmcmVzaDogYm9vbGVhbiA9IGZhbHNlKTogeyBuZXcgKCk6IFN0cnVjdHVyYWxPYmplY3QgfSB7XHJcbiAgICBpZiAodGhpcy5fY3RvciAmJiAhZm9yY2VSZWZyZXNoKSByZXR1cm4gdGhpcy5fY3RvcjtcclxuXHJcbiAgICBsZXQgY3RvclJlZ2lzdHJ5ID0gdGhpcy5tZXRhZGF0YVN0b3JlLl9jdG9yUmVnaXN0cnk7XHJcbiAgICBsZXQgciA9IGN0b3JSZWdpc3RyeVt0aGlzLm5hbWVdIHx8IGN0b3JSZWdpc3RyeVt0aGlzLnNob3J0TmFtZV0gfHwge307XHJcbiAgICBsZXQgYUN0b3IgPSByLmN0b3IgfHwgdGhpcy5fY3RvcjtcclxuXHJcbiAgICBsZXQgY3RvclR5cGUgPSBhQ3RvciAmJiBhQ3Rvci5wcm90b3R5cGUgJiYgKGFDdG9yLnByb3RvdHlwZS5lbnRpdHlUeXBlIHx8IGFDdG9yLnByb3RvdHlwZS5jb21wbGV4VHlwZSk7XHJcbiAgICBpZiAoY3RvclR5cGUgJiYgY3RvclR5cGUubWV0YWRhdGFTdG9yZSAhPT0gdGhpcy5tZXRhZGF0YVN0b3JlKSB7XHJcbiAgICAgIC8vIFdlIGNhbid0IHJpc2sgYSBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBjdG9yIGFuZCB0aGUgdHlwZSBpbmZvIGluIGEgc3BlY2lmaWMgbWV0YWRhdGFzdG9yZVxyXG4gICAgICAvLyBiZWNhdXNlIG1vZGVsTGlicmFyaWVzIHJlbHkgb24gdHlwZSBpbmZvIHRvIGludGVyY2VwdCBjdG9yIHByb3BlcnRpZXNcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlZ2lzdGVyIHRoZSBzYW1lIGNvbnN0cnVjdG9yIGZvciBcIiArIHRoaXMubmFtZSArIFwiIGluIGRpZmZlcmVudCBtZXRhZGF0YSBzdG9yZXMuICBQbGVhc2UgZGVmaW5lIGEgc2VwYXJhdGUgY29uc3RydWN0b3IgZm9yIGVhY2ggbWV0YWRhdGEgc3RvcmUuXCIpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAoci5jdG9yICYmIGZvcmNlUmVmcmVzaCkge1xyXG4gICAgICB0aGlzLl9leHRyYSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWFDdG9yKSB7XHJcbiAgICAgIGxldCBjcmVhdGVDdG9yID0gY29uZmlnLmludGVyZmFjZVJlZ2lzdHJ5Lm1vZGVsTGlicmFyeS5nZXREZWZhdWx0SW5zdGFuY2UoKS5jcmVhdGVDdG9yO1xyXG4gICAgICBhQ3RvciA9IGNyZWF0ZUN0b3IgPyBjcmVhdGVDdG9yKHRoaXMpIDogY3JlYXRlRW1wdHlDdG9yKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuaW5pdEZuID0gci5pbml0Rm47XHJcbiAgICB0aGlzLm5vVHJhY2tpbmdGbiA9IHIubm9UcmFja2luZ0ZuO1xyXG5cclxuICAgIGFDdG9yLnByb3RvdHlwZS5fJHR5cGVOYW1lID0gdGhpcy5uYW1lO1xyXG4gICAgdGhpcy5fc2V0Q3RvcihhQ3Rvcik7XHJcbiAgICByZXR1cm4gYUN0b3I7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgLy8gTWF5IG1ha2UgcHVibGljIGxhdGVyLlxyXG4gIF9zZXRDdG9yKGFDdG9yOiB7IG5ldyAoKTogU3RydWN0dXJhbE9iamVjdCB9LCBpbnRlcmNlcHRvcj86IGFueSkge1xyXG5cclxuICAgIGxldCBpbnN0YW5jZVByb3RvID0gYUN0b3IucHJvdG90eXBlO1xyXG5cclxuICAgIC8vIHBsYWNlIGZvciBleHRyYSBicmVlemUgcmVsYXRlZCBkYXRhXHJcbiAgICB0aGlzLl9leHRyYSA9IHRoaXMuX2V4dHJhIHx8IHt9O1xyXG5cclxuICAgIGxldCBpbnN0YW5jZSA9IG5ldyBhQ3RvcigpO1xyXG4gICAgY2FsY1VubWFwcGVkUHJvcGVydGllcyh0aGlzLCBpbnN0YW5jZSk7XHJcblxyXG4gICAgaWYgKHRoaXMuXyR0eXBlTmFtZSA9PT0gXCJFbnRpdHlUeXBlXCIpIHtcclxuICAgICAgLy8gaW5zdXJlIHRoYXQgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGFyZSBvbiB0aGUgJ3RlbXBsYXRlJyBpbnN0YW5jZSBiZWZvcmUgd2F0Y2hpbmcgdGhlIGNsYXNzLlxyXG4gICAgICBpbnN0YW5jZVByb3RvLmVudGl0eVR5cGUgPSB0aGlzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5zdGFuY2VQcm90by5jb21wbGV4VHlwZSA9IHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGVmYXVsdFByb3BlcnR5SW50ZXJjZXB0b3IgaXMgYSAnZ2xvYmFsJyAoYnV0IGludGVybmFsIHRvIGJyZWV6ZSkgZnVuY3Rpb247XHJcbiAgICAoaW5zdGFuY2VQcm90byBhcyBhbnkpLl8kaW50ZXJjZXB0b3IgPSBpbnRlcmNlcHRvciB8fCBkZWZhdWx0UHJvcGVydHlJbnRlcmNlcHRvcjtcclxuICAgIGNvbmZpZy5pbnRlcmZhY2VSZWdpc3RyeS5tb2RlbExpYnJhcnkuZ2V0RGVmYXVsdEluc3RhbmNlKCkuaW5pdGlhbGl6ZUVudGl0eVByb3RvdHlwZShpbnN0YW5jZVByb3RvKTtcclxuICAgIHRoaXMuX2N0b3IgPSBhQ3RvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIEFkZHMgZWl0aGVyIGFuIGVudGl0eSBvciBwcm9wZXJ0eSBsZXZlbCB2YWxpZGF0b3IgdG8gdGhpcyBFbnRpdHlUeXBlLlxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXIgY29udGFpbmluZyBhIG51bWJlciBvZiBleGlzdGluZyBlbnRpdGllcy5cclxuICA+ICAgICAgbGV0IGN1c3RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkN1c3RvbWVyXCIpO1xyXG4gID4gICAgICBsZXQgY291bnRyeVByb3AgPSBjdXN0VHlwZS5nZXRQcm9wZXJ0eShcIkNvdW50cnlcIik7XHJcbiAgPiAgICAgIGxldCB2YWxGbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgPiAgICAgICAgICAgICAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgPiAgICAgICAgICAgICAgcmV0dXJuIChjb3JlLnN0cmluZ1N0YXJ0c1dpdGgodiwgXCJVU1wiKSk7XHJcbiAgPiAgICAgICAgICB9O1xyXG4gID4gICAgICBsZXQgY291bnRyeVZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3IoXCJjb3VudHJ5SXNVU1wiLCB2YWxGbixcclxuICA+ICAgICAgeyBkaXNwbGF5TmFtZTogXCJDb3VudHJ5XCIsIG1lc3NhZ2VUZW1wbGF0ZTogXCInJWRpc3BsYXlOYW1lJScgbXVzdCBzdGFydCB3aXRoICdVUydcIiB9KTtcclxuICA+ICAgICAgY3VzdFR5cGUuYWRkVmFsaWRhdG9yKGNvdW50cnlWYWxpZGF0b3IsIGNvdW50cnlQcm9wKTtcclxuXHJcbiAgVGhpcyBpcyB0aGUgc2FtZSBhcyBhZGRpbmcgYW4gZW50aXR5IGxldmVsIHZhbGlkYXRvciB2aWEgdGhlICd2YWxpZGF0b3JzJyBwcm9wZXJ0eSBvZiBEYXRhUHJvcGVydHkgb3IgTmF2aWdhdGlvblByb3BlcnR5XHJcbiAgPiAgICAgIGNvdW50cnlQcm9wLnZhbGlkYXRvcnMucHVzaChjb3VudHJ5VmFsaWRhdG9yKTtcclxuXHJcbiAgRW50aXR5IGxldmVsIHZhbGlkYXRvcnMgY2FuIGFsc28gYmUgYWRkZWQgYnkgb21pdHRpbmcgdGhlICdwcm9wZXJ0eScgcGFyYW1ldGVyLlxyXG4gID4gICAgICBjdXN0VHlwZS5hZGRWYWxpZGF0b3Ioc29tZUVudGl0eUxldmVsVmFsaWRhdG9yKTtcclxuXHJcbiAgb3JcclxuICA+ICAgICAgY3VzdFR5cGUudmFsaWRhdG9ycy5wdXNoKHNvbWVFbnRpdHlMZXZlbFZhbGlkYXRvcik7XHJcbiAgQHBhcmFtIHZhbGlkYXRvciAtIFZhbGlkYXRvciB0byBhZGQuXHJcbiAgQHBhcmFtIHByb3BlcnR5IC0gUHJvcGVydHkgdG8gYWRkIHRoaXMgdmFsaWRhdG9yIHRvLiAgSWYgb21pdHRlZCwgdGhlIHZhbGlkYXRvciBpcyBhc3N1bWVkIHRvIGJlIGFuXHJcbiAgZW50aXR5IGxldmVsIHZhbGlkYXRvciBhbmQgaXMgYWRkZWQgdG8gdGhlIEVudGl0eVR5cGUncyAndmFsaWRhdG9ycycuXHJcbiAgKiovXHJcbiAgYWRkVmFsaWRhdG9yKHZhbGlkYXRvcjogVmFsaWRhdG9yLCBwcm9wZXJ0eT86IEVudGl0eVByb3BlcnR5IHwgc3RyaW5nKSB7XHJcbiAgICBhc3NlcnRQYXJhbSh2YWxpZGF0b3IsIFwidmFsaWRhdG9yXCIpLmlzSW5zdGFuY2VPZihWYWxpZGF0b3IpLmNoZWNrKCk7XHJcbiAgICBhc3NlcnRQYXJhbShwcm9wZXJ0eSwgXCJwcm9wZXJ0eVwiKS5pc09wdGlvbmFsKCkuaXNTdHJpbmcoKS5vcigpLmlzRW50aXR5UHJvcGVydHkoKS5jaGVjaygpO1xyXG4gICAgaWYgKHByb3BlcnR5ICE9IG51bGwpIHtcclxuICAgICAgbGV0IHByb3AgPSAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykgPyB0aGlzLmdldFByb3BlcnR5KHByb3BlcnR5LCB0cnVlKSA6IHByb3BlcnR5O1xyXG4gICAgICBwcm9wIS52YWxpZGF0b3JzLnB1c2godmFsaWRhdG9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHZhbGlkYXRvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGFsbCBvZiB0aGUgcHJvcGVydGllcyAoIGRhdGFQcm9wZXJ0aWVzIGFuZCBuYXZpZ2F0aW9uUHJvcGVydGllcykgZm9yIHRoaXMgRW50aXR5VHlwZS5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICA+ICAgICAgbGV0IGFycmF5T2ZQcm9wcyA9IGN1c3RUeXBlLmdldFByb3BlcnRpZXMoKTtcclxuICBAcmV0dXJuIEFuIGFycmF5IG9mIERhdGEgYW5kIE5hdmlnYXRpb24gcHJvcGVydGllcy5cclxuICAqKi9cclxuICBnZXRQcm9wZXJ0aWVzKCk6IEVudGl0eVByb3BlcnR5W10ge1xyXG4gICAgcmV0dXJuICh0aGlzLmRhdGFQcm9wZXJ0aWVzIGFzIEVudGl0eVByb3BlcnR5W10pLmNvbmNhdCh0aGlzLm5hdmlnYXRpb25Qcm9wZXJ0aWVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYWxsIG9mIHRoZSBwcm9wZXJ0eSBuYW1lcyAoIGZvciBib3RoIGRhdGFQcm9wZXJ0aWVzIGFuZCBuYXZpZ2F0aW9uUHJvcGVydGllcykgZm9yIHRoaXMgRW50aXR5VHlwZS5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICA+ICAgICAgbGV0IGFycmF5T2ZQcm9wTmFtZXMgPSBjdXN0VHlwZS5nZXRQcm9wZXJ0eU5hbWVzKCk7XHJcbiAgKiovXHJcbiAgZ2V0UHJvcGVydHlOYW1lcygpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFByb3BlcnRpZXMoKS5tYXAoY29yZS5wbHVjaygnbmFtZScpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBkYXRhIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIG9yIG51bGwuXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbTEgaXMgYW4gRW50aXR5TWFuYWdlciBjb250YWluaW5nIGEgbnVtYmVyIG9mIGV4aXN0aW5nIGVudGl0aWVzLlxyXG4gID4gICAgICBsZXQgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgPiAgICAgIGxldCBjdXN0b21lck5hbWVEYXRhUHJvcCA9IGN1c3RUeXBlLmdldERhdGFQcm9wZXJ0eShcIkN1c3RvbWVyTmFtZVwiKTtcclxuICBAcmV0dXJuIEEgRGF0YVByb3BlcnR5IG9yIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICoqL1xyXG4gIGdldERhdGFQcm9wZXJ0eShwcm9wZXJ0eU5hbWU6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIGNvcmUuYXJyYXlGaXJzdCh0aGlzLmRhdGFQcm9wZXJ0aWVzLCBjb3JlLnByb3BFcSgnbmFtZScsIHByb3BlcnR5TmFtZSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIG5hdmlnYXRpb24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgb3IgbnVsbC5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIGxldCBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICA+ICAgICAgbGV0IGN1c3RvbWVyT3JkZXJzTmF2UHJvcCA9IGN1c3RUeXBlLmdldERhdGFQcm9wZXJ0eShcIk9yZGVyc1wiKTtcclxuICBAcmV0dXJuIEEgTmF2aWdhdGlvblByb3BlcnR5IG9yIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICoqL1xyXG4gIGdldE5hdmlnYXRpb25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWU6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIGNvcmUuYXJyYXlGaXJzdCh0aGlzLm5hdmlnYXRpb25Qcm9wZXJ0aWVzLCBjb3JlLnByb3BFcSgnbmFtZScsIHByb3BlcnR5TmFtZSkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBlaXRoZXIgYSBEYXRhUHJvcGVydHkgb3IgYSBOYXZpZ2F0aW9uUHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgb3IgbnVsbC5cclxuICBcclxuICBUaGlzIG1ldGhvZCBhbHNvIGFjY2VwdHMgYSAnLicgZGVsaW1pdGVkIHByb3BlcnR5IHBhdGggYW5kIHdpbGwgcmV0dXJuIHRoZSAncHJvcGVydHknIGF0IHRoZVxyXG4gIGVuZCBvZiB0aGUgcGF0aC5cclxuICA+ICAgICAgbGV0IGN1c3RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkN1c3RvbWVyXCIpO1xyXG4gID4gICAgICBsZXQgY29tcGFueU5hbWVQcm9wID0gY3VzdFR5cGUuZ2V0UHJvcGVydHkoXCJDb21wYW55TmFtZVwiKTtcclxuXHJcbiAgVGhpcyBtZXRob2QgY2FuIGFsc28gd2FsayBhIHByb3BlcnR5IHBhdGggdG8gcmV0dXJuIGEgcHJvcGVydHlcclxuICA+ICAgICAgbGV0IG9yZGVyRGV0YWlsVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJPcmRlckRldGFpbFwiKTtcclxuICA+ICAgICAgbGV0IGNvbXBhbnlOYW1lUHJvcDIgPSBvcmRlckRldGFpbFR5cGUuZ2V0UHJvcGVydHkoXCJPcmRlci5DdXN0b21lci5Db21wYW55TmFtZVwiKTtcclxuICA+ICAgICAgLy8gY29tcGFueU5hbWVQcm9wID09PSBjb21wYW55TmFtZVByb3AyXHJcbiAgQHBhcmFtIFt0aHJvd0lmTm90Rm91bmQ9ZmFsc2VdIHtCb29sZWFufSBXaGV0aGVyIHRvIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBub3QgZm91bmQuXHJcbiAgQHJldHVybiBBIERhdGFQcm9wZXJ0eSBvciBOYXZpZ2F0aW9uUHJvcGVydHkgb3IgbnVsbCBpZiBub3QgZm91bmQuXHJcbiAgKiovXHJcbiAgZ2V0UHJvcGVydHkocHJvcGVydHlQYXRoOiBzdHJpbmcsIHRocm93SWZOb3RGb3VuZDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICBsZXQgcHJvcHMgPSB0aGlzLmdldFByb3BlcnRpZXNPblBhdGgocHJvcGVydHlQYXRoLCBmYWxzZSwgdGhyb3dJZk5vdEZvdW5kKTtcclxuICAgIHJldHVybiAocHJvcHMgJiYgcHJvcHMubGVuZ3RoID4gMCkgPyBwcm9wc1twcm9wcy5sZW5ndGggLSAxXSA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICAvLyBUT0RPOiBoYXZlIHRoaXMgcmV0dXJuIGVtcHR5IGFycmF5IGluc3RlYWQgb2YgbnVsbCBhbmQgZml4IGNvbnN1bWVycy5cclxuICAvLyBUT0RPOiB0aGluayBhYm91dCByZW5hbWluZyB3aXRoICdfJyBwcmVmaXguXHJcbiAgZ2V0UHJvcGVydGllc09uUGF0aChwcm9wZXJ0eVBhdGg6IHN0cmluZywgdXNlU2VydmVyTmFtZTogYm9vbGVhbiB8IG51bGwsIHRocm93SWZOb3RGb3VuZDogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgICBsZXQgcHJvcGVydHlOYW1lczogc3RyaW5nW10gPSAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eVBhdGgpKSA/IHByb3BlcnR5UGF0aCA6IHByb3BlcnR5UGF0aC50cmltKCkuc3BsaXQoJy4nKTtcclxuXHJcbiAgICBsZXQgb2sgPSB0cnVlO1xyXG4gICAgbGV0IGtleSA9IHVzZVNlcnZlck5hbWUgPT09IHRydWUgPyBcIm5hbWVPblNlcnZlclwiIDogdXNlU2VydmVyTmFtZSA9PT0gZmFsc2UgPyBcIm5hbWVcIiA6IG51bGw7XHJcbiAgICBsZXQgcGFyZW50VHlwZSA9IHRoaXMgYXMgU3RydWN0dXJhbFR5cGU7XHJcbiAgICBcclxuICAgIGNvbnN0IGdldFByb3BzID0gKHByb3BOYW1lOiBzdHJpbmcpID0+IHsgXHJcbiAgICAgIGNvbnN0IGZuID0ga2V5ID09PSBudWxsID8gY29yZS5wcm9wc0VxKFwibmFtZVwiLCBcIm5hbWVPblNlcnZlclwiLCBwcm9wTmFtZSkgOiBjb3JlLnByb3BFcShrZXksIHByb3BOYW1lKTtcclxuICAgICAgbGV0IHByb3AgPSBjb3JlLmFycmF5Rmlyc3QocGFyZW50VHlwZS5nZXRQcm9wZXJ0aWVzKCksIGZuKTtcclxuICAgICAgaWYgKHByb3ApIHtcclxuICAgICAgICBwYXJlbnRUeXBlID0gKHByb3AgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uUHJvcGVydHkpID8gcHJvcC5lbnRpdHlUeXBlIDogcHJvcC5kYXRhVHlwZSBhcyBDb21wbGV4VHlwZTtcclxuICAgICAgICAvLyBwYXJlbnRUeXBlID0gcHJvcC5pc05hdmlnYXRpb25Qcm9wZXJ0eSA/IHByb3AuZW50aXR5VHlwZSA6IHByb3AuZGF0YVR5cGU7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGxvY2F0ZSBwcm9wZXJ0eTogXCIgKyBwcm9wTmFtZSArIFwiIG9uIGVudGl0eVR5cGU6IFwiICsgcGFyZW50VHlwZS5uYW1lKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvayA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgfTtcclxuXHJcbiAgICBsZXQgcHJvcHMgPSBwcm9wZXJ0eU5hbWVzLm1hcChnZXRQcm9wcykgYXMgRW50aXR5UHJvcGVydHlbXTtcclxuICAgIHJldHVybiBvayA/IHByb3BzIDogbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKiBGb3IgdXNlIGluIHBsdWdnYWJsZSBhZGFwdGVycy4gKi9cclxuICAvLyBUT0RPOiBkb2N1bWVudCB1c2VcclxuICBjbGllbnRQcm9wZXJ0eVBhdGhUb1NlcnZlcihwcm9wZXJ0eVBhdGg6IHN0cmluZywgZGVsaW1pdGVyOiBzdHJpbmcgPSAnLicpIHtcclxuICAgIGxldCBwcm9wTmFtZXM6IHN0cmluZ1tdO1xyXG4gICAgaWYgKHRoaXMuaXNBbm9ueW1vdXMpIHtcclxuICAgICAgbGV0IGZuID0gdGhpcy5tZXRhZGF0YVN0b3JlLm5hbWluZ0NvbnZlbnRpb24uY2xpZW50UHJvcGVydHlOYW1lVG9TZXJ2ZXI7XHJcbiAgICAgIHByb3BOYW1lcyA9IHByb3BlcnR5UGF0aC5zcGxpdChcIi5cIikubWFwKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmbihwcm9wTmFtZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IHByb3BzID0gdGhpcy5nZXRQcm9wZXJ0aWVzT25QYXRoKHByb3BlcnR5UGF0aCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICBwcm9wTmFtZXMgPSBwcm9wcyEubWFwKChwcm9wOiBFbnRpdHlQcm9wZXJ0eSkgPT4gcHJvcC5uYW1lT25TZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BOYW1lcy5qb2luKGRlbGltaXRlcik7XHJcbiAgfVxyXG5cclxuICAvKiogRm9yIHVzZSBpbiBwbHVnZ2FibGUgYWRhcHRlcnMuICovXHJcbiAgLy8gVE9ETzogZG9jdW1lbnQgdXNlXHJcbiAgZ2V0RW50aXR5S2V5RnJvbVJhd0VudGl0eShyYXdFbnRpdHk6IGFueSwgcmF3VmFsdWVGbjogRnVuY3Rpb24pIHtcclxuICAgIGxldCBrZXlWYWx1ZXMgPSB0aGlzLmtleVByb3BlcnRpZXMubWFwKChkcCkgPT4ge1xyXG4gICAgICBsZXQgdmFsID0gcmF3VmFsdWVGbihyYXdFbnRpdHksIGRwKTtcclxuICAgICAgcmV0dXJuIERhdGFUeXBlLnBhcnNlUmF3VmFsdWUodmFsLCBkcC5kYXRhVHlwZSBhcyBEYXRhVHlwZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXcgRW50aXR5S2V5KHRoaXMsIGtleVZhbHVlcyk7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfdXBkYXRlVGFyZ2V0RnJvbVJhdyh0YXJnZXQ6IFN0cnVjdHVyYWxPYmplY3QsIHJhdzogYW55LCByYXdWYWx1ZUZuOiBGdW5jdGlvbikge1xyXG4gICAgLy8gY2FsbGVkIHJlY3Vyc2l2ZWx5IGZvciBjb21wbGV4IHByb3BlcnRpZXNcclxuICAgIHRoaXMuZGF0YVByb3BlcnRpZXMuZm9yRWFjaCgoZHApID0+IHtcclxuICAgICAgaWYgKCFkcC5pc1NldHRhYmxlKSByZXR1cm47XHJcbiAgICAgIGxldCByYXdWYWwgPSByYXdWYWx1ZUZuKHJhdywgZHApO1xyXG4gICAgICBpZiAocmF3VmFsID09PSB1bmRlZmluZWQpIHJldHVybjtcclxuICAgICAgbGV0IGRhdGFUeXBlID0gZHAuZGF0YVR5cGU7IC8vIHRoaXMgd2lsbCBiZSBhIGNvbXBsZXhUeXBlIHdoZW4gZHAgaXMgYSBjb21wbGV4UHJvcGVydHlcclxuICAgICAgbGV0IG9sZFZhbDogYW55O1xyXG4gICAgICBpZiAoZHAuaXNDb21wbGV4UHJvcGVydHkpIHtcclxuICAgICAgICBsZXQgY29tcGxleFR5cGUgPSBkcC5kYXRhVHlwZSBhcyBDb21wbGV4VHlwZTtcclxuICAgICAgICBpZiAocmF3VmFsID09PSBudWxsKSByZXR1cm47IC8vIHJhd1ZhbCBtYXkgYmUgbnVsbCBpbiBub3NxbCBkYnMgd2hlcmUgaXQgd2FzIG5ldmVyIGRlZmluZWQgZm9yIHRoZSBnaXZlbiByb3cuXHJcbiAgICAgICAgb2xkVmFsID0gdGFyZ2V0LmdldFByb3BlcnR5KGRwLm5hbWUpO1xyXG4gICAgICAgIGlmIChkcC5pc1NjYWxhcikge1xyXG4gICAgICAgICAgY29tcGxleFR5cGUuX3VwZGF0ZVRhcmdldEZyb21SYXcob2xkVmFsLCByYXdWYWwsIHJhd1ZhbHVlRm4pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdWYWwpKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXdWYWwgPSByYXdWYWwubWFwKGZ1bmN0aW9uIChyYXdDbykge1xyXG4gICAgICAgICAgICAgIGxldCBuZXdDbyA9IGNvbXBsZXhUeXBlLl9jcmVhdGVJbnN0YW5jZUNvcmUodGFyZ2V0LCBkcCk7XHJcbiAgICAgICAgICAgICAgY29tcGxleFR5cGUuX3VwZGF0ZVRhcmdldEZyb21SYXcobmV3Q28sIHJhd0NvLCByYXdWYWx1ZUZuKTtcclxuICAgICAgICAgICAgICBjb21wbGV4VHlwZS5faW5pdGlhbGl6ZUluc3RhbmNlKG5ld0NvKTtcclxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q287XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIWNvcmUuYXJyYXlFcXVhbHMob2xkVmFsLCBuZXdWYWwsIGNvRXF1YWxzKSkge1xyXG4gICAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBvbGQgYXJyYXkgYW5kIHB1c2ggbmV3IG9iamVjdHMgaW50byBpdC5cclxuICAgICAgICAgICAgICBvbGRWYWwubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICBuZXdWYWwuZm9yRWFjaChmdW5jdGlvbiAobnYpIHtcclxuICAgICAgICAgICAgICAgIG9sZFZhbC5wdXNoKG52KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb2xkVmFsLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmIChkcC5pc1NjYWxhcikge1xyXG4gICAgICAgICAgbGV0IG5ld1ZhbCA9IERhdGFUeXBlLnBhcnNlUmF3VmFsdWUocmF3VmFsLCBkYXRhVHlwZSBhcyBEYXRhVHlwZSk7XHJcbiAgICAgICAgICB0YXJnZXQuc2V0UHJvcGVydHkoZHAubmFtZSwgbmV3VmFsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb2xkVmFsID0gdGFyZ2V0LmdldFByb3BlcnR5KGRwLm5hbWUpO1xyXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmF3VmFsKSkge1xyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNvbXBhcmUgdmFsdWVzXHJcbiAgICAgICAgICAgIGxldCBuZXdWYWwgPSByYXdWYWwubWFwKChydikgPT4ge1xyXG4gICAgICAgICAgICAgIHJldHVybiBEYXRhVHlwZS5wYXJzZVJhd1ZhbHVlKHJ2LCBkYXRhVHlwZSBhcyBEYXRhVHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIWNvcmUuYXJyYXlFcXVhbHMob2xkVmFsLCBuZXdWYWwpKSB7XHJcbiAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIG9sZCBhcnJheSBhbmQgcHVzaCBuZXcgb2JqZWN0cyBpbnRvIGl0LlxyXG4gICAgICAgICAgICAgIG9sZFZhbC5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgIG5ld1ZhbC5mb3JFYWNoKGZ1bmN0aW9uIChudikge1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsLnB1c2gobnYpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBvbGRWYWwubGVuZ3RoID0gMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBpZiBtZXJnaW5nIGZyb20gYW4gaW1wb3J0IHRoZW4gcmF3IHdpbGwgaGF2ZSBhbiBlbnRpdHlBc3BlY3Qgb3IgYSBjb21wbGV4QXNwZWN0XHJcbiAgICBsZXQgcmF3QXNwZWN0ID0gcmF3LmVudGl0eUFzcGVjdCB8fCByYXcuY29tcGxleEFzcGVjdDtcclxuICAgIGlmIChyYXdBc3BlY3QpIHtcclxuXHJcbiAgICAgIGxldCB0YXJnZXRBc3BlY3QgPSBFbnRpdHlBc3BlY3QuaXNFbnRpdHkodGFyZ2V0KSA/IHRhcmdldC5lbnRpdHlBc3BlY3QgOiB0YXJnZXQuY29tcGxleEFzcGVjdDtcclxuICAgICAgaWYgKHJhd0FzcGVjdC5vcmlnaW5hbFZhbHVlc01hcCkge1xyXG4gICAgICAgIHRhcmdldEFzcGVjdC5vcmlnaW5hbFZhbHVlcyA9IHJhd0FzcGVjdC5vcmlnaW5hbFZhbHVlc01hcDtcclxuICAgICAgfVxyXG4gICAgICBpZiAocmF3QXNwZWN0LmV4dHJhTWV0YWRhdGEpIHtcclxuICAgICAgICB0YXJnZXRBc3BlY3QuZXh0cmFNZXRhZGF0YSA9IHJhd0FzcGVjdC5leHRyYU1ldGFkYXRhO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBFbnRpdHlUeXBlLlxyXG4gICoqL1xyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubmFtZTtcclxuICB9XHJcblxyXG4gIHRvSlNPTigpIHtcclxuICAgIHJldHVybiBjb3JlLnRvSnNvbih0aGlzLCB7XHJcbiAgICAgIHNob3J0TmFtZTogbnVsbCxcclxuICAgICAgbmFtZXNwYWNlOiBudWxsLFxyXG4gICAgICBiYXNlVHlwZU5hbWU6IG51bGwsXHJcbiAgICAgIGlzQWJzdHJhY3Q6IGZhbHNlLFxyXG4gICAgICBhdXRvR2VuZXJhdGVkS2V5VHlwZTogbnVsbCwgLy8gZG8gbm90IHN1cHByZXNzIGRlZmF1bHQgdmFsdWVcclxuICAgICAgZGVmYXVsdFJlc291cmNlTmFtZTogbnVsbCxcclxuICAgICAgZGF0YVByb3BlcnRpZXM6IGxvY2FsUHJvcHNPbmx5LFxyXG4gICAgICBuYXZpZ2F0aW9uUHJvcGVydGllczogbG9jYWxQcm9wc09ubHksXHJcbiAgICAgIHZhbGlkYXRvcnM6IG51bGwsXHJcbiAgICAgIGN1c3RvbTogbnVsbFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfdXBkYXRlTmFtZXMocHJvcGVydHk6IEVudGl0eVByb3BlcnR5KSB7XHJcbiAgICBsZXQgbmMgPSB0aGlzLm1ldGFkYXRhU3RvcmUubmFtaW5nQ29udmVudGlvbjtcclxuICAgIHVwZGF0ZUNsaWVudFNlcnZlck5hbWVzKG5jLCBwcm9wZXJ0eSwgXCJuYW1lXCIpO1xyXG5cclxuICAgIGlmIChwcm9wZXJ0eS5pc05hdmlnYXRpb25Qcm9wZXJ0eSkge1xyXG4gICAgICB1cGRhdGVDbGllbnRTZXJ2ZXJOYW1lcyhuYywgcHJvcGVydHksIFwiZm9yZWlnbktleU5hbWVzXCIpO1xyXG4gICAgICB1cGRhdGVDbGllbnRTZXJ2ZXJOYW1lcyhuYywgcHJvcGVydHksIFwiaW52Rm9yZWlnbktleU5hbWVzXCIpO1xyXG5cclxuICAgICAgLy8gdGhlc2Ugd2lsbCBnZXQgc2V0IGxhdGVyIHZpYSBfdXBkYXRlTnBzXHJcbiAgICAgIC8vIHRoaXMuaW52ZXJzZVxyXG4gICAgICAvLyB0aGlzLmVudGl0eVR5cGVcclxuICAgICAgLy8gdGhpcy5yZWxhdGVkRGF0YVByb3BlcnRpZXNcclxuICAgICAgLy8gICAgZGF0YVByb3BlcnR5LnJlbGF0ZWROYXZpZ2F0aW9uUHJvcGVydHlcclxuICAgICAgLy8gICAgZGF0YVByb3BlcnR5LmludmVyc2VOYXZpZ2F0aW9uUHJvcGVydHlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9jaGVja05hdlByb3BlcnR5KG5hdmlnYXRpb25Qcm9wZXJ0eTogTmF2aWdhdGlvblByb3BlcnR5IHwgc3RyaW5nKSB7XHJcbiAgICAvLyBpZiAobmF2aWdhdGlvblByb3BlcnR5LmlzTmF2aWdhdGlvblByb3BlcnR5KSB7XHJcbiAgICBpZiAobmF2aWdhdGlvblByb3BlcnR5IGluc3RhbmNlb2YgTmF2aWdhdGlvblByb3BlcnR5KSB7XHJcbiAgICAgIGlmIChuYXZpZ2F0aW9uUHJvcGVydHkucGFyZW50VHlwZSAhPT0gdGhpcykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihjb3JlLmZvcm1hdFN0cmluZyhcIlRoZSBuYXZpZ2F0aW9uUHJvcGVydHkgJyUxJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiBlbnRpdHkgdHlwZSAnJTInXCIsXHJcbiAgICAgICAgICBuYXZpZ2F0aW9uUHJvcGVydHkubmFtZSwgdGhpcy5uYW1lKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG5hdmlnYXRpb25Qcm9wZXJ0eTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIChuYXZpZ2F0aW9uUHJvcGVydHkpID09PSAnc3RyaW5nJykge1xyXG4gICAgICBsZXQgbnAgPSB0aGlzLmdldFByb3BlcnR5KG5hdmlnYXRpb25Qcm9wZXJ0eSk7XHJcbiAgICAgIC8vIGlmIChucCAmJiBucC5pc05hdmlnYXRpb25Qcm9wZXJ0eSkgcmV0dXJuIG5wO1xyXG4gICAgICBpZiAobnAgJiYgbnAgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uUHJvcGVydHkpIHJldHVybiBucDtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnbmF2aWdhdGlvblByb3BlcnR5JyBwYXJhbWV0ZXIgbXVzdCBlaXRoZXIgYmUgYSBOYXZpZ2F0aW9uUHJvcGVydHkgb3IgdGhlIG5hbWUgb2YgYSBOYXZpZ2F0aW9uUHJvcGVydHlcIik7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfYWRkRGF0YVByb3BlcnR5KGRwOiBEYXRhUHJvcGVydHkpIHtcclxuXHJcbiAgICB0aGlzLmRhdGFQcm9wZXJ0aWVzLnB1c2goZHApO1xyXG5cclxuICAgIGlmIChkcC5pc1BhcnRPZktleSkge1xyXG4gICAgICB0aGlzLmtleVByb3BlcnRpZXMucHVzaChkcCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRwLmlzQ29tcGxleFByb3BlcnR5KSB7XHJcbiAgICAgIHRoaXMuY29tcGxleFByb3BlcnRpZXMucHVzaChkcCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRwLmNvbmN1cnJlbmN5TW9kZSAmJiBkcC5jb25jdXJyZW5jeU1vZGUgIT09IFwiTm9uZVwiKSB7XHJcbiAgICAgIHRoaXMuY29uY3VycmVuY3lQcm9wZXJ0aWVzLnB1c2goZHApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkcC5pc1VubWFwcGVkKSB7XHJcbiAgICAgIHRoaXMudW5tYXBwZWRQcm9wZXJ0aWVzLnB1c2goZHApO1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9hZGROYXZpZ2F0aW9uUHJvcGVydHkobnA6IE5hdmlnYXRpb25Qcm9wZXJ0eSkge1xyXG5cclxuICAgIHRoaXMubmF2aWdhdGlvblByb3BlcnRpZXMucHVzaChucCk7XHJcblxyXG4gICAgaWYgKCFpc1F1YWxpZmllZFR5cGVOYW1lKG5wLmVudGl0eVR5cGVOYW1lKSkge1xyXG4gICAgICBucC5lbnRpdHlUeXBlTmFtZSA9IHF1YWxpZnlUeXBlTmFtZShucC5lbnRpdHlUeXBlTmFtZSwgdGhpcy5uYW1lc3BhY2UpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX3VwZGF0ZUNwcygpIHtcclxuICAgIGxldCBtZXRhZGF0YVN0b3JlID0gdGhpcy5tZXRhZGF0YVN0b3JlO1xyXG4gICAgbGV0IGluY29tcGxldGVUeXBlTWFwID0gbWV0YWRhdGFTdG9yZS5faW5jb21wbGV0ZUNvbXBsZXhUeXBlTWFwO1xyXG4gICAgdGhpcy5jb21wbGV4UHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChjcCkge1xyXG4gICAgICBpZiAoY3AuY29tcGxleFR5cGUpIHJldHVybjtcclxuICAgICAgaWYgKCFyZXNvbHZlQ3AoY3AsIG1ldGFkYXRhU3RvcmUpKSB7XHJcbiAgICAgICAgY29yZS5nZXRBcnJheShpbmNvbXBsZXRlVHlwZU1hcCwgY3AuY29tcGxleFR5cGVOYW1lKS5wdXNoKGNwKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuaXNDb21wbGV4VHlwZSkge1xyXG4gICAgICAoaW5jb21wbGV0ZVR5cGVNYXBbdGhpcy5uYW1lXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoY3A6IERhdGFQcm9wZXJ0eSkge1xyXG4gICAgICAgIHJlc29sdmVDcChjcCwgbWV0YWRhdGFTdG9yZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBkZWxldGUgaW5jb21wbGV0ZVR5cGVNYXBbdGhpcy5uYW1lXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF91cGRhdGVOcHMoKSB7XHJcbiAgICBsZXQgbWV0YWRhdGFTdG9yZSA9IHRoaXMubWV0YWRhdGFTdG9yZTtcclxuXHJcbiAgICAvLyByZXNvbHZlIGFsbCBuYXZQcm9wcyBmb3IgdGhpcyBlbnRpdHlUeXBlXHJcbiAgICB0aGlzLm5hdmlnYXRpb25Qcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKG5wKSB7XHJcbiAgICAgIHRyeVJlc29sdmVOcChucCwgbWV0YWRhdGFTdG9yZSk7XHJcbiAgICB9KTtcclxuICAgIGxldCBpbmNvbXBsZXRlVHlwZU1hcCA9IG1ldGFkYXRhU3RvcmUuX2luY29tcGxldGVUeXBlTWFwO1xyXG4gICAgLy8gbmV4dCByZXNvbHZlIGFsbCBuYXZQcm9wIHRoYXQgcG9pbnQgdG8gdGhpcyBlbnRpdHlUeXBlLlxyXG4gICAgKGluY29tcGxldGVUeXBlTWFwW3RoaXMubmFtZV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKG5wOiBOYXZpZ2F0aW9uUHJvcGVydHkpIHtcclxuICAgICAgdHJ5UmVzb2x2ZU5wKG5wLCBtZXRhZGF0YVN0b3JlKTtcclxuICAgIH0pO1xyXG4gICAgLy8gZXZlcnkgbmF2UHJvcCB0aGF0IHBvaW50ZWQgdG8gdGhpcyB0eXBlIHNob3VsZCBub3cgYmUgcmVzb2x2ZWRcclxuICAgIGRlbGV0ZSBpbmNvbXBsZXRlVHlwZU1hcFt0aGlzLm5hbWVdO1xyXG4gIH1cclxufVxyXG5cclxuRW50aXR5VHlwZS5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IFwiRW50aXR5VHlwZVwiO1xyXG5cclxuZnVuY3Rpb24gZ2V0UmF3VmFsdWVGcm9tQ29uZmlnKHJhd0VudGl0eTogYW55LCBkcDogRGF0YVByb3BlcnR5KSB7XHJcbiAgLy8gJ3RydWUnIGZvcmsgY2FuIGhhcHBlbiBpZiBhbiBpbml0aWFsaXplciBjb250YWlucyBhbiBhY3RhdWwgaW5zdGFuY2Ugb2YgYW4gYWxyZWFkeSBjcmVhdGVkIGNvbXBsZXggb2JqZWN0LlxyXG4gIHJldHVybiAocmF3RW50aXR5LmVudGl0eUFzcGVjdCB8fCByYXdFbnRpdHkuY29tcGxleEFzcGVjdCkgPyByYXdFbnRpdHkuZ2V0UHJvcGVydHkoZHAubmFtZSkgOiByYXdFbnRpdHlbZHAubmFtZV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUNsaWVudFNlcnZlck5hbWVzKG5jOiBOYW1pbmdDb252ZW50aW9uLCBwYXJlbnQ6IGFueSwgY2xpZW50UHJvcE5hbWU6IHN0cmluZykge1xyXG4gIGxldCBzZXJ2ZXJQcm9wTmFtZSA9IGNsaWVudFByb3BOYW1lICsgXCJPblNlcnZlclwiO1xyXG4gIGxldCBjbGllbnROYW1lID0gcGFyZW50W2NsaWVudFByb3BOYW1lXTtcclxuICBpZiAoY2xpZW50TmFtZSAmJiBjbGllbnROYW1lLmxlbmd0aCkge1xyXG4gICAgLy8gaWYgKHBhcmVudC5pc1VubWFwcGVkKSByZXR1cm47XHJcbiAgICBsZXQgc2VydmVyTmFtZXMgPSBjb3JlLnRvQXJyYXkoY2xpZW50TmFtZSkubWFwKGZ1bmN0aW9uIChjTmFtZSkge1xyXG4gICAgICBsZXQgc05hbWUgPSBuYy5jbGllbnRQcm9wZXJ0eU5hbWVUb1NlcnZlcihjTmFtZSwgcGFyZW50KTtcclxuICAgICAgbGV0IHRlc3ROYW1lID0gbmMuc2VydmVyUHJvcGVydHlOYW1lVG9DbGllbnQoc05hbWUsIHBhcmVudCk7XHJcbiAgICAgIGlmIChjTmFtZSAhPT0gdGVzdE5hbWUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1pbmdDb252ZW50aW9uIGZvciB0aGlzIGNsaWVudCBwcm9wZXJ0eSBuYW1lIGRvZXMgbm90IHJvdW5kdHJpcCBwcm9wZXJseTpcIiArIGNOYW1lICsgXCItLT5cIiArIHRlc3ROYW1lKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc05hbWU7XHJcbiAgICB9KTtcclxuICAgIHBhcmVudFtzZXJ2ZXJQcm9wTmFtZV0gPSBBcnJheS5pc0FycmF5KGNsaWVudE5hbWUpID8gc2VydmVyTmFtZXMgOiBzZXJ2ZXJOYW1lc1swXTtcclxuICB9IGVsc2Uge1xyXG4gICAgbGV0IHNlcnZlck5hbWUgPSBwYXJlbnRbc2VydmVyUHJvcE5hbWVdO1xyXG4gICAgaWYgKCghc2VydmVyTmFtZSkgfHwgc2VydmVyTmFtZS5sZW5ndGggPT09IDApIHJldHVybjtcclxuICAgIGxldCBjbGllbnROYW1lcyA9IGNvcmUudG9BcnJheShzZXJ2ZXJOYW1lKS5tYXAoZnVuY3Rpb24gKHNOYW1lKSB7XHJcbiAgICAgIGxldCBjTmFtZSA9IG5jLnNlcnZlclByb3BlcnR5TmFtZVRvQ2xpZW50KHNOYW1lLCBwYXJlbnQpO1xyXG4gICAgICBsZXQgdGVzdE5hbWUgPSBuYy5jbGllbnRQcm9wZXJ0eU5hbWVUb1NlcnZlcihjTmFtZSwgcGFyZW50KTtcclxuICAgICAgaWYgKHNOYW1lICE9PSB0ZXN0TmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hbWluZ0NvbnZlbnRpb24gZm9yIHRoaXMgc2VydmVyIHByb3BlcnR5IG5hbWUgZG9lcyBub3Qgcm91bmR0cmlwIHByb3Blcmx5OlwiICsgc05hbWUgKyBcIi0tPlwiICsgdGVzdE5hbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjTmFtZTtcclxuICAgIH0pO1xyXG4gICAgcGFyZW50W2NsaWVudFByb3BOYW1lXSA9IEFycmF5LmlzQXJyYXkoc2VydmVyTmFtZSkgPyBjbGllbnROYW1lcyA6IGNsaWVudE5hbWVzWzBdO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRW1wdHlDdG9yKHR5cGU6IGFueSkge1xyXG4gIGlmIChjb25maWcubm9FdmFsKSB7XHJcbiAgICBsZXQgRW50aXR5ID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIHJldHVybiBFbnRpdHk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGxldCBuYW1lID0gdHlwZS5uYW1lLnJlcGxhY2UoL1xcVy9nLCAnXycpO1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCdyZXR1cm4gZnVuY3Rpb24gJyArIG5hbWUgKyAnKCl7fScpKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjb0VxdWFscyhjbzE6IENvbXBsZXhPYmplY3QsIGNvMjogQ29tcGxleE9iamVjdCk6IGJvb2xlYW4ge1xyXG4gIGxldCBjb21wbGV4VHlwZSA9IGNvMS5jb21wbGV4QXNwZWN0IS5wYXJlbnRQcm9wZXJ0eSEuZGF0YVR5cGUgYXMgQ29tcGxleFR5cGU7XHJcbiAgbGV0IGRhdGFQcm9wcyA9IGNvbXBsZXhUeXBlLmRhdGFQcm9wZXJ0aWVzO1xyXG4gIGxldCBhcmVFcXVhbCA9IGRhdGFQcm9wcy5ldmVyeShmdW5jdGlvbiAoZHApIHtcclxuICAgIGlmICghZHAuaXNTZXR0YWJsZSkgcmV0dXJuIHRydWU7XHJcbiAgICBsZXQgdjEgPSBjbzEuZ2V0UHJvcGVydHkoZHAubmFtZSk7XHJcbiAgICBsZXQgdjIgPSBjbzIuZ2V0UHJvcGVydHkoZHAubmFtZSk7XHJcbiAgICBpZiAoZHAuaXNDb21wbGV4UHJvcGVydHkgJiYgZHAuaXNTY2FsYXIpIHtcclxuICAgICAgcmV0dXJuIGNvRXF1YWxzKHYxLCB2Mik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChkcC5pc0NvbXBsZXhQcm9wZXJ0eSAmJiAhZHAuaXNTY2FsYXIpIHtcclxuICAgICAgcmV0dXJuIGNvcmUuYXJyYXlFcXVhbHModjEsIHYyLCBjb0VxdWFscyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgZGF0YVR5cGUgPSA8YW55PmRwLmRhdGFUeXBlOyAvLyB0aGlzIHdpbGwgYmUgYSBjb21wbGV4VHlwZSB3aGVuIGRwIGlzIGEgY29tcGxleFByb3BlcnR5XHJcbiAgICAgIHJldHVybiAodjEgPT09IHYyIHx8IChkYXRhVHlwZSAmJiBkYXRhVHlwZS5ub3JtYWxpemUgJiYgdjEgJiYgdjIgJiYgZGF0YVR5cGUubm9ybWFsaXplKHYxKSA9PT0gZGF0YVR5cGUubm9ybWFsaXplKHYyKSkpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBhcmVFcXVhbDtcclxufVxyXG5cclxuZnVuY3Rpb24gbG9jYWxQcm9wc09ubHkocHJvcHM6IEVudGl0eVByb3BlcnR5W10pIHtcclxuICByZXR1cm4gcHJvcHMuZmlsdGVyKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICByZXR1cm4gcHJvcC5iYXNlUHJvcGVydHkgPT0gbnVsbDtcclxuICB9KTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJlc29sdmVDcChjcDogRGF0YVByb3BlcnR5LCBtZXRhZGF0YVN0b3JlOiBNZXRhZGF0YVN0b3JlKSB7XHJcbiAgbGV0IGNvbXBsZXhUeXBlID0gbWV0YWRhdGFTdG9yZS5fZ2V0U3RydWN0dXJhbFR5cGUoY3AuY29tcGxleFR5cGVOYW1lLCB0cnVlKTtcclxuICBpZiAoIWNvbXBsZXhUeXBlKSByZXR1cm4gZmFsc2U7XHJcbiAgaWYgKCEoY29tcGxleFR5cGUgaW5zdGFuY2VvZiBDb21wbGV4VHlwZSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIENvbXBsZXhUeXBlIHdpdGggdGhlIG5hbWU6IFwiICsgY3AuY29tcGxleFR5cGVOYW1lICsgXCIgZm9yIHRoZSBwcm9wZXJ0eTogXCIgKyBjcC5uYW1lKTtcclxuICB9XHJcbiAgY3AuZGF0YVR5cGUgPSBjb21wbGV4VHlwZTtcclxuICBjcC5kZWZhdWx0VmFsdWUgPSBudWxsO1xyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cnlSZXNvbHZlTnAobnA6IE5hdmlnYXRpb25Qcm9wZXJ0eSwgbWV0YWRhdGFTdG9yZTogTWV0YWRhdGFTdG9yZSkge1xyXG4gIGlmIChucC5lbnRpdHlUeXBlKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgbGV0IGVudGl0eVR5cGUgPSBtZXRhZGF0YVN0b3JlLl9nZXRTdHJ1Y3R1cmFsVHlwZShucC5lbnRpdHlUeXBlTmFtZSwgdHJ1ZSkgYXMgRW50aXR5VHlwZTtcclxuICBpZiAoZW50aXR5VHlwZSkge1xyXG4gICAgbnAuZW50aXR5VHlwZSA9IGVudGl0eVR5cGU7XHJcbiAgICBucC5fcmVzb2x2ZU5wKCk7XHJcbiAgICAvLyBkb24ndCBib3RoZXIgcmVtb3ZpbmcgLSBfdXBkYXRlTnBzIHdpbGwgZG8gaXQgbGF0ZXIuXHJcbiAgICAvLyBfX2FycmF5UmVtb3ZlSXRlbShpbmNvbXBsZXRlTnBzLCBucCwgZmFsc2UpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgaW5jb21wbGV0ZU5wcyA9IGNvcmUuZ2V0QXJyYXkobWV0YWRhdGFTdG9yZS5faW5jb21wbGV0ZVR5cGVNYXAsIG5wLmVudGl0eVR5cGVOYW1lKTtcclxuICAgIGNvcmUuYXJyYXlBZGRJdGVtVW5pcXVlKGluY29tcGxldGVOcHMsIG5wKTtcclxuICB9XHJcbiAgcmV0dXJuICEhZW50aXR5VHlwZTtcclxufVxyXG5cclxuZnVuY3Rpb24gY2FsY1VubWFwcGVkUHJvcGVydGllcyhzdHlwZTogU3RydWN0dXJhbFR5cGUsIGluc3RhbmNlOiBhbnkpIHtcclxuICBsZXQgbWV0YWRhdGFQcm9wTmFtZXMgPSBzdHlwZS5nZXRQcm9wZXJ0eU5hbWVzKCk7XHJcbiAgbGV0IG1vZGVsTGliID0gY29uZmlnLmludGVyZmFjZVJlZ2lzdHJ5Lm1vZGVsTGlicmFyeS5nZXREZWZhdWx0SW5zdGFuY2UoKTtcclxuICBsZXQgdHJhY2thYmxlUHJvcE5hbWVzID0gbW9kZWxMaWIuZ2V0VHJhY2thYmxlUHJvcGVydHlOYW1lcyhpbnN0YW5jZSk7XHJcbiAgdHJhY2thYmxlUHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBuOiBzdHJpbmcpIHtcclxuICAgIGlmIChtZXRhZGF0YVByb3BOYW1lcy5pbmRleE9mKHBuKSA9PT0gLTEpIHtcclxuICAgICAgbGV0IHZhbCA9IGluc3RhbmNlW3BuXTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiKSB2YWwgPSB2YWwoKTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBkdCA9IERhdGFUeXBlLmZyb21WYWx1ZSh2YWwpO1xyXG4gICAgICBsZXQgbmV3UHJvcCA9IG5ldyBEYXRhUHJvcGVydHkoe1xyXG4gICAgICAgIG5hbWU6IHBuLFxyXG4gICAgICAgIGRhdGFUeXBlOiBkdCxcclxuICAgICAgICBpc051bGxhYmxlOiB0cnVlLFxyXG4gICAgICAgIGlzVW5tYXBwZWQ6IHRydWVcclxuICAgICAgfSk7XHJcbiAgICAgIG5ld1Byb3AuaXNTZXR0YWJsZSA9IGNvcmUuaXNTZXR0YWJsZShpbnN0YW5jZSwgcG4pO1xyXG4gICAgICBpZiAoc3R5cGUgaW5zdGFuY2VvZiBFbnRpdHlUeXBlICYmIHN0eXBlLnN1YnR5cGVzICE9IG51bGwgJiYgc3R5cGUuc3VidHlwZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgc3R5cGUuZ2V0U2VsZkFuZFN1YnR5cGVzKCkuZm9yRWFjaCgoc3QpID0+IHtcclxuICAgICAgICAgIHN0Ll9hZGRQcm9wZXJ0eUNvcmUobmV3IERhdGFQcm9wZXJ0eShuZXdQcm9wKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3R5cGUuX2FkZFByb3BlcnR5Q29yZShuZXdQcm9wKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXhUeXBlQ29uZmlnIHtcclxuICBzaG9ydE5hbWU/OiBzdHJpbmc7XHJcbiAgbmFtZXNwYWNlPzogc3RyaW5nO1xyXG4gIGRhdGFQcm9wZXJ0aWVzPzogRGF0YVByb3BlcnR5W10gfCBPYmplY3RbXSB8IE9iamVjdDtcclxuICBpc0NvbXBsZXhUeXBlPzogYm9vbGVhbjsgIC8vIG5lZWRlZCBiZWNhdXNlIHRoaXMgY3RvciBjYW4gZ2V0IGNhbGxlZCBmcm9tIHRoZSBhZGRFbnRpdHlUeXBlIG1ldGhvZCB3aGljaCBuZWVkcyB0aGUgaXNDb21wbGV4VHlwZSBwcm9wXHJcbiAgY3VzdG9tPzogT2JqZWN0O1xyXG59XHJcblxyXG4vKiogIENvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBtZXRhZGF0YSBhYm91dCBhIHNwZWNpZmljIHR5cGUgb2YgQ29tcGxleCBvYmplY3QuXHJcbj4gICAgIGxldCBjb21wbGV4VHlwZSA9IG5ldyBDb21wbGV4VHlwZSgge1xyXG4+ICAgICAgICAgc2hvcnROYW1lOiBcImFkZHJlc3NcIixcclxuPiAgICAgICAgIG5hbWVzcGFjZTogXCJteUFwcE5hbWVzcGFjZVwiXHJcbj4gICAgIH0pO1xyXG5AcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBzZXR0aW5nc1xyXG4qKi9cclxuZXhwb3J0IGNsYXNzIENvbXBsZXhUeXBlIHtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfJHR5cGVOYW1lOiBzdHJpbmc7IC8vIG9uIHByb3RvXHJcbiAgLyoqIEZvciBwb2x5bW9ycGhpYyBwdXJwb3NlIG9ubHkgLSBhbHdheXMgdHJ1ZSBoZXJlICovXHJcbiAgaXNDb21wbGV4VHlwZSA9IHRydWU7XHJcblxyXG4gIC8qKiBUaGUgW1tNZXRhZGF0YVN0b3JlXV0gY29udGFpbmluZyB0aGlzIENvbXBsZXhUeXBlLiAqL1xyXG4gIG1ldGFkYXRhU3RvcmU6IE1ldGFkYXRhU3RvcmU7XHJcblxyXG4gIC8qKiAgVGhlIGZ1bGx5IHF1YWxpZmVkIG5hbWUgb2YgdGhpcyBDb21wbGV4VHlwZS4gX19SZWFkIE9ubHlfXyAgKiovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIC8qKiAgVGhlIHNob3J0LCB1bnF1YWxpZmllZCwgbmFtZSBmb3IgdGhpcyBDb21wbGV4VHlwZS4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBzaG9ydE5hbWU6IHN0cmluZztcclxuXHJcbiAgLyoqIFRoZSBuYW1lc3BhY2UgZm9yIHRoaXMgQ29tcGxleFR5cGUuIF9fUmVhZCBPbmx5X18gKiovXHJcbiAgbmFtZXNwYWNlOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBEYXRhUHJvcGVydGllcyAoc2VlIFtbRGF0YVByb3BlcnR5XV0gYXNzb2NpYXRlZCB3aXRoIHRoaXMgQ29tcGxleFR5cGUuIF9fUmVhZCBPbmx5X18gKi9cclxuICBkYXRhUHJvcGVydGllczogRGF0YVByb3BlcnR5W107XHJcbiAgLyoqIFRoZSBEYXRhUHJvcGVydGllcyBmb3IgdGhpcyBDb21wbGV4VHlwZSB0aGF0IGNvbnRhaW4gaW5zdGFuY2VzIG9mIGEgW1tDb21wbGV4VHlwZV1dLiBfX1JlYWQgT25seV9fICovXHJcbiAgY29tcGxleFByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG5cclxuICAvKipcclxuICBUaGUgZW50aXR5IGxldmVsIHZhbGlkYXRvcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQ29tcGxleFR5cGUuIFZhbGlkYXRvcnMgY2FuIGJlIGFkZGVkIGFuZFxyXG4gIHJlbW92ZWQgZnJvbSB0aGlzIGNvbGxlY3Rpb24uIF9fUmVhZCBPbmx5X18gICoqL1xyXG4gIHZhbGlkYXRvcnM6IFZhbGlkYXRvcltdO1xyXG4gIC8qKiBGb3IgcG9seW1vcnBoaWMgcHVycG9zZSBvbmx5IC0gYWx3YXlzIGVtcHR5IGhlcmUgKi9cclxuICBjb25jdXJyZW5jeVByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG4gIC8qKiBUaGUgRGF0YVByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQ29tcGxleFR5cGUgdGhhdCBhcmUgbm90IG1hcHBlZCB0byBhbnkgYmFja2VuZCBkYXRhc3RvcmUuIFRoZXNlIGFyZSBlZmZlY3RpdmVseSBmcmVlIHN0YW5kaW5nXHJcbiAgcHJvcGVydGllcy4gX19SZWFkIE9ubHlfXyAgICoqL1xyXG4gIHVubWFwcGVkUHJvcGVydGllczogRGF0YVByb3BlcnR5W107XHJcblxyXG4gIC8vIGtleVByb3BlcnRpZXMgYW5kIG5hdmlnYXRpb25Qcm9wZXJ0aWVzIGFyZSBub3QgdXNlZCBvbiBjb21wbGV4VHlwZXMgLSBidXQgaGVyZSB0byBhbGxvdyBzaGFyaW5nIG9mIGNvZGUgYmV0d2VlbiBFbnRpdHlUeXBlIGFuZCBDb21wbGV4VHlwZS5cclxuICBuYXZpZ2F0aW9uUHJvcGVydGllczogRGF0YVByb3BlcnR5W107XHJcbiAgLy8gYW5kIG1heSBiZSB1c2VkIGxhdGVyIHRvIGVuZm9yY2UgdW5pcXVlbmVzcyBvbiBhcnJheXMgb2YgY29tcGxleHR5cGVzLlxyXG4gIGtleVByb3BlcnRpZXM6IERhdGFQcm9wZXJ0eVtdO1xyXG4gIHdhcm5pbmdzOiBhbnlbXTtcclxuICBzZXJpYWxpemVyRm4/OiAocHJvcDogRW50aXR5UHJvcGVydHksIHZhbDogYW55KSA9PiBhbnk7XHJcblxyXG4gIC8qKiBBIGZyZWUgZm9ybSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgYW55IGN1c3RvbSBtZXRhZGF0YSBmb3IgdGhpcyBDb21wbGV4VHlwZS4gKioqL1xyXG4gIGN1c3RvbT86IGFueTtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfbWFwcGVkUHJvcGVydGllc0NvdW50OiBudW1iZXI7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2V4dHJhPzogYW55O1xyXG5cclxuICAvLyBjb3B5IGVudGl0eVR5cGUgbWV0aG9kcyBvbnRvIGNvbXBsZXhUeXBlXHJcbiAgLyoqIFNlZSBbW0VudGl0eVR5cGUuZ2V0Q3Rvcl1dICovXHJcbiAgZ2V0Q3RvciA9IEVudGl0eVR5cGUucHJvdG90eXBlLmdldEN0b3I7XHJcbiAgLy8gbm90ZSB0aGUgbmFtZSBjaGFuZ2UuXHJcbiAgY3JlYXRlSW5zdGFuY2UgPSBFbnRpdHlUeXBlLnByb3RvdHlwZS5jcmVhdGVFbnRpdHk7XHJcbiAgLyoqIFNlZSBbRW50aXR5VHlwZS5hZGRWYWxpZGF0b3JdICovXHJcbiAgYWRkVmFsaWRhdG9yID0gRW50aXR5VHlwZS5wcm90b3R5cGUuYWRkVmFsaWRhdG9yO1xyXG4gIGdldFByb3BlcnR5ID0gRW50aXR5VHlwZS5wcm90b3R5cGUuZ2V0UHJvcGVydHk7XHJcbiAgZ2V0UHJvcGVydGllc09uUGF0aCA9IEVudGl0eVR5cGUucHJvdG90eXBlLmdldFByb3BlcnRpZXNPblBhdGg7XHJcbiAgZ2V0UHJvcGVydHlOYW1lcyA9IEVudGl0eVR5cGUucHJvdG90eXBlLmdldFByb3BlcnR5TmFtZXM7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2FkZFByb3BlcnR5Q29yZSA9IEVudGl0eVR5cGUucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUNvcmU7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX2FkZERhdGFQcm9wZXJ0eSA9IEVudGl0eVR5cGUucHJvdG90eXBlLl9hZGREYXRhUHJvcGVydHk7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX3VwZGF0ZU5hbWVzID0gRW50aXR5VHlwZS5wcm90b3R5cGUuX3VwZGF0ZU5hbWVzO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF91cGRhdGVDcHMgPSBFbnRpdHlUeXBlLnByb3RvdHlwZS5fdXBkYXRlQ3BzO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9pbml0aWFsaXplSW5zdGFuY2UgPSBFbnRpdHlUeXBlLnByb3RvdHlwZS5faW5pdGlhbGl6ZUluc3RhbmNlO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF91cGRhdGVUYXJnZXRGcm9tUmF3ID0gRW50aXR5VHlwZS5wcm90b3R5cGUuX3VwZGF0ZVRhcmdldEZyb21SYXc7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX3NldEN0b3IgPSBFbnRpdHlUeXBlLnByb3RvdHlwZS5fc2V0Q3RvcjtcclxuXHJcbiAgY29uc3RydWN0b3IoY29uZmlnOiBDb21wbGV4VHlwZUNvbmZpZykge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBDb21wbGV4VHlwZSBjdG9yIGhhcyBhIHNpbmdsZSBhcmd1bWVudCB0aGF0IGlzIGEgY29uZmlndXJhdGlvbiBvYmplY3QuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzc2VydENvbmZpZyhjb25maWcpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwic2hvcnROYW1lXCIpLmlzTm9uRW1wdHlTdHJpbmcoKVxyXG4gICAgICAud2hlcmVQYXJhbShcIm5hbWVzcGFjZVwiKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChcIlwiKVxyXG4gICAgICAud2hlcmVQYXJhbShcImRhdGFQcm9wZXJ0aWVzXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImlzQ29tcGxleFR5cGVcIikuaXNPcHRpb25hbCgpLmlzQm9vbGVhbigpICAgLy8gbmVlZGVkIGJlY2F1c2UgdGhpcyBjdG9yIGNhbiBnZXQgY2FsbGVkIGZyb20gdGhlIGFkZEVudGl0eVR5cGUgbWV0aG9kIHdoaWNoIG5lZWRzIHRoZSBpc0NvbXBsZXhUeXBlIHByb3BcclxuICAgICAgLndoZXJlUGFyYW0oXCJjdXN0b21cIikuaXNPcHRpb25hbCgpXHJcbiAgICAgIC5hcHBseUFsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLm5hbWUgPSBxdWFsaWZ5VHlwZU5hbWUodGhpcy5zaG9ydE5hbWUsIHRoaXMubmFtZXNwYWNlKTtcclxuICAgIHRoaXMuaXNDb21wbGV4VHlwZSA9IHRydWU7XHJcbiAgICB0aGlzLmRhdGFQcm9wZXJ0aWVzID0gW107XHJcbiAgICB0aGlzLmNvbXBsZXhQcm9wZXJ0aWVzID0gW107XHJcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSBbXTtcclxuICAgIHRoaXMuY29uY3VycmVuY3lQcm9wZXJ0aWVzID0gW107XHJcbiAgICB0aGlzLnVubWFwcGVkUHJvcGVydGllcyA9IFtdO1xyXG4gICAgdGhpcy5fbWFwcGVkUHJvcGVydGllc0NvdW50ID0gMDtcclxuICAgIC8vIGtleVByb3BlcnRpZXMgYW5kIG5hdmlnYXRpb25Qcm9wZXJ0aWVzIGFyZSBub3QgdXNlZCBvbiBjb21wbGV4VHlwZXMgLSBidXQgaGVyZSB0byBhbGxvdyBzaGFyaW5nIG9mIGNvZGUgYmV0d2VlbiBFbnRpdHlUeXBlIGFuZCBDb21wbGV4VHlwZS5cclxuICAgIHRoaXMubmF2aWdhdGlvblByb3BlcnRpZXMgPSBbXTtcclxuICAgIHRoaXMua2V5UHJvcGVydGllcyA9IFtdOyAvLyBtYXkgYmUgdXNlZCBsYXRlciB0byBlbmZvcmNlIHVuaXF1ZW5lc3Mgb24gYXJyYXlzIG9mIGNvbXBsZXh0eXBlcy5cclxuICAgIGlmIChjb25maWcuZGF0YVByb3BlcnRpZXMpIHtcclxuICAgICAgYWRkUHJvcGVydGllcyh0aGlzLCBjb25maWcuZGF0YVByb3BlcnRpZXMsIERhdGFQcm9wZXJ0eSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBHZW5lcmFsIHB1cnBvc2UgcHJvcGVydHkgc2V0IG1ldGhvZFxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXJcclxuICA+ICAgICAgbGV0IGFkZHJlc3N0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJBZGRyZXNzXCIpO1xyXG4gID4gICAgICBhZGRyZXNzVHlwZS5zZXRQcm9wZXJ0aWVzKCB7XHJcbiAgPiAgICAgICAgICBjdXN0b206IHsgZm9vOiA3LCBiYXI6IFwidGVzdFwiIH1cclxuICA+ICAgICAgfSk7XHJcbiAgQHBhcmFtIGNvbmZpZyAtIEN1c3RvbSBjb25maWcgb2JqZWN0XHJcbiAgQHBhcmFtIGNvbmZpZy5jdXN0b20gLSB7T2JqZWN0fVxyXG4gICoqL1xyXG4gIHNldFByb3BlcnRpZXMoY29uZmlnOiB7IGN1c3RvbT86IE9iamVjdCB9KSB7XHJcbiAgICBhc3NlcnRDb25maWcoY29uZmlnKVxyXG4gICAgICAud2hlcmVQYXJhbShcImN1c3RvbVwiKS5pc09wdGlvbmFsKClcclxuICAgICAgLmFwcGx5QWxsKHRoaXMpO1xyXG4gIH1cclxuXHJcblxyXG4gIGdldEFsbFZhbGlkYXRvcnMoKSB7XHJcbiAgICAvLyBDb21wbGV4VHlwZSBpbmhlcml0YW5jZSBpcyBub3QgWUVUIHN1cHBvcnRlZC5cclxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcnM7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfY3JlYXRlSW5zdGFuY2VDb3JlKHBhcmVudDogU3RydWN0dXJhbE9iamVjdCwgcGFyZW50UHJvcGVydHk6IERhdGFQcm9wZXJ0eSkge1xyXG4gICAgbGV0IGFDdG9yID0gdGhpcy5nZXRDdG9yKCk7XHJcbiAgICBsZXQgaW5zdGFuY2UgPSBuZXcgYUN0b3IoKSBhcyBDb21wbGV4T2JqZWN0O1xyXG4gICAgbmV3IENvbXBsZXhBc3BlY3QoaW5zdGFuY2UsIHBhcmVudCwgcGFyZW50UHJvcGVydHkpO1xyXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gb2NjdXJzIGR1cmluZyBlaXRoZXIgYXR0YWNoIG9yIGluIGNyZWF0ZUluc3RhbmNlIGNhbGwuXHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuXHJcbiAgYWRkUHJvcGVydHkoZGF0YVByb3BlcnR5OiBEYXRhUHJvcGVydHkpIHtcclxuICAgIGFzc2VydFBhcmFtKGRhdGFQcm9wZXJ0eSwgXCJkYXRhUHJvcGVydHlcIikuaXNJbnN0YW5jZU9mKERhdGFQcm9wZXJ0eSkuY2hlY2soKTtcclxuICAgIHJldHVybiB0aGlzLl9hZGRQcm9wZXJ0eUNvcmUoZGF0YVByb3BlcnR5KTtcclxuICB9XHJcblxyXG4gIGdldFByb3BlcnRpZXMoKTogRW50aXR5UHJvcGVydHlbXSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhUHJvcGVydGllcztcclxuICB9XHJcblxyXG4gIHRvSlNPTigpIHtcclxuICAgIHJldHVybiBjb3JlLnRvSnNvbih0aGlzLCB7XHJcbiAgICAgIHNob3J0TmFtZTogbnVsbCxcclxuICAgICAgbmFtZXNwYWNlOiBudWxsLFxyXG4gICAgICBpc0NvbXBsZXhUeXBlOiBudWxsLFxyXG4gICAgICBkYXRhUHJvcGVydGllczogbnVsbCxcclxuICAgICAgdmFsaWRhdG9yczogbnVsbCxcclxuICAgICAgY3VzdG9tOiBudWxsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG59XHJcbkNvbXBsZXhUeXBlLnByb3RvdHlwZS5fJHR5cGVOYW1lID0gXCJDb21wbGV4VHlwZVwiO1xyXG4vKiogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNvbXBsZXhUeXBlICovXHJcbkNvbXBsZXhUeXBlLnByb3RvdHlwZS5jcmVhdGVJbnN0YW5jZSA9IEVudGl0eVR5cGUucHJvdG90eXBlLmNyZWF0ZUVudGl0eTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVByb3BlcnR5Q29uZmlnIHtcclxuICBuYW1lPzogc3RyaW5nO1xyXG4gIG5hbWVPblNlcnZlcj86IHN0cmluZztcclxuICBkYXRhVHlwZT86IERhdGFUeXBlIHwgc3RyaW5nIHwgQ29tcGxleFR5cGU7XHJcbiAgY29tcGxleFR5cGVOYW1lPzogc3RyaW5nO1xyXG4gIGlzTnVsbGFibGU/OiBib29sZWFuO1xyXG4gIGlzU2NhbGFyPzogYm9vbGVhbjsgLy8gd2lsbCBiZSBmYWxzZSBmb3Igc29tZSBOb1NRTCBkYXRhYmFzZXMuXHJcbiAgZGVmYXVsdFZhbHVlPzogYW55O1xyXG4gIGlzUGFydE9mS2V5PzogYm9vbGVhbjtcclxuICBpc1VubWFwcGVkPzogYm9vbGVhbjtcclxuICBpc1NldHRhYmxlPzogYm9vbGVhbjtcclxuICBjb25jdXJyZW5jeU1vZGU/OiBzdHJpbmc7XHJcbiAgbWF4TGVuZ3RoPzogbnVtYmVyO1xyXG4gIHZhbGlkYXRvcnM/OiBWYWxpZGF0b3JbXTtcclxuICBkaXNwbGF5TmFtZT86IHN0cmluZztcclxuICBlbnVtVHlwZT86IGFueTtcclxuICByYXdUeXBlTmFtZT86IHN0cmluZzsgIC8vIG9jY3VycyB3aXRoIHVuZGVmaW5lZCBkYXRhdHlwZXNcclxuICBjdXN0b20/OiBPYmplY3Q7XHJcbn1cclxuXHJcbi8qKlxyXG5BIERhdGFQcm9wZXJ0eSBkZXNjcmliZXMgdGhlIG1ldGFkYXRhIGZvciBhIHNpbmdsZSBwcm9wZXJ0eSBvZiBhbiAgW1tFbnRpdHlUeXBlXV0gdGhhdCBjb250YWlucyBzaW1wbGUgZGF0YS5cclxuXHJcbkluc3RhbmNlcyBvZiB0aGUgRGF0YVByb3BlcnR5IGNsYXNzIGFyZSBjb25zdHJ1Y3RlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyBNZXRhZGF0YSByZXRyaWV2YWwuIEhvd2V2ZXIgaXQgaXMgYWxzbyBwb3NzaWJsZSB0byBjb25zdHJ1Y3QgdGhlbVxyXG5kaXJlY3RseSB2aWEgdGhlIGNvbnN0cnVjdG9yLlxyXG4qKi9cclxuZXhwb3J0IGNsYXNzIERhdGFQcm9wZXJ0eSB7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgXyR0eXBlTmFtZTogc3RyaW5nOyAvLyBvbiBwcm90b1xyXG4gIC8qKiBJcyB0aGlzIGEgRGF0YVByb3BlcnR5PyAtIGFsd2F5cyB0cnVlIGhlcmUuIEFsbG93cyBwb2x5bW9ycGhpYyB0cmVhdG1lbnQgb2YgRGF0YVByb3BlcnRpZXMgYW5kIE5hdmlnYXRpb25Qcm9wZXJ0aWVzLiBfX1JlYWQgT25seV9fICovXHJcbiAgaXNEYXRhUHJvcGVydHkgPSB0cnVlO1xyXG4gIC8qKiBJcyB0aGlzIGEgTmF2aWdhdGlvblByb3BlcnR5PyAtIGFsd2F5cyBmYWxzZSBoZXJlLiAgQWxsb3dzIHBvbHltb3JwaGljIHRyZWF0bWVudCBvZiBEYXRhUHJvcGVydGllcyBhbmQgTmF2aWdhdGlvblByb3BlcnRpZXMuIF9fUmVhZCBPbmx5X18gKi9cclxuICBpc05hdmlnYXRpb25Qcm9wZXJ0eSA9IGZhbHNlO1xyXG4gIC8qKiBUaGUgbmFtZSBvZiB0aGlzIHByb3BlcnR5LiBfX1JlYWQgT25seV9fICAqKi9cclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgcHJvcGVydHkgb24gdGhlIHNlcnZlci4gX19SZWFkIE9ubHlfXyAqKi9cclxuICBuYW1lT25TZXJ2ZXI6IHN0cmluZztcclxuICAvKiogVGhlIFtbRGF0YVR5cGVdXSBvZiB0aGlzIHByb3BlcnR5LiBfX1JlYWQgT25seV9fICovXHJcbiAgZGF0YVR5cGU6IERhdGFUeXBlIHwgQ29tcGxleFR5cGU7IC8vIHRoaXMgd2lsbCBiZSBhIGNvbXBsZXhUeXBlIHdoZW4gZHAgaXMgYSBjb21wbGV4UHJvcGVydHlcclxuICAvKiogVGhlIG5hbWUgb2YgdGhlIFtbQ29tcGxleFR5cGVdXSBhc3NvY2lhdGVkIHdpdGggdGhpcyBwcm9wZXJ0eTsgbWF5IGJlIG51bGwuIF9fUmVhZCBPbmx5X18gKi9cclxuICBjb21wbGV4VHlwZU5hbWU6IHN0cmluZztcclxuICAvKiogVGhlIFtbQ29tcGxleFR5cGVdXSBhc3NvY2lhdGVkIHdpdGggdGhpcyBwcm9wZXJ0eTsgbWF5IGJlIHVuZGVmaW5lZC4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGNvbXBsZXhUeXBlPzogQ29tcGxleFR5cGU7XHJcbiAgLyoqICBXaGV0aGVyIHRoZSBjb250ZW50cyBvZiB0aGlzIHByb3BlcnR5IGlzIGFuIGluc3RhbmNlIG9mIGEgW1tDb21wbGV4VHlwZV1dLiBfX1JlYWQgT25seV9fICovXHJcbiAgaXNDb21wbGV4UHJvcGVydHk6IGJvb2xlYW47XHJcbiAgLyoqIFdoZXRoZXIgdGhpcyBwcm9wZXJ0eSBpcyBudWxsYWJsZS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGlzTnVsbGFibGU6IGJvb2xlYW47XHJcbiAgLyoqICBXaGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgc2NhbGFyIChpLmUuLCByZXR1cm5zIGEgc2luZ2xlIHZhbHVlIGFzIG9wcG9zZWQgdG8gYW4gYXJyYXkpLiBfX1JlYWQgT25seV9fICovXHJcbiAgaXNTY2FsYXI6IGJvb2xlYW47IC8vIHdpbGwgYmUgZmFsc2UgZm9yIHNvbWUgTm9TUUwgZGF0YWJhc2VzLlxyXG4gIC8qKiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBwcm9wZXJ0eS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGRlZmF1bHRWYWx1ZTogYW55O1xyXG4gIC8qKiAgV2hldGhlciB0aGlzIHByb3BlcnR5IGlzIGEgJ2tleScgcHJvcGVydHkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBpc1BhcnRPZktleTogYm9vbGVhbjtcclxuICAvKiogV2hldGhlciB0aGlzIHByb3BlcnR5IGlzIGFuICd1bm1hcHBlZCcgcHJvcGVydHkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBpc1VubWFwcGVkOiBib29sZWFuO1xyXG4gIC8qKiBXaGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgJ3NldHRhYmxlJy4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGlzU2V0dGFibGU6IGJvb2xlYW47XHJcbiAgLy8gVE9ETzogZG9jIHRoaXNcclxuICBjb25jdXJyZW5jeU1vZGU6IHN0cmluZztcclxuICAvKiogIFRoZSBtYXhpbXVtIGxlbmd0aCBmb3IgdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkuIE9ubHkgbWVhbmluZ2Z1bCBmb3Igc3RyaW5ncy4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIG1heExlbmd0aD86IG51bWJlcjtcclxuICAvKiogVGhlIFtbVmFsaWRhdG9yXV0gaW5zdGFuY2VzIHRoYXQgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHByb3BlcnR5LiBWYWxpZGF0b3JzIGNhbiBiZSBhZGRlZCBhbmRcclxuICByZW1vdmVkIGZyb20gdGhpcyBjb2xsZWN0aW9uLiBfX1JlYWQgT25seV9fICovXHJcbiAgdmFsaWRhdG9yczogVmFsaWRhdG9yW107XHJcbiAgLyoqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhpcyBwcm9wZXJ0eS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGRpc3BsYXlOYW1lOiBzdHJpbmc7XHJcbiAgLy8gVE9ETzogZG9jIHRoaXNcclxuICBlbnVtVHlwZT86IGFueTtcclxuICAvKiogVGhlIHJhdyB0eXBlIG5hbWUgb2YgdGhpcyBwcm9wZXJ0eS4gd2lsbCBvbmx5IGJlIGRlZmluZWQgZm9yIHByb3BlcnRpZXMgd2l0aCBhIERhdGFUeXBlIG9mICdVbmRlZmluZWQnICovXHJcbiAgcmF3VHlwZU5hbWU/OiBzdHJpbmc7ICAvLyBvY2N1cnMgd2l0aCB1bmRlZmluZWQgZGF0YXR5cGVzXHJcbiAgLyoqICBBIGZyZWUgZm9ybSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBkZWZpbmUgYW55IGN1c3RvbSBtZXRhZGF0YSBmb3IgdGhpcyBEYXRhUHJvcGVydHkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBjdXN0b20/OiBPYmplY3Q7XHJcbiAgLy8gVE9ETzogZG9jIHRoaXNcclxuICBpbnZlcnNlTmF2aWdhdGlvblByb3BlcnR5PzogTmF2aWdhdGlvblByb3BlcnR5O1xyXG4gIC8qKlxyXG4gIFRoZSBuYXZpZ2F0aW9uIHByb3BlcnR5IHJlbGF0ZWQgdG8gdGhpcyBwcm9wZXJ0eS4gIFdpbGwgb25seSBiZSBzZXQgaWYgdGhpcyBpcyBhIGZvcmVpZ24ga2V5IHByb3BlcnR5LiBfX1JlYWQgT25seV9fICovXHJcbiAgcmVsYXRlZE5hdmlnYXRpb25Qcm9wZXJ0eT86IE5hdmlnYXRpb25Qcm9wZXJ0eTtcclxuICAvKiogVGhlIHBhcmVudCB0eXBlIHRoYXQgdGhpcyBwcm9wZXJ0eSBiZWxvbmdzIHRvIC0gd2lsbCBiZSBlaXRoZXIgYSBbW0VudGl0eVR5cGVdXSBvciBhIFtbQ29tcGxleFR5cGVdXS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIHBhcmVudFR5cGU6IFN0cnVjdHVyYWxUeXBlO1xyXG4gIC8qKiBQcm9wZXJ0eSBvbiB0aGUgYmFzZSB0eXBlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBpbmhlcml0ZWQgZnJvbS4gV2lsbCBiZSBudWxsIGlmIHRoZSBwcm9wZXJ0eSBpcyBub3Qgb24gdGhlIGJhc2UgdHlwZS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGJhc2VQcm9wZXJ0eT86IERhdGFQcm9wZXJ0eTtcclxuXHJcbiAgLyoqIERhdGFQcm9wZXJ0eSBjb25zdHJ1Y3RvclxyXG4gID4gICAgICBsZXQgbGFzdE5hbWVQcm9wID0gbmV3IERhdGFQcm9wZXJ0eSgge1xyXG4gID4gICAgICAgICAgbmFtZTogXCJsYXN0TmFtZVwiLFxyXG4gID4gICAgICAgICAgZGF0YVR5cGU6IERhdGFUeXBlLlN0cmluZyxcclxuICA+ICAgICAgICAgIGlzTnVsbGFibGU6IHRydWUsXHJcbiAgPiAgICAgICAgICBtYXhMZW5ndGg6IDIwXHJcbiAgPiAgICAgIH0pO1xyXG4gID4gICAgICAvLyBhc3N1bWluZyBwZXJzb25FbnRpdHlUeXBlIGlzIGEgbmV3bHkgY29uc3RydWN0ZWQgRW50aXR5VHlwZVxyXG4gID4gICAgICBwZXJzb25FbnRpdHlUeXBlLmFkZFByb3BlcnR5KGxhc3ROYW1lUHJvcGVydHkpO1xyXG4gIEBwYXJhbSBjb25maWcgLSBBIGNvbmZpZ3VyYXRpb24gT2JqZWN0IG9yIGEgRGF0YVByb3BlcnR5XHJcbiAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb25maWc6IERhdGFQcm9wZXJ0eUNvbmZpZyB8IERhdGFQcm9wZXJ0eSkge1xyXG4gICAgYXNzZXJ0Q29uZmlnKGNvbmZpZylcclxuICAgICAgLndoZXJlUGFyYW0oXCJuYW1lXCIpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwibmFtZU9uU2VydmVyXCIpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZGF0YVR5cGVcIikuaXNFbnVtT2YoRGF0YVR5cGUpLmlzT3B0aW9uYWwoKS5vcigpLmlzU3RyaW5nKCkub3IoKS5pc0luc3RhbmNlT2YoQ29tcGxleFR5cGUpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiY29tcGxleFR5cGVOYW1lXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImlzTnVsbGFibGVcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KHRydWUpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiaXNTY2FsYXJcIikuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KHRydWUpLy8gd2lsbCBiZSBmYWxzZSBmb3Igc29tZSBOb1NRTCBkYXRhYmFzZXMuXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZGVmYXVsdFZhbHVlXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImlzUGFydE9mS2V5XCIpLmlzQm9vbGVhbigpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImlzVW5tYXBwZWRcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiaXNTZXR0YWJsZVwiKS5pc0Jvb2xlYW4oKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQodHJ1ZSlcclxuICAgICAgLndoZXJlUGFyYW0oXCJjb25jdXJyZW5jeU1vZGVcIikuaXNTdHJpbmcoKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJtYXhMZW5ndGhcIikuaXNOdW1iZXIoKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJ2YWxpZGF0b3JzXCIpLmlzSW5zdGFuY2VPZihWYWxpZGF0b3IpLmlzQXJyYXkoKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQoW10pXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZGlzcGxheU5hbWVcIikuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZW51bVR5cGVcIikuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwicmF3VHlwZU5hbWVcIikuaXNPcHRpb25hbCgpIC8vIG9jY3VycyB3aXRoIHVuZGVmaW5lZCBkYXRhdHlwZXNcclxuICAgICAgLndoZXJlUGFyYW0oXCJjdXN0b21cIikuaXNPcHRpb25hbCgpXHJcbiAgICAgIC5hcHBseUFsbCh0aGlzKTtcclxuICAgIGxldCBoYXNOYW1lID0gISEodGhpcy5uYW1lIHx8IHRoaXMubmFtZU9uU2VydmVyKTtcclxuICAgIGlmICghaGFzTmFtZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIERhdGFQcm9wZXJ0eSBtdXN0IGJlIGluc3RhbnRpYXRlZCB3aXRoIGVpdGhlciBhICduYW1lJyBvciBhICduYW1lT25TZXJ2ZXInIHByb3BlcnR5XCIpO1xyXG4gICAgfVxyXG4gICAgLy8gbmFtZS9uYW1lT25TZXJ2ZXIgaXMgcmVzb2x2ZWQgbGF0ZXIgd2hlbiBhIG1ldGFkYXRhU3RvcmUgaXMgYXZhaWxhYmxlLlxyXG5cclxuICAgIGlmICh0aGlzLmNvbXBsZXhUeXBlTmFtZSkge1xyXG4gICAgICB0aGlzLmlzQ29tcGxleFByb3BlcnR5ID0gdHJ1ZTtcclxuICAgICAgLy8gdGhpcy5kYXRhVHlwZSA9IG51bGw7IC8vIFRPRE86IHdvdWxkIGxpa2UgdG8gcmVtb3ZlIHRoaXMgbGluZSBiZWNhdXNlIGRhdGFUeXBlIHdpbGwgYmUgc2V0IGxhdGVyLlxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKHRoaXMuZGF0YVR5cGUpID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIGxldCBkdCA9IERhdGFUeXBlLmZyb21OYW1lKHRoaXMuZGF0YVR5cGUpO1xyXG4gICAgICBpZiAoIWR0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgYSBEYXRhVHlwZSBlbnVtZXJhdGlvbiBieSB0aGUgbmFtZSBvZjogXCIgKyB0aGlzLmRhdGFUeXBlKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmRhdGFUeXBlID0gZHQ7XHJcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmRhdGFUeXBlKSB7XHJcbiAgICAgIHRoaXMuZGF0YVR5cGUgPSBEYXRhVHlwZS5TdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT0gYXMgb3Bwb3NlZCB0byA9PT0gaXMgZGVsaWJlcmF0ZSBoZXJlLlxyXG4gICAgaWYgKHRoaXMuZGVmYXVsdFZhbHVlID09IG51bGwpIHtcclxuICAgICAgaWYgKHRoaXMuaXNOdWxsYWJsZSkge1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXhQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgLy8gd2hhdCB0byBkbz8gLSBzaG91bGRuJ3QgaGFwcGVuIGZyb20gRUYgLSBidXQgb3RoZXJ3aXNlID8/P1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuQmluYXJ5KSB7XHJcbiAgICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IFwiQUFBQUFBQUFKM1U9XCI7IC8vIGhhY2sgZm9yIGFsbCBiaW5hcnkgZmllbGRzIGJ1dCB2YWx1ZSBpcyBzcGVjaWZpY2FsbHkgdmFsaWQgZm9yIHRpbWVzdGFtcCBmaWVsZHMgLSBhcmJpdHJhcnkgdmFsaWQgOCBieXRlIGJhc2U2NCB2YWx1ZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSAodGhpcy5kYXRhVHlwZSBhcyBhbnkpLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgbm9ubnVsbGFibGUgRGF0YVByb3BlcnR5IGNhbm5vdCBoYXZlIGEgbnVsbCBkZWZhdWx0VmFsdWUuIE5hbWU6IFwiICsgKHRoaXMubmFtZSB8fCB0aGlzLm5hbWVPblNlcnZlcikpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICgodGhpcy5kYXRhVHlwZSBhcyBhbnkpLmlzTnVtZXJpYykge1xyXG4gICAgICAvLyBpbiBjYXNlIHRoZSBkZWZhdWx0VmFsdWUgY29tZXMgaW4gYXMgYSBzdHJpbmcgKCB3aGljaCBpdCBkb2VzIGluIEVGNikuXHJcbiAgICAgIGlmICh0eXBlb2YgKHRoaXMuZGVmYXVsdFZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLmRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc0NvbXBsZXhQcm9wZXJ0eSkge1xyXG4gICAgICB0aGlzLmlzU2NhbGFyID0gdGhpcy5pc1NjYWxhciA9PSBudWxsIHx8IHRoaXMuaXNTY2FsYXIgPT09IHRydWU7XHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGdldFJhd1ZhbHVlRnJvbVNlcnZlcihyYXdFbnRpdHk6IE9iamVjdCwgZHA6IERhdGFQcm9wZXJ0eSkge1xyXG4gICAgaWYgKGRwLmlzVW5tYXBwZWQpIHtcclxuICAgICAgcmV0dXJuIHJhd0VudGl0eVtkcC5uYW1lT25TZXJ2ZXIgfHwgZHAubmFtZV07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgdmFsID0gcmF3RW50aXR5W2RwLm5hbWVPblNlcnZlcl07XHJcbiAgICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IGRwLmRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBnZXRSYXdWYWx1ZUZyb21DbGllbnQocmF3RW50aXR5OiBPYmplY3QsIGRwOiBEYXRhUHJvcGVydHkpIHtcclxuICAgIGxldCB2YWwgPSByYXdFbnRpdHlbZHAubmFtZV07XHJcbiAgICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgPyB2YWwgOiBkcC5kZWZhdWx0VmFsdWU7XHJcbiAgfVxyXG5cclxuICByZXNvbHZlUHJvcGVydHkocHJvcE5hbWU6IHN0cmluZykge1xyXG4gICAgbGV0IHJlc3VsdCA9IHRoaXNbcHJvcE5hbWVdO1xyXG4gICAgbGV0IGJhc2VQcm9wID0gdGhpcy5iYXNlUHJvcGVydHk7XHJcbiAgICB3aGlsZSAocmVzdWx0ID09IHVuZGVmaW5lZCAmJiBiYXNlUHJvcCAhPSBudWxsKSB7XHJcbiAgICAgIHJlc3VsdCA9IGJhc2VQcm9wW3Byb3BOYW1lXTtcclxuICAgICAgYmFzZVByb3AgPSBiYXNlUHJvcC5iYXNlUHJvcGVydHk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgZm9ybWF0TmFtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnBhcmVudFR5cGUubmFtZSArIFwiLS1cIiArIHRoaXMubmFtZTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICBHZW5lcmFsIHB1cnBvc2UgcHJvcGVydHkgc2V0IG1ldGhvZFxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXJcclxuICA+ICAgICAgbGV0IHByb3AgPSBteUVudGl0eVR5cGUuZ2V0UHJvcGVydHkoXCJteVByb3BlcnR5XCIpO1xyXG4gID4gICAgICBwcm9wLnNldFByb3BlcnRpZXMoIHtcclxuICA+ICAgICAgICAgIGN1c3RvbTogeyBmb286IDcsIGJhcjogXCJ0ZXN0XCIgfVxyXG4gID4gICAgICB9KTtcclxuICBAcGFyYW0gY29uZmlnIC0gQSBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICAqKi9cclxuICBzZXRQcm9wZXJ0aWVzKGNvbmZpZzogeyBkaXNwbGF5TmFtZT86IHN0cmluZywgY3VzdG9tPzogT2JqZWN0IH0pIHtcclxuICAgIGFzc2VydENvbmZpZyhjb25maWcpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZGlzcGxheU5hbWVcIikuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiY3VzdG9tXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAuYXBwbHlBbGwodGhpcyk7XHJcbiAgfVxyXG5cclxuICBnZXRBbGxWYWxpZGF0b3JzKCkge1xyXG4gICAgbGV0IHZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuc2xpY2UoMCk7XHJcbiAgICBsZXQgYmFzZVByb3AgPSB0aGlzLmJhc2VQcm9wZXJ0eTtcclxuICAgIHdoaWxlIChiYXNlUHJvcCkge1xyXG4gICAgICB2YWxpZGF0b3JzLnB1c2guYXBwbHkodmFsaWRhdG9ycywgYmFzZVByb3AudmFsaWRhdG9ycyk7XHJcbiAgICAgIGJhc2VQcm9wID0gYmFzZVByb3AuYmFzZVByb3BlcnR5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbGlkYXRvcnM7XHJcbiAgfVxyXG5cclxuICB0b0pTT04oKSB7XHJcbiAgICAvLyBkbyBub3Qgc2VyaWFsaXplIGRhdGFUeXBlcyB0aGF0IGFyZSBjb21wbGV4VHlwZXNcclxuICAgIHJldHVybiBjb3JlLnRvSnNvbih0aGlzLCB7XHJcbiAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgIGRhdGFUeXBlOiBmdW5jdGlvbiAodjogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuICh2ICYmIHYgaW5zdGFuY2VvZiBEYXRhVHlwZSkgPyB2Lm5hbWUgOiB1bmRlZmluZWQ7XHJcbiAgICAgIH0sIC8vIGRvIG5vdCBzZXJpYWxpemUgZGF0YVR5cGVzIHRoYXQgYXJlIGNvbXBsZXhUeXBlc1xyXG4gICAgICBjb21wbGV4VHlwZU5hbWU6IG51bGwsXHJcbiAgICAgIGlzTnVsbGFibGU6IHRydWUsXHJcbiAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCxcclxuICAgICAgaXNQYXJ0T2ZLZXk6IGZhbHNlLFxyXG4gICAgICBpc1VubWFwcGVkOiBmYWxzZSxcclxuICAgICAgaXNTZXR0YWJsZTogdHJ1ZSxcclxuICAgICAgY29uY3VycmVuY3lNb2RlOiBudWxsLFxyXG4gICAgICBtYXhMZW5ndGg6IG51bGwsXHJcbiAgICAgIHZhbGlkYXRvcnM6IG51bGwsXHJcbiAgICAgIGRpc3BsYXlOYW1lOiBudWxsLFxyXG4gICAgICBlbnVtVHlwZTogbnVsbCxcclxuICAgICAgcmF3VHlwZU5hbWU6IG51bGwsXHJcbiAgICAgIGlzU2NhbGFyOiB0cnVlLFxyXG4gICAgICBjdXN0b206IG51bGxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGZyb21KU09OKGpzb246IGFueSkge1xyXG4gICAganNvbi5kYXRhVHlwZSA9IERhdGFUeXBlLmZyb21OYW1lKGpzb24uZGF0YVR5cGUpO1xyXG4gICAgLy8gUGFyc2UgZGVmYXVsdCB2YWx1ZSBpbnRvIGNvcnJlY3QgZGF0YSB0eXBlLiAoZGF0ZVRpbWUgaW5zdGFuY2VzIHJlcXVpcmUgZXh0cmEgd29yayB0byBkZXNlcmlhbGl6ZSBwcm9wZXJseS4pXHJcbiAgICBpZiAoanNvbi5kZWZhdWx0VmFsdWUgJiYganNvbi5kYXRhVHlwZSAmJiBqc29uLmRhdGFUeXBlLnBhcnNlKSB7XHJcbiAgICAgIGpzb24uZGVmYXVsdFZhbHVlID0ganNvbi5kYXRhVHlwZS5wYXJzZShqc29uLmRlZmF1bHRWYWx1ZSwgdHlwZW9mIGpzb24uZGVmYXVsdFZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoanNvbi52YWxpZGF0b3JzKSB7XHJcbiAgICAgIGpzb24udmFsaWRhdG9ycyA9IGpzb24udmFsaWRhdG9ycy5tYXAoVmFsaWRhdG9yLmZyb21KU09OKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IERhdGFQcm9wZXJ0eShqc29uKTtcclxuICB9XHJcblxyXG59XHJcbkRhdGFQcm9wZXJ0eS5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IFwiRGF0YVByb3BlcnR5XCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRpb25Qcm9wZXJ0eUNvbmZpZyB7XHJcbiAgbmFtZT86IHN0cmluZztcclxuICBuYW1lT25TZXJ2ZXI/OiBzdHJpbmc7XHJcbiAgZW50aXR5VHlwZU5hbWU/OiBzdHJpbmc7XHJcbiAgaXNTY2FsYXI/OiBib29sZWFuO1xyXG4gIGFzc29jaWF0aW9uTmFtZT86IHN0cmluZztcclxuICBmb3JlaWduS2V5TmFtZXM/OiBzdHJpbmdbXTtcclxuICBmb3JlaWduS2V5TmFtZXNPblNlcnZlcj86IHN0cmluZ1tdO1xyXG4gIGludkZvcmVpZ25LZXlOYW1lcz86IHN0cmluZ1tdO1xyXG4gIGludkZvcmVpZ25LZXlOYW1lc09uU2VydmVyPzogc3RyaW5nW107XHJcbiAgdmFsaWRhdG9ycz86IFZhbGlkYXRvcltdO1xyXG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xyXG4gIGN1c3RvbT86IE9iamVjdDtcclxufVxyXG5cclxuLyoqICAgQSBOYXZpZ2F0aW9uUHJvcGVydHkgZGVzY3JpYmVzIHRoZSBtZXRhZGF0YSBmb3IgYSBzaW5nbGUgcHJvcGVydHkgb2YgYW4gW1tFbnRpdHlUeXBlXV0gdGhhdCByZXR1cm4gaW5zdGFuY2VzIG9mIG90aGVyIEVudGl0eVR5cGVzLlxyXG5cclxuSW5zdGFuY2VzIG9mIHRoZSBOYXZpZ2F0aW9uUHJvcGVydHkgY2xhc3MgYXJlIGNvbnN0cnVjdGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIE1ldGFkYXRhIHJldHJpZXZhbC4gICBIb3dldmVyIGl0IGlzIGFsc28gcG9zc2libGUgdG8gY29uc3RydWN0IHRoZW1cclxuZGlyZWN0bHkgdmlhIHRoZSBjb25zdHJ1Y3Rvci5cclxuKiovXHJcbmV4cG9ydCBjbGFzcyBOYXZpZ2F0aW9uUHJvcGVydHkge1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF8kdHlwZU5hbWU6IHN0cmluZztcclxuICAvKiogSXMgdGhpcyBhIERhdGFQcm9wZXJ0eT8gLSBhbHdheXMgZmFsc2UgaGVyZSBcclxuICBBbGxvd3MgcG9seW1vcnBoaWMgdHJlYXRtZW50IG9mIERhdGFQcm9wZXJ0aWVzIGFuZCBOYXZpZ2F0aW9uUHJvcGVydGllcy4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGlzRGF0YVByb3BlcnR5ID0gZmFsc2U7XHJcbiAgLyoqIElzIHRoaXMgYSBOYXZpZ2F0aW9uUHJvcGVydHk/IC0gYWx3YXlzIHRydWUgaGVyZVxyXG4gIEFsbG93cyBwb2x5bW9ycGhpYyB0cmVhdG1lbnQgb2YgRGF0YVByb3BlcnRpZXMgYW5kIE5hdmlnYXRpb25Qcm9wZXJ0aWVzLiBfX1JlYWQgT25seV9fICovXHJcbiAgaXNOYXZpZ2F0aW9uUHJvcGVydHkgPSB0cnVlO1xyXG5cclxuICBmb3JtYXROYW1lID0gRGF0YVByb3BlcnR5LnByb3RvdHlwZS5mb3JtYXROYW1lO1xyXG4gIGdldEFsbFZhbGlkYXRvcnMgPSBEYXRhUHJvcGVydHkucHJvdG90eXBlLmdldEFsbFZhbGlkYXRvcnM7XHJcbiAgcmVzb2x2ZVByb3BlcnR5ID0gRGF0YVByb3BlcnR5LnByb3RvdHlwZS5yZXNvbHZlUHJvcGVydHk7XHJcblxyXG4gIC8qKiBUaGUgW1tFbnRpdHlUeXBlXV0gcmV0dXJuZWQgYnkgdGhpcyBwcm9wZXJ0eS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGVudGl0eVR5cGU6IEVudGl0eVR5cGU7XHJcbiAgLyoqIFRoZSBuYW1lIG9mIHRoZSBbW0VudGl0eVR5cGVdXSByZXR1cm5lZCBieSB0aGlzIHByb3BlcnR5LiBfX1JlYWQgT25seV9fICovXHJcbiAgZW50aXR5VHlwZU5hbWU6IHN0cmluZztcclxuICAvKiogVGhlIFtbRW50aXR5VHlwZV1dIHRoYXQgdGhpcyBwcm9wZXJ0eSBiZWxvbmdzIHRvLiAoIHNhbWUgYXMgZW50aXR5VHlwZSkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBwYXJlbnRUeXBlOiBFbnRpdHlUeXBlOyAvLyA/PyBzYW1lIGFzIGVudGl0eVR5cGVcclxuICAvKiogVGhlIFtbRW50aXR5VHlwZV1dIHRoYXQgdGhpcyBwcm9wZXJ0eSBiZWxvbmdzIHRvLiAoIHNhbWUgYXMgZW50aXR5VHlwZSkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBwYXJlbnRFbnRpdHlUeXBlOiBFbnRpdHlUeXBlOyAvLyA/PyBzYW1lIGFzIGFib3ZlXHJcbiAgLyoqIFByb3BlcnR5IG9uIHRoZSBiYXNlIHR5cGUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIGluaGVyaXRlZCBmcm9tLiBXaWxsIGJlIG51bGwgaWYgdGhlIHByb3BlcnR5IGlzIG5vdCBvbiB0aGUgYmFzZSB0eXBlLiBfX1JlYWQgT25seV9fICovXHJcbiAgYmFzZVByb3BlcnR5PzogTmF2aWdhdGlvblByb3BlcnR5O1xyXG4gIC8qKiBUaGUgaW52ZXJzZSBvZiB0aGlzIE5hdmlnYXRpb25Qcm9wZXJ0eS4gIFRoZSBOYXZpZ2F0aW9uUHJvcGVydHkgdGhhdCByZXByZXNlbnRzIGEgbmF2aWdhdGlvbiBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXHJcbiAgdG8gdGhpcyBOYXZpZ2F0aW9uUHJvcGVydHkuIE1heSBiZSB1bmRlZmluZWQgZm9yIGEgdW5kaXJlY3Rpb25hbCBOYXZpZ2F0aW9uUHJvcGVydHkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBwcml2YXRlIF9pbnZlcnNlPzogTmF2aWdhdGlvblByb3BlcnR5O1xyXG4gIC8qKiBUaGUgbmFtZSBvZiB0aGlzIHByb3BlcnR5LiBfX1JlYWQgT25seV9fICovXHJcbiAgbmFtZTogc3RyaW5nO1xyXG4gIC8qKiBUaGUgbmFtZSBvZiB0aGlzIHByb3BlcnR5IG9uIHRoZSBzZXJ2ZXIuIF9fUmVhZCBPbmx5X18gKi9cclxuICBuYW1lT25TZXJ2ZXI6IHN0cmluZztcclxuICAvKipcclxuICBXaGV0aGVyIHRoaXMgcHJvcGVydHkgcmV0dXJucyBhIHNpbmdsZSBlbnRpdHkgYXMgb3Bwb3NlZCB0byAgYW4gYXJyYXkgb2YgZW50aXRpZXMuIF9fUmVhZCBPbmx5X18gKi9cclxuICBpc1NjYWxhcjogYm9vbGVhbjtcclxuICAvKiogVGhlIG5hbWUgb2YgdGhlIGFzc29jaWF0aW9uIHRvIHdoaWNoIHRoYXQgdGhpcyBwcm9wZXJ0eSBiZWxvbmdzLiAgVGhpcyBhc3NvY2lhdGlvbk5hbWUgd2lsbCBiZSBzaGFyZWQgd2l0aCB0aGlzXHJcbiAgcHJvcGVydGllcyAnaW52ZXJzZScuIF9fUmVhZCBPbmx5X18gKi9cclxuICBhc3NvY2lhdGlvbk5hbWU6IHN0cmluZztcclxuICAvKiogVGhlIG5hbWVzIG9mIHRoZSBmb3JlaWduIGtleSBEYXRhUHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBOYXZpZ2F0aW9uUHJvcGVydHkuIFRoZXJlIHdpbGwgdXN1YWxseSBvbmx5IGJlIGEgc2luZ2xlIERhdGFQcm9wZXJ0eSBhc3NvY2lhdGVkXHJcbiAgd2l0aCBhIE5hdmlnYXRpb24gcHJvcGVydHkgZXhjZXB0IGluIHRoZSBjYXNlIG9mIGVudGl0aWVzIHdpdGggbXVsdGlwYXJ0IGtleXMuIF9fUmVhZCBPbmx5X18gKi9cclxuICBmb3JlaWduS2V5TmFtZXM6IHN0cmluZ1tdO1xyXG4gIC8qKiBUaGUgc2VydmVyIHNpZGUgbmFtZXMgb2YgdGhlIGZvcmVpZ24ga2V5IERhdGFQcm9wZXJ0aWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE5hdmlnYXRpb25Qcm9wZXJ0eS4gVGhlcmUgd2lsbCB1c3VhbGx5IG9ubHkgYmUgYSBzaW5nbGUgRGF0YVByb3BlcnR5IGFzc29jaWF0ZWRcclxuICB3aXRoIGEgTmF2aWdhdGlvbiBwcm9wZXJ0eSBleGNlcHQgaW4gdGhlIGNhc2Ugb2YgZW50aXRpZXMgd2l0aCBtdWx0aXBhcnQga2V5cy4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGZvcmVpZ25LZXlOYW1lc09uU2VydmVyOiBzdHJpbmdbXTtcclxuICBpbnZGb3JlaWduS2V5TmFtZXM6IHN0cmluZ1tdO1xyXG4gIGludkZvcmVpZ25LZXlOYW1lc09uU2VydmVyOiBzdHJpbmdbXTtcclxuICAvKiogVGhlICdmb3JlaWduIGtleScgRGF0YVByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgTmF2aWdhdGlvblByb3BlcnR5LiBUaGVyZSB3aWxsIHVzdWFsbHkgb25seSBiZSBhIHNpbmdsZSBEYXRhUHJvcGVydHkgYXNzb2NpYXRlZFxyXG4gIHdpdGggYSBOYXZpZ2F0aW9uIHByb3BlcnR5IGV4Y2VwdCBpbiB0aGUgY2FzZSBvZiBlbnRpdGllcyB3aXRoIG11bHRpcGFydCBrZXlzLiBfX1JlYWQgT25seV9fICovXHJcbiAgcmVsYXRlZERhdGFQcm9wZXJ0aWVzOiBEYXRhUHJvcGVydHlbXTtcclxuICAvKiogVGhlIFtbVmFsaWRhdG9yXV0gaW5zdGFuY2VzIHRoYXQgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHByb3BlcnR5LiBWYWxpZGF0b3JzIGNhbiBiZSBhZGRlZCBhbmRcclxuICByZW1vdmVkIGZyb20gdGhpcyBjb2xsZWN0aW9uLiBfX1JlYWQgT25seV9fICovXHJcbiAgdmFsaWRhdG9yczogVmFsaWRhdG9yW107XHJcbiAgLyoqIFRoZSBkaXNwbGF5IG5hbWUgb2YgdGhpcyBwcm9wZXJ0eS4gX19SZWFkIE9ubHlfXyAqL1xyXG4gIGRpc3BsYXlOYW1lOiBzdHJpbmc7XHJcbiAgaXNVbm1hcHBlZDogYm9vbGVhbjtcclxuICAvKiogQSBmcmVlIGZvcm0gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIGFueSBjdXN0b20gbWV0YWRhdGEgZm9yIHRoaXMgTmF2aWdhdGlvblByb3BlcnR5LiAgICoqL1xyXG4gIGN1c3RvbTogT2JqZWN0O1xyXG5cclxuICAvKiogTmF2aWdhdGlvblByb3BlcnR5IGNvbnN0cnVjdG9yXHJcbiAgPiAgICAgIGxldCBob21lQWRkcmVzc1Byb3AgPSBuZXcgTmF2aWdhdGlvblByb3BlcnR5KCB7XHJcbiAgPiAgICAgICAgICBuYW1lOiBcImhvbWVBZGRyZXNzXCIsXHJcbiAgPiAgICAgICAgICBlbnRpdHlUeXBlTmFtZTogXCJBZGRyZXNzOiNteU5hbWVzcGFjZVwiLFxyXG4gID4gICAgICAgICAgaXNTY2FsYXI6IHRydWUsXHJcbiAgPiAgICAgICAgICBhc3NvY2lhdGlvbk5hbWU6IFwiYWRkcmVzc19wZXJzb25cIixcclxuICA+ICAgICAgICAgIGZvcmVpZ25LZXlOYW1lczogW1wiaG9tZUFkZHJlc3NJZFwiXVxyXG4gID4gICAgICB9KTtcclxuICA+ICAgICAgbGV0IGhvbWVBZGRyZXNzSWRQcm9wID0gbmV3IERhdGFQcm9wZXJ0eSgge1xyXG4gID4gICAgICAgICAgbmFtZTogXCJob21lQWRkcmVzc0lkXCJcclxuICA+ICAgICAgICAgIGRhdGFUeXBlOiBEYXRhVHlwZS5JbnRlZ2VyXHJcbiAgPiAgICAgIH0pO1xyXG4gID4gICAgICAvLyBhc3N1bWluZyBwZXJzb25FbnRpdHlUeXBlIGlzIGEgbmV3bHkgY29uc3RydWN0ZWQgRW50aXR5VHlwZVxyXG4gID4gICAgICBwZXJzb25FbnRpdHlUeXBlLmFkZFByb3BlcnR5KGhvbWVBZGRyZXNzUHJvcCk7XHJcbiAgPiAgICAgIHBlcnNvbkVudGl0eVR5cGUuYWRkUHJvcGVydHkoaG9tZUFkZHJlc3NJZFByb3ApO1xyXG4gIEBwYXJhbSBjb25maWcgLSBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxyXG4gICoqL1xyXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogTmF2aWdhdGlvblByb3BlcnR5Q29uZmlnKSB7XHJcbiAgICBhc3NlcnRDb25maWcoY29uZmlnKVxyXG4gICAgICAud2hlcmVQYXJhbShcIm5hbWVcIikuaXNTdHJpbmcoKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJuYW1lT25TZXJ2ZXJcIikuaXNTdHJpbmcoKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJlbnRpdHlUeXBlTmFtZVwiKS5pc1N0cmluZygpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiaXNTY2FsYXJcIikuaXNCb29sZWFuKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KHRydWUpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiYXNzb2NpYXRpb25OYW1lXCIpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiZm9yZWlnbktleU5hbWVzXCIpLmlzQXJyYXkoKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChbXSlcclxuICAgICAgLndoZXJlUGFyYW0oXCJmb3JlaWduS2V5TmFtZXNPblNlcnZlclwiKS5pc0FycmF5KCkuaXNTdHJpbmcoKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQoW10pXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiaW52Rm9yZWlnbktleU5hbWVzXCIpLmlzQXJyYXkoKS5pc1N0cmluZygpLmlzT3B0aW9uYWwoKS53aXRoRGVmYXVsdChbXSlcclxuICAgICAgLndoZXJlUGFyYW0oXCJpbnZGb3JlaWduS2V5TmFtZXNPblNlcnZlclwiKS5pc0FycmF5KCkuaXNTdHJpbmcoKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQoW10pXHJcbiAgICAgIC53aGVyZVBhcmFtKFwidmFsaWRhdG9yc1wiKS5pc0luc3RhbmNlT2YoVmFsaWRhdG9yKS5pc0FycmF5KCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KFtdKVxyXG4gICAgICAud2hlcmVQYXJhbShcImRpc3BsYXlOYW1lXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAud2hlcmVQYXJhbShcImN1c3RvbVwiKS5pc09wdGlvbmFsKClcclxuICAgICAgLmFwcGx5QWxsKHRoaXMpO1xyXG4gICAgbGV0IGhhc05hbWUgPSAhISh0aGlzLm5hbWUgfHwgdGhpcy5uYW1lT25TZXJ2ZXIpO1xyXG5cclxuICAgIGlmICghaGFzTmFtZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIE5hdmlnYXRpb24gcHJvcGVydHkgbXVzdCBiZSBpbnN0YW50aWF0ZWQgd2l0aCBlaXRoZXIgYSAnbmFtZScgb3IgYSAnbmFtZU9uU2VydmVyJyBwcm9wZXJ0eVwiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIEdlbmVyYWwgcHVycG9zZSBwcm9wZXJ0eSBzZXQgbWV0aG9kXHJcbiAgPiAgICAgIC8vIGFzc3VtZSBteUVudGl0eVR5cGUgaXMgYW4gRW50aXR5VHlwZVxyXG4gID4gICAgICBsZXQgcHJvcCA9IG15RW50aXR5VHlwZS5nZXRQcm9wZXJ0eShcIm15UHJvcGVydHlcIik7XHJcbiAgPiAgICAgIHByb3Auc2V0UHJvcGVydGllcygge1xyXG4gID4gICAgICAgICAgY3VzdG9tOiB7IGZvbzogNywgYmFyOiBcInRlc3RcIiB9XHJcbiAgPiAgICAgIH0pO1xyXG4gIEBwYXJhbSBjb25maWcgLSBBIGNvbmZpZyBvYmplY3RcclxuICAqKi9cclxuICAvLyBUT0RPOiBjcmVhdGUgYW4gaW50ZXJmYWNlIGZvciB0aGlzLlxyXG4gIHNldFByb3BlcnRpZXMoY29uZmlnOiB7XHJcbiAgICBkaXNwbGF5TmFtZT86IHN0cmluZyxcclxuICAgIGZvcmVpZ25LZXlOYW1lcz86IHN0cmluZ1tdLFxyXG4gICAgaW52Rm9yZWlnbktleU5hbWVzPzogc3RyaW5nW10sXHJcbiAgICBpbnZlcnNlPzogTmF2aWdhdGlvblByb3BlcnR5IHwgc3RyaW5nLFxyXG4gICAgY3VzdG9tPzogT2JqZWN0XHJcbiAgfSkge1xyXG4gICAgaWYgKCF0aGlzLnBhcmVudFR5cGUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgTmF2aWdhdGlvblByb3BlcnR5LnNldFByb3BlcnRpZXMgdW50aWwgdGhlIHBhcmVudCBFbnRpdHlUeXBlIG9mIHRoZSBOYXZpZ2F0aW9uUHJvcGVydHkgaGFzIGJlZW4gc2V0LlwiKTtcclxuICAgIH1cclxuICAgIGxldCBpbnZlcnNlID0gY29uZmlnLmludmVyc2U7XHJcbiAgICBpZiAoaW52ZXJzZSkgZGVsZXRlIGNvbmZpZy5pbnZlcnNlO1xyXG4gICAgYXNzZXJ0Q29uZmlnKGNvbmZpZylcclxuICAgICAgLndoZXJlUGFyYW0oXCJkaXNwbGF5TmFtZVwiKS5pc09wdGlvbmFsKClcclxuICAgICAgLndoZXJlUGFyYW0oXCJmb3JlaWduS2V5TmFtZXNcIikuaXNBcnJheSgpLmlzU3RyaW5nKCkuaXNPcHRpb25hbCgpLndpdGhEZWZhdWx0KFtdKVxyXG4gICAgICAud2hlcmVQYXJhbShcImludkZvcmVpZ25LZXlOYW1lc1wiKS5pc0FycmF5KCkuaXNTdHJpbmcoKS5pc09wdGlvbmFsKCkud2l0aERlZmF1bHQoW10pXHJcbiAgICAgIC53aGVyZVBhcmFtKFwiY3VzdG9tXCIpLmlzT3B0aW9uYWwoKVxyXG4gICAgICAuYXBwbHlBbGwodGhpcyk7XHJcbiAgICB0aGlzLnBhcmVudFR5cGUuX3VwZGF0ZU5hbWVzKHRoaXMpO1xyXG5cclxuICAgIHRoaXMuX3Jlc29sdmVOcCgpO1xyXG4gICAgaWYgKGludmVyc2UpIHtcclxuICAgICAgdGhpcy5zZXRJbnZlcnNlKGludmVyc2UpO1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIC8qKiBUaGUgaW52ZXJzZSBvZiB0aGlzIE5hdmlnYXRpb25Qcm9wZXJ0eS4gIFRoZSBOYXZpZ2F0aW9uUHJvcGVydHkgdGhhdCByZXByZXNlbnRzIGEgbmF2aWdhdGlvbiBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXHJcbiAgdG8gdGhpcyBOYXZpZ2F0aW9uUHJvcGVydHkuIE1heSBiZSB1bmRlZmluZWQgZm9yIGEgdW5kaXJlY3Rpb25hbCBOYXZpZ2F0aW9uUHJvcGVydHkuIF9fUmVhZCBPbmx5X18gKi9cclxuICBnZXQgaW52ZXJzZSgpOiBOYXZpZ2F0aW9uUHJvcGVydHkgfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0SW52ZXJzZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgZ2V0SW52ZXJzZSgpOiBOYXZpZ2F0aW9uUHJvcGVydHkgfCB1bmRlZmluZWQge1xyXG4gICAgbGV0IG5wOiBOYXZpZ2F0aW9uUHJvcGVydHkgPSB0aGlzO1xyXG4gICAgd2hpbGUgKCFucC5faW52ZXJzZSAmJiBucC5iYXNlUHJvcGVydHkpIHtcclxuICAgICAgbnAgPSBucC5iYXNlUHJvcGVydHk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnAuX2ludmVyc2U7XHJcbiAgfVxyXG5cclxuICBzZXRJbnZlcnNlKGludmVyc2VOcDogTmF2aWdhdGlvblByb3BlcnR5IHwgc3RyaW5nKSB7XHJcbiAgICAvLyBsZXQgaW52TnA6IE5hdmlnYXRpb25Qcm9wZXJ0eTtcclxuICAgIGxldCBpbnZOcCA9IChpbnZlcnNlTnAgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uUHJvcGVydHkpID8gaW52ZXJzZU5wIDogdGhpcy5lbnRpdHlUeXBlLmdldE5hdmlnYXRpb25Qcm9wZXJ0eShpbnZlcnNlTnApO1xyXG5cclxuICAgIGlmICghaW52TnApIHtcclxuICAgICAgdGhyb3cgdGhyb3dTZXRJbnZlcnNlRXJyb3IodGhpcywgXCJVbmFibGUgdG8gZmluZCBpbnZlcnNlIHByb3BlcnR5OiBcIiArIGludmVyc2VOcCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2ludmVyc2UgfHwgaW52TnAuX2ludmVyc2UpIHtcclxuICAgICAgdGhyb3dTZXRJbnZlcnNlRXJyb3IodGhpcywgXCJJdCBoYXMgYWxyZWFkeSBiZWVuIHNldCBvbiBvbmUgc2lkZSBvciB0aGUgb3RoZXIuXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGludk5wLmVudGl0eVR5cGUgIT09IHRoaXMucGFyZW50VHlwZSkge1xyXG4gICAgICB0aHJvd1NldEludmVyc2VFcnJvcih0aGlzLCBpbnZOcC5mb3JtYXROYW1lICsgXCIgaXMgbm90IGEgdmFsaWQgaW52ZXJzZSBwcm9wZXJ0eSBmb3IgdGhpcy5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5hc3NvY2lhdGlvbk5hbWUpIHtcclxuICAgICAgaW52TnAuYXNzb2NpYXRpb25OYW1lID0gdGhpcy5hc3NvY2lhdGlvbk5hbWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoIWludk5wLmFzc29jaWF0aW9uTmFtZSkge1xyXG4gICAgICAgIGludk5wLmFzc29jaWF0aW9uTmFtZSA9IHRoaXMuZm9ybWF0TmFtZSgpICsgXCJfXCIgKyBpbnZOcC5mb3JtYXROYW1lKCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5hc3NvY2lhdGlvbk5hbWUgPSBpbnZOcC5hc3NvY2lhdGlvbk5hbWU7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9yZXNvbHZlTnAoKTtcclxuICAgIGludk5wLl9yZXNvbHZlTnAoKTtcclxuICB9XHJcblxyXG4gIC8vIC8vIEluIHByb2dyZXNzIC0gd2lsbCBiZSB1c2VkIGZvciBtYW51YWwgbWV0YWRhdGEgY29uZmlnXHJcbiAgLy8gY3JlYXRlSW52ZXJzZShjb25maWc6IGFueSkge1xyXG5cclxuICAvLyAgIGlmICghdGhpcy5lbnRpdHlUeXBlKSB7XHJcbiAgLy8gICAgIHRocm93Q3JlYXRlSW52ZXJzZUVycm9yKHRoaXMsIFwiaGFzIG5vdCB5ZXQgYmVlbiBkZWZpbmVkLlwiKTtcclxuICAvLyAgIH1cclxuICAvLyAgIGlmICh0aGlzLmVudGl0eVR5cGUuaXNGcm96ZW4pIHtcclxuICAvLyAgICAgdGhyb3dDcmVhdGVJbnZlcnNlRXJyb3IodGhpcywgXCJpcyBmcm96ZW4uXCIpO1xyXG4gIC8vICAgfVxyXG4gIC8vICAgbGV0IG1ldGFkYXRhU3RvcmUgPSB0aGlzLmVudGl0eVR5cGUubWV0YWRhdGFTdG9yZTtcclxuICAvLyAgIGlmIChtZXRhZGF0YVN0b3JlID09IG51bGwpIHtcclxuICAvLyAgICAgdGhyb3dDcmVhdGVJbnZlcnNlRXJyb3IodGhpcywgXCJoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIHRoZSBtZXRhZGF0YVN0b3JlLlwiKTtcclxuICAvLyAgIH1cclxuXHJcbiAgLy8gICBjb25maWcuZW50aXR5VHlwZU5hbWUgPSB0aGlzLnBhcmVudEVudGl0eVR5cGUubmFtZTtcclxuICAvLyAgIGNvbmZpZy5hc3NvY2lhdGlvbk5hbWUgPSB0aGlzLmFzc29jaWF0aW9uTmFtZTtcclxuICAvLyAgIGxldCBpbnZOcCA9IG5ldyBOYXZpZ2F0aW9uUHJvcGVydHkoY29uZmlnKTtcclxuICAvLyAgIHRoaXMucGFyZW50RW50aXR5VHlwZS5hZGROYXZpZ2F0aW9uUHJvcGVydHkoaW52TnApO1xyXG4gIC8vICAgcmV0dXJuIGludk5wO1xyXG4gIC8vIH07XHJcblxyXG5cclxuXHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIGNvcmUudG9Kc29uKHRoaXMsIHtcclxuICAgICAgbmFtZTogbnVsbCxcclxuICAgICAgZW50aXR5VHlwZU5hbWU6IG51bGwsXHJcbiAgICAgIGlzU2NhbGFyOiBudWxsLFxyXG4gICAgICBhc3NvY2lhdGlvbk5hbWU6IG51bGwsXHJcbiAgICAgIHZhbGlkYXRvcnM6IG51bGwsXHJcbiAgICAgIGRpc3BsYXlOYW1lOiBudWxsLFxyXG4gICAgICBmb3JlaWduS2V5TmFtZXM6IG51bGwsXHJcbiAgICAgIGludkZvcmVpZ25LZXlOYW1lczogbnVsbCxcclxuICAgICAgY3VzdG9tOiBudWxsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uOiBhbnkpIHtcclxuICAgIGlmIChqc29uLnZhbGlkYXRvcnMpIHtcclxuICAgICAganNvbi52YWxpZGF0b3JzID0ganNvbi52YWxpZGF0b3JzLm1hcChWYWxpZGF0b3IuZnJvbUpTT04pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBOYXZpZ2F0aW9uUHJvcGVydHkoanNvbik7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfcmVzb2x2ZU5wKCkge1xyXG4gICAgbGV0IG5wID0gdGhpcztcclxuICAgIGxldCBlbnRpdHlUeXBlID0gbnAuZW50aXR5VHlwZTtcclxuICAgIGxldCBpbnZOcCA9IGNvcmUuYXJyYXlGaXJzdChlbnRpdHlUeXBlLm5hdmlnYXRpb25Qcm9wZXJ0aWVzLCAoYWx0TnApID0+IHtcclxuICAgICAgLy8gQ2FuJ3QgZG8gdGhpcyBiZWNhdXNlIG9mIHBvc3NpYmlsaXR5IG9mIGNvbXBhcmluZyBhIGJhc2UgY2xhc3MgbnAgd2l0aCBhIHN1YmNsYXNzIGFsdE5wLlxyXG4gICAgICAvLyByZXR1cm4gYWx0TnAuYXNzb2NpYXRpb25OYW1lID09PSBucC5hc3NvY2lhdGlvbk5hbWVcclxuICAgICAgLy8gICAgJiYgYWx0TnAgIT09IG5wO1xyXG4gICAgICAvLyBTbyB1c2UgdGhpcyBpbnN0ZWFkLlxyXG4gICAgICByZXR1cm4gYWx0TnAuYXNzb2NpYXRpb25OYW1lID09PSBucC5hc3NvY2lhdGlvbk5hbWUgJiZcclxuICAgICAgICAoYWx0TnAubmFtZSAhPT0gbnAubmFtZSB8fCBhbHROcC5lbnRpdHlUeXBlTmFtZSAhPT0gbnAuZW50aXR5VHlwZU5hbWUpO1xyXG4gICAgfSk7XHJcbiAgICBucC5faW52ZXJzZSA9IGludk5wIHx8IHVuZGVmaW5lZDtcclxuICAgIC8vaWYgKGludk5wICYmIGludk5wLmludmVyc2UgPT0gbnVsbCkge1xyXG4gICAgLy8gICAgaW52TnAuX3Jlc29sdmVOcCgpO1xyXG4gICAgLy99XHJcbiAgICBpZiAoIWludk5wKSB7XHJcbiAgICAgIC8vIHVuaWRpcmVjdGlvbmFsIDEtbiByZWxhdGlvbnNoaXBcclxuICAgICAgbnAuaW52Rm9yZWlnbktleU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGludkZrTmFtZSkge1xyXG4gICAgICAgIGxldCBma1Byb3AgPSBlbnRpdHlUeXBlLmdldERhdGFQcm9wZXJ0eShpbnZGa05hbWUpO1xyXG4gICAgICAgIGlmIChma1Byb3AgPT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW50aXR5VHlwZSAnXCIgKyBucC5lbnRpdHlUeXBlTmFtZSArIFwiJyBoYXMgbm8gZm9yZWlnbiBrZXkgbWF0Y2hpbmcgJ1wiICsgaW52RmtOYW1lICsgXCInXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaW52RW50aXR5VHlwZSA9IG5wLnBhcmVudFR5cGU7XHJcbiAgICAgICAgaW52TnAgPSBjb3JlLmFycmF5Rmlyc3QoaW52RW50aXR5VHlwZS5uYXZpZ2F0aW9uUHJvcGVydGllcywgKG5wMikgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIG5wMi5pbnZGb3JlaWduS2V5TmFtZXMgJiYgbnAyLmludkZvcmVpZ25LZXlOYW1lcy5pbmRleE9mKGZrUHJvcCEubmFtZSkgPj0gMCAmJiBucDIuZW50aXR5VHlwZSA9PT0gZmtQcm9wIS5wYXJlbnRUeXBlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZrUHJvcC5pbnZlcnNlTmF2aWdhdGlvblByb3BlcnR5ID0gaW52TnAgfHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvcmUuYXJyYXlBZGRJdGVtVW5pcXVlKGVudGl0eVR5cGUuZm9yZWlnbktleVByb3BlcnRpZXMsIGZrUHJvcCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc29sdmVSZWxhdGVkKG5wKTtcclxuICB9XHJcblxyXG59XHJcbk5hdmlnYXRpb25Qcm9wZXJ0eS5wcm90b3R5cGUuXyR0eXBlTmFtZSA9IFwiTmF2aWdhdGlvblByb3BlcnR5XCI7XHJcblxyXG5mdW5jdGlvbiB0aHJvd1NldEludmVyc2VFcnJvcihucDogTmF2aWdhdGlvblByb3BlcnR5LCBtZXNzYWdlOiBzdHJpbmcpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBpbnZlcnNlIHByb3BlcnR5IGZvcjogXCIgKyBucC5mb3JtYXROYW1lKCkgKyBcIi4gXCIgKyBtZXNzYWdlKTtcclxufVxyXG5cclxuLy8gTm90IGN1cnJlbnQgdXNlZC5cclxuLy8gZnVuY3Rpb24gdGhyb3dDcmVhdGVJbnZlcnNlRXJyb3IobnA6IE5hdmlnYXRpb25Qcm9wZXJ0eSwgbWVzc2FnZTogc3RyaW5nKSB7XHJcbi8vICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBpbnZlcnNlIGZvcjogXCIgKyBucC5mb3JtYXROYW1lKCkgKyBcIi4gVGhlIGVudGl0eVR5cGUgZm9yIHRoaXMgbmF2aWdhdGlvbiBwcm9wZXJ0eSBcIiArIG1lc3NhZ2UpO1xyXG4vLyB9XHJcblxyXG4vLyBzZXRzIG5hdmlnYXRpb24gcHJvcGVydHk6IHJlbGF0ZWREYXRhUHJvcGVydGllcyBhbmQgZGF0YVByb3BlcnR5OiByZWxhdGVkTmF2aWdhdGlvblByb3BlcnR5XHJcbmZ1bmN0aW9uIHJlc29sdmVSZWxhdGVkKG5wOiBOYXZpZ2F0aW9uUHJvcGVydHkpIHtcclxuXHJcbiAgbGV0IGZrTmFtZXMgPSBucC5mb3JlaWduS2V5TmFtZXM7XHJcbiAgaWYgKGZrTmFtZXMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gIGxldCBwYXJlbnRFbnRpdHlUeXBlID0gbnAucGFyZW50VHlwZTtcclxuICBsZXQgZmtQcm9wcyA9IGZrTmFtZXMubWFwKGZ1bmN0aW9uIChma05hbWUpIHtcclxuICAgIHJldHVybiBwYXJlbnRFbnRpdHlUeXBlLmdldERhdGFQcm9wZXJ0eShma05hbWUpO1xyXG4gIH0pO1xyXG4gIGxldCBma1Byb3BDb2xsZWN0aW9uID0gcGFyZW50RW50aXR5VHlwZS5mb3JlaWduS2V5UHJvcGVydGllcztcclxuXHJcbiAgZmtQcm9wcy5mb3JFYWNoKChkcDogRGF0YVByb3BlcnR5KSA9PiB7XHJcbiAgICBjb3JlLmFycmF5QWRkSXRlbVVuaXF1ZShma1Byb3BDb2xsZWN0aW9uLCBkcCk7XHJcbiAgICBkcC5yZWxhdGVkTmF2aWdhdGlvblByb3BlcnR5ID0gbnA7XHJcbiAgICAvLyBub3cgdXBkYXRlIHRoZSBpbnZlcnNlXHJcbiAgICBjb3JlLmFycmF5QWRkSXRlbVVuaXF1ZShucC5lbnRpdHlUeXBlLmludmVyc2VGb3JlaWduS2V5UHJvcGVydGllcywgZHApO1xyXG4gICAgaWYgKG5wLnJlbGF0ZWREYXRhUHJvcGVydGllcykge1xyXG4gICAgICBjb3JlLmFycmF5QWRkSXRlbVVuaXF1ZShucC5yZWxhdGVkRGF0YVByb3BlcnRpZXMsIGRwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG5wLnJlbGF0ZWREYXRhUHJvcGVydGllcyA9IFtkcF07XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcblxyXG4vKipcclxuQXV0b0dlbmVyYXRlZEtleVR5cGUgaXMgYW4gJ0VudW0nIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSB2YWxpZCBzdGF0ZXMgZm9yIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGtleS5cclxuKiovXHJcbmV4cG9ydCBjbGFzcyBBdXRvR2VuZXJhdGVkS2V5VHlwZSBleHRlbmRzIEJyZWV6ZUVudW0ge1xyXG5cclxuICAvKipcclxuICBUaGlzIGVudGl0eSBkb2VzIG5vdCBoYXZlIGFuIGF1dG9nZW5lcmF0ZWQga2V5LlxyXG4gIFRoZSBjbGllbnQgbXVzdCBzZXQgdGhlIGtleSBiZWZvcmUgYWRkaW5nIHRoZSBlbnRpdHkgdG8gdGhlIEVudGl0eU1hbmFnZXJcclxuICAqKi9cclxuICBzdGF0aWMgTm9uZSA9IG5ldyBBdXRvR2VuZXJhdGVkS2V5VHlwZSgpO1xyXG4gIC8qKiBcclxuICBUaGlzIGVudGl0eSdzIGtleSBpcyBhbiBJZGVudGl0eSBjb2x1bW4gYW5kIGlzIHNldCBieSB0aGUgYmFja2VuZCBkYXRhYmFzZS5cclxuICBLZXlzIGZvciBuZXcgZW50aXRpZXMgd2lsbCBiZSB0ZW1wb3JhcnkgdW50aWwgdGhlIGVudGl0aWVzIGFyZSBzYXZlZCBhdCB3aGljaCBwb2ludCB0aGUga2V5cyB3aWxsXHJcbiAgYmUgY29udmVydGVkIHRvIHRoZWlyICdyZWFsJyB2ZXJzaW9ucy5cclxuICAqKi9cclxuICBzdGF0aWMgSWRlbnRpdHkgPSBuZXcgQXV0b0dlbmVyYXRlZEtleVR5cGUoKTtcclxuICAvKipcclxuICBUaGlzIGVudGl0eSdzIGtleSBpcyBnZW5lcmF0ZWQgYnkgYSBLZXlHZW5lcmF0b3IgYW5kIGlzIHNldCBieSB0aGUgYmFja2VuZCBkYXRhYmFzZS5cclxuICBLZXlzIGZvciBuZXcgZW50aXRpZXMgd2lsbCBiZSB0ZW1wb3JhcnkgdW50aWwgdGhlIGVudGl0aWVzIGFyZSBzYXZlZCBhdCB3aGljaCBwb2ludCB0aGUga2V5cyB3aWxsXHJcbiAgYmUgY29udmVydGVkIHRvIHRoZWlyICdyZWFsJyB2ZXJzaW9ucy5cclxuICAqKi9cclxuICBzdGF0aWMgS2V5R2VuZXJhdG9yID0gbmV3IEF1dG9HZW5lcmF0ZWRLZXlUeXBlKCk7XHJcblxyXG59XHJcbkF1dG9HZW5lcmF0ZWRLZXlUeXBlLnByb3RvdHlwZS5fJHR5cGVOYW1lID0gXCJBdXRvR2VuZXJhdGVkS2V5VHlwZVwiO1xyXG5FcnJvclsneCddID0gQXV0b0dlbmVyYXRlZEtleVR5cGUucmVzb2x2ZVN5bWJvbHMoKTtcclxuXHJcblxyXG4vLyBtaXhpbiBtZXRob2RzXHJcbi8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG5kZWNsYXJlIG1vZHVsZSBcIi4vYXNzZXJ0LXBhcmFtXCIge1xyXG4gIGludGVyZmFjZSBQYXJhbSB7XHJcbiAgICBpc0VudGl0eSgpOiBQYXJhbTtcclxuICAgIGlzRW50aXR5UHJvcGVydHkoKTogUGFyYW07XHJcbiAgfVxyXG59XHJcblxyXG5sZXQgcHJvdG8gPSBQYXJhbS5wcm90b3R5cGU7XHJcblxyXG4vLyAndGhpcycgYmVsb3cgaXMgVFMgYW5ub3RhdGlvbiBcclxucHJvdG8uaXNFbnRpdHkgPSBmdW5jdGlvbiAodGhpczogUGFyYW0pIHtcclxuICByZXR1cm4gdGhpcy5fYWRkQ29udGV4dCh7XHJcbiAgICBmbjogaXNFbnRpdHksXHJcbiAgICBtc2c6IFwiIG11c3QgYmUgYW4gZW50aXR5XCJcclxuICB9KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGlzRW50aXR5KGNvbnRleHQ6IGFueSwgdjogYW55KSB7XHJcbiAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xyXG4gIHJldHVybiAodi5lbnRpdHlUeXBlICE9PSB1bmRlZmluZWQpO1xyXG59XHJcblxyXG5wcm90by5pc0VudGl0eVByb3BlcnR5ID0gZnVuY3Rpb24gKHRoaXM6IFBhcmFtKSB7XHJcbiAgcmV0dXJuIHRoaXMuX2FkZENvbnRleHQoe1xyXG4gICAgZm46IGlzRW50aXR5UHJvcGVydHksXHJcbiAgICBtc2c6IFwiIG11c3QgYmUgZWl0aGVyIGEgRGF0YVByb3BlcnR5IG9yIGEgTmF2aWdhdGlvblByb3BlcnR5XCJcclxuICB9KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGlzRW50aXR5UHJvcGVydHkoY29udGV4dDogYW55LCB2OiBhbnkpIHtcclxuICBpZiAodiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcbiAgcmV0dXJuICh2LmlzRGF0YVByb3BlcnR5IHx8IHYuaXNOYXZpZ2F0aW9uUHJvcGVydHkpO1xyXG59XHJcblxyXG4vLyBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gY2xhc3NlcyByZWxhdGVkIHRvIE1ldGFkYXRhXHJcblxyXG5mdW5jdGlvbiBpc1F1YWxpZmllZFR5cGVOYW1lKGVudGl0eVR5cGVOYW1lOiBzdHJpbmcpIHtcclxuICByZXR1cm4gZW50aXR5VHlwZU5hbWUuaW5kZXhPZihcIjojXCIpID49IDA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBxdWFsaWZ5VHlwZU5hbWUoc2hvcnROYW1lOiBzdHJpbmcsIG5zPzogc3RyaW5nKSB7XHJcbiAgaWYgKG5zICYmIG5zLmxlbmd0aCA+IDApIHtcclxuICAgIHJldHVybiBzaG9ydE5hbWUgKyBcIjojXCIgKyBucztcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHNob3J0TmFtZTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFVzZWQgYnkgYm90aCBDb21wbGV4VHlwZSBhbmQgRW50aXR5VHlwZVxyXG5mdW5jdGlvbiBhZGRQcm9wZXJ0aWVzKGVudGl0eVR5cGU6IFN0cnVjdHVyYWxUeXBlLCBwcm9wT2JqOiBPYmplY3QgfCB1bmRlZmluZWQsIGN0b3I6IGFueSkge1xyXG4gIGlmIChwcm9wT2JqID09IG51bGwpIHJldHVybjtcclxuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wT2JqKSkge1xyXG4gICAgcHJvcE9iai5mb3JFYWNoKGVudGl0eVR5cGUuX2FkZFByb3BlcnR5Q29yZS5iaW5kKGVudGl0eVR5cGUpKTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiAocHJvcE9iaikgPT09ICdvYmplY3QnKSB7XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gcHJvcE9iaikge1xyXG4gICAgICBpZiAoY29yZS5oYXNPd25Qcm9wZXJ0eShwcm9wT2JqLCBrZXkpKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gcHJvcE9ialtrZXldO1xyXG4gICAgICAgIHZhbHVlLm5hbWUgPSBrZXk7XHJcbiAgICAgICAgbGV0IHByb3AgPSBuZXcgY3Rvcih2YWx1ZSk7XHJcbiAgICAgICAgZW50aXR5VHlwZS5fYWRkUHJvcGVydHlDb3JlKHByb3ApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnZGF0YVByb3BlcnRpZXMnIG9yICduYXZpZ2F0aW9uUHJvcGVydGllcycgdmFsdWVzIG11c3QgYmUgZWl0aGVyIGFuIGFycmF5IG9mIGRhdGEvbmF2IHByb3BlcnRpZXMgb3IgYW4gb2JqZWN0IHdoZXJlIGVhY2ggcHJvcGVydHkgZGVmaW5lcyBhIGRhdGEvbmF2IHByb3BlcnR5XCIpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiJdfQ==