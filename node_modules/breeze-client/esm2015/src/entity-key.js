import { core } from './core';
import { assertParam } from './assert-param';
import { EntityType } from './entity-metadata';
import { DataType } from './data-type';
/**
An EntityKey is an object that represents the unique identity of an entity.  EntityKey's are immutable.


**/
export class EntityKey {
    /**
    Constructs a new EntityKey.  Each entity within an EntityManager will have a unique EntityKey.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     var empType = em1.metadataStore.getEntityType("Employee");
    >     var entityKey = new EntityKey(empType, 1);
  
    EntityKey's may also be found by calling EntityAspect.getKey()
    >     // assume employee1 is an existing Employee entity
    >     var empKey = employee1.entityAspect.getKey();
  
    Multipart keys are created by passing an array as the 'keyValues' parameter
    >     var empTerrType = em1.metadataStore.getEntityType("EmployeeTerritory");
    >     var empTerrKey = new EntityKey(empTerrType, [ 1, 77]);
    >     // The order of the properties in the 'keyValues' array must be the same as that
    >     // returned by empTerrType.keyProperties
    @param entityType - The [[EntityType]] of the entity.
    @param keyValues - A single value or an array of values.
    */
    constructor(entityType, keyValues) {
        assertParam(entityType, "entityType").isInstanceOf(EntityType).check();
        let subtypes = entityType.getSelfAndSubtypes();
        if (subtypes.length > 1) {
            this._subtypes = subtypes.filter(function (st) {
                return st.isAbstract === false;
            });
        }
        if (!Array.isArray(keyValues)) {
            keyValues = [keyValues];
        }
        this.entityType = entityType;
        entityType.keyProperties.forEach(function (kp, i) {
            // insure that guid keys are comparable.
            if (kp.dataType === DataType.Guid) {
                keyValues[i] = keyValues[i] && keyValues[i].toLowerCase ? keyValues[i].toLowerCase() : keyValues[i];
            }
        });
        this.values = keyValues;
        this._keyInGroup = EntityKey.createKeyString(keyValues);
    }
    toJSON() {
        return {
            entityType: this.entityType.name,
            values: this.values
        };
    }
    static fromJSON(json, metadataStore) {
        let et = metadataStore._getStructuralType(json.entityType, true);
        return new EntityKey(et, json.values);
    }
    /**
    Used to compare EntityKeys are determine if they refer to the same Entity.
    There is also an static version of 'equals' with the same functionality.
    
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      var empType = em1.metadataStore.getEntityType("Employee");
    >      var empKey1 = new EntityKey(empType, 1);
    >      // assume employee1 is an existing Employee entity
    >      var empKey2 = employee1.entityAspect.getKey();
    >      if (empKey1.equals(empKey2)) {
    >          // do something  ...
    >      }
    **/
    equals(entityKey) {
        if (!(entityKey instanceof EntityKey))
            return false;
        return (this.entityType === entityKey.entityType) &&
            core.arrayEquals(this.values, entityKey.values);
    }
    /*
    Returns a human readable representation of this EntityKey.
    */
    toString(altEntityType) {
        return (altEntityType || this.entityType).name + '-' + this._keyInGroup;
    }
    /**
    Used to compare EntityKeys are determine if they refer to the same Entity.
    There is also an instance version of 'equals' with the same functionality.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      var empType = em1.metadataStore.getEntityType("Employee");
    >      var empKey1 = new EntityKey(empType, 1);
    >      // assume employee1 is an existing Employee entity
    >      var empKey2 = employee1.entityAspect.getKey();
    >      if (EntityKey.equals(empKey1, empKey2)) {
    >          // do something  ...
    >      }
    **/
    static equals(k1, k2) {
        if (!(k1 instanceof EntityKey))
            return false;
        return k1.equals(k2);
    }
    /** @hidden @internal */
    // TODO: we may want to compare to default values later.
    _isEmpty() {
        return this.values.join("").length === 0;
    }
    /** hidden */
    // TODO: think about giving _ prefix or documenting.
    static createKeyString(keyValues) {
        return keyValues.join(EntityKey.ENTITY_KEY_DELIMITER);
    }
}
/** @hidden @internal */
EntityKey.ENTITY_KEY_DELIMITER = ":::";
EntityKey.prototype._$typeName = "EntityKey";
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXR5LWtleS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2JyZWV6ZS1jbGllbnQvIiwic291cmNlcyI6WyJzcmMvZW50aXR5LWtleS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzlCLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM3QyxPQUFPLEVBQUUsVUFBVSxFQUFpQixNQUFNLG1CQUFtQixDQUFDO0FBQzlELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFFdkM7Ozs7R0FJRztBQUNILE1BQU0sT0FBTyxTQUFTO0lBZXBCOzs7Ozs7Ozs7Ozs7Ozs7OztNQWlCRTtJQUNGLFlBQVksVUFBc0IsRUFBRSxTQUFjO1FBQ2hELFdBQVcsQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3ZFLElBQUksUUFBUSxHQUFHLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQy9DLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDdkIsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRTtnQkFDM0MsT0FBTyxFQUFFLENBQUMsVUFBVSxLQUFLLEtBQUssQ0FBQztZQUNqQyxDQUFDLENBQUMsQ0FBQztTQUNKO1FBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDN0IsU0FBUyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDekI7UUFFRCxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixVQUFVLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsRUFBRSxDQUFDO1lBQzlDLHdDQUF3QztZQUN4QyxJQUFJLEVBQUUsQ0FBQyxRQUFRLEtBQUssUUFBUSxDQUFDLElBQUksRUFBRTtnQkFDakMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNyRztRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUM7UUFDeEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBRTFELENBQUM7SUFHRCxNQUFNO1FBQ0osT0FBTztZQUNMLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUk7WUFDaEMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1NBQ3BCLENBQUM7SUFDSixDQUFDO0lBRUQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFTLEVBQUUsYUFBNEI7UUFDckQsSUFBSSxFQUFFLEdBQUcsYUFBYSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFlLENBQUM7UUFDL0UsT0FBTyxJQUFJLFNBQVMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7SUFDSCxNQUFNLENBQUMsU0FBb0I7UUFDekIsSUFBSSxDQUFDLENBQUMsU0FBUyxZQUFZLFNBQVMsQ0FBQztZQUFFLE9BQU8sS0FBSyxDQUFDO1FBQ3BELE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxLQUFLLFNBQVMsQ0FBQyxVQUFVLENBQUM7WUFDL0MsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7O01BRUU7SUFDRixRQUFRLENBQUMsYUFBMEI7UUFDakMsT0FBTyxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7T0FXRztJQUNILE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBYSxFQUFFLEVBQWE7UUFDeEMsSUFBSSxDQUFDLENBQUMsRUFBRSxZQUFZLFNBQVMsQ0FBQztZQUFFLE9BQU8sS0FBSyxDQUFDO1FBQzdDLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQsd0JBQXdCO0lBQ3hCLHdEQUF3RDtJQUN4RCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFRCxhQUFhO0lBQ2Isb0RBQW9EO0lBQ3BELE1BQU0sQ0FBQyxlQUFlLENBQUMsU0FBZ0I7UUFDckMsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0lBQ3hELENBQUM7O0FBMUhELHdCQUF3QjtBQUNqQiw4QkFBb0IsR0FBRyxLQUFLLENBQUM7QUE0SHRDLFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLFdBQVcsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvcmUgfSBmcm9tICcuL2NvcmUnO1xyXG5pbXBvcnQgeyBhc3NlcnRQYXJhbSB9IGZyb20gJy4vYXNzZXJ0LXBhcmFtJztcclxuaW1wb3J0IHsgRW50aXR5VHlwZSwgTWV0YWRhdGFTdG9yZSB9IGZyb20gJy4vZW50aXR5LW1ldGFkYXRhJztcclxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuL2RhdGEtdHlwZSc7XHJcblxyXG4vKipcclxuQW4gRW50aXR5S2V5IGlzIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHVuaXF1ZSBpZGVudGl0eSBvZiBhbiBlbnRpdHkuICBFbnRpdHlLZXkncyBhcmUgaW1tdXRhYmxlLlxyXG5cclxuXHJcbioqL1xyXG5leHBvcnQgY2xhc3MgRW50aXR5S2V5IHtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfJHR5cGVOYW1lOiBzdHJpbmc7IC8vIGFjdHVhbGx5IHBsYWNlZCBvbiBwcm90b3R5cGVcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBzdGF0aWMgRU5USVRZX0tFWV9ERUxJTUlURVIgPSBcIjo6OlwiO1xyXG4gIC8qKiAgVGhlICdFbnRpdHlUeXBlJyB0aGF0IHRoaXMgaXMgYSBrZXkgZm9yLiBfX1JlYWQgT25seV9fICovXHJcbiAgZW50aXR5VHlwZTogRW50aXR5VHlwZTtcclxuICAvKiogIEFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgZm9yIHRoaXMga2V5LiBUaGlzIHdpbGwgdXN1YWxseSBvbmx5IGhhdmUgYSBzaW5nbGUgZWxlbWVudCwgXHJcbiAgdW5sZXNzIHRoZSBlbnRpdHkgdHlwZSBoYXMgYSBtdWx0aXBhcnQga2V5LiBfX1JlYWQgT25seV9fICovXHJcbiAgdmFsdWVzOiBhbnlbXTtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfa2V5SW5Hcm91cDogc3RyaW5nO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9zdWJ0eXBlczogRW50aXR5VHlwZVtdO1xyXG5cclxuICAvKipcclxuICBDb25zdHJ1Y3RzIGEgbmV3IEVudGl0eUtleS4gIEVhY2ggZW50aXR5IHdpdGhpbiBhbiBFbnRpdHlNYW5hZ2VyIHdpbGwgaGF2ZSBhIHVuaXF1ZSBFbnRpdHlLZXkuXHJcbiAgPiAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgdmFyIGVtcFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiRW1wbG95ZWVcIik7XHJcbiAgPiAgICAgdmFyIGVudGl0eUtleSA9IG5ldyBFbnRpdHlLZXkoZW1wVHlwZSwgMSk7XHJcblxyXG4gIEVudGl0eUtleSdzIG1heSBhbHNvIGJlIGZvdW5kIGJ5IGNhbGxpbmcgRW50aXR5QXNwZWN0LmdldEtleSgpXHJcbiAgPiAgICAgLy8gYXNzdW1lIGVtcGxveWVlMSBpcyBhbiBleGlzdGluZyBFbXBsb3llZSBlbnRpdHlcclxuICA+ICAgICB2YXIgZW1wS2V5ID0gZW1wbG95ZWUxLmVudGl0eUFzcGVjdC5nZXRLZXkoKTtcclxuXHJcbiAgTXVsdGlwYXJ0IGtleXMgYXJlIGNyZWF0ZWQgYnkgcGFzc2luZyBhbiBhcnJheSBhcyB0aGUgJ2tleVZhbHVlcycgcGFyYW1ldGVyXHJcbiAgPiAgICAgdmFyIGVtcFRlcnJUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkVtcGxveWVlVGVycml0b3J5XCIpO1xyXG4gID4gICAgIHZhciBlbXBUZXJyS2V5ID0gbmV3IEVudGl0eUtleShlbXBUZXJyVHlwZSwgWyAxLCA3N10pO1xyXG4gID4gICAgIC8vIFRoZSBvcmRlciBvZiB0aGUgcHJvcGVydGllcyBpbiB0aGUgJ2tleVZhbHVlcycgYXJyYXkgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGF0XHJcbiAgPiAgICAgLy8gcmV0dXJuZWQgYnkgZW1wVGVyclR5cGUua2V5UHJvcGVydGllc1xyXG4gIEBwYXJhbSBlbnRpdHlUeXBlIC0gVGhlIFtbRW50aXR5VHlwZV1dIG9mIHRoZSBlbnRpdHkuXHJcbiAgQHBhcmFtIGtleVZhbHVlcyAtIEEgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcy4gXHJcbiAgKi9cclxuICBjb25zdHJ1Y3RvcihlbnRpdHlUeXBlOiBFbnRpdHlUeXBlLCBrZXlWYWx1ZXM6IGFueSkge1xyXG4gICAgYXNzZXJ0UGFyYW0oZW50aXR5VHlwZSwgXCJlbnRpdHlUeXBlXCIpLmlzSW5zdGFuY2VPZihFbnRpdHlUeXBlKS5jaGVjaygpO1xyXG4gICAgbGV0IHN1YnR5cGVzID0gZW50aXR5VHlwZS5nZXRTZWxmQW5kU3VidHlwZXMoKTtcclxuICAgIGlmIChzdWJ0eXBlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHRoaXMuX3N1YnR5cGVzID0gc3VidHlwZXMuZmlsdGVyKGZ1bmN0aW9uIChzdCkge1xyXG4gICAgICAgIHJldHVybiBzdC5pc0Fic3RyYWN0ID09PSBmYWxzZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGtleVZhbHVlcykpIHtcclxuICAgICAga2V5VmFsdWVzID0gW2tleVZhbHVlc107XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lbnRpdHlUeXBlID0gZW50aXR5VHlwZTtcclxuICAgIGVudGl0eVR5cGUua2V5UHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChrcCwgaSkge1xyXG4gICAgICAvLyBpbnN1cmUgdGhhdCBndWlkIGtleXMgYXJlIGNvbXBhcmFibGUuXHJcbiAgICAgIGlmIChrcC5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuR3VpZCkge1xyXG4gICAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlc1tpXSAmJiBrZXlWYWx1ZXNbaV0udG9Mb3dlckNhc2UgPyBrZXlWYWx1ZXNbaV0udG9Mb3dlckNhc2UoKSA6IGtleVZhbHVlc1tpXTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy52YWx1ZXMgPSBrZXlWYWx1ZXM7XHJcbiAgICB0aGlzLl9rZXlJbkdyb3VwID0gRW50aXR5S2V5LmNyZWF0ZUtleVN0cmluZyhrZXlWYWx1ZXMpO1xyXG5cclxuICB9XHJcblxyXG5cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBlbnRpdHlUeXBlOiB0aGlzLmVudGl0eVR5cGUubmFtZSxcclxuICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlc1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uOiBhbnksIG1ldGFkYXRhU3RvcmU6IE1ldGFkYXRhU3RvcmUpIHtcclxuICAgIGxldCBldCA9IG1ldGFkYXRhU3RvcmUuX2dldFN0cnVjdHVyYWxUeXBlKGpzb24uZW50aXR5VHlwZSwgdHJ1ZSkgYXMgRW50aXR5VHlwZTtcclxuICAgIHJldHVybiBuZXcgRW50aXR5S2V5KGV0LCBqc29uLnZhbHVlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBVc2VkIHRvIGNvbXBhcmUgRW50aXR5S2V5cyBhcmUgZGV0ZXJtaW5lIGlmIHRoZXkgcmVmZXIgdG8gdGhlIHNhbWUgRW50aXR5LlxyXG4gIFRoZXJlIGlzIGFsc28gYW4gc3RhdGljIHZlcnNpb24gb2YgJ2VxdWFscycgd2l0aCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LlxyXG4gIFxyXG4gID4gICAgICAvLyBhc3N1bWUgZW0xIGlzIGFuIEVudGl0eU1hbmFnZXIgY29udGFpbmluZyBhIG51bWJlciBvZiBleGlzdGluZyBlbnRpdGllcy5cclxuICA+ICAgICAgdmFyIGVtcFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiRW1wbG95ZWVcIik7XHJcbiAgPiAgICAgIHZhciBlbXBLZXkxID0gbmV3IEVudGl0eUtleShlbXBUeXBlLCAxKTtcclxuICA+ICAgICAgLy8gYXNzdW1lIGVtcGxveWVlMSBpcyBhbiBleGlzdGluZyBFbXBsb3llZSBlbnRpdHlcclxuICA+ICAgICAgdmFyIGVtcEtleTIgPSBlbXBsb3llZTEuZW50aXR5QXNwZWN0LmdldEtleSgpO1xyXG4gID4gICAgICBpZiAoZW1wS2V5MS5lcXVhbHMoZW1wS2V5MikpIHtcclxuICA+ICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyAgLi4uXHJcbiAgPiAgICAgIH1cclxuICAqKi9cclxuICBlcXVhbHMoZW50aXR5S2V5OiBFbnRpdHlLZXkpOiBib29sZWFuIHtcclxuICAgIGlmICghKGVudGl0eUtleSBpbnN0YW5jZW9mIEVudGl0eUtleSkpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiAodGhpcy5lbnRpdHlUeXBlID09PSBlbnRpdHlLZXkuZW50aXR5VHlwZSkgJiZcclxuICAgICAgY29yZS5hcnJheUVxdWFscyh0aGlzLnZhbHVlcywgZW50aXR5S2V5LnZhbHVlcyk7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIFJldHVybnMgYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEVudGl0eUtleS5cclxuICAqL1xyXG4gIHRvU3RyaW5nKGFsdEVudGl0eVR5cGU/OiBFbnRpdHlUeXBlKSB7XHJcbiAgICByZXR1cm4gKGFsdEVudGl0eVR5cGUgfHwgdGhpcy5lbnRpdHlUeXBlKS5uYW1lICsgJy0nICsgdGhpcy5fa2V5SW5Hcm91cDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFVzZWQgdG8gY29tcGFyZSBFbnRpdHlLZXlzIGFyZSBkZXRlcm1pbmUgaWYgdGhleSByZWZlciB0byB0aGUgc2FtZSBFbnRpdHkuXHJcbiAgVGhlcmUgaXMgYWxzbyBhbiBpbnN0YW5jZSB2ZXJzaW9uIG9mICdlcXVhbHMnIHdpdGggdGhlIHNhbWUgZnVuY3Rpb25hbGl0eS5cclxuICA+ICAgICAgLy8gYXNzdW1lIGVtMSBpcyBhbiBFbnRpdHlNYW5hZ2VyIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgZXhpc3RpbmcgZW50aXRpZXMuXHJcbiAgPiAgICAgIHZhciBlbXBUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkVtcGxveWVlXCIpO1xyXG4gID4gICAgICB2YXIgZW1wS2V5MSA9IG5ldyBFbnRpdHlLZXkoZW1wVHlwZSwgMSk7XHJcbiAgPiAgICAgIC8vIGFzc3VtZSBlbXBsb3llZTEgaXMgYW4gZXhpc3RpbmcgRW1wbG95ZWUgZW50aXR5XHJcbiAgPiAgICAgIHZhciBlbXBLZXkyID0gZW1wbG95ZWUxLmVudGl0eUFzcGVjdC5nZXRLZXkoKTtcclxuICA+ICAgICAgaWYgKEVudGl0eUtleS5lcXVhbHMoZW1wS2V5MSwgZW1wS2V5MikpIHtcclxuICA+ICAgICAgICAgIC8vIGRvIHNvbWV0aGluZyAgLi4uXHJcbiAgPiAgICAgIH1cclxuICAqKi9cclxuICBzdGF0aWMgZXF1YWxzKGsxOiBFbnRpdHlLZXksIGsyOiBFbnRpdHlLZXkpIHtcclxuICAgIGlmICghKGsxIGluc3RhbmNlb2YgRW50aXR5S2V5KSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIGsxLmVxdWFscyhrMik7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICAvLyBUT0RPOiB3ZSBtYXkgd2FudCB0byBjb21wYXJlIHRvIGRlZmF1bHQgdmFsdWVzIGxhdGVyLlxyXG4gIF9pc0VtcHR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWVzLmpvaW4oXCJcIikubGVuZ3RoID09PSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqIGhpZGRlbiAqL1xyXG4gIC8vIFRPRE86IHRoaW5rIGFib3V0IGdpdmluZyBfIHByZWZpeCBvciBkb2N1bWVudGluZy5cclxuICBzdGF0aWMgY3JlYXRlS2V5U3RyaW5nKGtleVZhbHVlczogYW55W10pIHtcclxuICAgIHJldHVybiBrZXlWYWx1ZXMuam9pbihFbnRpdHlLZXkuRU5USVRZX0tFWV9ERUxJTUlURVIpO1xyXG4gIH1cclxuXHJcbn1cclxuRW50aXR5S2V5LnByb3RvdHlwZS5fJHR5cGVOYW1lID0gXCJFbnRpdHlLZXlcIjtcclxuXHJcblxyXG4iXX0=