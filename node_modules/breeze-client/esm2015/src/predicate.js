import { core } from './core';
import { EntityType, DataProperty } from './entity-metadata';
import { DataType } from './data-type';
import { EntityAspect } from './entity-aspect';
/**
Used to define a 'where' predicate for an [[EntityQuery]].  Predicates are immutable, which means that any
method that would modify a Predicate actually returns a new Predicate.
**/
export class Predicate {
    /**
    Predicate constructor
    >     let p1 = new Predicate("CompanyName", "StartsWith", "B");
    >     let query = new EntityQuery("Customers").where(p1);
  
    or
    >     let p2 = new Predicate("Region", FilterQueryOp.Equals, null);
    >     let query = new EntityQuery("Customers").where(p2);
    @param property - A property name, a nested property name or an expression involving a property name.
    @param operator -
    @param value - This will be treated as either a property expression or a literal depending on context.  In general,
    if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal.
    In most cases this works well, but you can also force the interpretation by making the value argument itself an object with a 'value'
    property and an 'isLiteral' property set to either true or false.  Breeze also tries to infer the dataType of any
    literal based on context, if this fails you can force this inference by making the value argument an object with a
    'value' property and a 'dataType' property set to one of the breeze.DataType enumeration instances.
    **/
    constructor(...args) {
        if (args.length === 0)
            return;
        if (!(this instanceof Predicate)) {
            return new Predicate(...args);
        }
        return Predicate.create(...args);
    }
    /**
    Same as using the ctor.
    >      // so
    >      let p = Predicate.create(a, b, c);
    >      // is the same as
    >      let p = new Predicate(a, b, c);
    @param property -  A property name, a nested property name or an expression involving a property name.
    @param operator - the filter query operator.
    @param value - This will be treated as either a property expression or a literal depending on context.  In general,
    if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal.
    In most cases this works well, but you can also force the interpretation by making the value argument itself an object with a 'value'
    property and an 'isLiteral' property set to either true or false.  Breeze also tries to infer the dataType of any
    literal based on context, if this fails you can force this inference by making the value argument an object with a
    'value' property and a 'dataType' property set to one of the breeze.DataType enumeration instances.
    **/
    static create(...args) {
        // can be called from std javascript without new ( legacy )
        // empty ctor is used by all subclasses.
        if (args.length === 0)
            return new Predicate();
        if (args.length === 1) {
            // possibilities:
            //      Predicate([ aPredicate ]) or  Predicate(["freight", ">", 100]) - an array
            //      Predicate(aPredicate) - a predicate
            //      Predicate( "freight gt 100" }  // passthru ( i.e. maybe an odata string) - a string
            //      Predicate( { freight: { ">": 100 } }) - an object
            let arg = arguments[0];
            if (Array.isArray(arg)) {
                if (arg.length === 1) {
                    // recurse
                    return new Predicate(arg[0]);
                }
                else {
                    return createPredicateFromArray(arg);
                }
            }
            else if (arg instanceof Predicate) {
                return arg;
            }
            else if (typeof arg === 'string') {
                return new PassthruPredicate(arg);
            }
            else {
                return createPredicateFromObject(arg);
            }
        }
        else {
            // 2 possibilities
            //      Predicate("freight", ">", 100");
            //      Predicate("orders", "any", "freight",  ">", 950);
            return createPredicateFromArray(args);
        }
    }
    /** @hidden @internal */
    _validate(entityType, usesNameOnServer) {
        // noop here;
    }
    /**
    Creates a 'composite' Predicate by 'and'ing a set of specified Predicates together.
    >      let dt = new Date(88, 9, 12);
    >      let p1 = Predicate.create("OrderDate", "ne", dt);
    >      let p2 = Predicate.create("ShipCity", "startsWith", "C");
    >      let p3 = Predicate.create("Freight", ">", 100);
    >      let newPred = Predicate.and(p1, p2, p3);
  
    or
    >      let preds = [p1, p2, p3];
    >      let newPred = Predicate.and(preds);
    @param predicates - multiple Predicates or an array of Predicate.
    Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.
    **/
    static and(...args) {
        let pred = new AndOrPredicate("and", args);
        // TODO removed below
        // return undefined if empty
        // return pred.op && pred;
        return pred;
    }
    /**
    Creates a 'composite' Predicate by 'or'ing a set of specified Predicates together.
    >      let dt = new Date(88, 9, 12);
    >      let p1 = Predicate.create("OrderDate", "ne", dt);
    >      let p2 = Predicate.create("ShipCity", "startsWith", "C");
    >      let p3 = Predicate.create("Freight", ">", 100);
    >      let newPred = Predicate.or(p1, p2, p3);
  
    or
    >      let preds = [p1, p2, p3];
    >      let newPred = Predicate.or(preds);
    @param predicates - multiple Predicates or an array of Predicate.
    Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.
    **/
    static or(...args) {
        let pred = new AndOrPredicate("or", args);
        // return pred.op && pred;
        return pred;
    }
    /**
    Creates a 'composite' Predicate by 'negating' a specified predicate.
    >      let p1 = Predicate.create("Freight", "gt", 100);
    >      let not_p1 = Predicate.not(p1);
  
    This can also be accomplished using the 'instance' version of the 'not' method
    >      let not_p1 = p1.not();
  
    Both of which would be the same as
    >      let not_p1 = Predicate.create("Freight", "le", 100);
    **/
    static not(pred) {
        return pred.not();
    }
    // TODO: determine if/where this is used.
    // static extendBinaryPredicateFn(opMap: IOpMap, visitorFn: any) {
    //   let baseVisitorFn = toFunctionVisitor.binaryPredicate;
    //   for (let op in (opMap || {})) {
    //     let config = opMap[op];
    //     config.visitorFn = visitorFn;
    //     updateAliasMap(BinaryPredicate.prototype.aliasMap, op, opMap[op]);
    //   }
    //   if (!toFunctionVisitor.isExtended) {
    //     toFunctionVisitor.binaryPredicate = function (context, expr1Val, expr2Val) {
    //       let visitorFn = this.aliasMap[this.op.key].visitorFn;
    //       if (visitorFn) {
    //         return visitorFn(context, expr1Val, expr2Val);
    //       } else {
    //         return baseVisitorFn(context, expr1Val, expr2Val);
    //       }
    //     };
    //     toFunctionVisitor.isExtended = true;
    //   }
    // };
    /**
    'And's this Predicate with one or more other Predicates and returns a new 'composite' Predicate
    >      let dt = new Date(88, 9, 12);
    >      let p1 = Predicate.create("OrderDate", "ne", dt);
    >      let p2 = Predicate.create("ShipCity", "startsWith", "C");
    >      let p3 = Predicate.create("Freight", ">", 100);
    >      let newPred = p1.and(p2, p3);
  
    or
    >      let preds = [p2, p3];
    >      let newPred = p1.and(preds);
  
    The 'and' method is also used to write "fluent" expressions
    >      let p4 = Predicate.create("ShipCity", "startswith", "F")
    >        .and("Size", "gt", 2000);
    @param predicates - multiple Predicates or an array of Predicates.
    Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.
    **/
    and(...args) {
        return new AndOrPredicate("and", argsForAndOrPredicates(this, args));
    }
    /**
    'Or's this Predicate with one or more other Predicates and returns a new 'composite' Predicate
    >      let dt = new Date(88, 9, 12);
    >      let p1 = Predicate.create("OrderDate", "ne", dt);
    >      let p2 = Predicate.create("ShipCity", "startsWith", "C");
    >      let p3 = Predicate.create("Freight", ">", 100);
    >      let newPred = p1.or(p2, p3);
  
    or
    >      let preds = [p2, p3];
    >      let newPred = p1.or(preds);
  
    The 'or' method is also used to write "fluent" expressions
    >      let p4 = Predicate.create("ShipCity", "startswith", "F")
    >        .or("Size", "gt", 2000);
    @param predicates - multiple Predicates or an array of Predicates.
    Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.
    **/
    or(...args) {
        return new AndOrPredicate("or", argsForAndOrPredicates(this, args));
    }
    /**
    Returns the 'negated' version of this Predicate
    >      let p1 = Predicate.create("Freight", "gt", 100);
    >      let not_p1 = p1.not();
  
    This can also be accomplished using the 'static' version of the 'not' method
    >      let p1 = Predicate.create("Freight", "gt", 100);
    >      let not_p1 = Predicate.not(p1);
  
    which would be the same as
    >      let not_p1 = Predicate.create("Freight", "le", 100);
    **/
    not() {
        return new UnaryPredicate("not", this);
    }
    //
    toJSON() {
        // toJSON ( part of js standard - takes a single parameter
        // that is either "" or the name of the property being serialized.
        return this.toJSONExt({ entityType: this._entityType });
    }
    /** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
    @adapter (see [[IUriBuilderAdapter]])
    @hidden @internal
    */
    toJSONExt(context) {
        return this.visit(context, toJSONVisitor);
    }
    /** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
    @adapter (see [[IUriBuilderAdapter]])
    @hidden @internal
    */
    toFunction(context) {
        return this.visit(context, toFunctionVisitor);
    }
    toString() {
        return JSON.stringify(this);
    }
    /** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
    @adapter (see [[IUriBuilderAdapter]])
    @hidden @internal
    */
    visit(context, visitor) {
        if (core.isEmpty(context)) {
            context = { entityType: undefined };
        }
        else if (context instanceof EntityType) {
            context = { entityType: context };
        }
        else if (!core.hasOwnProperty(context, "entityType")) {
            throw new Error("All visitor methods must be called with a context object containing at least an 'entityType' property");
        }
        if (visitor) {
            context.visitor = visitor;
        }
        let tVisitor = visitor || context.visitor;
        let fn = tVisitor[this.visitorMethodName];
        if (fn == null) {
            throw new Error("Unable to locate method: " + this.visitorMethodName + " on visitor");
        }
        let entityType = context.entityType;
        // don't bother validating if already done so ( or if no _validate method
        if (this._validate && (entityType == null || this._entityType !== entityType)) {
            // don't need to capture return value because validation fn doesn't have one.
            // TODO: this was old code
            // this._validate(entityType, context.usesNameOnServer);
            this._validate(entityType, context.toNameOnServer);
            this._entityType = entityType;
        }
        return fn.call(this, context);
    }
    /** @hidden @internal */
    _initialize(visitorMethodName, opMap = {}) {
        this.visitorMethodName = visitorMethodName;
        let aliasMap = this.aliasMap = {};
        for (let op in opMap) {
            updateAliasMap(aliasMap, op, opMap[op]);
        }
    }
    /** @hidden @internal */
    _resolveOp(op, okIfNotFound) {
        let opStr = (typeof op === "string") ? op : op.operator;
        let result = this.aliasMap[opStr.toLowerCase()];
        if (!result && !okIfNotFound) {
            throw new Error("Unable to resolve operator: " + opStr);
        }
        return result;
    }
}
function createPredicateFromArray(arr) {
    // TODO: assert that length of the array should be > 3
    // Needs to handle:
    //      [ "freight", ">", 100"];
    //      [ "orders", "any", "freight",  ">", 950 ]
    //      [ "orders", "and", anotherPred ]
    //      [ "orders", "and", [ "freight, ">", 950 ]]
    let json = {};
    let value = {};
    json[arr[0]] = value;
    let op = arr[1];
    op = op.operator || op; // incoming op will be either a string or a FilterQueryOp
    if (arr.length === 3) {
        value[op] = arr[2];
    }
    else {
        value[op] = createPredicateFromArray(arr.splice(2));
    }
    return createPredicateFromObject(json);
}
function createPredicateFromObject(obj) {
    if (obj instanceof Predicate)
        return obj;
    if (typeof obj !== 'object') {
        throw new Error("Unable to convert to a Predicate: " + obj);
    }
    let keys = Object.keys(obj);
    let preds = keys.map(function (key) {
        return createPredicateFromKeyValue(key, obj[key]);
    });
    return (preds.length === 1) ? preds[0] : new AndOrPredicate("and", preds);
}
function createPredicateFromKeyValue(key, value) {
    // { and: [a,b] } key='and', value = [a,b]
    if (AndOrPredicate.prototype._resolveOp(key, true)) {
        return new AndOrPredicate(key, value);
    }
    // { not: a }  key= 'not', value = a
    if (UnaryPredicate.prototype._resolveOp(key, true)) {
        return new UnaryPredicate(key, value);
    }
    if ((typeof value !== 'object') || value == null || core.isDate(value)) {
        // { foo: bar } key='foo', value = bar ( where bar is a literal i.e. a string, a number, a boolean or a date.
        return new BinaryPredicate("eq", key, value);
    }
    else if (core.hasOwnProperty(value, 'value')) {
        // { foo: { value: bar, dataType: xxx} } key='foo', value = bar ( where bar is an object representing a literal
        return new BinaryPredicate("eq", key, value);
    }
    if (Array.isArray(value)) {
        throw new Error("Unable to resolve predicate after the phrase: " + key);
    }
    let expr = key;
    let keys = Object.keys(value);
    let preds = keys.map(function (op) {
        // { a: { any: b } op = 'any', expr=a, value[op] = b
        if (AnyAllPredicate.prototype._resolveOp(op, true)) {
            return new AnyAllPredicate(op, expr, value[op]);
        }
        if (BinaryPredicate.prototype._resolveOp(op, true)) {
            // { a: { ">": b }} op = ">", expr=a, value[op] = b
            return new BinaryPredicate(op, expr, value[op]);
        }
        else if (core.hasOwnProperty(value[op], 'value')) {
            // { a: { ">": { value: b, dataType: 'Int32' }} expr = a value[op] = { value: b, dataType: 'Int32' }
            return new BinaryPredicate("eq", expr, value[op]);
        }
        let msg = core.formatString("Unable to resolve predicate after the phrase: '%1' for operator: '%2'  and value: '%3'", expr, op, value[op]);
        throw new Error(msg);
    });
    return (preds.length === 1) ? preds[0] : new AndOrPredicate("and", preds);
}
function argsForAndOrPredicates(obj, args) {
    let preds = args[0];
    if (preds instanceof Predicate) {
        preds = core.arraySlice(args);
    }
    else if (!Array.isArray(preds)) {
        preds = [new Predicate(core.arraySlice(args))];
    }
    return [obj].concat(preds);
}
function updateAliasMap(aliasMap, opStr, op) {
    let key = opStr.toLowerCase();
    op.key = key;
    aliasMap[key] = op;
    op.aliases && op.aliases.forEach((alias) => {
        aliasMap[alias.toLowerCase()] = op;
    });
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden @internal
*/
class PassthruPredicate extends Predicate {
    constructor(value) {
        super();
        this.value = value;
    }
}
Error['x'] = PassthruPredicate.prototype._initialize('passthruPredicate');
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export class UnaryPredicate extends Predicate {
    constructor(op, ...args) {
        super();
        this.op = this._resolveOp(op);
        this.pred = new Predicate(args);
    }
    _validate(entityType, usesNameOnServer) {
        this.pred._validate(entityType, usesNameOnServer);
    }
}
Error['x'] = UnaryPredicate.prototype._initialize('unaryPredicate', {
    'not': { aliases: ['!', '~'] },
});
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export class BinaryPredicate extends Predicate {
    constructor(op, expr1, expr2) {
        super();
        // 5 public props op, expr1Source, expr2Source, expr1, expr2
        this.op = this._resolveOp(op);
        this.expr1Source = expr1;
        this.expr2Source = expr2;
        // this.expr1 and this.expr2 won't be
        // determined until validate is run
    }
    _validate(entityType, usesNameOnServer) {
        let expr1Context = { entityType: entityType, usesNameOnServer: usesNameOnServer };
        this.expr1 = createExpr(this.expr1Source, expr1Context);
        if (this.expr1 == null) {
            throw new Error("Unable to validate 1st expression: " + this.expr1Source);
        }
        if (this.expr1 instanceof LitExpr) {
            // lhs must be either a property or a function.
            throw new Error("The left hand side of a binary predicate cannot be a literal expression, it must be a valid property or functional predicate expression: " + this.expr1Source);
        }
        if (this.op.key === 'in' && !Array.isArray(this.expr2Source)) {
            throw new Error("The 'in' operator requires that its right hand argument be an array");
        }
        let expr2Context = core.extend(expr1Context, { isRHS: true, dataType: this.expr1.dataType });
        this.expr2 = createExpr(this.expr2Source, expr2Context);
        if (this.expr2 == null) {
            throw new Error("Unable to validate 2nd expression: " + this.expr2Source);
        }
        if (this.expr1.dataType == null) {
            this.expr1.dataType = this.expr2.dataType;
        }
    }
}
Error['x'] = BinaryPredicate.prototype._initialize('binaryPredicate', {
    'eq': {
        aliases: ["==", "equals"]
    },
    'ne': {
        aliases: ["!=", "~=", "notequals"]
    },
    'lt': {
        aliases: ["<", "lessthan"]
    },
    'le': {
        aliases: ["<=", "lessthanorequal"]
    },
    'gt': {
        aliases: [">", "greaterthan"]
    },
    'ge': {
        aliases: [">=", "greaterthanorequal"]
    },
    'startswith': {
        isFunction: true
    },
    'endswith': {
        isFunction: true
    },
    'contains': {
        aliases: ["substringof"],
        isFunction: true
    },
    'in': {}
});
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export class AndOrPredicate extends Predicate {
    constructor(op, preds) {
        super();
        this.op = this._resolveOp(op);
        if (preds.length === 1 && Array.isArray(preds[0])) {
            preds = preds[0];
        }
        this.preds = preds.filter(function (pred) {
            return pred != null;
        }).map(function (pred) {
            return new Predicate(pred);
        });
        // TODO: this was removed - test if really needed.
        // if (this.preds.length === 0) {
        //   // marker for an empty predicate
        //   this.op = null;
        // }
        if (this.preds.length === 1) {
            return this.preds[0]; // HACK: this.preds[0] is actually NOT a AndOrPredicate but some other kind of pred.
        }
    }
    _validate(entityType, usesNameOnServer) {
        this.preds.forEach((pred) => {
            pred._validate(entityType, usesNameOnServer);
        });
    }
}
Error['x'] = AndOrPredicate.prototype._initialize("andOrPredicate", {
    'and': { aliases: ['&&'] },
    'or': { aliases: ['||'] }
});
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export class AnyAllPredicate extends Predicate {
    // 4 public props: op, exprSource, expr, pred
    constructor(op, expr, pred) {
        super();
        this.op = this._resolveOp(op);
        this.exprSource = expr;
        // this.expr will not be resolved until validate is called
        this.pred = new Predicate(pred);
    }
    _validate(entityType, usesNameOnServer) {
        this.expr = createExpr(this.exprSource, { entityType: entityType, usesNameOnServer: usesNameOnServer });
        // can't really know the predicateEntityType unless the original entity type was known.
        if (entityType == null || entityType.isAnonymous) {
            this.expr.dataType = undefined;
        }
        this.pred._validate(this.expr.dataType, usesNameOnServer);
    }
}
Error['x'] = AnyAllPredicate.prototype._initialize("anyAllPredicate", {
    'any': { aliases: ['some'] },
    'all': { aliases: ["every"] }
});
/** @hidden */
export class PredicateExpression {
    constructor(visitorMethodName) {
        this.visitorMethodName = visitorMethodName;
        // give expressions the Predicate prototype method
        this.visit = Predicate.prototype.visit;
    }
    // default impls - may/will be overridden be subclass expressions
    _validate(entityType, usesNameOnServer) {
        // noop;
    }
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export class LitExpr extends PredicateExpression {
    // 2 public props: value, dataType
    constructor(value, dataType, hasExplicitDataType) {
        super("litExpr");
        // dataType may come is an a string
        let dt1 = resolveDataType(dataType);
        // if the DataType comes in as Undefined this means
        // that we should NOT attempt to parse it but just leave it alone
        // for now - this is usually because it is part of a Func expr.
        // TODO: cast as DataType seems to be needed by early version of TypeDoc - may be able to remove later
        let dt2 = (dt1 || DataType.fromValue(value));
        if (dt2.parse) {
            if (Array.isArray(value)) {
                this.value = value.map((v) => { return dt2.parse(v, typeof v); });
            }
            else {
                this.value = dt2.parse(value, typeof value);
            }
        }
        else {
            this.value = value;
        }
        this.dataType = dt2;
        this.hasExplicitDataType = !!hasExplicitDataType;
    }
    toString() {
        return " LitExpr - value: " + this.value.toString() + " dataType: " + this.dataType.toString();
    }
}
function resolveDataType(dataType) {
    if (dataType == null)
        return dataType;
    // if (DataType.contains(dataType)) {
    if (dataType instanceof DataType) {
        return dataType;
    }
    if (typeof dataType === 'string') {
        let dt = DataType.fromName(dataType);
        if (dt)
            return dt;
        throw new Error("Unable to resolve a dataType named: " + dataType);
    }
    throw new Error("The dataType parameter passed into this literal expression is not a 'DataType'" + dataType);
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export class PropExpr extends PredicateExpression {
    // two public props: propertyPath, dateType
    constructor(propertyPath) {
        super('propExpr');
        this.propertyPath = propertyPath;
        //this.dataType = DataType.Undefined;
        // this.dataType resolved after validate ( if not on an anon type }
    }
    toString() {
        return " PropExpr - " + this.propertyPath;
    }
    _validate(entityType, usesNameOnServer) {
        if (entityType == null || entityType.isAnonymous)
            return;
        let props = entityType.getPropertiesOnPath(this.propertyPath, null, false);
        if (!props) {
            let msg = core.formatString("Unable to resolve propertyPath.  EntityType: '%1'   PropertyPath: '%2'", entityType.name, this.propertyPath);
            throw new Error(msg);
        }
        // get the last property
        let prop = props[props.length - 1];
        if (prop instanceof DataProperty) {
            this.dataType = prop.dataType;
        }
        else {
            this.dataType = prop.entityType;
        }
    }
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden @dynamic
*/
export class FnExpr extends PredicateExpression {
    constructor(fnName, exprs) {
        super('fnExpr');
        // 4 public props: fnName, exprs, localFn, dataType
        this.fnName = fnName;
        this.exprs = exprs;
        let qf = FnExpr._funcMap[fnName];
        if (qf == null) {
            throw new Error("Unknown function: " + fnName);
        }
        this.localFn = qf.fn;
        this.dataType = qf.dataType;
    }
    toString() {
        let exprStr = this.exprs.map(function (expr) {
            expr.toString();
        }).toString();
        return "FnExpr - " + this.fnName + "(" + exprStr + ")";
    }
    _validate(entityType, usesNameOnServer) {
        this.exprs.forEach(function (expr) {
            expr._validate(entityType, usesNameOnServer);
        });
    }
}
FnExpr._funcMap = {
    toupper: {
        fn: function (source) {
            return source.toUpperCase();
        }, dataType: DataType.String
    },
    tolower: {
        fn: function (source) {
            return source.toLowerCase();
        }, dataType: DataType.String
    },
    substring: {
        fn: function (source, pos, length) {
            return source.substring(pos, length);
        }, dataType: DataType.String
    },
    substringof: {
        fn: function (find, source) {
            return source.indexOf(find) >= 0;
        }, dataType: DataType.Boolean
    },
    length: {
        fn: function (source) {
            return source.length;
        }, dataType: DataType.Int32
    },
    trim: {
        fn: function (source) {
            return source.trim();
        }, dataType: DataType.String
    },
    concat: {
        fn: function (s1, s2) {
            return s1.concat(s2);
        }, dataType: DataType.String
    },
    replace: {
        fn: function (source, find, replace) {
            return source.replace(find, replace);
        }, dataType: DataType.String
    },
    startswith: {
        fn: function (source, find) {
            return core.stringStartsWith(source, find);
        }, dataType: DataType.Boolean
    },
    endswith: {
        fn: function (source, find) {
            return core.stringEndsWith(source, find);
        }, dataType: DataType.Boolean
    },
    indexof: {
        fn: function (source, find) {
            return source.indexOf(find);
        }, dataType: DataType.Int32
    },
    round: {
        fn: function (source) {
            return Math.round(source);
        }, dataType: DataType.Int32
    },
    ceiling: {
        fn: function (source) {
            return Math.ceil(source);
        }, dataType: DataType.Int32
    },
    floor: {
        fn: function (source) {
            return Math.floor(source);
        }, dataType: DataType.Int32
    },
    second: {
        fn: function (source) {
            return source.getSeconds();
        }, dataType: DataType.Int32
    },
    minute: {
        fn: function (source) {
            return source.getMinutes();
        }, dataType: DataType.Int32
    },
    day: {
        fn: function (source) {
            return source.getDate();
        }, dataType: DataType.Int32
    },
    month: {
        fn: function (source) {
            return source.getMonth() + 1;
        }, dataType: DataType.Int32
    },
    year: {
        fn: function (source) {
            return source.getFullYear();
        }, dataType: DataType.Int32
    }
};
// TODO: add dataTypes for the args next - will help to infer other dataTypes.
let RX_IDENTIFIER = /^[a-z_][\w.$]*$/i;
// comma delimited expressions ignoring commas inside of both single and double quotes.
let RX_COMMA_DELIM1 = /('[^']*'|[^,]+)/g;
let RX_COMMA_DELIM2 = /("[^"]*"|[^,]+)/g;
let DELIM = String.fromCharCode(191);
function createExpr(source, exprContext) {
    let entityType = exprContext.entityType;
    // the right hand side of an 'in' clause
    if (Array.isArray(source)) {
        if (!exprContext.isRHS) {
            throw new Error("Array expressions are only permitted on the right hand side of a BinaryPredicate");
        }
        return new LitExpr(source, exprContext.dataType);
    }
    if (!(typeof source === 'string')) {
        if (source != null && typeof source === 'object' && !source.toISOString) {
            // source is an object but not a Date-like thing such as a JS or MomentJS Date
            if (source.value === undefined) {
                throw new Error("Unable to resolve an expression for: " + source + " on entityType: " + (entityType ? entityType.name : 'null'));
            }
            if (source.isProperty) {
                return new PropExpr(source.value);
            }
            else {
                // we want to insure that any LitExpr created this way is tagged with 'hasExplicitDataType: true'
                // because we want to insure that if we roundtrip thru toJSON that we don't
                // accidentally reinterpret this node as a PropExpr.
                // return new LitExpr(source.value, source.dataType || context.dataType, !!source.dataType);
                return new LitExpr(source.value, source.dataType || exprContext.dataType, true);
            }
        }
        else {
            return new LitExpr(source, exprContext.dataType);
        }
    }
    if (exprContext.isRHS) {
        if (entityType == null || entityType.isAnonymous) {
            // if entityType is unknown then assume that the rhs is a literal
            return new LitExpr(source, exprContext.dataType);
        }
        else {
            return parseLitOrPropExpr(source, exprContext);
        }
    }
    else {
        let regex = /\([^()]*\)/;
        let m;
        let tokens = [];
        let i = 0;
        while (m = regex.exec(source)) {
            let token = m[0];
            tokens.push(token);
            let repl = DELIM + i++;
            source = source.replace(token, repl);
        }
        let expr = parseExpr(source, tokens, exprContext);
        expr._validate(entityType, exprContext.usesNameOnServer);
        return expr;
    }
}
function parseExpr(source, tokens, exprContext) {
    let parts = source.split(DELIM);
    if (parts.length === 1) {
        return parseLitOrPropExpr(parts[0], exprContext);
    }
    else {
        return parseFnExpr(source, parts, tokens, exprContext);
    }
}
function parseLitOrPropExpr(value, exprContext) {
    value = value.trim();
    // value is either a string, a quoted string, a number, a bool value, or a date
    // if a string ( not a quoted string) then this represents a property name ( 1st ) or a lit string ( 2nd)
    let firstChar = value.substr(0, 1);
    let isQuoted = (firstChar === "'" || firstChar === '"') && value.length > 1 && value.substr(value.length - 1) === firstChar;
    if (isQuoted) {
        let unquotedValue = value.substr(1, value.length - 2);
        return new LitExpr(unquotedValue, exprContext.dataType || DataType.String);
    }
    else {
        let entityType = exprContext.entityType;
        // TODO: get rid of isAnonymous below when we get the chance.
        if (entityType == null || entityType.isAnonymous) {
            // this fork will only be reached on the LHS of an BinaryPredicate -
            // a RHS expr cannot get here with an anon type
            return new PropExpr(value);
        }
        else {
            let mayBeIdentifier = RX_IDENTIFIER.test(value);
            if (mayBeIdentifier) {
                // if (entityType.getProperty(value, false) != null) {
                if (entityType.getPropertiesOnPath(value, null, false) != null) {
                    return new PropExpr(value);
                }
            }
        }
        // we don't really know the datatype here because even though it comes in as a string
        // its usually a string BUT it might be a number  i.e. the "1" or the "2" from an expr
        // like "toUpper(substring(companyName, 1, 2))"
        return new LitExpr(value, exprContext.dataType);
    }
}
function parseFnExpr(source, parts, tokens, exprContext) {
    try {
        let fnName = parts[0].trim().toLowerCase();
        let argSource = tokens[parts[1]].trim();
        if (argSource.substr(0, 1) === "(") {
            argSource = argSource.substr(1, argSource.length - 2);
        }
        let commaMatchStr = source.indexOf("'") >= 0 ? RX_COMMA_DELIM1 : RX_COMMA_DELIM2;
        let args = argSource.match(commaMatchStr);
        let newContext = core.extend({}, exprContext);
        // a dataType of Undefined on a context basically means not to try parsing
        // the value if the expr is a literal
        newContext.dataType = DataType.Undefined;
        newContext.isFnArg = true;
        let exprs = args.map(function (a) {
            return parseExpr(a, tokens, newContext);
        });
        return new FnExpr(fnName, exprs);
    }
    catch (e) {
        // TODO: removed old code here
        // return null;
        // and replaced with 
        throw e;
    }
}
const ɵ0 = function () {
    throw new Error("Cannot execute an PassthruPredicate expression against the local cache: " + this.value);
}, ɵ1 = function (context) {
    let predFn = this.pred.visit(context);
    switch (this.op.key) {
        case "not":
            return function (entity) {
                return !predFn(entity);
            };
        default:
            throw new Error("Invalid unary operator:" + this.op.key);
    }
}, ɵ2 = function (context) {
    let expr1Fn = this.expr1.visit(context);
    let expr2Fn = this.expr2.visit(context);
    let dataType = this.expr1.dataType || this.expr2.dataType;
    let lqco = context.entityType.metadataStore.localQueryComparisonOptions;
    let predFn = getBinaryPredicateFn(this, dataType, lqco);
    if (predFn == null) {
        throw new Error("Invalid binaryPredicate operator:" + this.op.key);
    }
    return function (entity) {
        return predFn(expr1Fn(entity), expr2Fn(entity));
    };
}, ɵ3 = function (context) {
    let predFns = this.preds.map((pred) => {
        return pred.visit(context);
    });
    switch (this.op.key) {
        case "and":
            return function (entity) {
                let result = predFns.reduce(function (prev, cur) {
                    return prev && cur(entity);
                }, true);
                return result;
            };
        case "or":
            return function (entity) {
                let result = predFns.reduce(function (prev, cur) {
                    return prev || cur(entity);
                }, false);
                return result;
            };
        default:
            throw new Error("Invalid boolean operator:" + this.op.key);
    }
}, ɵ4 = function (context) {
    let exprFn = this.expr.visit(context);
    let newContext = core.extend({}, context);
    newContext.entityType = this.expr.dataType;
    let predFn = this.pred.visit(newContext);
    let anyAllPredFn = getAnyAllPredicateFn(this.op);
    return function (entity) {
        return anyAllPredFn(exprFn(entity), predFn);
    };
}, ɵ5 = function () {
    let value = this.value;
    return function (entity) {
        return value;
    };
}, ɵ6 = function () {
    let propertyPath = this.propertyPath;
    let properties = propertyPath.split('.');
    if (properties.length === 1) {
        return function (entity) {
            return entity.getProperty(propertyPath);
        };
    }
    else {
        return function (entity) {
            return EntityAspect.getPropertyPathValue(entity, properties);
        };
    }
}, ɵ7 = function (context) {
    let exprFns = this.exprs.map(function (expr) {
        return expr.visit(context);
    });
    let that = this;
    return function (entity) {
        let values = exprFns.map(function (exprFn) {
            let value = exprFn(entity);
            return value;
        });
        let result = that.localFn.apply(null, values);
        return result;
    };
};
// toFunctionVisitor
let toFunctionVisitor = {
    isExtended: false,
    passthruPredicate: ɵ0,
    unaryPredicate: ɵ1,
    binaryPredicate: ɵ2,
    andOrPredicate: ɵ3,
    anyAllPredicate: ɵ4,
    litExpr: ɵ5,
    propExpr: ɵ6,
    fnExpr: ɵ7
};
function getAnyAllPredicateFn(op) {
    switch (op.key) {
        case "any":
            return function (v1, v2) {
                return v1.some(function (v) {
                    return v2(v);
                });
            };
        case "all":
            return function (v1, v2) {
                return v1.every(function (v) {
                    return v2(v);
                });
            };
        default:
            throw new Error("Unknown operator: " + op.key);
    }
}
function getBinaryPredicateFn(binaryPredicate, dataType, lqco) {
    let op = binaryPredicate.op;
    let mc = DataType.getComparableFn(dataType);
    let predFn;
    switch (op.key) {
        case 'eq':
            predFn = function (v1, v2) {
                if (v1 && typeof v1 === 'string') {
                    return stringEquals(v1, v2, lqco);
                }
                else {
                    return mc(v1) === mc(v2);
                }
            };
            break;
        case 'ne':
            predFn = function (v1, v2) {
                if (v1 && typeof v1 === 'string') {
                    return !stringEquals(v1, v2, lqco);
                }
                else {
                    return mc(v1) !== mc(v2);
                }
            };
            break;
        case 'gt':
            predFn = function (v1, v2) {
                return mc(v1) > mc(v2);
            };
            break;
        case 'ge':
            predFn = function (v1, v2) {
                return mc(v1) >= mc(v2);
            };
            break;
        case 'lt':
            predFn = function (v1, v2) {
                return mc(v1) < mc(v2);
            };
            break;
        case 'le':
            predFn = function (v1, v2) {
                return mc(v1) <= mc(v2);
            };
            break;
        case 'startswith':
            predFn = function (v1, v2) {
                return stringStartsWith(v1, v2, lqco);
            };
            break;
        case 'endswith':
            predFn = function (v1, v2) {
                return stringEndsWith(v1, v2, lqco);
            };
            break;
        case 'contains':
            predFn = function (v1, v2) {
                return stringContains(v1, v2, lqco);
            };
            break;
        case 'in':
            predFn = function (v1, v2) {
                v1 = mc(v1);
                v2 = v2.map(function (v) { return mc(v); });
                return v2.indexOf(v1) >= 0;
            };
            break;
        default:
            return null;
    }
    return predFn;
}
function stringEquals(a, b, lqco) {
    if (b == null)
        return false;
    if (typeof b !== 'string') {
        b = b.toString();
    }
    if (lqco.usesSql92CompliantStringComparison) {
        a = (a || "").trim();
        b = (b || "").trim();
    }
    if (!lqco.isCaseSensitive) {
        a = (a || "").toLowerCase();
        b = (b || "").toLowerCase();
    }
    return a === b;
}
function stringStartsWith(a, b, lqco) {
    if (!lqco.isCaseSensitive) {
        a = (a || "").toLowerCase();
        b = (b || "").toLowerCase();
    }
    return core.stringStartsWith(a, b);
}
function stringEndsWith(a, b, lqco) {
    if (!lqco.isCaseSensitive) {
        a = (a || "").toLowerCase();
        b = (b || "").toLowerCase();
    }
    return core.stringEndsWith(a, b);
}
function stringContains(a, b, lqco) {
    if (!lqco.isCaseSensitive) {
        a = (a || "").toLowerCase();
        b = (b || "").toLowerCase();
    }
    return a.indexOf(b) >= 0;
}
const ɵ8 = function () {
    return this.value;
}, ɵ9 = function (context) {
    let predVal = this.pred.visit(context);
    let json = {};
    json[this.op.key] = predVal;
    return json;
}, ɵ10 = function (context) {
    let expr1Val = this.expr1.visit(context);
    let expr2Val = this.expr2.visit(context);
    let json = {};
    if (this.expr2 instanceof PropExpr) {
        expr2Val = { value: expr2Val, isProperty: true };
    }
    if (this.op.key === "eq") {
        json[expr1Val] = expr2Val;
    }
    else {
        let value = {};
        json[expr1Val] = value;
        value[this.op.key] = expr2Val;
    }
    return json;
}, ɵ11 = function (context) {
    let predVals = this.preds.map(function (pred) {
        return pred.visit(context);
    });
    if (!predVals || !predVals.length) {
        return {};
    }
    let json;
    // normalizeAnd clauses if possible.
    // passthru predicate will appear as string and their 'ands' can't be 'normalized'
    if (this.op.key === 'and' && predVals.length === 2 && !predVals.some((v) => typeof (v) === 'string')) {
        // normalize 'and' clauses - will return null if can't be combined.
        json = predVals.reduce(combine);
    }
    if (json == null) {
        json = {};
        json[this.op.key] = predVals;
    }
    return json;
}, ɵ12 = function (context) {
    let exprVal = this.expr.visit(context);
    let newContext = core.extend({}, context);
    newContext.entityType = this.expr.dataType;
    let predVal = this.pred.visit(newContext);
    let json = {};
    let value = {};
    value[this.op.key] = predVal;
    json[exprVal] = value;
    return json;
}, ɵ13 = function (context) {
    if (this.hasExplicitDataType || context.useExplicitDataType) {
        return { value: this.value, dataType: this.dataType.name };
    }
    else {
        return this.value;
    }
}, ɵ14 = function (context) {
    if (context.toNameOnServer) {
        return context.entityType.clientPropertyPathToServer(this.propertyPath);
    }
    else {
        return this.propertyPath;
    }
}, ɵ15 = function (context) {
    let exprVals = this.exprs.map(function (expr) {
        return expr.visit(context);
    });
    return this.fnName + "(" + exprVals.join(",") + ")";
};
// toJSONVisitor
let toJSONVisitor = {
    passthruPredicate: ɵ8,
    unaryPredicate: ɵ9,
    binaryPredicate: ɵ10,
    andOrPredicate: ɵ11,
    anyAllPredicate: ɵ12,
    litExpr: ɵ13,
    propExpr: ɵ14,
    fnExpr: ɵ15
};
function combine(j1, j2) {
    let ok = Object.keys(j2).every(function (key) {
        if (j1.hasOwnProperty(key)) {
            if (typeof (j2[key]) !== 'object') {
                // exit and indicate that we can't combine
                return false;
            }
            if (combine(j1[key], j2[key]) == null) {
                return false;
            }
        }
        else {
            j1[key] = j2[key];
        }
        return true;
    });
    return ok ? j1 : null;
}
export { ɵ0, ɵ1, ɵ2, ɵ3, ɵ4, ɵ5, ɵ6, ɵ7, ɵ8, ɵ9, ɵ10, ɵ11, ɵ12, ɵ13, ɵ14, ɵ15 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlZGljYXRlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vYnJlZXplLWNsaWVudC8iLCJzb3VyY2VzIjpbInNyYy9wcmVkaWNhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUM5QixPQUFPLEVBQUUsVUFBVSxFQUFrQixZQUFZLEVBQUcsTUFBTSxtQkFBbUIsQ0FBQztBQUU5RSxPQUFPLEVBQUUsUUFBUSxFQUFHLE1BQU0sYUFBYSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxZQUFZLEVBQVUsTUFBTSxpQkFBaUIsQ0FBQztBQThDdkQ7OztHQUdHO0FBQ0gsTUFBTSxPQUFPLFNBQVM7SUFTcEI7Ozs7Ozs7Ozs7Ozs7Ozs7T0FnQkc7SUFDSCxZQUFZLEdBQUcsSUFBVztRQUN4QixJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQztZQUFFLE9BQU87UUFDOUIsSUFBSSxDQUFDLENBQUMsSUFBSSxZQUFZLFNBQVMsQ0FBQyxFQUFFO1lBQ2hDLE9BQU8sSUFBSSxTQUFTLENBQUMsR0FBUSxJQUFJLENBQUMsQ0FBQztTQUNwQztRQUNELE9BQU8sU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFRLElBQUksQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7T0FjRztJQUNILE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFXO1FBQzFCLDJEQUEyRDtRQUUzRCx3Q0FBd0M7UUFDeEMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUM7WUFBRSxPQUFPLElBQUksU0FBUyxFQUFFLENBQUM7UUFDOUMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNyQixpQkFBaUI7WUFDakIsaUZBQWlGO1lBQ2pGLDJDQUEyQztZQUMzQywyRkFBMkY7WUFDM0YseURBQXlEO1lBQ3pELElBQUksR0FBRyxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QixJQUFJ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SUFBUztZQUNsQyxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUIsQ0FBQyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsS0FBSztLQUM1QjtJQUNELEtBQUssRUFBRTtRQUNMLEVBQUUsRUFBRSxVQUFVLE1BQWM7WUFDMUIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzVCLENBQUMsRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLEtBQUs7S0FDNUI7SUFDRCxPQUFPLEVBQUU7UUFDUCxFQUFFLEVBQUUsVUFBVSxNQUFjO1lBQzFCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMzQixDQUFDLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxLQUFLO0tBQzVCO0lBQ0QsS0FBSyxFQUFFO1FBQ0wsRUFBRSxFQUFFLFVBQVUsTUFBYztZQUMxQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUIsQ0FBQyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsS0FBSztLQUM1QjtJQUNELE1BQU0sRUFBRTtRQUNOLEVBQUUsRUFBRSxVQUFVLE1BQVk7WUFDeEIsT0FBTyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDN0IsQ0FBQyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsS0FBSztLQUM1QjtJQUNELE1BQU0sRUFBRTtRQUNOLEVBQUUsRUFBRSxVQUFVLE1BQVk7WUFDeEIsT0FBTyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDN0IsQ0FBQyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsS0FBSztLQUM1QjtJQUNELEdBQUcsRUFBRTtRQUNILEVBQUUsRUFBRSxVQUFVLE1BQVk7WUFDeEIsT0FBTyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDMUIsQ0FBQyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsS0FBSztLQUM1QjtJQUNELEtBQUssRUFBRTtRQUNMLEVBQUUsRUFBRSxVQUFV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QUssQ0FBQyxVQUFVLEdBQUc7UUFDMUMsSUFBSSxFQUFFLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzFCLElBQUksT0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtnQkFDakMsMENBQTBDO2dCQUMxQyxPQUFPLEtBQUssQ0FBQzthQUNkO1lBQ0QsSUFBSSxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRTtnQkFDckMsT0FBTyxLQUFLLENBQUM7YUFDZDtTQUNGO2FBQU07WUFDTCxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ25CO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUN4QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29yZSB9IGZyb20gJy4vY29yZSc7XHJcbmltcG9ydCB7IEVudGl0eVR5cGUsIFN0cnVjdHVyYWxUeXBlLCBEYXRhUHJvcGVydHkgIH0gZnJvbSAnLi9lbnRpdHktbWV0YWRhdGEnO1xyXG5pbXBvcnQgeyBRdWVyeU9wIH0gZnJvbSAnLi9lbnRpdHktcXVlcnknO1xyXG5pbXBvcnQgeyBEYXRhVHlwZSAgfSBmcm9tICcuL2RhdGEtdHlwZSc7XHJcbmltcG9ydCB7IEVudGl0eUFzcGVjdCwgRW50aXR5IH0gZnJvbSAnLi9lbnRpdHktYXNwZWN0JztcclxuaW1wb3J0IHsgTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zIH0gZnJvbSAnLi9sb2NhbC1xdWVyeS1jb21wYXJpc29uLW9wdGlvbnMnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcCB7XHJcbiAga2V5OiBzdHJpbmc7XHJcbiAgYWxpYXNlcz86IHN0cmluZ1tdO1xyXG4gIGlzRnVuY3Rpb24/OiBib29sZWFuO1xyXG59XHJcblxyXG4vKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuZXhwb3J0IGludGVyZmFjZSBPcE1hcCB7XHJcbiAgW2tleTogc3RyaW5nXTogT3A7XHJcbn1cclxuXHJcbi8qKiBGb3IgdXNlIGJ5IGJyZWV6ZSBwbHVnaW4gYXV0aG9ycyBvbmx5LiBUaGUgY2xhc3MgaXMgZm9yIHVzZSBpbiBidWlsZGluZyBhIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0gaW1wbGVtZW50YXRpb24uIFxyXG5AYWRhcHRlciAoc2VlIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0pICAgIFxyXG5AaGlkZGVuIFxyXG4qL1xyXG5leHBvcnQgaW50ZXJmYWNlIFZpc2l0b3Ige1xyXG5cclxufVxyXG5cclxuLyoqIEZvciB1c2UgYnkgYnJlZXplIHBsdWdpbiBhdXRob3JzIG9ubHkuIFRoZSBjbGFzcyBpcyBmb3IgdXNlIGluIGJ1aWxkaW5nIGEgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSBpbXBsZW1lbnRhdGlvbi4gXHJcbkBhZGFwdGVyIChzZWUgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSkgICAgXHJcbkBoaWRkZW4gXHJcbiovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVmlzaXRDb250ZXh0IHtcclxuICBlbnRpdHlUeXBlPzogRW50aXR5VHlwZTtcclxuICAvLyB1c2VzTmFtZU9uU2VydmVyPzogYm9vbGVhbjtcclxuICB0b05hbWVPblNlcnZlcj86IGJvb2xlYW47XHJcbiAgdXNlRXhwbGljaXREYXRhVHlwZT86IGJvb2xlYW47XHJcbiAgdmlzaXRvcj86IFZpc2l0b3I7XHJcbn1cclxuXHJcbi8qKiBGb3IgdXNlIGJ5IGJyZWV6ZSBwbHVnaW4gYXV0aG9ycyBvbmx5LiBUaGUgY2xhc3MgaXMgZm9yIHVzZSBpbiBidWlsZGluZyBhIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0gaW1wbGVtZW50YXRpb24uIFxyXG5AYWRhcHRlciAoc2VlIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0pICAgIFxyXG5AaGlkZGVuIFxyXG4qL1xyXG5leHBvcnQgaW50ZXJmYWNlIEV4cHJlc3Npb25Db250ZXh0IHtcclxuICBlbnRpdHlUeXBlPzogRW50aXR5VHlwZTtcclxuICB1c2VzTmFtZU9uU2VydmVyPzogYm9vbGVhbjtcclxuICBkYXRhVHlwZT86IERhdGFUeXBlIHwgc3RyaW5nO1xyXG4gIGlzUkhTPzogYm9vbGVhbjtcclxuICBpc0ZuQXJnPzogYm9vbGVhbjtcclxufVxyXG5cclxuLyoqXHJcblVzZWQgdG8gZGVmaW5lIGEgJ3doZXJlJyBwcmVkaWNhdGUgZm9yIGFuIFtbRW50aXR5UXVlcnldXS4gIFByZWRpY2F0ZXMgYXJlIGltbXV0YWJsZSwgd2hpY2ggbWVhbnMgdGhhdCBhbnlcclxubWV0aG9kIHRoYXQgd291bGQgbW9kaWZ5IGEgUHJlZGljYXRlIGFjdHVhbGx5IHJldHVybnMgYSBuZXcgUHJlZGljYXRlLlxyXG4qKi9cclxuZXhwb3J0IGNsYXNzIFByZWRpY2F0ZSB7XHJcbiAgb3A6IE9wO1xyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9lbnRpdHlUeXBlPzogRW50aXR5VHlwZTtcclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBhbGlhc01hcDogT3BNYXA7XHJcbiAgdmlzaXRvck1ldGhvZE5hbWU6IHN0cmluZztcclxuXHJcblxyXG4gIC8qKlxyXG4gIFByZWRpY2F0ZSBjb25zdHJ1Y3RvclxyXG4gID4gICAgIGxldCBwMSA9IG5ldyBQcmVkaWNhdGUoXCJDb21wYW55TmFtZVwiLCBcIlN0YXJ0c1dpdGhcIiwgXCJCXCIpO1xyXG4gID4gICAgIGxldCBxdWVyeSA9IG5ldyBFbnRpdHlRdWVyeShcIkN1c3RvbWVyc1wiKS53aGVyZShwMSk7XHJcblxyXG4gIG9yXHJcbiAgPiAgICAgbGV0IHAyID0gbmV3IFByZWRpY2F0ZShcIlJlZ2lvblwiLCBGaWx0ZXJRdWVyeU9wLkVxdWFscywgbnVsbCk7XHJcbiAgPiAgICAgbGV0IHF1ZXJ5ID0gbmV3IEVudGl0eVF1ZXJ5KFwiQ3VzdG9tZXJzXCIpLndoZXJlKHAyKTtcclxuICBAcGFyYW0gcHJvcGVydHkgLSBBIHByb3BlcnR5IG5hbWUsIGEgbmVzdGVkIHByb3BlcnR5IG5hbWUgb3IgYW4gZXhwcmVzc2lvbiBpbnZvbHZpbmcgYSBwcm9wZXJ0eSBuYW1lLlxyXG4gIEBwYXJhbSBvcGVyYXRvciAtIFxyXG4gIEBwYXJhbSB2YWx1ZSAtIFRoaXMgd2lsbCBiZSB0cmVhdGVkIGFzIGVpdGhlciBhIHByb3BlcnR5IGV4cHJlc3Npb24gb3IgYSBsaXRlcmFsIGRlcGVuZGluZyBvbiBjb250ZXh0LiAgSW4gZ2VuZXJhbCxcclxuICBpZiB0aGUgdmFsdWUgY2FuIGJlIGludGVycHJldGVkIGFzIGEgcHJvcGVydHkgZXhwcmVzc2lvbiBpdCB3aWxsIGJlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgbGl0ZXJhbC5cclxuICBJbiBtb3N0IGNhc2VzIHRoaXMgd29ya3Mgd2VsbCwgYnV0IHlvdSBjYW4gYWxzbyBmb3JjZSB0aGUgaW50ZXJwcmV0YXRpb24gYnkgbWFraW5nIHRoZSB2YWx1ZSBhcmd1bWVudCBpdHNlbGYgYW4gb2JqZWN0IHdpdGggYSAndmFsdWUnXHJcbiAgcHJvcGVydHkgYW5kIGFuICdpc0xpdGVyYWwnIHByb3BlcnR5IHNldCB0byBlaXRoZXIgdHJ1ZSBvciBmYWxzZS4gIEJyZWV6ZSBhbHNvIHRyaWVzIHRvIGluZmVyIHRoZSBkYXRhVHlwZSBvZiBhbnlcclxuICBsaXRlcmFsIGJhc2VkIG9uIGNvbnRleHQsIGlmIHRoaXMgZmFpbHMgeW91IGNhbiBmb3JjZSB0aGlzIGluZmVyZW5jZSBieSBtYWtpbmcgdGhlIHZhbHVlIGFyZ3VtZW50IGFuIG9iamVjdCB3aXRoIGFcclxuICAndmFsdWUnIHByb3BlcnR5IGFuZCBhICdkYXRhVHlwZScgcHJvcGVydHkgc2V0IHRvIG9uZSBvZiB0aGUgYnJlZXplLkRhdGFUeXBlIGVudW1lcmF0aW9uIGluc3RhbmNlcy5cclxuICAqKi9cclxuICBjb25zdHJ1Y3RvciguLi5hcmdzOiBhbnlbXSkge1xyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm47XHJcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJlZGljYXRlKSkge1xyXG4gICAgICByZXR1cm4gbmV3IFByZWRpY2F0ZSguLi48YW55PmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByZWRpY2F0ZS5jcmVhdGUoLi4uPGFueT5hcmdzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFNhbWUgYXMgdXNpbmcgdGhlIGN0b3IuXHJcbiAgPiAgICAgIC8vIHNvIFxyXG4gID4gICAgICBsZXQgcCA9IFByZWRpY2F0ZS5jcmVhdGUoYSwgYiwgYyk7XHJcbiAgPiAgICAgIC8vIGlzIHRoZSBzYW1lIGFzIFxyXG4gID4gICAgICBsZXQgcCA9IG5ldyBQcmVkaWNhdGUoYSwgYiwgYyk7IFxyXG4gIEBwYXJhbSBwcm9wZXJ0eSAtICBBIHByb3BlcnR5IG5hbWUsIGEgbmVzdGVkIHByb3BlcnR5IG5hbWUgb3IgYW4gZXhwcmVzc2lvbiBpbnZvbHZpbmcgYSBwcm9wZXJ0eSBuYW1lLlxyXG4gIEBwYXJhbSBvcGVyYXRvciAtIHRoZSBmaWx0ZXIgcXVlcnkgb3BlcmF0b3IuXHJcbiAgQHBhcmFtIHZhbHVlIC0gVGhpcyB3aWxsIGJlIHRyZWF0ZWQgYXMgZWl0aGVyIGEgcHJvcGVydHkgZXhwcmVzc2lvbiBvciBhIGxpdGVyYWwgZGVwZW5kaW5nIG9uIGNvbnRleHQuICBJbiBnZW5lcmFsLFxyXG4gIGlmIHRoZSB2YWx1ZSBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgYSBwcm9wZXJ0eSBleHByZXNzaW9uIGl0IHdpbGwgYmUsIG90aGVyd2lzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBsaXRlcmFsLlxyXG4gIEluIG1vc3QgY2FzZXMgdGhpcyB3b3JrcyB3ZWxsLCBidXQgeW91IGNhbiBhbHNvIGZvcmNlIHRoZSBpbnRlcnByZXRhdGlvbiBieSBtYWtpbmcgdGhlIHZhbHVlIGFyZ3VtZW50IGl0c2VsZiBhbiBvYmplY3Qgd2l0aCBhICd2YWx1ZSdcclxuICBwcm9wZXJ0eSBhbmQgYW4gJ2lzTGl0ZXJhbCcgcHJvcGVydHkgc2V0IHRvIGVpdGhlciB0cnVlIG9yIGZhbHNlLiAgQnJlZXplIGFsc28gdHJpZXMgdG8gaW5mZXIgdGhlIGRhdGFUeXBlIG9mIGFueVxyXG4gIGxpdGVyYWwgYmFzZWQgb24gY29udGV4dCwgaWYgdGhpcyBmYWlscyB5b3UgY2FuIGZvcmNlIHRoaXMgaW5mZXJlbmNlIGJ5IG1ha2luZyB0aGUgdmFsdWUgYXJndW1lbnQgYW4gb2JqZWN0IHdpdGggYVxyXG4gICd2YWx1ZScgcHJvcGVydHkgYW5kIGEgJ2RhdGFUeXBlJyBwcm9wZXJ0eSBzZXQgdG8gb25lIG9mIHRoZSBicmVlemUuRGF0YVR5cGUgZW51bWVyYXRpb24gaW5zdGFuY2VzLlxyXG4gICoqL1xyXG4gIHN0YXRpYyBjcmVhdGUoLi4uYXJnczogYW55W10pIHtcclxuICAgIC8vIGNhbiBiZSBjYWxsZWQgZnJvbSBzdGQgamF2YXNjcmlwdCB3aXRob3V0IG5ldyAoIGxlZ2FjeSApXHJcblxyXG4gICAgLy8gZW1wdHkgY3RvciBpcyB1c2VkIGJ5IGFsbCBzdWJjbGFzc2VzLlxyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IFByZWRpY2F0ZSgpO1xyXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIC8vIHBvc3NpYmlsaXRpZXM6XHJcbiAgICAgIC8vICAgICAgUHJlZGljYXRlKFsgYVByZWRpY2F0ZSBdKSBvciAgUHJlZGljYXRlKFtcImZyZWlnaHRcIiwgXCI+XCIsIDEwMF0pIC0gYW4gYXJyYXlcclxuICAgICAgLy8gICAgICBQcmVkaWNhdGUoYVByZWRpY2F0ZSkgLSBhIHByZWRpY2F0ZVxyXG4gICAgICAvLyAgICAgIFByZWRpY2F0ZSggXCJmcmVpZ2h0IGd0IDEwMFwiIH0gIC8vIHBhc3N0aHJ1ICggaS5lLiBtYXliZSBhbiBvZGF0YSBzdHJpbmcpIC0gYSBzdHJpbmdcclxuICAgICAgLy8gICAgICBQcmVkaWNhdGUoIHsgZnJlaWdodDogeyBcIj5cIjogMTAwIH0gfSkgLSBhbiBvYmplY3RcclxuICAgICAgbGV0IGFyZyA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xyXG4gICAgICAgIGlmIChhcmcubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAvLyByZWN1cnNlXHJcbiAgICAgICAgICByZXR1cm4gbmV3IFByZWRpY2F0ZShhcmdbMF0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUHJlZGljYXRlRnJvbUFycmF5KGFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIFByZWRpY2F0ZSkge1xyXG4gICAgICAgIHJldHVybiBhcmc7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBhc3N0aHJ1UHJlZGljYXRlKGFyZyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVByZWRpY2F0ZUZyb21PYmplY3QoYXJnKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gMiBwb3NzaWJpbGl0aWVzXHJcbiAgICAgIC8vICAgICAgUHJlZGljYXRlKFwiZnJlaWdodFwiLCBcIj5cIiwgMTAwXCIpO1xyXG4gICAgICAvLyAgICAgIFByZWRpY2F0ZShcIm9yZGVyc1wiLCBcImFueVwiLCBcImZyZWlnaHRcIiwgIFwiPlwiLCA5NTApO1xyXG4gICAgICByZXR1cm4gY3JlYXRlUHJlZGljYXRlRnJvbUFycmF5KGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgX3ZhbGlkYXRlKGVudGl0eVR5cGU6IEVudGl0eVR5cGUgfCB1bmRlZmluZWQsIHVzZXNOYW1lT25TZXJ2ZXI/OiBib29sZWFuKSB7XHJcbiAgICAvLyBub29wIGhlcmU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBDcmVhdGVzIGEgJ2NvbXBvc2l0ZScgUHJlZGljYXRlIGJ5ICdhbmQnaW5nIGEgc2V0IG9mIHNwZWNpZmllZCBQcmVkaWNhdGVzIHRvZ2V0aGVyLlxyXG4gID4gICAgICBsZXQgZHQgPSBuZXcgRGF0ZSg4OCwgOSwgMTIpO1xyXG4gID4gICAgICBsZXQgcDEgPSBQcmVkaWNhdGUuY3JlYXRlKFwiT3JkZXJEYXRlXCIsIFwibmVcIiwgZHQpO1xyXG4gID4gICAgICBsZXQgcDIgPSBQcmVkaWNhdGUuY3JlYXRlKFwiU2hpcENpdHlcIiwgXCJzdGFydHNXaXRoXCIsIFwiQ1wiKTtcclxuICA+ICAgICAgbGV0IHAzID0gUHJlZGljYXRlLmNyZWF0ZShcIkZyZWlnaHRcIiwgXCI+XCIsIDEwMCk7XHJcbiAgPiAgICAgIGxldCBuZXdQcmVkID0gUHJlZGljYXRlLmFuZChwMSwgcDIsIHAzKTtcclxuXHJcbiAgb3JcclxuICA+ICAgICAgbGV0IHByZWRzID0gW3AxLCBwMiwgcDNdO1xyXG4gID4gICAgICBsZXQgbmV3UHJlZCA9IFByZWRpY2F0ZS5hbmQocHJlZHMpO1xyXG4gIEBwYXJhbSBwcmVkaWNhdGVzIC0gbXVsdGlwbGUgUHJlZGljYXRlcyBvciBhbiBhcnJheSBvZiBQcmVkaWNhdGUuIFxyXG4gIEFueSBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMgcGFzc2VkIGluIHdpbGwgYmUgYXV0b21hdGljYWxseSBmaWx0ZXJlZCBvdXQgYmVmb3JlIGNvbnN0cnVjdGluZyB0aGUgY29tcG9zaXRlIHByZWRpY2F0ZS5cclxuICAqKi9cclxuICBzdGF0aWMgYW5kKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBsZXQgcHJlZCA9IG5ldyBBbmRPclByZWRpY2F0ZShcImFuZFwiLCBhcmdzKTtcclxuICAgIC8vIFRPRE8gcmVtb3ZlZCBiZWxvd1xyXG4gICAgLy8gcmV0dXJuIHVuZGVmaW5lZCBpZiBlbXB0eVxyXG4gICAgLy8gcmV0dXJuIHByZWQub3AgJiYgcHJlZDtcclxuICAgIHJldHVybiBwcmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgQ3JlYXRlcyBhICdjb21wb3NpdGUnIFByZWRpY2F0ZSBieSAnb3InaW5nIGEgc2V0IG9mIHNwZWNpZmllZCBQcmVkaWNhdGVzIHRvZ2V0aGVyLlxyXG4gID4gICAgICBsZXQgZHQgPSBuZXcgRGF0ZSg4OCwgOSwgMTIpO1xyXG4gID4gICAgICBsZXQgcDEgPSBQcmVkaWNhdGUuY3JlYXRlKFwiT3JkZXJEYXRlXCIsIFwibmVcIiwgZHQpO1xyXG4gID4gICAgICBsZXQgcDIgPSBQcmVkaWNhdGUuY3JlYXRlKFwiU2hpcENpdHlcIiwgXCJzdGFydHNXaXRoXCIsIFwiQ1wiKTtcclxuICA+ICAgICAgbGV0IHAzID0gUHJlZGljYXRlLmNyZWF0ZShcIkZyZWlnaHRcIiwgXCI+XCIsIDEwMCk7XHJcbiAgPiAgICAgIGxldCBuZXdQcmVkID0gUHJlZGljYXRlLm9yKHAxLCBwMiwgcDMpO1xyXG5cclxuICBvclxyXG4gID4gICAgICBsZXQgcHJlZHMgPSBbcDEsIHAyLCBwM107XHJcbiAgPiAgICAgIGxldCBuZXdQcmVkID0gUHJlZGljYXRlLm9yKHByZWRzKTtcclxuICBAcGFyYW0gcHJlZGljYXRlcyAtIG11bHRpcGxlIFByZWRpY2F0ZXMgb3IgYW4gYXJyYXkgb2YgUHJlZGljYXRlLlxyXG4gIEFueSBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMgcGFzc2VkIGluIHdpbGwgYmUgYXV0b21hdGljYWxseSBmaWx0ZXJlZCBvdXQgYmVmb3JlIGNvbnN0cnVjdGluZyB0aGUgY29tcG9zaXRlIHByZWRpY2F0ZS5cclxuICAqKi9cclxuICBzdGF0aWMgb3IoLi4uYXJnczogYW55W10pIHtcclxuICAgIGxldCBwcmVkID0gbmV3IEFuZE9yUHJlZGljYXRlKFwib3JcIiwgYXJncyk7XHJcbiAgICAvLyByZXR1cm4gcHJlZC5vcCAmJiBwcmVkO1xyXG4gICAgcmV0dXJuIHByZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBDcmVhdGVzIGEgJ2NvbXBvc2l0ZScgUHJlZGljYXRlIGJ5ICduZWdhdGluZycgYSBzcGVjaWZpZWQgcHJlZGljYXRlLlxyXG4gID4gICAgICBsZXQgcDEgPSBQcmVkaWNhdGUuY3JlYXRlKFwiRnJlaWdodFwiLCBcImd0XCIsIDEwMCk7XHJcbiAgPiAgICAgIGxldCBub3RfcDEgPSBQcmVkaWNhdGUubm90KHAxKTtcclxuXHJcbiAgVGhpcyBjYW4gYWxzbyBiZSBhY2NvbXBsaXNoZWQgdXNpbmcgdGhlICdpbnN0YW5jZScgdmVyc2lvbiBvZiB0aGUgJ25vdCcgbWV0aG9kXHJcbiAgPiAgICAgIGxldCBub3RfcDEgPSBwMS5ub3QoKTtcclxuXHJcbiAgQm90aCBvZiB3aGljaCB3b3VsZCBiZSB0aGUgc2FtZSBhc1xyXG4gID4gICAgICBsZXQgbm90X3AxID0gUHJlZGljYXRlLmNyZWF0ZShcIkZyZWlnaHRcIiwgXCJsZVwiLCAxMDApO1xyXG4gICoqL1xyXG4gIHN0YXRpYyBub3QocHJlZDogUHJlZGljYXRlKSB7XHJcbiAgICByZXR1cm4gcHJlZC5ub3QoKTtcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IGRldGVybWluZSBpZi93aGVyZSB0aGlzIGlzIHVzZWQuXHJcbiAgLy8gc3RhdGljIGV4dGVuZEJpbmFyeVByZWRpY2F0ZUZuKG9wTWFwOiBJT3BNYXAsIHZpc2l0b3JGbjogYW55KSB7XHJcbiAgLy8gICBsZXQgYmFzZVZpc2l0b3JGbiA9IHRvRnVuY3Rpb25WaXNpdG9yLmJpbmFyeVByZWRpY2F0ZTtcclxuICAvLyAgIGZvciAobGV0IG9wIGluIChvcE1hcCB8fCB7fSkpIHtcclxuICAvLyAgICAgbGV0IGNvbmZpZyA9IG9wTWFwW29wXTtcclxuICAvLyAgICAgY29uZmlnLnZpc2l0b3JGbiA9IHZpc2l0b3JGbjtcclxuICAvLyAgICAgdXBkYXRlQWxpYXNNYXAoQmluYXJ5UHJlZGljYXRlLnByb3RvdHlwZS5hbGlhc01hcCwgb3AsIG9wTWFwW29wXSk7XHJcbiAgLy8gICB9XHJcbiAgLy8gICBpZiAoIXRvRnVuY3Rpb25WaXNpdG9yLmlzRXh0ZW5kZWQpIHtcclxuICAvLyAgICAgdG9GdW5jdGlvblZpc2l0b3IuYmluYXJ5UHJlZGljYXRlID0gZnVuY3Rpb24gKGNvbnRleHQsIGV4cHIxVmFsLCBleHByMlZhbCkge1xyXG4gIC8vICAgICAgIGxldCB2aXNpdG9yRm4gPSB0aGlzLmFsaWFzTWFwW3RoaXMub3Aua2V5XS52aXNpdG9yRm47XHJcbiAgLy8gICAgICAgaWYgKHZpc2l0b3JGbikge1xyXG4gIC8vICAgICAgICAgcmV0dXJuIHZpc2l0b3JGbihjb250ZXh0LCBleHByMVZhbCwgZXhwcjJWYWwpO1xyXG4gIC8vICAgICAgIH0gZWxzZSB7XHJcbiAgLy8gICAgICAgICByZXR1cm4gYmFzZVZpc2l0b3JGbihjb250ZXh0LCBleHByMVZhbCwgZXhwcjJWYWwpO1xyXG4gIC8vICAgICAgIH1cclxuICAvLyAgICAgfTtcclxuICAvLyAgICAgdG9GdW5jdGlvblZpc2l0b3IuaXNFeHRlbmRlZCA9IHRydWU7XHJcbiAgLy8gICB9XHJcbiAgLy8gfTtcclxuXHJcblxyXG4gIC8qKlxyXG4gICdBbmQncyB0aGlzIFByZWRpY2F0ZSB3aXRoIG9uZSBvciBtb3JlIG90aGVyIFByZWRpY2F0ZXMgYW5kIHJldHVybnMgYSBuZXcgJ2NvbXBvc2l0ZScgUHJlZGljYXRlXHJcbiAgPiAgICAgIGxldCBkdCA9IG5ldyBEYXRlKDg4LCA5LCAxMik7XHJcbiAgPiAgICAgIGxldCBwMSA9IFByZWRpY2F0ZS5jcmVhdGUoXCJPcmRlckRhdGVcIiwgXCJuZVwiLCBkdCk7XHJcbiAgPiAgICAgIGxldCBwMiA9IFByZWRpY2F0ZS5jcmVhdGUoXCJTaGlwQ2l0eVwiLCBcInN0YXJ0c1dpdGhcIiwgXCJDXCIpO1xyXG4gID4gICAgICBsZXQgcDMgPSBQcmVkaWNhdGUuY3JlYXRlKFwiRnJlaWdodFwiLCBcIj5cIiwgMTAwKTtcclxuICA+ICAgICAgbGV0IG5ld1ByZWQgPSBwMS5hbmQocDIsIHAzKTtcclxuXHJcbiAgb3JcclxuICA+ICAgICAgbGV0IHByZWRzID0gW3AyLCBwM107XHJcbiAgPiAgICAgIGxldCBuZXdQcmVkID0gcDEuYW5kKHByZWRzKTtcclxuXHJcbiAgVGhlICdhbmQnIG1ldGhvZCBpcyBhbHNvIHVzZWQgdG8gd3JpdGUgXCJmbHVlbnRcIiBleHByZXNzaW9uc1xyXG4gID4gICAgICBsZXQgcDQgPSBQcmVkaWNhdGUuY3JlYXRlKFwiU2hpcENpdHlcIiwgXCJzdGFydHN3aXRoXCIsIFwiRlwiKVxyXG4gID4gICAgICAgIC5hbmQoXCJTaXplXCIsIFwiZ3RcIiwgMjAwMCk7XHJcbiAgQHBhcmFtIHByZWRpY2F0ZXMgLSBtdWx0aXBsZSBQcmVkaWNhdGVzIG9yIGFuIGFycmF5IG9mIFByZWRpY2F0ZXMuIFxyXG4gIEFueSBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMgcGFzc2VkIGluIHdpbGwgYmUgYXV0b21hdGljYWxseSBmaWx0ZXJlZCBvdXQgYmVmb3JlIGNvbnN0cnVjdGluZyB0aGUgY29tcG9zaXRlIHByZWRpY2F0ZS5cclxuICAqKi9cclxuICBhbmQoLi4uYXJnczogYW55W10pIHtcclxuICAgIHJldHVybiBuZXcgQW5kT3JQcmVkaWNhdGUoXCJhbmRcIiwgYXJnc0ZvckFuZE9yUHJlZGljYXRlcyh0aGlzLCBhcmdzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAnT3IncyB0aGlzIFByZWRpY2F0ZSB3aXRoIG9uZSBvciBtb3JlIG90aGVyIFByZWRpY2F0ZXMgYW5kIHJldHVybnMgYSBuZXcgJ2NvbXBvc2l0ZScgUHJlZGljYXRlXHJcbiAgPiAgICAgIGxldCBkdCA9IG5ldyBEYXRlKDg4LCA5LCAxMik7XHJcbiAgPiAgICAgIGxldCBwMSA9IFByZWRpY2F0ZS5jcmVhdGUoXCJPcmRlckRhdGVcIiwgXCJuZVwiLCBkdCk7XHJcbiAgPiAgICAgIGxldCBwMiA9IFByZWRpY2F0ZS5jcmVhdGUoXCJTaGlwQ2l0eVwiLCBcInN0YXJ0c1dpdGhcIiwgXCJDXCIpO1xyXG4gID4gICAgICBsZXQgcDMgPSBQcmVkaWNhdGUuY3JlYXRlKFwiRnJlaWdodFwiLCBcIj5cIiwgMTAwKTtcclxuICA+ICAgICAgbGV0IG5ld1ByZWQgPSBwMS5vcihwMiwgcDMpO1xyXG5cclxuICBvclxyXG4gID4gICAgICBsZXQgcHJlZHMgPSBbcDIsIHAzXTtcclxuICA+ICAgICAgbGV0IG5ld1ByZWQgPSBwMS5vcihwcmVkcyk7XHJcblxyXG4gIFRoZSAnb3InIG1ldGhvZCBpcyBhbHNvIHVzZWQgdG8gd3JpdGUgXCJmbHVlbnRcIiBleHByZXNzaW9uc1xyXG4gID4gICAgICBsZXQgcDQgPSBQcmVkaWNhdGUuY3JlYXRlKFwiU2hpcENpdHlcIiwgXCJzdGFydHN3aXRoXCIsIFwiRlwiKVxyXG4gID4gICAgICAgIC5vcihcIlNpemVcIiwgXCJndFwiLCAyMDAwKTtcclxuICBAcGFyYW0gcHJlZGljYXRlcyAtIG11bHRpcGxlIFByZWRpY2F0ZXMgb3IgYW4gYXJyYXkgb2YgUHJlZGljYXRlcy4gXHJcbiAgQW55IG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlcyBwYXNzZWQgaW4gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGZpbHRlcmVkIG91dCBiZWZvcmUgY29uc3RydWN0aW5nIHRoZSBjb21wb3NpdGUgcHJlZGljYXRlLlxyXG4gICoqL1xyXG4gIG9yKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICByZXR1cm4gbmV3IEFuZE9yUHJlZGljYXRlKFwib3JcIiwgYXJnc0ZvckFuZE9yUHJlZGljYXRlcyh0aGlzLCBhcmdzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZXR1cm5zIHRoZSAnbmVnYXRlZCcgdmVyc2lvbiBvZiB0aGlzIFByZWRpY2F0ZVxyXG4gID4gICAgICBsZXQgcDEgPSBQcmVkaWNhdGUuY3JlYXRlKFwiRnJlaWdodFwiLCBcImd0XCIsIDEwMCk7XHJcbiAgPiAgICAgIGxldCBub3RfcDEgPSBwMS5ub3QoKTtcclxuXHJcbiAgVGhpcyBjYW4gYWxzbyBiZSBhY2NvbXBsaXNoZWQgdXNpbmcgdGhlICdzdGF0aWMnIHZlcnNpb24gb2YgdGhlICdub3QnIG1ldGhvZFxyXG4gID4gICAgICBsZXQgcDEgPSBQcmVkaWNhdGUuY3JlYXRlKFwiRnJlaWdodFwiLCBcImd0XCIsIDEwMCk7XHJcbiAgPiAgICAgIGxldCBub3RfcDEgPSBQcmVkaWNhdGUubm90KHAxKTtcclxuXHJcbiAgd2hpY2ggd291bGQgYmUgdGhlIHNhbWUgYXNcclxuICA+ICAgICAgbGV0IG5vdF9wMSA9IFByZWRpY2F0ZS5jcmVhdGUoXCJGcmVpZ2h0XCIsIFwibGVcIiwgMTAwKTtcclxuICAqKi9cclxuICBub3QoKSB7XHJcbiAgICByZXR1cm4gbmV3IFVuYXJ5UHJlZGljYXRlKFwibm90XCIsIHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgLy9cclxuICB0b0pTT04oKSB7XHJcbiAgICAvLyB0b0pTT04gKCBwYXJ0IG9mIGpzIHN0YW5kYXJkIC0gdGFrZXMgYSBzaW5nbGUgcGFyYW1ldGVyXHJcbiAgICAvLyB0aGF0IGlzIGVpdGhlciBcIlwiIG9yIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBzZXJpYWxpemVkLlxyXG4gICAgcmV0dXJuIHRoaXMudG9KU09ORXh0KHsgZW50aXR5VHlwZTogdGhpcy5fZW50aXR5VHlwZSB9KTtcclxuICB9XHJcblxyXG4gIC8qKiBGb3IgdXNlIGJ5IGJyZWV6ZSBwbHVnaW4gYXV0aG9ycyBvbmx5LiBUaGUgY2xhc3MgaXMgZm9yIHVzZSBpbiBidWlsZGluZyBhIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0gaW1wbGVtZW50YXRpb24uIFxyXG4gIEBhZGFwdGVyIChzZWUgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSkgICAgXHJcbiAgQGhpZGRlbiBAaW50ZXJuYWwgXHJcbiAgKi9cclxuICB0b0pTT05FeHQoY29udGV4dDogVmlzaXRDb250ZXh0KSB7XHJcbiAgICByZXR1cm4gdGhpcy52aXNpdChjb250ZXh0LCB0b0pTT05WaXNpdG9yKTtcclxuICB9XHJcblxyXG4gIC8qKiBGb3IgdXNlIGJ5IGJyZWV6ZSBwbHVnaW4gYXV0aG9ycyBvbmx5LiBUaGUgY2xhc3MgaXMgZm9yIHVzZSBpbiBidWlsZGluZyBhIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0gaW1wbGVtZW50YXRpb24uIFxyXG4gIEBhZGFwdGVyIChzZWUgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSkgICAgXHJcbiAgQGhpZGRlbiBAaW50ZXJuYWwgXHJcbiAgKi9cclxuICB0b0Z1bmN0aW9uKGNvbnRleHQ6IFZpc2l0Q29udGV4dCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmlzaXQoY29udGV4dCwgdG9GdW5jdGlvblZpc2l0b3IpO1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKiogRm9yIHVzZSBieSBicmVlemUgcGx1Z2luIGF1dGhvcnMgb25seS4gVGhlIGNsYXNzIGlzIGZvciB1c2UgaW4gYnVpbGRpbmcgYSBbW0lVcmlCdWlsZGVyQWRhcHRlcl1dIGltcGxlbWVudGF0aW9uLiBcclxuICBAYWRhcHRlciAoc2VlIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0pICAgIFxyXG4gIEBoaWRkZW4gQGludGVybmFsIFxyXG4gICovXHJcbiAgdmlzaXQoY29udGV4dDogVmlzaXRDb250ZXh0LCB2aXNpdG9yPzogVmlzaXRvcikge1xyXG4gICAgaWYgKGNvcmUuaXNFbXB0eShjb250ZXh0KSkge1xyXG4gICAgICBjb250ZXh0ID0geyBlbnRpdHlUeXBlOiB1bmRlZmluZWQgfTtcclxuICAgIH0gZWxzZSBpZiAoY29udGV4dCBpbnN0YW5jZW9mIEVudGl0eVR5cGUpIHtcclxuICAgICAgY29udGV4dCA9IHsgZW50aXR5VHlwZTogY29udGV4dCB9O1xyXG4gICAgfSBlbHNlIGlmICghY29yZS5oYXNPd25Qcm9wZXJ0eShjb250ZXh0LCBcImVudGl0eVR5cGVcIikpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxsIHZpc2l0b3IgbWV0aG9kcyBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgY29udGV4dCBvYmplY3QgY29udGFpbmluZyBhdCBsZWFzdCBhbiAnZW50aXR5VHlwZScgcHJvcGVydHlcIik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHZpc2l0b3IpIHtcclxuICAgICAgY29udGV4dC52aXNpdG9yID0gdmlzaXRvcjtcclxuICAgIH1cclxuICAgIGxldCB0VmlzaXRvciA9IHZpc2l0b3IgfHwgY29udGV4dC52aXNpdG9yITtcclxuICAgIGxldCBmbiA9IHRWaXNpdG9yW3RoaXMudmlzaXRvck1ldGhvZE5hbWVdO1xyXG4gICAgaWYgKGZuID09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvY2F0ZSBtZXRob2Q6IFwiICsgdGhpcy52aXNpdG9yTWV0aG9kTmFtZSArIFwiIG9uIHZpc2l0b3JcIik7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGVudGl0eVR5cGUgPSBjb250ZXh0LmVudGl0eVR5cGU7XHJcbiAgICAvLyBkb24ndCBib3RoZXIgdmFsaWRhdGluZyBpZiBhbHJlYWR5IGRvbmUgc28gKCBvciBpZiBubyBfdmFsaWRhdGUgbWV0aG9kXHJcbiAgICBpZiAodGhpcy5fdmFsaWRhdGUgJiYgKGVudGl0eVR5cGUgPT0gbnVsbCB8fCB0aGlzLl9lbnRpdHlUeXBlICE9PSBlbnRpdHlUeXBlKSkge1xyXG4gICAgICAvLyBkb24ndCBuZWVkIHRvIGNhcHR1cmUgcmV0dXJuIHZhbHVlIGJlY2F1c2UgdmFsaWRhdGlvbiBmbiBkb2Vzbid0IGhhdmUgb25lLlxyXG4gICAgICAvLyBUT0RPOiB0aGlzIHdhcyBvbGQgY29kZVxyXG4gICAgICAvLyB0aGlzLl92YWxpZGF0ZShlbnRpdHlUeXBlLCBjb250ZXh0LnVzZXNOYW1lT25TZXJ2ZXIpO1xyXG4gICAgICB0aGlzLl92YWxpZGF0ZShlbnRpdHlUeXBlLCBjb250ZXh0LnRvTmFtZU9uU2VydmVyKTtcclxuICAgICAgdGhpcy5fZW50aXR5VHlwZSA9IGVudGl0eVR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZuLmNhbGwodGhpcywgY29udGV4dCk7XHJcbiAgfVxyXG5cclxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cclxuICBfaW5pdGlhbGl6ZSh2aXNpdG9yTWV0aG9kTmFtZTogc3RyaW5nLCBvcE1hcDogeyBba2V5OiBzdHJpbmddOiB7IGFsaWFzZXM/OiBzdHJpbmdbXSwgaXNGdW5jdGlvbj86IGJvb2xlYW4gfX0gPSB7fSkge1xyXG4gICAgdGhpcy52aXNpdG9yTWV0aG9kTmFtZSA9IHZpc2l0b3JNZXRob2ROYW1lO1xyXG4gICAgbGV0IGFsaWFzTWFwID0gdGhpcy5hbGlhc01hcCA9IHt9O1xyXG4gICAgZm9yIChsZXQgb3AgaW4gb3BNYXAgKSB7XHJcbiAgICAgIHVwZGF0ZUFsaWFzTWFwKGFsaWFzTWFwLCBvcCwgb3BNYXBbb3BdIGFzIE9wKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xyXG4gIF9yZXNvbHZlT3Aob3A6IHN0cmluZyB8IFF1ZXJ5T3AsIG9rSWZOb3RGb3VuZD86IGJvb2xlYW4pIHtcclxuICAgIGxldCBvcFN0ciA9ICh0eXBlb2Ygb3AgPT09IFwic3RyaW5nXCIpID8gb3AgOiBvcC5vcGVyYXRvcjtcclxuICAgIGxldCByZXN1bHQgPSB0aGlzLmFsaWFzTWFwW29wU3RyLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgaWYgKCFyZXN1bHQgJiYgIW9rSWZOb3RGb3VuZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBvcGVyYXRvcjogXCIgKyBvcFN0cik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUZyb21BcnJheShhcnI6IGFueVtdKSB7XHJcbiAgLy8gVE9ETzogYXNzZXJ0IHRoYXQgbGVuZ3RoIG9mIHRoZSBhcnJheSBzaG91bGQgYmUgPiAzXHJcbiAgLy8gTmVlZHMgdG8gaGFuZGxlOlxyXG4gIC8vICAgICAgWyBcImZyZWlnaHRcIiwgXCI+XCIsIDEwMFwiXTtcclxuICAvLyAgICAgIFsgXCJvcmRlcnNcIiwgXCJhbnlcIiwgXCJmcmVpZ2h0XCIsICBcIj5cIiwgOTUwIF1cclxuICAvLyAgICAgIFsgXCJvcmRlcnNcIiwgXCJhbmRcIiwgYW5vdGhlclByZWQgXVxyXG4gIC8vICAgICAgWyBcIm9yZGVyc1wiLCBcImFuZFwiLCBbIFwiZnJlaWdodCwgXCI+XCIsIDk1MCBdXVxyXG4gIGxldCBqc29uID0ge307XHJcbiAgbGV0IHZhbHVlID0ge307XHJcbiAganNvblthcnJbMF1dID0gdmFsdWU7XHJcbiAgbGV0IG9wID0gYXJyWzFdO1xyXG4gIG9wID0gb3Aub3BlcmF0b3IgfHwgb3A7ICAvLyBpbmNvbWluZyBvcCB3aWxsIGJlIGVpdGhlciBhIHN0cmluZyBvciBhIEZpbHRlclF1ZXJ5T3BcclxuICBpZiAoYXJyLmxlbmd0aCA9PT0gMykge1xyXG4gICAgdmFsdWVbb3BdID0gYXJyWzJdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB2YWx1ZVtvcF0gPSBjcmVhdGVQcmVkaWNhdGVGcm9tQXJyYXkoYXJyLnNwbGljZSgyKSk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVQcmVkaWNhdGVGcm9tT2JqZWN0KGpzb24pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVGcm9tT2JqZWN0KG9iajogT2JqZWN0KSB7XHJcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIFByZWRpY2F0ZSkgcmV0dXJuIG9iajtcclxuXHJcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29udmVydCB0byBhIFByZWRpY2F0ZTogXCIgKyBvYmopO1xyXG4gIH1cclxuICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XHJcbiAgbGV0IHByZWRzID0ga2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVByZWRpY2F0ZUZyb21LZXlWYWx1ZShrZXksIG9ialtrZXldKTtcclxuICB9KTtcclxuICByZXR1cm4gKHByZWRzLmxlbmd0aCA9PT0gMSkgPyBwcmVkc1swXSA6IG5ldyBBbmRPclByZWRpY2F0ZShcImFuZFwiLCBwcmVkcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUZyb21LZXlWYWx1ZShrZXk6IHN0cmluZywgdmFsdWU6IGFueSk6IFByZWRpY2F0ZSB7XHJcbiAgLy8geyBhbmQ6IFthLGJdIH0ga2V5PSdhbmQnLCB2YWx1ZSA9IFthLGJdXHJcbiAgaWYgKEFuZE9yUHJlZGljYXRlLnByb3RvdHlwZS5fcmVzb2x2ZU9wKGtleSwgdHJ1ZSkpIHtcclxuICAgIHJldHVybiBuZXcgQW5kT3JQcmVkaWNhdGUoa2V5LCB2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvLyB7IG5vdDogYSB9ICBrZXk9ICdub3QnLCB2YWx1ZSA9IGFcclxuICBpZiAoVW5hcnlQcmVkaWNhdGUucHJvdG90eXBlLl9yZXNvbHZlT3Aoa2V5LCB0cnVlKSkge1xyXG4gICAgcmV0dXJuIG5ldyBVbmFyeVByZWRpY2F0ZShrZXksIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIGlmICgodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgfHwgdmFsdWUgPT0gbnVsbCB8fCBjb3JlLmlzRGF0ZSh2YWx1ZSkpIHtcclxuICAgIC8vIHsgZm9vOiBiYXIgfSBrZXk9J2ZvbycsIHZhbHVlID0gYmFyICggd2hlcmUgYmFyIGlzIGEgbGl0ZXJhbCBpLmUuIGEgc3RyaW5nLCBhIG51bWJlciwgYSBib29sZWFuIG9yIGEgZGF0ZS5cclxuICAgIHJldHVybiBuZXcgQmluYXJ5UHJlZGljYXRlKFwiZXFcIiwga2V5LCB2YWx1ZSk7XHJcbiAgfSBlbHNlIGlmIChjb3JlLmhhc093blByb3BlcnR5KHZhbHVlLCAndmFsdWUnKSkge1xyXG4gICAgLy8geyBmb286IHsgdmFsdWU6IGJhciwgZGF0YVR5cGU6IHh4eH0gfSBrZXk9J2ZvbycsIHZhbHVlID0gYmFyICggd2hlcmUgYmFyIGlzIGFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBsaXRlcmFsXHJcbiAgICByZXR1cm4gbmV3IEJpbmFyeVByZWRpY2F0ZShcImVxXCIsIGtleSwgdmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBwcmVkaWNhdGUgYWZ0ZXIgdGhlIHBocmFzZTogXCIgKyBrZXkpO1xyXG4gIH1cclxuXHJcbiAgbGV0IGV4cHIgPSBrZXk7XHJcbiAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XHJcbiAgbGV0IHByZWRzID0ga2V5cy5tYXAoZnVuY3Rpb24gKG9wKSB7XHJcblxyXG4gICAgLy8geyBhOiB7IGFueTogYiB9IG9wID0gJ2FueScsIGV4cHI9YSwgdmFsdWVbb3BdID0gYlxyXG4gICAgaWYgKEFueUFsbFByZWRpY2F0ZS5wcm90b3R5cGUuX3Jlc29sdmVPcChvcCwgdHJ1ZSkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBBbnlBbGxQcmVkaWNhdGUob3AsIGV4cHIsIHZhbHVlW29wXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKEJpbmFyeVByZWRpY2F0ZS5wcm90b3R5cGUuX3Jlc29sdmVPcChvcCwgdHJ1ZSkpIHtcclxuICAgICAgLy8geyBhOiB7IFwiPlwiOiBiIH19IG9wID0gXCI+XCIsIGV4cHI9YSwgdmFsdWVbb3BdID0gYlxyXG4gICAgICByZXR1cm4gbmV3IEJpbmFyeVByZWRpY2F0ZShvcCwgZXhwciwgdmFsdWVbb3BdKTtcclxuICAgIH0gZWxzZSBpZiAoY29yZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZVtvcF0sICd2YWx1ZScpKSB7XHJcbiAgICAgIC8vIHsgYTogeyBcIj5cIjogeyB2YWx1ZTogYiwgZGF0YVR5cGU6ICdJbnQzMicgfX0gZXhwciA9IGEgdmFsdWVbb3BdID0geyB2YWx1ZTogYiwgZGF0YVR5cGU6ICdJbnQzMicgfVxyXG4gICAgICByZXR1cm4gbmV3IEJpbmFyeVByZWRpY2F0ZShcImVxXCIsIGV4cHIsIHZhbHVlW29wXSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG1zZyA9IGNvcmUuZm9ybWF0U3RyaW5nKFwiVW5hYmxlIHRvIHJlc29sdmUgcHJlZGljYXRlIGFmdGVyIHRoZSBwaHJhc2U6ICclMScgZm9yIG9wZXJhdG9yOiAnJTInICBhbmQgdmFsdWU6ICclMydcIiwgZXhwciwgb3AsIHZhbHVlW29wXSk7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiAocHJlZHMubGVuZ3RoID09PSAxKSA/IHByZWRzWzBdIDogbmV3IEFuZE9yUHJlZGljYXRlKFwiYW5kXCIsIHByZWRzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYXJnc0ZvckFuZE9yUHJlZGljYXRlcyhvYmo6IHt9LCBhcmdzOiBhbnlbXSkge1xyXG4gIGxldCBwcmVkcyA9IGFyZ3NbMF07XHJcbiAgaWYgKHByZWRzIGluc3RhbmNlb2YgUHJlZGljYXRlKSB7XHJcbiAgICBwcmVkcyA9IGNvcmUuYXJyYXlTbGljZShhcmdzKTtcclxuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByZWRzKSkge1xyXG4gICAgcHJlZHMgPSBbbmV3IFByZWRpY2F0ZShjb3JlLmFycmF5U2xpY2UoYXJncykpXTtcclxuICB9XHJcbiAgcmV0dXJuIFtvYmpdLmNvbmNhdChwcmVkcyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZUFsaWFzTWFwKGFsaWFzTWFwOiBPcE1hcCwgb3BTdHI6IHN0cmluZywgb3A6IE9wKSB7XHJcbiAgbGV0IGtleSA9IG9wU3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgb3Aua2V5ID0ga2V5O1xyXG4gIGFsaWFzTWFwW2tleV0gPSBvcDtcclxuXHJcbiAgb3AuYWxpYXNlcyAmJiBvcC5hbGlhc2VzLmZvckVhY2goKGFsaWFzOiBhbnkpID0+IHtcclxuICAgIGFsaWFzTWFwW2FsaWFzLnRvTG93ZXJDYXNlKCldID0gb3A7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKiBGb3IgdXNlIGJ5IGJyZWV6ZSBwbHVnaW4gYXV0aG9ycyBvbmx5LiBUaGUgY2xhc3MgaXMgZm9yIHVzZSBpbiBidWlsZGluZyBhIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0gaW1wbGVtZW50YXRpb24uIFxyXG5AYWRhcHRlciAoc2VlIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0pICAgIFxyXG5AaGlkZGVuIEBpbnRlcm5hbCBcclxuKi9cclxuY2xhc3MgUGFzc3RocnVQcmVkaWNhdGUgZXh0ZW5kcyBQcmVkaWNhdGUge1xyXG4gIHZhbHVlOiBhbnk7XHJcbiAgY29uc3RydWN0b3IodmFsdWU6IGFueSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICB9XHJcblxyXG4gIC8vIF92YWxpZGF0ZSA9IGNvcmUubm9vcDtcclxufVxyXG5FcnJvclsneCddID0gUGFzc3RocnVQcmVkaWNhdGUucHJvdG90eXBlLl9pbml0aWFsaXplKCdwYXNzdGhydVByZWRpY2F0ZScpO1xyXG5cclxuLyoqIEZvciB1c2UgYnkgYnJlZXplIHBsdWdpbiBhdXRob3JzIG9ubHkuIFRoZSBjbGFzcyBpcyBmb3IgdXNlIGluIGJ1aWxkaW5nIGEgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSBpbXBsZW1lbnRhdGlvbi4gXHJcbkBhZGFwdGVyIChzZWUgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSkgICAgXHJcbkBoaWRkZW4gXHJcbiovXHJcbmV4cG9ydCBjbGFzcyBVbmFyeVByZWRpY2F0ZSBleHRlbmRzIFByZWRpY2F0ZSB7XHJcbiAgb3A6IE9wO1xyXG4gIHByZWQ6IFByZWRpY2F0ZTtcclxuICBjb25zdHJ1Y3RvcihvcDogc3RyaW5nIHwgUXVlcnlPcCwgLi4uYXJnczogYW55W10pIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm9wID0gdGhpcy5fcmVzb2x2ZU9wKG9wKTtcclxuICAgIHRoaXMucHJlZCA9IG5ldyBQcmVkaWNhdGUoYXJncyk7XHJcbiAgfVxyXG5cclxuICBfdmFsaWRhdGUoZW50aXR5VHlwZTogRW50aXR5VHlwZSwgdXNlc05hbWVPblNlcnZlcj86IGJvb2xlYW4pIHtcclxuICAgIHRoaXMucHJlZC5fdmFsaWRhdGUoZW50aXR5VHlwZSwgdXNlc05hbWVPblNlcnZlcik7XHJcbiAgfVxyXG59XHJcblxyXG5FcnJvclsneCddID0gVW5hcnlQcmVkaWNhdGUucHJvdG90eXBlLl9pbml0aWFsaXplKCd1bmFyeVByZWRpY2F0ZScsIHtcclxuICAnbm90JzogeyBhbGlhc2VzOiBbJyEnLCAnfiddIH0sXHJcbn0pO1xyXG5cclxuLyoqIEZvciB1c2UgYnkgYnJlZXplIHBsdWdpbiBhdXRob3JzIG9ubHkuIFRoZSBjbGFzcyBpcyBmb3IgdXNlIGluIGJ1aWxkaW5nIGEgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSBpbXBsZW1lbnRhdGlvbi4gXHJcbkBhZGFwdGVyIChzZWUgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSkgICAgXHJcbkBoaWRkZW4gXHJcbiovXHJcbmV4cG9ydCBjbGFzcyBCaW5hcnlQcmVkaWNhdGUgZXh0ZW5kcyBQcmVkaWNhdGUge1xyXG4gIG9wOiBPcDtcclxuICBleHByMVNvdXJjZTogYW55O1xyXG4gIGV4cHIyU291cmNlOiBhbnk7XHJcbiAgZXhwcjE/OiBQcmVkaWNhdGVFeHByZXNzaW9uO1xyXG4gIGV4cHIyPzogUHJlZGljYXRlRXhwcmVzc2lvbjtcclxuICBjb25zdHJ1Y3RvcihvcDogc3RyaW5nIHwgUXVlcnlPcCwgZXhwcjE6IGFueSwgZXhwcjI6IGFueSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIC8vIDUgcHVibGljIHByb3BzIG9wLCBleHByMVNvdXJjZSwgZXhwcjJTb3VyY2UsIGV4cHIxLCBleHByMlxyXG4gICAgdGhpcy5vcCA9IHRoaXMuX3Jlc29sdmVPcChvcCk7XHJcbiAgICB0aGlzLmV4cHIxU291cmNlID0gZXhwcjE7XHJcbiAgICB0aGlzLmV4cHIyU291cmNlID0gZXhwcjI7XHJcbiAgICAvLyB0aGlzLmV4cHIxIGFuZCB0aGlzLmV4cHIyIHdvbid0IGJlXHJcbiAgICAvLyBkZXRlcm1pbmVkIHVudGlsIHZhbGlkYXRlIGlzIHJ1blxyXG4gIH1cclxuXHJcblxyXG4gIF92YWxpZGF0ZShlbnRpdHlUeXBlOiBFbnRpdHlUeXBlLCB1c2VzTmFtZU9uU2VydmVyPzogYm9vbGVhbikge1xyXG4gICAgbGV0IGV4cHIxQ29udGV4dCA9IHsgZW50aXR5VHlwZTogZW50aXR5VHlwZSwgdXNlc05hbWVPblNlcnZlcjogdXNlc05hbWVPblNlcnZlciB9O1xyXG4gICAgdGhpcy5leHByMSA9IGNyZWF0ZUV4cHIodGhpcy5leHByMVNvdXJjZSwgZXhwcjFDb250ZXh0KTtcclxuICAgIGlmICh0aGlzLmV4cHIxID09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHZhbGlkYXRlIDFzdCBleHByZXNzaW9uOiBcIiArIHRoaXMuZXhwcjFTb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZXhwcjEgaW5zdGFuY2VvZiBMaXRFeHByKSB7XHJcbiAgICAgIC8vIGxocyBtdXN0IGJlIGVpdGhlciBhIHByb3BlcnR5IG9yIGEgZnVuY3Rpb24uXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsZWZ0IGhhbmQgc2lkZSBvZiBhIGJpbmFyeSBwcmVkaWNhdGUgY2Fubm90IGJlIGEgbGl0ZXJhbCBleHByZXNzaW9uLCBpdCBtdXN0IGJlIGEgdmFsaWQgcHJvcGVydHkgb3IgZnVuY3Rpb25hbCBwcmVkaWNhdGUgZXhwcmVzc2lvbjogXCIgKyB0aGlzLmV4cHIxU291cmNlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5vcC5rZXkgPT09ICdpbicgJiYgIUFycmF5LmlzQXJyYXkodGhpcy5leHByMlNvdXJjZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdpbicgb3BlcmF0b3IgcmVxdWlyZXMgdGhhdCBpdHMgcmlnaHQgaGFuZCBhcmd1bWVudCBiZSBhbiBhcnJheVwiKTtcclxuICAgIH1cclxuICAgIGxldCBleHByMkNvbnRleHQgPSBjb3JlLmV4dGVuZChleHByMUNvbnRleHQsIHsgaXNSSFM6IHRydWUsIGRhdGFUeXBlOiB0aGlzLmV4cHIxLmRhdGFUeXBlIH0pO1xyXG4gICAgdGhpcy5leHByMiA9IGNyZWF0ZUV4cHIodGhpcy5leHByMlNvdXJjZSwgZXhwcjJDb250ZXh0KTtcclxuICAgIGlmICh0aGlzLmV4cHIyID09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHZhbGlkYXRlIDJuZCBleHByZXNzaW9uOiBcIiArIHRoaXMuZXhwcjJTb3VyY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmV4cHIxLmRhdGFUeXBlID09IG51bGwpIHtcclxuICAgICAgdGhpcy5leHByMS5kYXRhVHlwZSA9IHRoaXMuZXhwcjIuZGF0YVR5cGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbn1cclxuXHJcbkVycm9yWyd4J10gPSBCaW5hcnlQcmVkaWNhdGUucHJvdG90eXBlLl9pbml0aWFsaXplKCdiaW5hcnlQcmVkaWNhdGUnLCB7XHJcbiAgJ2VxJzoge1xyXG4gICAgYWxpYXNlczogW1wiPT1cIiwgXCJlcXVhbHNcIl1cclxuICB9LFxyXG4gICduZSc6IHtcclxuICAgIGFsaWFzZXM6IFtcIiE9XCIsIFwifj1cIiwgXCJub3RlcXVhbHNcIl1cclxuICB9LFxyXG4gICdsdCc6IHtcclxuICAgIGFsaWFzZXM6IFtcIjxcIiwgXCJsZXNzdGhhblwiXVxyXG4gIH0sXHJcbiAgJ2xlJzoge1xyXG4gICAgYWxpYXNlczogW1wiPD1cIiwgXCJsZXNzdGhhbm9yZXF1YWxcIl1cclxuICB9LFxyXG4gICdndCc6IHtcclxuICAgIGFsaWFzZXM6IFtcIj5cIiwgXCJncmVhdGVydGhhblwiXVxyXG4gIH0sXHJcbiAgJ2dlJzoge1xyXG4gICAgYWxpYXNlczogW1wiPj1cIiwgXCJncmVhdGVydGhhbm9yZXF1YWxcIl1cclxuICB9LFxyXG4gICdzdGFydHN3aXRoJzoge1xyXG4gICAgaXNGdW5jdGlvbjogdHJ1ZVxyXG4gIH0sXHJcbiAgJ2VuZHN3aXRoJzoge1xyXG4gICAgaXNGdW5jdGlvbjogdHJ1ZVxyXG4gIH0sXHJcbiAgJ2NvbnRhaW5zJzoge1xyXG4gICAgYWxpYXNlczogW1wic3Vic3RyaW5nb2ZcIl0sXHJcbiAgICBpc0Z1bmN0aW9uOiB0cnVlXHJcbiAgfSxcclxuICAnaW4nOiB7XHJcblxyXG4gIH1cclxufSk7XHJcblxyXG4vKiogRm9yIHVzZSBieSBicmVlemUgcGx1Z2luIGF1dGhvcnMgb25seS4gVGhlIGNsYXNzIGlzIGZvciB1c2UgaW4gYnVpbGRpbmcgYSBbW0lVcmlCdWlsZGVyQWRhcHRlcl1dIGltcGxlbWVudGF0aW9uLiBcclxuQGFkYXB0ZXIgKHNlZSBbW0lVcmlCdWlsZGVyQWRhcHRlcl1dKSAgICBcclxuQGhpZGRlblxyXG4qL1xyXG5leHBvcnQgY2xhc3MgQW5kT3JQcmVkaWNhdGUgZXh0ZW5kcyBQcmVkaWNhdGUge1xyXG4gIG9wOiBPcDtcclxuICBwcmVkczogUHJlZGljYXRlW107XHJcbiAgY29uc3RydWN0b3Iob3A6IHN0cmluZyB8IFF1ZXJ5T3AsIHByZWRzOiBhbnlbXSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMub3AgPSB0aGlzLl9yZXNvbHZlT3Aob3ApO1xyXG4gICAgaWYgKHByZWRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHByZWRzWzBdKSkge1xyXG4gICAgICBwcmVkcyA9IHByZWRzWzBdO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wcmVkcyA9IHByZWRzLmZpbHRlcihmdW5jdGlvbiAocHJlZCkge1xyXG4gICAgICByZXR1cm4gcHJlZCAhPSBudWxsO1xyXG4gICAgfSkubWFwKGZ1bmN0aW9uIChwcmVkKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJlZGljYXRlKHByZWQpO1xyXG4gICAgfSk7XHJcbiAgICAvLyBUT0RPOiB0aGlzIHdhcyByZW1vdmVkIC0gdGVzdCBpZiByZWFsbHkgbmVlZGVkLlxyXG4gICAgLy8gaWYgKHRoaXMucHJlZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAvLyAgIC8vIG1hcmtlciBmb3IgYW4gZW1wdHkgcHJlZGljYXRlXHJcbiAgICAvLyAgIHRoaXMub3AgPSBudWxsO1xyXG4gICAgLy8gfVxyXG4gICAgaWYgKHRoaXMucHJlZHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnByZWRzWzBdIGFzIEFuZE9yUHJlZGljYXRlOyAvLyBIQUNLOiB0aGlzLnByZWRzWzBdIGlzIGFjdHVhbGx5IE5PVCBhIEFuZE9yUHJlZGljYXRlIGJ1dCBzb21lIG90aGVyIGtpbmQgb2YgcHJlZC5cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF92YWxpZGF0ZShlbnRpdHlUeXBlOiBFbnRpdHlUeXBlLCB1c2VzTmFtZU9uU2VydmVyPzogYm9vbGVhbikge1xyXG4gICAgdGhpcy5wcmVkcy5mb3JFYWNoKChwcmVkKSA9PiB7XHJcbiAgICAgIHByZWQuX3ZhbGlkYXRlKGVudGl0eVR5cGUsIHVzZXNOYW1lT25TZXJ2ZXIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5FcnJvclsneCddID0gQW5kT3JQcmVkaWNhdGUucHJvdG90eXBlLl9pbml0aWFsaXplKFwiYW5kT3JQcmVkaWNhdGVcIiwge1xyXG4gICdhbmQnOiB7IGFsaWFzZXM6IFsnJiYnXSB9LFxyXG4gICdvcic6IHsgYWxpYXNlczogWyd8fCddIH1cclxufSApO1xyXG5cclxuLyoqIEZvciB1c2UgYnkgYnJlZXplIHBsdWdpbiBhdXRob3JzIG9ubHkuIFRoZSBjbGFzcyBpcyBmb3IgdXNlIGluIGJ1aWxkaW5nIGEgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSBpbXBsZW1lbnRhdGlvbi4gXHJcbkBhZGFwdGVyIChzZWUgW1tJVXJpQnVpbGRlckFkYXB0ZXJdXSkgICAgXHJcbkBoaWRkZW4gXHJcbiovXHJcbmV4cG9ydCBjbGFzcyBBbnlBbGxQcmVkaWNhdGUgZXh0ZW5kcyBQcmVkaWNhdGUge1xyXG4gIG9wOiBPcDtcclxuICAvKiogQGludGVybmFsICovXHJcbiAgZXhwcjogUHJlZGljYXRlRXhwcmVzc2lvbjtcclxuICBleHByU291cmNlOiBzdHJpbmc7XHJcbiAgcHJlZDogUHJlZGljYXRlO1xyXG4gIC8vIDQgcHVibGljIHByb3BzOiBvcCwgZXhwclNvdXJjZSwgZXhwciwgcHJlZFxyXG4gIGNvbnN0cnVjdG9yKG9wOiBzdHJpbmcgfCBRdWVyeU9wLCBleHByOiBzdHJpbmcsIHByZWQ6IGFueSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMub3AgPSB0aGlzLl9yZXNvbHZlT3Aob3ApO1xyXG4gICAgdGhpcy5leHByU291cmNlID0gZXhwcjtcclxuICAgIC8vIHRoaXMuZXhwciB3aWxsIG5vdCBiZSByZXNvbHZlZCB1bnRpbCB2YWxpZGF0ZSBpcyBjYWxsZWRcclxuICAgIHRoaXMucHJlZCA9IG5ldyBQcmVkaWNhdGUocHJlZCk7XHJcbiAgfVxyXG5cclxuICBfdmFsaWRhdGUoZW50aXR5VHlwZTogRW50aXR5VHlwZSwgdXNlc05hbWVPblNlcnZlcjogYm9vbGVhbikge1xyXG4gICAgdGhpcy5leHByID0gY3JlYXRlRXhwcih0aGlzLmV4cHJTb3VyY2UsIHsgZW50aXR5VHlwZTogZW50aXR5VHlwZSwgdXNlc05hbWVPblNlcnZlcjogdXNlc05hbWVPblNlcnZlciB9IGFzIEV4cHJlc3Npb25Db250ZXh0KTtcclxuICAgIC8vIGNhbid0IHJlYWxseSBrbm93IHRoZSBwcmVkaWNhdGVFbnRpdHlUeXBlIHVubGVzcyB0aGUgb3JpZ2luYWwgZW50aXR5IHR5cGUgd2FzIGtub3duLlxyXG4gICAgaWYgKGVudGl0eVR5cGUgPT0gbnVsbCB8fCBlbnRpdHlUeXBlLmlzQW5vbnltb3VzKSB7XHJcbiAgICAgIHRoaXMuZXhwci5kYXRhVHlwZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHRoaXMucHJlZC5fdmFsaWRhdGUodGhpcy5leHByLmRhdGFUeXBlIGFzIEVudGl0eVR5cGUgfCB1bmRlZmluZWQsIHVzZXNOYW1lT25TZXJ2ZXIpO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbkVycm9yWyd4J10gPSBBbnlBbGxQcmVkaWNhdGUucHJvdG90eXBlLl9pbml0aWFsaXplKFwiYW55QWxsUHJlZGljYXRlXCIsIHtcclxuICAnYW55JzogeyBhbGlhc2VzOiBbJ3NvbWUnXSB9LFxyXG4gICdhbGwnOiB7IGFsaWFzZXM6IFtcImV2ZXJ5XCJdIH1cclxufSk7XHJcblxyXG4vKiogQGhpZGRlbiAqL1xyXG5leHBvcnQgY2xhc3MgUHJlZGljYXRlRXhwcmVzc2lvbiB7XHJcbiAgdmlzaXRvck1ldGhvZE5hbWU6IHN0cmluZztcclxuICB2aXNpdDogRnVuY3Rpb247IC8vIFRPRE9cclxuICBkYXRhVHlwZT86IERhdGFUeXBlIHwgU3RydWN0dXJhbFR5cGU7XHJcbiAgY29uc3RydWN0b3IodmlzaXRvck1ldGhvZE5hbWU6IHN0cmluZykge1xyXG4gICAgdGhpcy52aXNpdG9yTWV0aG9kTmFtZSA9IHZpc2l0b3JNZXRob2ROYW1lO1xyXG4gICAgLy8gZ2l2ZSBleHByZXNzaW9ucyB0aGUgUHJlZGljYXRlIHByb3RvdHlwZSBtZXRob2RcclxuICAgIHRoaXMudmlzaXQgPSBQcmVkaWNhdGUucHJvdG90eXBlLnZpc2l0O1xyXG4gIH1cclxuXHJcbiAgLy8gZGVmYXVsdCBpbXBscyAtIG1heS93aWxsIGJlIG92ZXJyaWRkZW4gYmUgc3ViY2xhc3MgZXhwcmVzc2lvbnNcclxuICBfdmFsaWRhdGUoZW50aXR5VHlwZTogRW50aXR5VHlwZSB8IHVuZGVmaW5lZCwgdXNlc05hbWVPblNlcnZlcj86IGJvb2xlYW4pIHtcclxuICAgIC8vIG5vb3A7XHJcbiAgfVxyXG59XHJcblxyXG4vKiogRm9yIHVzZSBieSBicmVlemUgcGx1Z2luIGF1dGhvcnMgb25seS4gVGhlIGNsYXNzIGlzIGZvciB1c2UgaW4gYnVpbGRpbmcgYSBbW0lVcmlCdWlsZGVyQWRhcHRlcl1dIGltcGxlbWVudGF0aW9uLiBcclxuQGFkYXB0ZXIgKHNlZSBbW0lVcmlCdWlsZGVyQWRhcHRlcl1dKSAgICBcclxuQGhpZGRlbiBcclxuKi9cclxuZXhwb3J0IGNsYXNzIExpdEV4cHIgZXh0ZW5kcyBQcmVkaWNhdGVFeHByZXNzaW9uIHtcclxuICB2YWx1ZTogYW55O1xyXG4gIGRhdGFUeXBlOiBEYXRhVHlwZTtcclxuICBoYXNFeHBsaWNpdERhdGFUeXBlOiBib29sZWFuO1xyXG4gIC8vIDIgcHVibGljIHByb3BzOiB2YWx1ZSwgZGF0YVR5cGVcclxuICBjb25zdHJ1Y3Rvcih2YWx1ZTogYW55LCBkYXRhVHlwZTogc3RyaW5nIHwgRGF0YVR5cGUgfCB1bmRlZmluZWQsIGhhc0V4cGxpY2l0RGF0YVR5cGU/OiBib29sZWFuKSB7XHJcbiAgICBzdXBlcihcImxpdEV4cHJcIik7XHJcbiAgICAvLyBkYXRhVHlwZSBtYXkgY29tZSBpcyBhbiBhIHN0cmluZ1xyXG4gICAgbGV0IGR0MSA9IHJlc29sdmVEYXRhVHlwZShkYXRhVHlwZSk7XHJcbiAgICAvLyBpZiB0aGUgRGF0YVR5cGUgY29tZXMgaW4gYXMgVW5kZWZpbmVkIHRoaXMgbWVhbnNcclxuICAgIC8vIHRoYXQgd2Ugc2hvdWxkIE5PVCBhdHRlbXB0IHRvIHBhcnNlIGl0IGJ1dCBqdXN0IGxlYXZlIGl0IGFsb25lXHJcbiAgICAvLyBmb3Igbm93IC0gdGhpcyBpcyB1c3VhbGx5IGJlY2F1c2UgaXQgaXMgcGFydCBvZiBhIEZ1bmMgZXhwci5cclxuICAgIC8vIFRPRE86IGNhc3QgYXMgRGF0YVR5cGUgc2VlbXMgdG8gYmUgbmVlZGVkIGJ5IGVhcmx5IHZlcnNpb24gb2YgVHlwZURvYyAtIG1heSBiZSBhYmxlIHRvIHJlbW92ZSBsYXRlclxyXG4gICAgbGV0IGR0MiA9IChkdDEgfHwgRGF0YVR5cGUuZnJvbVZhbHVlKHZhbHVlKSkgYXMgRGF0YVR5cGU7XHJcblxyXG4gICAgaWYgKGR0Mi5wYXJzZSkge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWUubWFwKCh2KSA9PiB7IHJldHVybiBkdDIucGFyc2UhKHYsIHR5cGVvZiB2KTsgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IGR0Mi5wYXJzZSh2YWx1ZSwgdHlwZW9mIHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5kYXRhVHlwZSA9IGR0MjtcclxuICAgIHRoaXMuaGFzRXhwbGljaXREYXRhVHlwZSA9ICEhaGFzRXhwbGljaXREYXRhVHlwZTtcclxuICB9XHJcblxyXG4gIHRvU3RyaW5nKCkge1xyXG4gICAgcmV0dXJuIFwiIExpdEV4cHIgLSB2YWx1ZTogXCIgKyB0aGlzLnZhbHVlLnRvU3RyaW5nKCkgKyBcIiBkYXRhVHlwZTogXCIgKyB0aGlzLmRhdGFUeXBlLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZURhdGFUeXBlKGRhdGFUeXBlPzogRGF0YVR5cGUgfCBzdHJpbmcpIHtcclxuICBpZiAoZGF0YVR5cGUgPT0gbnVsbCkgcmV0dXJuIGRhdGFUeXBlO1xyXG4gIC8vIGlmIChEYXRhVHlwZS5jb250YWlucyhkYXRhVHlwZSkpIHtcclxuICBpZiAoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZSkge1xyXG4gICAgcmV0dXJuIGRhdGFUeXBlO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGRhdGFUeXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgbGV0IGR0ID0gRGF0YVR5cGUuZnJvbU5hbWUoZGF0YVR5cGUpIGFzIERhdGFUeXBlO1xyXG4gICAgaWYgKGR0KSByZXR1cm4gZHQ7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBhIGRhdGFUeXBlIG5hbWVkOiBcIiArIGRhdGFUeXBlKTtcclxuICB9XHJcblxyXG4gIHRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhVHlwZSBwYXJhbWV0ZXIgcGFzc2VkIGludG8gdGhpcyBsaXRlcmFsIGV4cHJlc3Npb24gaXMgbm90IGEgJ0RhdGFUeXBlJ1wiICsgZGF0YVR5cGUpO1xyXG59XHJcblxyXG4vKiogRm9yIHVzZSBieSBicmVlemUgcGx1Z2luIGF1dGhvcnMgb25seS4gVGhlIGNsYXNzIGlzIGZvciB1c2UgaW4gYnVpbGRpbmcgYSBbW0lVcmlCdWlsZGVyQWRhcHRlcl1dIGltcGxlbWVudGF0aW9uLiBcclxuQGFkYXB0ZXIgKHNlZSBbW0lVcmlCdWlsZGVyQWRhcHRlcl1dKSAgICBcclxuQGhpZGRlbiBcclxuKi9cclxuZXhwb3J0IGNsYXNzIFByb3BFeHByIGV4dGVuZHMgUHJlZGljYXRlRXhwcmVzc2lvbiB7XHJcbiAgcHJvcGVydHlQYXRoOiBzdHJpbmc7XHJcbiAgZGF0YVR5cGU6IERhdGFUeXBlIHwgU3RydWN0dXJhbFR5cGU7XHJcbiAgLy8gdHdvIHB1YmxpYyBwcm9wczogcHJvcGVydHlQYXRoLCBkYXRlVHlwZVxyXG4gIGNvbnN0cnVjdG9yKHByb3BlcnR5UGF0aDogc3RyaW5nKSB7XHJcbiAgICBzdXBlcigncHJvcEV4cHInKTtcclxuICAgIHRoaXMucHJvcGVydHlQYXRoID0gcHJvcGVydHlQYXRoO1xyXG4gICAgLy90aGlzLmRhdGFUeXBlID0gRGF0YVR5cGUuVW5kZWZpbmVkO1xyXG4gICAgLy8gdGhpcy5kYXRhVHlwZSByZXNvbHZlZCBhZnRlciB2YWxpZGF0ZSAoIGlmIG5vdCBvbiBhbiBhbm9uIHR5cGUgfVxyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gXCIgUHJvcEV4cHIgLSBcIiArIHRoaXMucHJvcGVydHlQYXRoO1xyXG4gIH1cclxuXHJcbiAgX3ZhbGlkYXRlKGVudGl0eVR5cGU6IEVudGl0eVR5cGUgfCB1bmRlZmluZWQsIHVzZXNOYW1lT25TZXJ2ZXI/OiBib29sZWFuKSB7XHJcblxyXG4gICAgaWYgKGVudGl0eVR5cGUgPT0gbnVsbCB8fCBlbnRpdHlUeXBlLmlzQW5vbnltb3VzKSByZXR1cm47XHJcbiAgICBsZXQgcHJvcHMgPSBlbnRpdHlUeXBlLmdldFByb3BlcnRpZXNPblBhdGgodGhpcy5wcm9wZXJ0eVBhdGgsIG51bGwsIGZhbHNlKTtcclxuXHJcbiAgICBpZiAoIXByb3BzKSB7XHJcbiAgICAgIGxldCBtc2cgPSBjb3JlLmZvcm1hdFN0cmluZyhcIlVuYWJsZSB0byByZXNvbHZlIHByb3BlcnR5UGF0aC4gIEVudGl0eVR5cGU6ICclMScgICBQcm9wZXJ0eVBhdGg6ICclMidcIiwgZW50aXR5VHlwZS5uYW1lLCB0aGlzLnByb3BlcnR5UGF0aCk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xyXG4gICAgfVxyXG4gICAgLy8gZ2V0IHRoZSBsYXN0IHByb3BlcnR5XHJcbiAgICBsZXQgcHJvcCA9IHByb3BzW3Byb3BzLmxlbmd0aCAtIDFdO1xyXG4gICAgaWYgKHByb3AgaW5zdGFuY2VvZiBEYXRhUHJvcGVydHkpIHtcclxuICAgICAgdGhpcy5kYXRhVHlwZSA9IHByb3AuZGF0YVR5cGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmRhdGFUeXBlID0gcHJvcC5lbnRpdHlUeXBlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn1cclxuXHJcbi8qKiBGb3IgdXNlIGJ5IGJyZWV6ZSBwbHVnaW4gYXV0aG9ycyBvbmx5LiBUaGUgY2xhc3MgaXMgZm9yIHVzZSBpbiBidWlsZGluZyBhIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0gaW1wbGVtZW50YXRpb24uIFxyXG5AYWRhcHRlciAoc2VlIFtbSVVyaUJ1aWxkZXJBZGFwdGVyXV0pICAgIFxyXG5AaGlkZGVuIEBkeW5hbWljXHJcbiovXHJcbmV4cG9ydCBjbGFzcyBGbkV4cHIgZXh0ZW5kcyBQcmVkaWNhdGVFeHByZXNzaW9uIHtcclxuICBmbk5hbWU6IHN0cmluZztcclxuICBleHByczogUHJlZGljYXRlRXhwcmVzc2lvbltdO1xyXG4gIGxvY2FsRm46IGFueTsgLy8gVE9ETzpcclxuICBkYXRhVHlwZTogRGF0YVR5cGU7XHJcbiAgY29uc3RydWN0b3IoZm5OYW1lOiBzdHJpbmcsIGV4cHJzOiBQcmVkaWNhdGVFeHByZXNzaW9uW10pIHtcclxuICAgIHN1cGVyKCdmbkV4cHInKTtcclxuICAgIC8vIDQgcHVibGljIHByb3BzOiBmbk5hbWUsIGV4cHJzLCBsb2NhbEZuLCBkYXRhVHlwZVxyXG4gICAgdGhpcy5mbk5hbWUgPSBmbk5hbWU7XHJcbiAgICB0aGlzLmV4cHJzID0gZXhwcnM7XHJcbiAgICBsZXQgcWYgPSBGbkV4cHIuX2Z1bmNNYXBbZm5OYW1lXTtcclxuICAgIGlmIChxZiA9PSBudWxsKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZnVuY3Rpb246IFwiICsgZm5OYW1lKTtcclxuICAgIH1cclxuICAgIHRoaXMubG9jYWxGbiA9IHFmLmZuO1xyXG4gICAgdGhpcy5kYXRhVHlwZSA9IHFmLmRhdGFUeXBlO1xyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICBsZXQgZXhwclN0ciA9IHRoaXMuZXhwcnMubWFwKGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgIGV4cHIudG9TdHJpbmcoKTtcclxuICAgIH0pLnRvU3RyaW5nKCk7XHJcbiAgICByZXR1cm4gXCJGbkV4cHIgLSBcIiArIHRoaXMuZm5OYW1lICsgXCIoXCIgKyBleHByU3RyICsgXCIpXCI7XHJcbiAgfVxyXG5cclxuICBfdmFsaWRhdGUoZW50aXR5VHlwZTogRW50aXR5VHlwZSB8IHVuZGVmaW5lZCwgdXNlc05hbWVPblNlcnZlcj86IGJvb2xlYW4pIHtcclxuICAgIHRoaXMuZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZXhwcikge1xyXG4gICAgICBleHByLl92YWxpZGF0ZShlbnRpdHlUeXBlLCB1c2VzTmFtZU9uU2VydmVyKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9mdW5jTWFwID0ge1xyXG4gICAgdG91cHBlcjoge1xyXG4gICAgICBmbjogZnVuY3Rpb24gKHNvdXJjZTogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICB9LCBkYXRhVHlwZTogRGF0YVR5cGUuU3RyaW5nXHJcbiAgICB9LFxyXG4gICAgdG9sb3dlcjoge1xyXG4gICAgICBmbjogZnVuY3Rpb24gKHNvdXJjZTogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICB9LCBkYXRhVHlwZTogRGF0YVR5cGUuU3RyaW5nXHJcbiAgICB9LFxyXG4gICAgc3Vic3RyaW5nOiB7XHJcbiAgICAgIGZuOiBmdW5jdGlvbiAoc291cmNlOiBzdHJpbmcsIHBvczogbnVtYmVyLCBsZW5ndGg6IG51bWJlcikge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic3RyaW5nKHBvcywgbGVuZ3RoKTtcclxuICAgICAgfSwgZGF0YVR5cGU6IERhdGFUeXBlLlN0cmluZ1xyXG4gICAgfSxcclxuICAgIHN1YnN0cmluZ29mOiB7XHJcbiAgICAgIGZuOiBmdW5jdGlvbiAoZmluZDogc3RyaW5nLCBzb3VyY2U6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UuaW5kZXhPZihmaW5kKSA+PSAwO1xyXG4gICAgICB9LCBkYXRhVHlwZTogRGF0YVR5cGUuQm9vbGVhblxyXG4gICAgfSxcclxuICAgIGxlbmd0aDoge1xyXG4gICAgICBmbjogZnVuY3Rpb24gKHNvdXJjZTogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5sZW5ndGg7XHJcbiAgICAgIH0sIGRhdGFUeXBlOiBEYXRhVHlwZS5JbnQzMlxyXG4gICAgfSxcclxuICAgIHRyaW06IHtcclxuICAgICAgZm46IGZ1bmN0aW9uIChzb3VyY2U6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UudHJpbSgpO1xyXG4gICAgICB9LCBkYXRhVHlwZTogRGF0YVR5cGUuU3RyaW5nXHJcbiAgICB9LFxyXG4gICAgY29uY2F0OiB7XHJcbiAgICAgIGZuOiBmdW5jdGlvbiAoczE6IHN0cmluZywgczI6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzMS5jb25jYXQoczIpO1xyXG4gICAgICB9LCBkYXRhVHlwZTogRGF0YVR5cGUuU3RyaW5nXHJcbiAgICB9LFxyXG4gICAgcmVwbGFjZToge1xyXG4gICAgICBmbjogZnVuY3Rpb24gKHNvdXJjZTogc3RyaW5nLCBmaW5kOiBzdHJpbmcsIHJlcGxhY2U6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZShmaW5kLCByZXBsYWNlKTtcclxuICAgICAgfSwgZGF0YVR5cGU6IERhdGFUeXBlLlN0cmluZ1xyXG4gICAgfSxcclxuICAgIHN0YXJ0c3dpdGg6IHtcclxuICAgICAgZm46IGZ1bmN0aW9uIChzb3VyY2U6IHN0cmluZywgZmluZDogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvcmUuc3RyaW5nU3RhcnRzV2l0aChzb3VyY2UsIGZpbmQpO1xyXG4gICAgICB9LCBkYXRhVHlwZTogRGF0YVR5cGUuQm9vbGVhblxyXG4gICAgfSxcclxuICAgIGVuZHN3aXRoOiB7XHJcbiAgICAgIGZuOiBmdW5jdGlvbiAoc291cmNlOiBzdHJpbmcsIGZpbmQ6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBjb3JlLnN0cmluZ0VuZHNXaXRoKHNvdXJjZSwgZmluZCk7XHJcbiAgICAgIH0sIGRhdGFUeXBlOiBEYXRhVHlwZS5Cb29sZWFuXHJcbiAgICB9LFxyXG4gICAgaW5kZXhvZjoge1xyXG4gICAgICBmbjogZnVuY3Rpb24gKHNvdXJjZTogYW55LCBmaW5kOiBhbnkpIHtcclxuICAgICAgICByZXR1cm4gc291cmNlLmluZGV4T2YoZmluZCk7XHJcbiAgICAgIH0sIGRhdGFUeXBlOiBEYXRhVHlwZS5JbnQzMlxyXG4gICAgfSxcclxuICAgIHJvdW5kOiB7XHJcbiAgICAgIGZuOiBmdW5jdGlvbiAoc291cmNlOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChzb3VyY2UpO1xyXG4gICAgICB9LCBkYXRhVHlwZTogRGF0YVR5cGUuSW50MzJcclxuICAgIH0sXHJcbiAgICBjZWlsaW5nOiB7XHJcbiAgICAgIGZuOiBmdW5jdGlvbiAoc291cmNlOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHNvdXJjZSk7XHJcbiAgICAgIH0sIGRhdGFUeXBlOiBEYXRhVHlwZS5JbnQzMlxyXG4gICAgfSxcclxuICAgIGZsb29yOiB7XHJcbiAgICAgIGZuOiBmdW5jdGlvbiAoc291cmNlOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihzb3VyY2UpO1xyXG4gICAgICB9LCBkYXRhVHlwZTogRGF0YVR5cGUuSW50MzJcclxuICAgIH0sXHJcbiAgICBzZWNvbmQ6IHtcclxuICAgICAgZm46IGZ1bmN0aW9uIChzb3VyY2U6IERhdGUpIHtcclxuICAgICAgICByZXR1cm4gc291cmNlLmdldFNlY29uZHMoKTtcclxuICAgICAgfSwgZGF0YVR5cGU6IERhdGFUeXBlLkludDMyXHJcbiAgICB9LFxyXG4gICAgbWludXRlOiB7XHJcbiAgICAgIGZuOiBmdW5jdGlvbiAoc291cmNlOiBEYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5nZXRNaW51dGVzKCk7XHJcbiAgICAgIH0sIGRhdGFUeXBlOiBEYXRhVHlwZS5JbnQzMlxyXG4gICAgfSxcclxuICAgIGRheToge1xyXG4gICAgICBmbjogZnVuY3Rpb24gKHNvdXJjZTogRGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UuZ2V0RGF0ZSgpO1xyXG4gICAgICB9LCBkYXRhVHlwZTogRGF0YVR5cGUuSW50MzJcclxuICAgIH0sXHJcbiAgICBtb250aDoge1xyXG4gICAgICBmbjogZnVuY3Rpb24gKHNvdXJjZTogRGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UuZ2V0TW9udGgoKSArIDE7XHJcbiAgICAgIH0sIGRhdGFUeXBlOiBEYXRhVHlwZS5JbnQzMlxyXG4gICAgfSxcclxuICAgIHllYXI6IHtcclxuICAgICAgZm46IGZ1bmN0aW9uIChzb3VyY2U6IERhdGUpIHtcclxuICAgICAgICByZXR1cm4gc291cmNlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgIH0sIGRhdGFUeXBlOiBEYXRhVHlwZS5JbnQzMlxyXG4gICAgfVxyXG4gIH07XHJcblxyXG59XHJcblxyXG4vLyBUT0RPOiBhZGQgZGF0YVR5cGVzIGZvciB0aGUgYXJncyBuZXh0IC0gd2lsbCBoZWxwIHRvIGluZmVyIG90aGVyIGRhdGFUeXBlcy5cclxuXHJcblxyXG5sZXQgUlhfSURFTlRJRklFUiA9IC9eW2Etel9dW1xcdy4kXSokL2k7XHJcbi8vIGNvbW1hIGRlbGltaXRlZCBleHByZXNzaW9ucyBpZ25vcmluZyBjb21tYXMgaW5zaWRlIG9mIGJvdGggc2luZ2xlIGFuZCBkb3VibGUgcXVvdGVzLlxyXG5sZXQgUlhfQ09NTUFfREVMSU0xID0gLygnW14nXSonfFteLF0rKS9nO1xyXG5sZXQgUlhfQ09NTUFfREVMSU0yID0gLyhcIlteXCJdKlwifFteLF0rKS9nO1xyXG5sZXQgREVMSU0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDE5MSk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVFeHByKHNvdXJjZTogYW55LCBleHByQ29udGV4dDogRXhwcmVzc2lvbkNvbnRleHQpIHtcclxuICBsZXQgZW50aXR5VHlwZSA9IGV4cHJDb250ZXh0LmVudGl0eVR5cGU7XHJcblxyXG4gIC8vIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgYW4gJ2luJyBjbGF1c2VcclxuICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XHJcbiAgICBpZiAoIWV4cHJDb250ZXh0LmlzUkhTKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5IGV4cHJlc3Npb25zIGFyZSBvbmx5IHBlcm1pdHRlZCBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIGEgQmluYXJ5UHJlZGljYXRlXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBMaXRFeHByKHNvdXJjZSwgZXhwckNvbnRleHQuZGF0YVR5cGUhKTtcclxuICB9XHJcblxyXG4gIGlmICghKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSkge1xyXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnICYmICFzb3VyY2UudG9JU09TdHJpbmcpIHtcclxuICAgICAgLy8gc291cmNlIGlzIGFuIG9iamVjdCBidXQgbm90IGEgRGF0ZS1saWtlIHRoaW5nIHN1Y2ggYXMgYSBKUyBvciBNb21lbnRKUyBEYXRlXHJcbiAgICAgIGlmIChzb3VyY2UudmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIGFuIGV4cHJlc3Npb24gZm9yOiBcIiArIHNvdXJjZSArIFwiIG9uIGVudGl0eVR5cGU6IFwiICsgKGVudGl0eVR5cGUgPyBlbnRpdHlUeXBlLm5hbWUgOiAnbnVsbCcpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc291cmNlLmlzUHJvcGVydHkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb3BFeHByKHNvdXJjZS52YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gd2Ugd2FudCB0byBpbnN1cmUgdGhhdCBhbnkgTGl0RXhwciBjcmVhdGVkIHRoaXMgd2F5IGlzIHRhZ2dlZCB3aXRoICdoYXNFeHBsaWNpdERhdGFUeXBlOiB0cnVlJ1xyXG4gICAgICAgIC8vIGJlY2F1c2Ugd2Ugd2FudCB0byBpbnN1cmUgdGhhdCBpZiB3ZSByb3VuZHRyaXAgdGhydSB0b0pTT04gdGhhdCB3ZSBkb24ndFxyXG4gICAgICAgIC8vIGFjY2lkZW50YWxseSByZWludGVycHJldCB0aGlzIG5vZGUgYXMgYSBQcm9wRXhwci5cclxuICAgICAgICAvLyByZXR1cm4gbmV3IExpdEV4cHIoc291cmNlLnZhbHVlLCBzb3VyY2UuZGF0YVR5cGUgfHwgY29udGV4dC5kYXRhVHlwZSwgISFzb3VyY2UuZGF0YVR5cGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTGl0RXhwcihzb3VyY2UudmFsdWUsIHNvdXJjZS5kYXRhVHlwZSB8fCBleHByQ29udGV4dC5kYXRhVHlwZSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBuZXcgTGl0RXhwcihzb3VyY2UsIGV4cHJDb250ZXh0LmRhdGFUeXBlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChleHByQ29udGV4dC5pc1JIUykge1xyXG4gICAgaWYgKGVudGl0eVR5cGUgPT0gbnVsbCB8fCBlbnRpdHlUeXBlLmlzQW5vbnltb3VzKSB7XHJcbiAgICAgIC8vIGlmIGVudGl0eVR5cGUgaXMgdW5rbm93biB0aGVuIGFzc3VtZSB0aGF0IHRoZSByaHMgaXMgYSBsaXRlcmFsXHJcbiAgICAgIHJldHVybiBuZXcgTGl0RXhwcihzb3VyY2UsIGV4cHJDb250ZXh0LmRhdGFUeXBlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBwYXJzZUxpdE9yUHJvcEV4cHIoc291cmNlLCBleHByQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGxldCByZWdleCA9IC9cXChbXigpXSpcXCkvO1xyXG4gICAgbGV0IG06IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGw7XHJcbiAgICBsZXQgdG9rZW5zOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgd2hpbGUgKG0gPSByZWdleC5leGVjKHNvdXJjZSkpIHtcclxuICAgICAgbGV0IHRva2VuID0gbVswXTtcclxuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICBsZXQgcmVwbCA9IERFTElNICsgaSsrO1xyXG4gICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZSh0b2tlbiwgcmVwbCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc291cmNlLCB0b2tlbnMsIGV4cHJDb250ZXh0KTtcclxuICAgIGV4cHIuX3ZhbGlkYXRlKGVudGl0eVR5cGUsIGV4cHJDb250ZXh0LnVzZXNOYW1lT25TZXJ2ZXIpO1xyXG4gICAgcmV0dXJuIGV4cHI7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUV4cHIoc291cmNlOiBzdHJpbmcsIHRva2Vuczogc3RyaW5nW10sIGV4cHJDb250ZXh0OiBFeHByZXNzaW9uQ29udGV4dCk6IFByZWRpY2F0ZUV4cHJlc3Npb24ge1xyXG4gIGxldCBwYXJ0cyA9IHNvdXJjZS5zcGxpdChERUxJTSk7XHJcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgcmV0dXJuIHBhcnNlTGl0T3JQcm9wRXhwcihwYXJ0c1swXSwgZXhwckNvbnRleHQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbkV4cHIoc291cmNlLCBwYXJ0cywgdG9rZW5zLCBleHByQ29udGV4dCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZUxpdE9yUHJvcEV4cHIodmFsdWU6IHN0cmluZywgZXhwckNvbnRleHQ6IEV4cHJlc3Npb25Db250ZXh0KTogUHJlZGljYXRlRXhwcmVzc2lvbiB7XHJcbiAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XHJcbiAgLy8gdmFsdWUgaXMgZWl0aGVyIGEgc3RyaW5nLCBhIHF1b3RlZCBzdHJpbmcsIGEgbnVtYmVyLCBhIGJvb2wgdmFsdWUsIG9yIGEgZGF0ZVxyXG4gIC8vIGlmIGEgc3RyaW5nICggbm90IGEgcXVvdGVkIHN0cmluZykgdGhlbiB0aGlzIHJlcHJlc2VudHMgYSBwcm9wZXJ0eSBuYW1lICggMXN0ICkgb3IgYSBsaXQgc3RyaW5nICggMm5kKVxyXG4gIGxldCBmaXJzdENoYXIgPSB2YWx1ZS5zdWJzdHIoMCwgMSk7XHJcbiAgbGV0IGlzUXVvdGVkID0gKGZpcnN0Q2hhciA9PT0gXCInXCIgfHwgZmlyc3RDaGFyID09PSAnXCInKSAmJiB2YWx1ZS5sZW5ndGggPiAxICYmIHZhbHVlLnN1YnN0cih2YWx1ZS5sZW5ndGggLSAxKSA9PT0gZmlyc3RDaGFyO1xyXG4gIGlmIChpc1F1b3RlZCkge1xyXG4gICAgbGV0IHVucXVvdGVkVmFsdWUgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMik7XHJcbiAgICByZXR1cm4gbmV3IExpdEV4cHIodW5xdW90ZWRWYWx1ZSwgZXhwckNvbnRleHQuZGF0YVR5cGUgfHwgRGF0YVR5cGUuU3RyaW5nKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbGV0IGVudGl0eVR5cGUgPSBleHByQ29udGV4dC5lbnRpdHlUeXBlO1xyXG4gICAgLy8gVE9ETzogZ2V0IHJpZCBvZiBpc0Fub255bW91cyBiZWxvdyB3aGVuIHdlIGdldCB0aGUgY2hhbmNlLlxyXG4gICAgaWYgKGVudGl0eVR5cGUgPT0gbnVsbCB8fCBlbnRpdHlUeXBlLmlzQW5vbnltb3VzKSB7XHJcbiAgICAgIC8vIHRoaXMgZm9yayB3aWxsIG9ubHkgYmUgcmVhY2hlZCBvbiB0aGUgTEhTIG9mIGFuIEJpbmFyeVByZWRpY2F0ZSAtXHJcbiAgICAgIC8vIGEgUkhTIGV4cHIgY2Fubm90IGdldCBoZXJlIHdpdGggYW4gYW5vbiB0eXBlXHJcbiAgICAgIHJldHVybiBuZXcgUHJvcEV4cHIodmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IG1heUJlSWRlbnRpZmllciA9IFJYX0lERU5USUZJRVIudGVzdCh2YWx1ZSk7XHJcbiAgICAgIGlmIChtYXlCZUlkZW50aWZpZXIpIHtcclxuICAgICAgICAvLyBpZiAoZW50aXR5VHlwZS5nZXRQcm9wZXJ0eSh2YWx1ZSwgZmFsc2UpICE9IG51bGwpIHtcclxuICAgICAgICBpZiAoZW50aXR5VHlwZS5nZXRQcm9wZXJ0aWVzT25QYXRoKHZhbHVlLCBudWxsLCBmYWxzZSkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wRXhwcih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB3ZSBkb24ndCByZWFsbHkga25vdyB0aGUgZGF0YXR5cGUgaGVyZSBiZWNhdXNlIGV2ZW4gdGhvdWdoIGl0IGNvbWVzIGluIGFzIGEgc3RyaW5nXHJcbiAgICAvLyBpdHMgdXN1YWxseSBhIHN0cmluZyBCVVQgaXQgbWlnaHQgYmUgYSBudW1iZXIgIGkuZS4gdGhlIFwiMVwiIG9yIHRoZSBcIjJcIiBmcm9tIGFuIGV4cHJcclxuICAgIC8vIGxpa2UgXCJ0b1VwcGVyKHN1YnN0cmluZyhjb21wYW55TmFtZSwgMSwgMikpXCJcclxuICAgIHJldHVybiBuZXcgTGl0RXhwcih2YWx1ZSwgZXhwckNvbnRleHQuZGF0YVR5cGUpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VGbkV4cHIoc291cmNlOiBzdHJpbmcsIHBhcnRzOiBzdHJpbmdbXSwgdG9rZW5zOiBzdHJpbmdbXSwgZXhwckNvbnRleHQ6IEV4cHJlc3Npb25Db250ZXh0KSB7XHJcbiAgdHJ5IHtcclxuICAgIGxldCBmbk5hbWUgPSBwYXJ0c1swXS50cmltKCkudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICBsZXQgYXJnU291cmNlID0gdG9rZW5zW3BhcnRzWzFdXS50cmltKCkgYXMgc3RyaW5nO1xyXG4gICAgaWYgKGFyZ1NvdXJjZS5zdWJzdHIoMCwgMSkgPT09IFwiKFwiKSB7XHJcbiAgICAgIGFyZ1NvdXJjZSA9IGFyZ1NvdXJjZS5zdWJzdHIoMSwgYXJnU291cmNlLmxlbmd0aCAtIDIpO1xyXG4gICAgfVxyXG4gICAgbGV0IGNvbW1hTWF0Y2hTdHIgPSBzb3VyY2UuaW5kZXhPZihcIidcIikgPj0gMCA/IFJYX0NPTU1BX0RFTElNMSA6IFJYX0NPTU1BX0RFTElNMjtcclxuICAgIGxldCBhcmdzID0gYXJnU291cmNlLm1hdGNoKGNvbW1hTWF0Y2hTdHIpO1xyXG4gICAgbGV0IG5ld0NvbnRleHQgPSBjb3JlLmV4dGVuZCh7fSwgZXhwckNvbnRleHQpIGFzIEV4cHJlc3Npb25Db250ZXh0O1xyXG4gICAgLy8gYSBkYXRhVHlwZSBvZiBVbmRlZmluZWQgb24gYSBjb250ZXh0IGJhc2ljYWxseSBtZWFucyBub3QgdG8gdHJ5IHBhcnNpbmdcclxuICAgIC8vIHRoZSB2YWx1ZSBpZiB0aGUgZXhwciBpcyBhIGxpdGVyYWxcclxuICAgIG5ld0NvbnRleHQuZGF0YVR5cGUgPSBEYXRhVHlwZS5VbmRlZmluZWQ7XHJcbiAgICBuZXdDb250ZXh0LmlzRm5BcmcgPSB0cnVlO1xyXG4gICAgbGV0IGV4cHJzID0gYXJncyEubWFwKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgIHJldHVybiBwYXJzZUV4cHIoYSwgdG9rZW5zLCBuZXdDb250ZXh0KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ldyBGbkV4cHIoZm5OYW1lLCBleHBycyk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgLy8gVE9ETzogcmVtb3ZlZCBvbGQgY29kZSBoZXJlXHJcbiAgICAvLyByZXR1cm4gbnVsbDtcclxuICAgIC8vIGFuZCByZXBsYWNlZCB3aXRoIFxyXG4gICAgdGhyb3cgZTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHRvRnVuY3Rpb25WaXNpdG9yXHJcblxyXG5sZXQgdG9GdW5jdGlvblZpc2l0b3IgPSB7XHJcblxyXG4gIGlzRXh0ZW5kZWQ6IGZhbHNlLFxyXG5cclxuICBwYXNzdGhydVByZWRpY2F0ZTogZnVuY3Rpb24gKHRoaXM6IFBhc3N0aHJ1UHJlZGljYXRlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZXhlY3V0ZSBhbiBQYXNzdGhydVByZWRpY2F0ZSBleHByZXNzaW9uIGFnYWluc3QgdGhlIGxvY2FsIGNhY2hlOiBcIiArIHRoaXMudmFsdWUpO1xyXG4gIH0sXHJcblxyXG4gIHVuYXJ5UHJlZGljYXRlOiBmdW5jdGlvbiAodGhpczogVW5hcnlQcmVkaWNhdGUsIGNvbnRleHQ6IFZpc2l0Q29udGV4dCkge1xyXG4gICAgbGV0IHByZWRGbiA9IHRoaXMucHJlZC52aXNpdChjb250ZXh0KTtcclxuICAgIHN3aXRjaCAodGhpcy5vcC5rZXkpIHtcclxuICAgICAgY2FzZSBcIm5vdFwiOlxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZW50aXR5OiBhbnkpIHtcclxuICAgICAgICAgIHJldHVybiAhcHJlZEZuKGVudGl0eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHVuYXJ5IG9wZXJhdG9yOlwiICsgdGhpcy5vcC5rZXkpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGJpbmFyeVByZWRpY2F0ZTogZnVuY3Rpb24gKHRoaXM6IEJpbmFyeVByZWRpY2F0ZSwgY29udGV4dDogVmlzaXRDb250ZXh0KSB7XHJcbiAgICBsZXQgZXhwcjFGbiA9IHRoaXMuZXhwcjEhLnZpc2l0KGNvbnRleHQpO1xyXG4gICAgbGV0IGV4cHIyRm4gPSB0aGlzLmV4cHIyIS52aXNpdChjb250ZXh0KTtcclxuICAgIGxldCBkYXRhVHlwZSA9IHRoaXMuZXhwcjEhLmRhdGFUeXBlIHx8IHRoaXMuZXhwcjIhLmRhdGFUeXBlO1xyXG4gICAgbGV0IGxxY28gPSBjb250ZXh0LmVudGl0eVR5cGUhLm1ldGFkYXRhU3RvcmUubG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zO1xyXG4gICAgbGV0IHByZWRGbiA9IGdldEJpbmFyeVByZWRpY2F0ZUZuKHRoaXMsIGRhdGFUeXBlIGFzIERhdGFUeXBlLCBscWNvKTtcclxuICAgIGlmIChwcmVkRm4gPT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJpbmFyeVByZWRpY2F0ZSBvcGVyYXRvcjpcIiArIHRoaXMub3Aua2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoZW50aXR5OiBFbnRpdHkpIHtcclxuICAgICAgcmV0dXJuIHByZWRGbiEoZXhwcjFGbihlbnRpdHkpLCBleHByMkZuKGVudGl0eSkpO1xyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICBhbmRPclByZWRpY2F0ZTogZnVuY3Rpb24gKHRoaXM6IEFuZE9yUHJlZGljYXRlLCBjb250ZXh0OiBWaXNpdENvbnRleHQpIHtcclxuICAgIGxldCBwcmVkRm5zID0gdGhpcy5wcmVkcy5tYXAoKHByZWQpID0+IHtcclxuICAgICAgcmV0dXJuIHByZWQudmlzaXQoY29udGV4dCk7XHJcbiAgICB9KTtcclxuICAgIHN3aXRjaCAodGhpcy5vcCEua2V5KSB7XHJcbiAgICAgIGNhc2UgXCJhbmRcIjpcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVudGl0eTogYW55KSB7XHJcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcHJlZEZucy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldiAmJiBjdXIoZW50aXR5KTtcclxuICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICBjYXNlIFwib3JcIjpcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVudGl0eTogYW55KSB7XHJcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcHJlZEZucy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldiB8fCBjdXIoZW50aXR5KTtcclxuICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJvb2xlYW4gb3BlcmF0b3I6XCIgKyB0aGlzLm9wIS5rZXkpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGFueUFsbFByZWRpY2F0ZTogZnVuY3Rpb24gKHRoaXM6IEFueUFsbFByZWRpY2F0ZSwgY29udGV4dDogVmlzaXRDb250ZXh0KSB7XHJcbiAgICBsZXQgZXhwckZuID0gdGhpcy5leHByLnZpc2l0KGNvbnRleHQpO1xyXG4gICAgbGV0IG5ld0NvbnRleHQgPSBjb3JlLmV4dGVuZCh7fSwgY29udGV4dCkgYXMgVmlzaXRDb250ZXh0O1xyXG4gICAgbmV3Q29udGV4dC5lbnRpdHlUeXBlID0gdGhpcy5leHByLmRhdGFUeXBlIGFzIEVudGl0eVR5cGU7XHJcbiAgICBsZXQgcHJlZEZuID0gdGhpcy5wcmVkLnZpc2l0KG5ld0NvbnRleHQpO1xyXG4gICAgbGV0IGFueUFsbFByZWRGbiA9IGdldEFueUFsbFByZWRpY2F0ZUZuKHRoaXMub3ApO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbnRpdHk6IGFueSkge1xyXG4gICAgICByZXR1cm4gYW55QWxsUHJlZEZuKGV4cHJGbihlbnRpdHkpLCBwcmVkRm4pO1xyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICBsaXRFeHByOiBmdW5jdGlvbiAodGhpczogTGl0RXhwcikge1xyXG4gICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZW50aXR5OiBhbnkpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICBwcm9wRXhwcjogZnVuY3Rpb24gKHRoaXM6IFByb3BFeHByKSB7XHJcbiAgICBsZXQgcHJvcGVydHlQYXRoID0gdGhpcy5wcm9wZXJ0eVBhdGg7XHJcbiAgICBsZXQgcHJvcGVydGllcyA9IHByb3BlcnR5UGF0aC5zcGxpdCgnLicpO1xyXG4gICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZW50aXR5OiBhbnkpIHtcclxuICAgICAgICByZXR1cm4gZW50aXR5LmdldFByb3BlcnR5KHByb3BlcnR5UGF0aCk7XHJcbiAgICAgIH07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVudGl0eTogRW50aXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIEVudGl0eUFzcGVjdC5nZXRQcm9wZXJ0eVBhdGhWYWx1ZShlbnRpdHksIHByb3BlcnRpZXMpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGZuRXhwcjogZnVuY3Rpb24gKHRoaXM6IEZuRXhwciwgY29udGV4dDogRXhwcmVzc2lvbkNvbnRleHQpIHtcclxuICAgIGxldCBleHByRm5zID0gdGhpcy5leHBycy5tYXAoZnVuY3Rpb24gKGV4cHIpIHtcclxuICAgICAgcmV0dXJuIGV4cHIudmlzaXQoY29udGV4dCk7XHJcbiAgICB9KTtcclxuICAgIGxldCB0aGF0ID0gdGhpcztcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZW50aXR5OiBhbnkpIHtcclxuICAgICAgbGV0IHZhbHVlcyA9IGV4cHJGbnMubWFwKGZ1bmN0aW9uIChleHByRm4pIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSBleHByRm4oZW50aXR5KTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH0pO1xyXG4gICAgICBsZXQgcmVzdWx0ID0gdGhhdC5sb2NhbEZuLmFwcGx5KG51bGwsIHZhbHVlcyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRBbnlBbGxQcmVkaWNhdGVGbihvcDogT3ApOiAodjE6IGFueVtdLCB2MjogYW55KSA9PiBib29sZWFuIHtcclxuICBzd2l0Y2ggKG9wLmtleSkge1xyXG4gICAgY2FzZSBcImFueVwiOlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYxLCB2Mikge1xyXG4gICAgICAgIHJldHVybiB2MS5zb21lKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICByZXR1cm4gdjIodik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICBjYXNlIFwiYWxsXCI6XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodjEsIHYyKSB7XHJcbiAgICAgICAgcmV0dXJuIHYxLmV2ZXJ5KGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICByZXR1cm4gdjIodik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yOiBcIiArIG9wLmtleSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRCaW5hcnlQcmVkaWNhdGVGbihiaW5hcnlQcmVkaWNhdGU6IEJpbmFyeVByZWRpY2F0ZSwgZGF0YVR5cGU6IERhdGFUeXBlLCBscWNvOiBMb2NhbFF1ZXJ5Q29tcGFyaXNvbk9wdGlvbnMpIHtcclxuICBsZXQgb3AgPSBiaW5hcnlQcmVkaWNhdGUub3A7XHJcbiAgbGV0IG1jID0gRGF0YVR5cGUuZ2V0Q29tcGFyYWJsZUZuKGRhdGFUeXBlKTtcclxuICBsZXQgcHJlZEZuOiAodjE6IGFueSwgdjI6IGFueSkgPT4gYm9vbGVhbjtcclxuICBzd2l0Y2ggKG9wLmtleSkge1xyXG4gICAgY2FzZSAnZXEnOlxyXG4gICAgICBwcmVkRm4gPSBmdW5jdGlvbiAodjEsIHYyKSB7XHJcbiAgICAgICAgaWYgKHYxICYmIHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybiBzdHJpbmdFcXVhbHModjEsIHYyLCBscWNvKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG1jKHYxKSA9PT0gbWModjIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICduZSc6XHJcbiAgICAgIHByZWRGbiA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuICAgICAgICBpZiAodjEgJiYgdHlwZW9mIHYxID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgcmV0dXJuICFzdHJpbmdFcXVhbHModjEsIHYyLCBscWNvKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG1jKHYxKSAhPT0gbWModjIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdndCc6XHJcbiAgICAgIHByZWRGbiA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuICAgICAgICByZXR1cm4gbWModjEpID4gbWModjIpO1xyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2dlJzpcclxuICAgICAgcHJlZEZuID0gZnVuY3Rpb24gKHYxLCB2Mikge1xyXG4gICAgICAgIHJldHVybiBtYyh2MSkgPj0gbWModjIpO1xyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2x0JzpcclxuICAgICAgcHJlZEZuID0gZnVuY3Rpb24gKHYxLCB2Mikge1xyXG4gICAgICAgIHJldHVybiBtYyh2MSkgPCBtYyh2Mik7XHJcbiAgICAgIH07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnbGUnOlxyXG4gICAgICBwcmVkRm4gPSBmdW5jdGlvbiAodjEsIHYyKSB7XHJcbiAgICAgICAgcmV0dXJuIG1jKHYxKSA8PSBtYyh2Mik7XHJcbiAgICAgIH07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAnc3RhcnRzd2l0aCc6XHJcbiAgICAgIHByZWRGbiA9IGZ1bmN0aW9uICh2MSwgdjIpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5nU3RhcnRzV2l0aCh2MSwgdjIsIGxxY28pO1xyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2VuZHN3aXRoJzpcclxuICAgICAgcHJlZEZuID0gZnVuY3Rpb24gKHYxLCB2Mikge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmdFbmRzV2l0aCh2MSwgdjIsIGxxY28pO1xyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2NvbnRhaW5zJzpcclxuICAgICAgcHJlZEZuID0gZnVuY3Rpb24gKHYxLCB2Mikge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmdDb250YWlucyh2MSwgdjIsIGxxY28pO1xyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2luJzpcclxuICAgICAgcHJlZEZuID0gZnVuY3Rpb24gKHYxOiBhbnksIHYyOiBhbnlbXSkge1xyXG4gICAgICAgIHYxID0gbWModjEpO1xyXG4gICAgICAgIHYyID0gdjIubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBtYyh2KTsgfSk7XHJcbiAgICAgICAgcmV0dXJuIHYyLmluZGV4T2YodjEpID49IDA7XHJcbiAgICAgIH07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHJldHVybiBwcmVkRm47XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ0VxdWFscyhhOiBhbnksIGI6IGFueSwgbHFjbzogTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zKSB7XHJcbiAgaWYgKGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xyXG4gIGlmICh0eXBlb2YgYiAhPT0gJ3N0cmluZycpIHtcclxuICAgIGIgPSBiLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG4gIGlmIChscWNvLnVzZXNTcWw5MkNvbXBsaWFudFN0cmluZ0NvbXBhcmlzb24pIHtcclxuICAgIGEgPSAoYSB8fCBcIlwiKS50cmltKCk7XHJcbiAgICBiID0gKGIgfHwgXCJcIikudHJpbSgpO1xyXG4gIH1cclxuICBpZiAoIWxxY28uaXNDYXNlU2Vuc2l0aXZlKSB7XHJcbiAgICBhID0gKGEgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxuICAgIGIgPSAoYiB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gIH1cclxuICByZXR1cm4gYSA9PT0gYjtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5nU3RhcnRzV2l0aChhOiBhbnksIGI6IGFueSwgbHFjbzogTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zKSB7XHJcbiAgaWYgKCFscWNvLmlzQ2FzZVNlbnNpdGl2ZSkge1xyXG4gICAgYSA9IChhIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBiID0gKGIgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvcmUuc3RyaW5nU3RhcnRzV2l0aChhLCBiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyaW5nRW5kc1dpdGgoYTogYW55LCBiOiBhbnksIGxxY286IExvY2FsUXVlcnlDb21wYXJpc29uT3B0aW9ucykge1xyXG4gIGlmICghbHFjby5pc0Nhc2VTZW5zaXRpdmUpIHtcclxuICAgIGEgPSAoYSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgYiA9IChiIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgfVxyXG4gIHJldHVybiBjb3JlLnN0cmluZ0VuZHNXaXRoKGEsIGIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJpbmdDb250YWlucyhhOiBhbnksIGI6IGFueSwgbHFjbzogTG9jYWxRdWVyeUNvbXBhcmlzb25PcHRpb25zKSB7XHJcbiAgaWYgKCFscWNvLmlzQ2FzZVNlbnNpdGl2ZSkge1xyXG4gICAgYSA9IChhIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBiID0gKGIgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxuICB9XHJcbiAgcmV0dXJuIGEuaW5kZXhPZihiKSA+PSAwO1xyXG59XHJcblxyXG4vLyB0b0pTT05WaXNpdG9yXHJcblxyXG5sZXQgdG9KU09OVmlzaXRvciA9IHtcclxuXHJcbiAgcGFzc3RocnVQcmVkaWNhdGU6IGZ1bmN0aW9uICh0aGlzOiBQYXNzdGhydVByZWRpY2F0ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgfSxcclxuXHJcbiAgdW5hcnlQcmVkaWNhdGU6IGZ1bmN0aW9uICh0aGlzOiBVbmFyeVByZWRpY2F0ZSwgY29udGV4dDogVmlzaXRDb250ZXh0KSB7XHJcbiAgICBsZXQgcHJlZFZhbCA9IHRoaXMucHJlZC52aXNpdChjb250ZXh0KTtcclxuICAgIGxldCBqc29uID0ge307XHJcbiAgICBqc29uW3RoaXMub3Aua2V5XSA9IHByZWRWYWw7XHJcbiAgICByZXR1cm4ganNvbjtcclxuICB9LFxyXG5cclxuICBiaW5hcnlQcmVkaWNhdGU6IGZ1bmN0aW9uICh0aGlzOiBCaW5hcnlQcmVkaWNhdGUsIGNvbnRleHQ6IFZpc2l0Q29udGV4dCkge1xyXG4gICAgbGV0IGV4cHIxVmFsID0gdGhpcy5leHByMSEudmlzaXQoY29udGV4dCk7XHJcbiAgICBsZXQgZXhwcjJWYWwgPSB0aGlzLmV4cHIyIS52aXNpdChjb250ZXh0KTtcclxuICAgIGxldCBqc29uID0ge307XHJcbiAgICBpZiAodGhpcy5leHByMiBpbnN0YW5jZW9mIFByb3BFeHByKSB7XHJcbiAgICAgIGV4cHIyVmFsID0geyB2YWx1ZTogZXhwcjJWYWwsIGlzUHJvcGVydHk6IHRydWUgfTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wLmtleSA9PT0gXCJlcVwiKSB7XHJcbiAgICAgIGpzb25bZXhwcjFWYWxdID0gZXhwcjJWYWw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgdmFsdWUgPSB7fTtcclxuICAgICAganNvbltleHByMVZhbF0gPSB2YWx1ZTtcclxuICAgICAgdmFsdWVbdGhpcy5vcC5rZXldID0gZXhwcjJWYWw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ganNvbjtcclxuICB9LFxyXG5cclxuICBhbmRPclByZWRpY2F0ZTogZnVuY3Rpb24gKHRoaXM6IEFuZE9yUHJlZGljYXRlLCBjb250ZXh0OiBWaXNpdENvbnRleHQpIHtcclxuICAgIGxldCBwcmVkVmFscyA9IHRoaXMucHJlZHMubWFwKGZ1bmN0aW9uIChwcmVkKSB7XHJcbiAgICAgIHJldHVybiBwcmVkLnZpc2l0KGNvbnRleHQpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAoIXByZWRWYWxzIHx8ICFwcmVkVmFscy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gICAgbGV0IGpzb246IE9iamVjdCB8IHVuZGVmaW5lZDtcclxuICAgIC8vIG5vcm1hbGl6ZUFuZCBjbGF1c2VzIGlmIHBvc3NpYmxlLlxyXG4gICAgLy8gcGFzc3RocnUgcHJlZGljYXRlIHdpbGwgYXBwZWFyIGFzIHN0cmluZyBhbmQgdGhlaXIgJ2FuZHMnIGNhbid0IGJlICdub3JtYWxpemVkJ1xyXG4gICAgaWYgKHRoaXMub3AhLmtleSA9PT0gJ2FuZCcgJiYgcHJlZFZhbHMubGVuZ3RoID09PSAyICYmICFwcmVkVmFscy5zb21lKCh2KSA9PiB0eXBlb2YodikgPT09ICdzdHJpbmcnKSkge1xyXG4gICAgICAvLyBub3JtYWxpemUgJ2FuZCcgY2xhdXNlcyAtIHdpbGwgcmV0dXJuIG51bGwgaWYgY2FuJ3QgYmUgY29tYmluZWQuXHJcbiAgICAgIGpzb24gPSBwcmVkVmFscy5yZWR1Y2UoY29tYmluZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoanNvbiA9PSBudWxsKSB7XHJcbiAgICAgIGpzb24gPSB7fTtcclxuICAgICAganNvblt0aGlzLm9wIS5rZXkhXSA9IHByZWRWYWxzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGpzb247XHJcbiAgfSxcclxuXHJcbiAgYW55QWxsUHJlZGljYXRlOiBmdW5jdGlvbiAodGhpczogQW55QWxsUHJlZGljYXRlLCBjb250ZXh0OiBWaXNpdENvbnRleHQpIHtcclxuICAgIGxldCBleHByVmFsID0gdGhpcy5leHByLnZpc2l0KGNvbnRleHQpO1xyXG4gICAgbGV0IG5ld0NvbnRleHQgPSBjb3JlLmV4dGVuZCh7fSwgY29udGV4dCkgYXMgVmlzaXRDb250ZXh0O1xyXG4gICAgbmV3Q29udGV4dC5lbnRpdHlUeXBlID0gdGhpcy5leHByLmRhdGFUeXBlIGFzIEVudGl0eVR5cGU7XHJcbiAgICBsZXQgcHJlZFZhbCA9IHRoaXMucHJlZC52aXNpdChuZXdDb250ZXh0KTtcclxuICAgIGxldCBqc29uID0ge307XHJcbiAgICBsZXQgdmFsdWUgPSB7fTtcclxuICAgIHZhbHVlW3RoaXMub3Aua2V5XSA9IHByZWRWYWw7XHJcbiAgICBqc29uW2V4cHJWYWxdID0gdmFsdWU7XHJcbiAgICByZXR1cm4ganNvbjtcclxuICB9LFxyXG5cclxuICBsaXRFeHByOiBmdW5jdGlvbiAodGhpczogTGl0RXhwciwgY29udGV4dDogVmlzaXRDb250ZXh0KSB7XHJcbiAgICBpZiAodGhpcy5oYXNFeHBsaWNpdERhdGFUeXBlIHx8IGNvbnRleHQudXNlRXhwbGljaXREYXRhVHlwZSkge1xyXG4gICAgICByZXR1cm4geyB2YWx1ZTogdGhpcy52YWx1ZSwgZGF0YVR5cGU6IHRoaXMuZGF0YVR5cGUubmFtZSB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcHJvcEV4cHI6IGZ1bmN0aW9uICh0aGlzOiBQcm9wRXhwciwgY29udGV4dDogVmlzaXRDb250ZXh0KSB7XHJcbiAgICBpZiAoY29udGV4dC50b05hbWVPblNlcnZlcikge1xyXG4gICAgICByZXR1cm4gY29udGV4dC5lbnRpdHlUeXBlIS5jbGllbnRQcm9wZXJ0eVBhdGhUb1NlcnZlcih0aGlzLnByb3BlcnR5UGF0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eVBhdGg7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZm5FeHByOiBmdW5jdGlvbiAodGhpczogRm5FeHByLCBjb250ZXh0OiBWaXNpdENvbnRleHQpIHtcclxuICAgIGxldCBleHByVmFscyA9IHRoaXMuZXhwcnMubWFwKGZ1bmN0aW9uIChleHByKSB7XHJcbiAgICAgIHJldHVybiBleHByLnZpc2l0KGNvbnRleHQpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcy5mbk5hbWUgKyBcIihcIiArIGV4cHJWYWxzLmpvaW4oXCIsXCIpICsgXCIpXCI7XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbmZ1bmN0aW9uIGNvbWJpbmUoajE6IE9iamVjdCwgajI6IE9iamVjdCkge1xyXG4gIGxldCBvayA9IE9iamVjdC5rZXlzKGoyKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICBpZiAoajEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICBpZiAodHlwZW9mIChqMltrZXldKSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvLyBleGl0IGFuZCBpbmRpY2F0ZSB0aGF0IHdlIGNhbid0IGNvbWJpbmVcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNvbWJpbmUoajFba2V5XSwgajJba2V5XSkgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgajFba2V5XSA9IGoyW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9KTtcclxuICByZXR1cm4gb2sgPyBqMSA6IG51bGw7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbiJdfQ==