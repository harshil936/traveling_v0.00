import { core } from './core';
import { assertParam } from './assert-param';
import { config } from './config';
export const INT16_MIN = -32768;
export const INT16_MAX = 32767;
export const INT32_MIN = -2147483648;
export const INT32_MAX = 2147483647;
export const BYTE_MIN = 0;
export const BYTE_MAX = 255;
const ɵ0 = function (context) {
    if (context.property) {
        return context.property.resolveProperty("displayName") || context.propertyName || context.property.name;
    }
    else {
        return "Value";
    }
};
// add common props and methods for every validator 'context' here.
let rootContext = {
    displayName: ɵ0
};
/**
Instances of the Validator class provide the logic to validate another object and provide a description of any errors
encountered during the validation process.  They are typically associated with a 'validators' property on the following types: [[EntityType]],
[[DataProperty]] or [[NavigationProperty]].

A number of property level validators are registered automatically, i.e added to each DataProperty.validators property
based on [[DataProperty]] metadata.  For example,

- DataProperty.dataType -> one of the 'dataType' validator methods such as Validator.int64, Validator.date, Validator.bool etc.
- DataProperty.maxLength -> Validator.maxLength
- DataProperty.isNullable -> Validator.required (if not nullable)

@class Validator
**/
/**
Validator constructor - This method is used to create create custom validations.  Several
basic "Validator" construction methods are also provided as static methods to this class. These methods
provide a simpler syntax for creating basic validations.

Many of these stock validators are inspired by and implemented to conform to the validators defined at
http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.aspx

Sometimes a custom validator will be required.
@example
Most validators will be 'property' level validators, like this.
@example
    // v is this function is the value to be validated, in this case a "country" string.
    var valFn = function (v) {
        if (v == null) return true;
        return (core.stringStartsWith(v, "US"));
    };
    var countryValidator = new Validator("countryIsUS", valFn, {
        displayName: "Country",
        messageTemplate: "'%displayName%' must start with 'US'"
    });

    // Now plug it into Breeze.
    // Assume em1 is a preexisting EntityManager.
    var custType = metadataStore.getEntityType("Customer");
    var countryProp = custType.getProperty("Country");
    // Note that validator is added to a 'DataProperty' validators collection.
    prop.validators.push(countryValidator);
Entity level validators are also possible
@example
    function isValidZipCode(value) {
        var re = /^\d{5}([\-]\d{4})?$/;
        return (re.test(value));
    }

    // v in this case will be a Customer entity
    var valFn = function (v) {
        // This validator only validates US Zip Codes.
        if ( v.getProperty("Country") === "USA") {
            var postalCode = v.getProperty("PostalCode");
            return isValidZipCode(postalCode);
        }
        return true;
    };
    var zipCodeValidator = new Validator("zipCodeValidator", valFn,
        { messageTemplate: "For the US, this is not a valid PostalCode" });

    // Now plug it into Breeze.
    // Assume em1 is a preexisting EntityManager.
    var custType = em1.metadataStore.getEntityType("Customer");
    // Note that validator is added to an 'EntityType' validators collection.
    custType.validators.push(zipCodeValidator);
What is commonly needed is a way of creating a parameterized function that will itself
return a new Validator.  This requires the use of a 'context' object.
@example
    // create a function that will take in a config object
    // and will return a validator
    var numericRangeValidator = function(context) {
        var valFn = function(v, ctx) {
            if (v == null) return true;
            if (typeof(v) !== "number") return false;
            if (ctx.min != null && v < ctx.min) return false;
            if (ctx.max != null && v > ctx.max) return false;
            return true;
        };
        // The last parameter below is the 'context' object that will be passed into the 'ctx' parameter above
        // when this validator executes. Several other properties, such as displayName will get added to this object as well.
        return new Validator("numericRange", valFn, {
            messageTemplate: "'%displayName%' must be a number between the values of %min% and %max%",
            min: context.min,
            max: context.max
        });
    };
    // Assume that freightProperty is a DataEntityProperty that describes numeric values.
    // register the validator
    freightProperty.validators.push(numericRangeValidator({ min: 100, max: 500 }));

Breeze substitutes context values and functions for the tokens in the messageTemplate when preparing the runtime error message;
'displayName' is a pre-defined context function that is always available.

Please note that Breeze substitutes the empty string for falsey parameters. That usually works in your favor.
Sometimes it doesn't as when the 'min' value is zero in which case the message text would have a hole
where the 'min' value goes, saying: "... an integer between the values of and ...". That is not what you want.

To avoid this effect, you may can bake certain of the context values into the 'messageTemplate' itself
as shown in this revision to the pertinent part of the previous example:
@example
    // ... as before
    // ... but bake the min/max values into the message template.
    var template = breeze.core.formatString(
        "'%displayName%' must be a number between the values of %1 and %2",
        context.min, context.max);
    return new Validator("numericRange", valFn, {
        messageTemplate: template,
        min: context.min,
        max: context.max
    });

@method <ctor> Validator
@param name {String} The name of this validator.
@param validatorFn {Function} A function to perform validation.

validatorFn(value, context)
@param validatorFn.value {Object} Value to be validated
@param validatorFn.context {Object} The same context object passed into the constructor with the following additional properties if not
otherwise specified.
@param validatorFn.context.value {Object} The value being validated.
@param validatorFn.context.name {String} The name of the validator being executed.
@param validatorFn.context.displayName {String} This will be either the value of the property's 'displayName' property or
the value of its 'name' property or the string 'Value'
@param validatorFn.context.messageTemplate {String} This will either be the value of Validator.messageTemplates[ {this validators name}] or null. Validator.messageTemplates
is an object that is keyed by validator name and that can be added to in order to 'register' your own message for a given validator.
The following property can also be specified for any validator to force a specific errorMessage string
@param [validatorFn.context.message] {String} If this property is set it will be used instead of the 'messageTemplate' property when an
error message is generated.

@param [context] {Object} A free form object whose properties will made available during the validation and error message creation process.
This object will be passed into the Validator's validation function whenever 'validate' is called. See above for a description
of additional properties that will be automatically added to this object if not otherwise specified.
@dynamic
**/
export class Validator {
    constructor(name, valFn, context) {
        // _baseContext is what will get serialized
        this._baseContext = context || {};
        this._baseContext.name = name;
        context = core.extend(Object.create(rootContext), this._baseContext);
        context.messageTemplate = context.messageTemplate || Validator.messageTemplates[name];
        this.name = name;
        this.valFn = valFn;
        this.context = context;
    }
    /**
    The name of this validator.
  
    __readOnly__
    @property name {String}
    **/
    /**
    The context for this validator.
  
    This object will typically contain at a minimum the following properties. "name", "displayName", and "message" or "messageTemplate".
    __readOnly__
    @property context {Object}
    **/
    /**
    Run this validator against the specified value.  This method will usually be called internally either
    automatically by an property change, entity attach, query or save operation, or manually as a result of
    a validateEntity call on the EntityAspect. The resulting ValidationResults are available via the
    EntityAspect.getValidationErrors method.
  
    However, you can also call a validator directly either for testing purposes or some other reason if needed.
    @example
        // using one of the predefined validators
        var validator = Validator.maxLength({ maxLength: 5, displayName: "City" });
        // should be ok because "asdf".length < 5
        var result = validator.validate("asdf");
        ok(result === null);
        result = validator.validate("adasdfasdf");
        // extract all of the properties of the 'result'
        var errMsg = result.errorMessage;
        var context = result.context;
        var sameValidator = result.validator;
    @method validate
    @param value {Object} Value to validate
    @param additionalContext {Object} Any additional contextual information that the Validator
    can make use of.
    @return {ValidationError|null} A ValidationError if validation fails, null otherwise
    **/
    validate(value, additionalContext) {
        let currentContext; // { value?: Object };
        if (additionalContext) {
            currentContext = core.extend(Object.create(this.context), additionalContext);
        }
        else {
            currentContext = this.context;
        }
        this.currentContext = currentContext;
        try {
            if (this.valFn(value, currentContext)) {
                return null;
            }
            else {
                currentContext.value = value;
                return new ValidationError(this, currentContext, this.getMessage());
            }
        }
        catch (e) {
            return new ValidationError(this, currentContext, "Exception occured while executing this validator: " + this.name);
        }
    }
    // context.value is not avail unless validate was called first.
    /**
    Returns the message generated by the most recent execution of this Validator.
    @example
        var v0 = Validator.maxLength({ maxLength: 5, displayName: "City" });
        v0.validate("adasdfasdf");
        var errMessage = v0.getMessage());
    @method getMessage
    @return {String}
    **/
    getMessage() {
        try {
            let context = this.currentContext;
            let message = context.message;
            if (message) {
                if (typeof (message) === "function") {
                    return message(context);
                }
                else {
                    return message;
                }
            }
            else if (context.messageTemplate) {
                return formatTemplate(context.messageTemplate, context);
            }
            else {
                return "invalid value: " + (this.name || "{unnamed validator}");
            }
        }
        catch (e) {
            return "Unable to format error message" + e.toString();
        }
    }
    toJSON() {
        return this._baseContext;
    }
    /**
    Creates a validator instance from a JSON object or an array of instances from an array of JSON objects.
    @method fromJSON
    @static
    @param json {Object} JSON object that represents the serialized version of a validator.
    **/
    static fromJSON(json) {
        if (Array.isArray(json)) {
            return json.map(function (js) {
                return Validator.fromJSON(js);
            });
        }
        if (json instanceof Validator) {
            return json;
        }
        let validatorName = "Validator." + json.name;
        let fn = config.getRegisteredFunction(validatorName);
        if (!fn) {
            throw new Error("Unable to locate a validator named:" + json.name);
        }
        return fn(json);
    }
    /**
    Register a validator instance so that any deserialized metadata can reference it.
    @method register
    @static
    @param validator {Validator} Validator to register.
    **/
    static register(validator) {
        config.registerFunction(function () {
            return validator;
        }, "Validator." + validator.name);
    }
    /**
    Register a validator factory so that any deserialized metadata can reference it.
    @method registerFactory
    @static
    @param validatorFactory {Function} A function that optionally takes a context property and returns a Validator instance.
    @param name {String} The name of the validator.
    **/
    static registerFactory(validatorFactory, name) {
        config.registerFunction(validatorFactory, "Validator." + name);
    }
}
/**
Map of standard error message templates keyed by validator name.
You can add to or modify this object to customize the template used for any validation error message.
@example
    // v is this function is the value to be validated, in this case a "country" string.
    var valFn = function (v) {
        if (v == null) return true;
        return (core.stringStartsWith(v, "US"));
    };
    var countryValidator = new Validator("countryIsUS", valFn, { displayName: "Country" });
    Validator.messageTemplates.countryIsUS = "'%displayName%' must start with 'US'";
    // This will have a similar effect to this
    var countryValidator = new Validator("countryIsUS", valFn, {
        displayName: "Country",
        messageTemplate: "'%displayName%' must start with 'US'"
    });
@property messageTemplates {Object}
@static
**/
Validator.messageTemplates = {
    bool: "'%displayName%' must be a 'true' or 'false' value",
    creditCard: "The %displayName% is not a valid credit card number",
    date: "'%displayName%' must be a date",
    duration: "'%displayName%' must be a ISO8601 duration string, such as 'P3H24M60S'",
    emailAddress: "The %displayName% '%value%' is not a valid email address",
    guid: "'%displayName%' must be a GUID",
    integer: "'%displayName%' must be an integer",
    integerRange: "'%displayName%' must be an integer between the values of %minValue% and %maxValue%",
    maxLength: "'%displayName%' must be a string with %maxLength% characters or less",
    number: "'%displayName%' must be a number",
    phone: "The %displayName% '%value%' is not a valid phone number",
    regularExpression: "The %displayName% '%value%' does not match '%expression%'",
    required: "'%displayName%' is required",
    string: "'%displayName%' must be a string",
    stringLength: "'%displayName%' must be a string with between %minLength% and %maxLength% characters",
    url: "The %displayName% '%value%' is not a valid url"
};
/**
Returns a standard 'required value' Validator
@example
    // Assume em1 is a preexisting EntityManager.
    var custType = em1.metadataStore.getEntityType("Customer");
    var regionProperty - custType.getProperty("Region");
    // Makes "Region" on Customer a required property.
    regionProperty.validators.push(Validator.required());
    // or to allow empty strings
    regionProperty.validators.push(Validator.required({ allowEmptyStrings: true }););
@method required
@static
@param context {Object}
@param [context.allowEmptyStrings] {Boolean} If this parameter is omitted or false then empty strings do NOT pass validation.
@return {Validator} A new Validator
**/
Validator.required = function (context) {
    let valFn = function (v, ctx) {
        if (typeof v === "string") {
            if (ctx && ctx.allowEmptyStrings)
                return true;
            return v.length > 0;
        }
        else {
            return v != null;
        }
    };
    return new Validator("required", valFn, context);
};
/**
Returns a standard maximum string length Validator; the maximum length must be specified
@example
    // Assume em1 is a preexisting EntityManager.
    var custType = em1.metadataStore.getEntityType("Customer");
    var regionProperty - custType.getProperty("Region");
    // Validates that the value of the Region property on Customer will be less than or equal to 5 characters.
    regionProperty.validators.push(Validator.maxLength( {maxLength: 5}));
@method maxLength
@static
@param context {Object}
@param context.maxLength {Integer}
@return {Validator} A new Validator
**/
Validator.maxLength = function (context) {
    let valFn = function (v, ctx) {
        if (v == null)
            return true;
        if (typeof (v) !== "string")
            return false;
        return v.length <= ctx.maxLength;
    };
    return new Validator("maxLength", valFn, context);
};
/**
Returns a standard string length Validator; both minimum and maximum lengths must be specified.
@example
    // Assume em1 is a preexisting EntityManager.
    var custType = em1.metadataStore.getEntityType("Customer");
    var regionProperty - custType.getProperty("Region");
    // Validates that the value of the Region property on Customer will be
    // between 2 and 5 characters
    regionProperty.validators.push(Validator.stringLength( {minLength: 2, maxLength: 5});
@method stringLength
@static
@param context {Object}
@param context.maxLength {Integer}
@param context.minLength {Integer}
@return {Validator} A new Validator
**/
Validator.stringLength = function (context) {
    let valFn = function (v, ctx) {
        if (v == null)
            return true;
        if (typeof (v) !== "string")
            return false;
        if (ctx.minLength != null && v.length < ctx.minLength)
            return false;
        if (ctx.maxLength != null && v.length > ctx.maxLength)
            return false;
        return true;
    };
    return new Validator("stringLength", valFn, context);
};
/**
Returns a standard string dataType Validator.
@example
    // Assume em1 is a preexisting EntityManager.
    var custType = em1.metadataStore.getEntityType("Customer");
    var regionProperty - custType.getProperty("Region");
    // Validates that the value of the Region property on Customer is a string.
    regionProperty.validators.push(Validator.string());
@method string
@static
@return {Validator} A new Validator
**/
Validator.string = function () {
    let valFn = function (v) {
        if (v == null)
            return true;
        return (typeof v === "string");
    };
    return new Validator("string", valFn);
};
/**
Returns a Guid data type Validator.
@example
    // Assume em1 is a preexisting EntityManager.
    var custType = em1.metadataStore.getEntityType("Customer");
    var customerIdProperty - custType.getProperty("CustomerID");
    // Validates that the value of the CustomerID property on Customer is a Guid.
    customerIdProperty.validators.push(Validator.guid());
@method guid
@static
@return {Validator} A new Validator
**/
Validator.guid = function () {
    let valFn = function (v) {
        if (v == null)
            return true;
        return core.isGuid(v);
    };
    return new Validator("guid", valFn);
};
/**
Returns a ISO 8601 duration string  Validator.
@example
    // Assume em1 is a preexisting EntityManager.
    var eventType = em1.metadataStore.getEntityType("Event");
    var elapsedTimeProperty - eventType.getProperty("ElapsedTime");
    // Validates that the value of the ElapsedTime property on Customer is a duration.
    elapsedTimeProperty.validators.push(Validator.duration());
@method duration
@static
@return {Validator} A new Validator
**/
Validator.duration = function () {
    let valFn = function (v) {
        if (v == null)
            return true;
        return core.isDuration(v);
    };
    return new Validator("duration", valFn);
};
/**
Returns a standard numeric data type Validator.
@example
    // Assume em1 is a preexisting EntityManager.
    var orderType = em1.metadataStore.getEntityType("Order");
    var freightProperty - orderType.getProperty("Freight");
    // Validates that the value of the Freight property on Order is a number.
    freightProperty.validators.push(Validator.number());
@method number
@static
@return {Validator} A new Validator
**/
// TODO: may need to have seperate logic for single.
Validator.number = function (context) {
    let valFn = function (v, ctx) {
        if (v == null)
            return true;
        if (typeof v === "string" && ctx && ctx.allowString) {
            v = parseFloat(v);
        }
        return (typeof v === "number" && !isNaN(v));
    };
    return new Validator("number", valFn, context);
};
Validator.double = Validator.number;
Validator.single = Validator.number;
/**
Returns a standard large integer data type - 64 bit - Validator.
@example
    // Assume em1 is a preexisting EntityManager.
    var orderType = em1.metadataStore.getEntityType("Order");
    var freightProperty - orderType.getProperty("Freight");
    // Validates that the value of the Freight property on Order is within the range of a 64 bit integer.
    freightProperty.validators.push(Validator.int64());
@method int64
@static
@return {Validator} A new Validator
**/
Validator.integer = function (context) {
    let valFn = function (v, ctx) {
        if (v == null)
            return true;
        if (typeof v === "string" && ctx && ctx.allowString) {
            v = parseInt(v, 10);
        }
        return (typeof v === "number") && (!isNaN(v)) && Math.floor(v) === v;
    };
    return new Validator("integer", valFn, context);
};
Validator.int64 = Validator.integer;
/**
Returns a standard 32 bit integer data type Validator.
@example
    // Assume em1 is a preexisting EntityManager.
    var orderType = em1.metadataStore.getEntityType("Order");
    var freightProperty - orderType.getProperty("Freight");
    freightProperty.validators.push(Validator.int32());
@method int32
@static
@return {Validator} A new Validator
**/
Validator.int32 = function (context) {
    return intRangeValidatorCtor("int32", INT32_MIN, INT32_MAX, context)();
};
/**
Returns a standard 16 bit integer data type Validator.
@example
    // Assume em1 is a preexisting EntityManager.
    var orderType = em1.metadataStore.getEntityType("Order");
    var freightProperty - orderType.getProperty("Freight");
    // Validates that the value of the Freight property on Order is within the range of a 16 bit integer.
    freightProperty.validators.push(Validator.int16());
@method int16
@static
@return {Validator} A new Validator
**/
Validator.int16 = function (context) {
    return intRangeValidatorCtor("int16", INT16_MIN, INT16_MAX, context)();
};
/**
Returns a standard byte data type Validator. (This is a integer between 0 and 255 inclusive for js purposes).
@example
    // Assume em1 is a preexisting EntityManager.
    var orderType = em1.metadataStore.getEntityType("Order");
    var freightProperty - orderType.getProperty("Freight");
    // Validates that the value of the Freight property on Order is within the range of a 16 bit integer.
    // Probably not a very good validation to place on the Freight property.
    regionProperty.validators.push(Validator.byte());
@method byte
@static
@return {Validator} A new Validator
**/
Validator.byte = function (context) {
    return intRangeValidatorCtor("byte", BYTE_MIN, BYTE_MAX, context)();
};
/**
Returns a standard boolean data type Validator.
@example
    // Assume em1 is a preexisting EntityManager.
    var productType = em1.metadataStore.getEntityType("Product");
    var discontinuedProperty - productType.getProperty("Discontinued");
    // Validates that the value of the Discontinued property on Product is a boolean
    discontinuedProperty.validators.push(Validator.bool());
@method bool
@static
@return {Validator} A new Validator
**/
Validator.bool = function () {
    let valFn = function (v) {
        if (v == null)
            return true;
        return (v === true) || (v === false);
    };
    return new Validator("bool", valFn);
};
Validator.none = function () {
    let valFn = function (v) {
        return true;
    };
    return new Validator("none", valFn);
};
/**
Returns a standard date data type Validator.
@example
    // Assume em1 is a preexisting EntityManager.
    var orderType = em1.metadataStore.getEntityType("Order");
    var orderDateProperty - orderType.getProperty("OrderDate");
    // Validates that the value of the OrderDate property on Order is a date
    // Probably not a very good validation to place on the Freight property.
    orderDateProperty.validators.push(Validator.date());
@method date
@static
@return {Validator} A new Validator
**/
Validator.date = function () {
    let valFn = function (v) {
        if (v == null)
            return true;
        if (typeof v === "string") {
            try {
                return !isNaN(Date.parse(v));
                // old code
                // return __isDate(new Date(v));
            }
            catch (e) {
                return false;
            }
        }
        else {
            return core.isDate(v);
        }
    };
    return new Validator("date", valFn);
};
/**
Returns a credit card number validator
Performs a luhn algorithm checksum test for plausability
catches simple mistakes; only service knows for sure
@example
    // Assume em is a preexisting EntityManager.
    var personType = em.metadataStore.getEntityType("Person");
    var creditCardProperty = personType.getProperty("creditCard");
    // Validates that the value of the Person.creditCard property is credit card.
    creditCardProperty.validators.push(Validator.creditCard());
@method creditCard
@static
@param [context] {Object} optional parameters to pass through to validation constructor
@return {Validator} A new Validator
**/
Validator.creditCard = function (context) {
    function valFn(v) {
        if (v == null || v === '')
            return true;
        if (typeof (v) !== 'string')
            return false;
        v = v.replace(/(\-|\s)/g, ""); // remove dashes and spaces
        if (!v || /\D/.test(v))
            return false; // all digits, not empty
        return luhn(v);
    }
    return new Validator('creditCard', valFn, context);
};
/**
Returns a regular expression validator; the expression must be specified
@example
    // Add validator to a property. Assume em is a preexisting EntityManager.
    var customerType = em.metadataStore.getEntityType("Customer");
    var regionProperty = customerType.getProperty("Region");
    // Validates that the value of Customer.Region is 2 char uppercase alpha.
    regionProperty.validators.push(Validator.regularExpression( {expression: '^[A-Z]{2}$'} );
@method regularExpression
@static
@param context {Object}
@param context.expression {String} String form of the regular expression to apply
@return {Validator} A new Validator
**/
Validator.regularExpression = function (context) {
    function valFn(v, ctx) {
        // do not invalidate if empty; use a separate required test
        if (v == null || v === '')
            return true;
        if (typeof (v) !== 'string')
            return false;
        try {
            let re = new RegExp(ctx.expression);
            return re.test(v);
        }
        catch (e) {
            throw new Error('Missing or invalid expression parameter to regExp validator');
        }
    }
    return new Validator('regularExpression', valFn, context);
};
/**
Returns the email address validator
@example
    // Assume em is a preexisting EntityManager.
    var personType = em.metadataStore.getEntityType("Person");
    var emailProperty = personType.getProperty("email");
    // Validates that the value of the Person.email property is an email address.
    emailProperty.validators.push(Validator.emailAddress());
@method emailAddress
@static
@param [context] {Object} optional parameters to pass through to validation constructor
@return {Validator} A new Validator
**/
Validator.emailAddress = function (context) {
    // See https://github.com/srkirkland/DataAnnotationsExtensions/blob/master/DataAnnotationsExtensions/EmailAttribute.cs
    let reEmailAddress = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i;
    return makeRegExpValidator('emailAddress', reEmailAddress, null, context);
};
/**
Returns the phone validator
Provides basic assertions on the format and will help to eliminate most nonsense input
Matches:
International dialing prefix: {{}, +, 0, 0000} (with or without a trailing break character, if not '+': [-/. ])
> ((\+)|(0(\d+)?[-/.\s]))
Country code: {{}, 1, ..., 999} (with or without a trailing break character: [-/. ])
> [1-9]\d{,2}[-/.\s]?
Area code: {(0), ..., (000000), 0, ..., 000000} (with or without a trailing break character: [-/. ])
> ((\(\d{1,6}\)|\d{1,6})[-/.\s]?)?
Local: {0, ...}+ (with or without a trailing break character: [-/. ])
> (\d+[-/.\s]?)+\d+
@example
    // Assume em is a preexisting EntityManager.
    var customerType = em.metadataStore.getEntityType("Customer");
    var phoneProperty = customerType.getProperty("phone");
    // Validates that the value of the Customer.phone property is phone.
    phoneProperty.validators.push(Validator.phone());
@method phone
@static
@param [context] {Object} optional parameters to pass through to validation constructor
@return {Validator} A new Validator
**/
Validator.phone = function (context) {
    // See https://github.com/srkirkland/DataAnnotationsExtensions/blob/master/DataAnnotationsExtensions/Expressions.cs
    let rePhone = /^((\+|(0(\d+)?[-/.\s]?))[1-9]\d{0,2}[-/.\s]?)?((\(\d{1,6}\)|\d{1,6})[-/.\s]?)?(\d+[-/.\s]?)+\d+$/;
    return makeRegExpValidator('phone', rePhone, null, context);
};
/**
Returns the URL (protocol required) validator
@example
    // Assume em is a preexisting EntityManager.
    var personType = em.metadataStore.getEntityType("Person");
    var websiteProperty = personType.getProperty("website");
    // Validates that the value of the Person.website property is a URL.
    websiteProperty.validators.push(Validator.url());
@method url
@static
@param [context] {Object} optional parameters to pass through to validation constructor
@return {Validator} A new Validator
**/
Validator.url = function (context) {
    //See https://github.com/srkirkland/DataAnnotationsExtensions/blob/master/DataAnnotationsExtensions/UrlAttribute.cs
    let reUrlProtocolRequired = /^(https?|ftp):\/\/(((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-fA-F]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|([a-zA-Z][\-a-zA-Z0-9]*)|((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-fA-F]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-fA-F]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-fA-F]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-fA-F]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/;
    return makeRegExpValidator('url', reUrlProtocolRequired, null, context);
};
/**
Creates a regular expression validator with a fixed expression.
Many of the stock validators are built with this factory method.
Their expressions are often derived from
https://github.com/srkirkland/DataAnnotationsExtensions/blob/master/DataAnnotationsExtensions
You can try many of them at http://dataannotationsextensions.org/
@example
    // Make a zipcode validator
    function zipValidator = Validator.makeRegExpValidator(
    "zipVal,
    /^\d{5}([\-]\d{4})?$/,
    "The %displayName% '%value%' is not a valid U.S. zipcode");
    // Register it.
    Validator.register(zipValidator);
    // Add it to a data property. Assume em is a preexisting EntityManager.
    var custType = em.metadataStore.getEntityType("Customer");
    var zipProperty = custType.getProperty("PostalCode");
    zipProperty.validators.push(zipValidator);
@method makeRegExpValidator
@static
@param validatorName {String} name of this validator
@param expression {String | RegExp} regular expression to apply
@param [defaultMessage] {String} default message for failed validations
@param [context] {Object} optional parameters to pass through to validation constructor
@return {Validator} A new Validator
**/
Validator.makeRegExpValidator = makeRegExpValidator;
Validator.prototype._$typeName = "Validator";
// register all validators
Error['x'] = core.objectForEach(Validator, function (key, value) {
    if (typeof (value) !== "function") {
        return;
    }
    if (key === "fromJSON" || key === "register" ||
        key === "registerFactory" || key === "makeRegExpValidator") {
        return;
    }
    config.registerFunction(value, "Validator." + key);
});
function formatTemplate(template, vars, ownPropertiesOnly = false) {
    if (!vars)
        return template;
    return template.replace(/%([^%]+)%/g, function (_, key) {
        let valOrFn;
        if (ownPropertiesOnly) {
            valOrFn = vars.hasOwnProperty(key) ? vars[key] : '';
        }
        else {
            valOrFn = vars[key];
        }
        if (valOrFn != null) {
            if (core.isFunction(valOrFn)) {
                return valOrFn(vars);
            }
            else {
                return valOrFn;
            }
        }
        else {
            return "";
        }
    });
}
function intRangeValidatorCtor(validatorName, minValue, maxValue, context) {
    context = context || {};
    if (minValue !== undefined) {
        context.min = minValue;
    }
    if (maxValue !== undefined) {
        context.max = maxValue;
    }
    let templateExists = context.messageTemplate || Validator.messageTemplates[validatorName];
    if (!templateExists) {
        Validator.messageTemplates[validatorName] = core.formatString("'%displayName%' must be an integer between the values of %1 and %2", minValue, maxValue);
    }
    return function () {
        let valFn = function (v, ctx) {
            if (v == null)
                return true;
            if (typeof v === "string" && ctx && ctx.allowString) {
                v = parseInt(v, 0);
            }
            if ((typeof v === "number") && (!isNaN(v)) && Math.floor(v) === v) {
                if (minValue != null && v < minValue) {
                    return false;
                }
                if (maxValue != null && v > maxValue) {
                    return false;
                }
                return true;
            }
            else {
                return false;
            }
        };
        return new Validator(validatorName, valFn, context);
    };
}
export function makeRegExpValidator(validatorName, expression, defaultMessage, context) {
    if (defaultMessage) {
        Validator.messageTemplates[validatorName] = defaultMessage;
    }
    let re = (typeof (expression) === 'string') ? new RegExp(expression) : expression;
    let valFn = function (v) {
        // do not invalidate if empty; use a separate required test
        if (v == null || v === '')
            return true;
        if (typeof (v) !== 'string')
            return false;
        return re.test(v);
    };
    return new Validator(validatorName, valFn, context);
}
const ɵ1 = function () {
    let luhnArr = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];
    return function (str) {
        let counter = 0;
        let incNum;
        let odd = false;
        let temp = String(str).replace(/[^\d]/g, "");
        if (temp.length === 0)
            return false;
        for (let i = temp.length - 1; i >= 0; --i) {
            incNum = parseInt(temp.charAt(i), 10);
            counter += (odd = !odd) ? incNum : luhnArr[incNum];
        }
        return (counter % 10 === 0);
    };
};
// http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers#JavaScript
// function luhn(a: string, b: number, c: number, d: number, e: number) {
//   for (d = +a[b = a.length - 1], e = 0; b--; ) {
//     c = +a[b], d += ++e % 2 ? 2 * c % 10 + (c > 4) : c;
//   }
//   return !(d % 10);
// };
let luhn = (ɵ1)();
/**
A ValidationError is used to describe a failed validation.

@class ValidationError
**/
/**
Constructs a new ValidationError
@method <ctor> ValidationError

@param validator {Validator || null} The Validator used to create this error, if any.
@param context { ContextObject || null} The Context object used in conjunction with the Validator to create this error.
@param errorMessage { String} The actual error message
@param [key] {String} An optional key used to define a key for this error. One will be created automatically if not provided here.
**/
export class ValidationError {
    constructor(validator, context, errorMessage, key) {
        // Error is with isInstanceOf(Validator)
        assertParam(validator, "validator").isOptional().isInstanceOf(Validator).check();
        assertParam(errorMessage, "errorMessage").isNonEmptyString().check();
        assertParam(key, "key").isOptional().isNonEmptyString().check();
        this.validator = validator || undefined;
        context = context || {};
        this.context = context;
        this.errorMessage = errorMessage;
        this.property = context.property;
        this.propertyName = context.propertyName || (context.property && context.property.name);
        if (key) {
            this.key = key;
        }
        else {
            this.key = ValidationError.getKey(validator || errorMessage, this.propertyName);
        }
        this.isServerError = false;
    }
    /**
    The Validator associated with this ValidationError.
  
    __readOnly__
    @property validator {Validator}
    **/
    /**
    A 'context' object associated with this ValidationError.
  
    __readOnly__
    @property context {Object}
    **/
    /**
    The DataProperty or NavigationProperty associated with this ValidationError.
  
    __readOnly__
    @property property {DataProperty|NavigationProperty}
    **/
    /**
    The property name associated with this ValidationError. This will be a "property path" for any properties of a complex object.
  
    __readOnly__
    @property propertyName {String}
    **/
    /**
    The error message associated with the ValidationError.
  
    __readOnly__
    @property errorMessage {string}
    **/
    /**
    The key by which this validation error may be removed from a collection of ValidationErrors.
  
    __readOnly__
    @property key {string}
    **/
    /**
    Whether this is a server error.
  
    __readOnly__
    @property isServerError {bool}
    **/
    /**
    Composes a ValidationError 'key' given a validator or an errorName and an optional propertyName
    @method getKey
    @static
    @param validator {ValidatorOrErrorKey} A Validator or an "error name" if no validator is available.
    @param [propertyName] A property name
    @return {String} A ValidationError 'key'
    **/
    static getKey(validatorOrErrorName, propertyName) {
        let name = (typeof validatorOrErrorName === 'string') ? validatorOrErrorName : validatorOrErrorName.name;
        return name + (propertyName ? ":" + propertyName : "");
    }
}
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9icmVlemUtY2xpZW50LyIsInNvdXJjZXMiOlsic3JjL3ZhbGlkYXRlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDOUIsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFFbEMsTUFBTSxDQUFDLE1BQU0sU0FBUyxHQUFHLENBQUMsS0FBSyxDQUFDO0FBQ2hDLE1BQU0sQ0FBQyxNQUFNLFNBQVMsR0FBRyxLQUFLLENBQUM7QUFFL0IsTUFBTSxDQUFDLE1BQU0sU0FBUyxHQUFHLENBQUMsVUFBVSxDQUFDO0FBQ3JDLE1BQU0sQ0FBQyxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUM7QUFFcEMsTUFBTSxDQUFDLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQztBQUMxQixNQUFNLENBQUMsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDO1dBY2IsVUFBVSxPQUEwQjtJQUMvQyxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUU7UUFDcEIsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsSUFBSSxPQUFPLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO0tBQ3pHO1NBQU07UUFDTCxPQUFPLE9BQU8sQ0FBQztLQUNoQjtBQUNILENBQUM7QUFSSCxtRUFBbUU7QUFDbkUsSUFBSSxXQUFXLEdBQUc7SUFDaEIsV0FBVyxJQU1WO0NBQ0YsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDekQsQ0FBQztDQUVGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29yZSB9IGZyb20gJy4vY29yZSc7XHJcbmltcG9ydCB7IGFzc2VydFBhcmFtIH0gZnJvbSAnLi9hc3NlcnQtcGFyYW0nO1xyXG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XHJcblxyXG5leHBvcnQgY29uc3QgSU5UMTZfTUlOID0gLTMyNzY4O1xyXG5leHBvcnQgY29uc3QgSU5UMTZfTUFYID0gMzI3Njc7XHJcblxyXG5leHBvcnQgY29uc3QgSU5UMzJfTUlOID0gLTIxNDc0ODM2NDg7XHJcbmV4cG9ydCBjb25zdCBJTlQzMl9NQVggPSAyMTQ3NDgzNjQ3O1xyXG5cclxuZXhwb3J0IGNvbnN0IEJZVEVfTUlOID0gMDtcclxuZXhwb3J0IGNvbnN0IEJZVEVfTUFYID0gMjU1O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uQ29udGV4dCB7XHJcbiAgcHJvcGVydHk/OiBhbnk7XHJcbiAgcHJvcGVydHlOYW1lPzogc3RyaW5nO1xyXG4gIHZhbHVlPzogYW55O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25GbiB7XHJcbiAgICAodmFsdWU6IGFueSwgY29udGV4dD86IGFueSk6IGJvb2xlYW47XHJcbn1cclxuXHJcbi8vIGFkZCBjb21tb24gcHJvcHMgYW5kIG1ldGhvZHMgZm9yIGV2ZXJ5IHZhbGlkYXRvciAnY29udGV4dCcgaGVyZS5cclxubGV0IHJvb3RDb250ZXh0ID0ge1xyXG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbiAoY29udGV4dDogVmFsaWRhdGlvbkNvbnRleHQpIHtcclxuICAgIGlmIChjb250ZXh0LnByb3BlcnR5KSB7XHJcbiAgICAgIHJldHVybiBjb250ZXh0LnByb3BlcnR5LnJlc29sdmVQcm9wZXJ0eShcImRpc3BsYXlOYW1lXCIpIHx8IGNvbnRleHQucHJvcGVydHlOYW1lIHx8IGNvbnRleHQucHJvcGVydHkubmFtZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBcIlZhbHVlXCI7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbkluc3RhbmNlcyBvZiB0aGUgVmFsaWRhdG9yIGNsYXNzIHByb3ZpZGUgdGhlIGxvZ2ljIHRvIHZhbGlkYXRlIGFub3RoZXIgb2JqZWN0IGFuZCBwcm92aWRlIGEgZGVzY3JpcHRpb24gb2YgYW55IGVycm9yc1xyXG5lbmNvdW50ZXJlZCBkdXJpbmcgdGhlIHZhbGlkYXRpb24gcHJvY2Vzcy4gIFRoZXkgYXJlIHR5cGljYWxseSBhc3NvY2lhdGVkIHdpdGggYSAndmFsaWRhdG9ycycgcHJvcGVydHkgb24gdGhlIGZvbGxvd2luZyB0eXBlczogW1tFbnRpdHlUeXBlXV0sXHJcbltbRGF0YVByb3BlcnR5XV0gb3IgW1tOYXZpZ2F0aW9uUHJvcGVydHldXS5cclxuXHJcbkEgbnVtYmVyIG9mIHByb3BlcnR5IGxldmVsIHZhbGlkYXRvcnMgYXJlIHJlZ2lzdGVyZWQgYXV0b21hdGljYWxseSwgaS5lIGFkZGVkIHRvIGVhY2ggRGF0YVByb3BlcnR5LnZhbGlkYXRvcnMgcHJvcGVydHlcclxuYmFzZWQgb24gW1tEYXRhUHJvcGVydHldXSBtZXRhZGF0YS4gIEZvciBleGFtcGxlLFxyXG5cclxuLSBEYXRhUHJvcGVydHkuZGF0YVR5cGUgLT4gb25lIG9mIHRoZSAnZGF0YVR5cGUnIHZhbGlkYXRvciBtZXRob2RzIHN1Y2ggYXMgVmFsaWRhdG9yLmludDY0LCBWYWxpZGF0b3IuZGF0ZSwgVmFsaWRhdG9yLmJvb2wgZXRjLlxyXG4tIERhdGFQcm9wZXJ0eS5tYXhMZW5ndGggLT4gVmFsaWRhdG9yLm1heExlbmd0aFxyXG4tIERhdGFQcm9wZXJ0eS5pc051bGxhYmxlIC0+IFZhbGlkYXRvci5yZXF1aXJlZCAoaWYgbm90IG51bGxhYmxlKVxyXG5cclxuQGNsYXNzIFZhbGlkYXRvclxyXG4qKi9cclxuXHJcbi8qKlxyXG5WYWxpZGF0b3IgY29uc3RydWN0b3IgLSBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNyZWF0ZSBjcmVhdGUgY3VzdG9tIHZhbGlkYXRpb25zLiAgU2V2ZXJhbFxyXG5iYXNpYyBcIlZhbGlkYXRvclwiIGNvbnN0cnVjdGlvbiBtZXRob2RzIGFyZSBhbHNvIHByb3ZpZGVkIGFzIHN0YXRpYyBtZXRob2RzIHRvIHRoaXMgY2xhc3MuIFRoZXNlIG1ldGhvZHNcclxucHJvdmlkZSBhIHNpbXBsZXIgc3ludGF4IGZvciBjcmVhdGluZyBiYXNpYyB2YWxpZGF0aW9ucy5cclxuXHJcbk1hbnkgb2YgdGhlc2Ugc3RvY2sgdmFsaWRhdG9ycyBhcmUgaW5zcGlyZWQgYnkgYW5kIGltcGxlbWVudGVkIHRvIGNvbmZvcm0gdG8gdGhlIHZhbGlkYXRvcnMgZGVmaW5lZCBhdFxyXG5odHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvc3lzdGVtLmNvbXBvbmVudG1vZGVsLmRhdGFhbm5vdGF0aW9ucy5hc3B4XHJcblxyXG5Tb21ldGltZXMgYSBjdXN0b20gdmFsaWRhdG9yIHdpbGwgYmUgcmVxdWlyZWQuXHJcbkBleGFtcGxlXHJcbk1vc3QgdmFsaWRhdG9ycyB3aWxsIGJlICdwcm9wZXJ0eScgbGV2ZWwgdmFsaWRhdG9ycywgbGlrZSB0aGlzLlxyXG5AZXhhbXBsZVxyXG4gICAgLy8gdiBpcyB0aGlzIGZ1bmN0aW9uIGlzIHRoZSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWQsIGluIHRoaXMgY2FzZSBhIFwiY291bnRyeVwiIHN0cmluZy5cclxuICAgIHZhciB2YWxGbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgcmV0dXJuIChjb3JlLnN0cmluZ1N0YXJ0c1dpdGgodiwgXCJVU1wiKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGNvdW50cnlWYWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKFwiY291bnRyeUlzVVNcIiwgdmFsRm4sIHtcclxuICAgICAgICBkaXNwbGF5TmFtZTogXCJDb3VudHJ5XCIsIFxyXG4gICAgICAgIG1lc3NhZ2VUZW1wbGF0ZTogXCInJWRpc3BsYXlOYW1lJScgbXVzdCBzdGFydCB3aXRoICdVUydcIiBcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE5vdyBwbHVnIGl0IGludG8gQnJlZXplLlxyXG4gICAgLy8gQXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgICB2YXIgY3VzdFR5cGUgPSBtZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICAgIHZhciBjb3VudHJ5UHJvcCA9IGN1c3RUeXBlLmdldFByb3BlcnR5KFwiQ291bnRyeVwiKTtcclxuICAgIC8vIE5vdGUgdGhhdCB2YWxpZGF0b3IgaXMgYWRkZWQgdG8gYSAnRGF0YVByb3BlcnR5JyB2YWxpZGF0b3JzIGNvbGxlY3Rpb24uXHJcbiAgICBwcm9wLnZhbGlkYXRvcnMucHVzaChjb3VudHJ5VmFsaWRhdG9yKTtcclxuRW50aXR5IGxldmVsIHZhbGlkYXRvcnMgYXJlIGFsc28gcG9zc2libGVcclxuQGV4YW1wbGVcclxuICAgIGZ1bmN0aW9uIGlzVmFsaWRaaXBDb2RlKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlID0gL15cXGR7NX0oW1xcLV1cXGR7NH0pPyQvO1xyXG4gICAgICAgIHJldHVybiAocmUudGVzdCh2YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHYgaW4gdGhpcyBjYXNlIHdpbGwgYmUgYSBDdXN0b21lciBlbnRpdHlcclxuICAgIHZhciB2YWxGbiA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgLy8gVGhpcyB2YWxpZGF0b3Igb25seSB2YWxpZGF0ZXMgVVMgWmlwIENvZGVzLlxyXG4gICAgICAgIGlmICggdi5nZXRQcm9wZXJ0eShcIkNvdW50cnlcIikgPT09IFwiVVNBXCIpIHtcclxuICAgICAgICAgICAgdmFyIHBvc3RhbENvZGUgPSB2LmdldFByb3BlcnR5KFwiUG9zdGFsQ29kZVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRaaXBDb2RlKHBvc3RhbENvZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICB2YXIgemlwQ29kZVZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3IoXCJ6aXBDb2RlVmFsaWRhdG9yXCIsIHZhbEZuLFxyXG4gICAgICAgIHsgbWVzc2FnZVRlbXBsYXRlOiBcIkZvciB0aGUgVVMsIHRoaXMgaXMgbm90IGEgdmFsaWQgUG9zdGFsQ29kZVwiIH0pO1xyXG5cclxuICAgIC8vIE5vdyBwbHVnIGl0IGludG8gQnJlZXplLlxyXG4gICAgLy8gQXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgICB2YXIgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgICAvLyBOb3RlIHRoYXQgdmFsaWRhdG9yIGlzIGFkZGVkIHRvIGFuICdFbnRpdHlUeXBlJyB2YWxpZGF0b3JzIGNvbGxlY3Rpb24uXHJcbiAgICBjdXN0VHlwZS52YWxpZGF0b3JzLnB1c2goemlwQ29kZVZhbGlkYXRvcik7XHJcbldoYXQgaXMgY29tbW9ubHkgbmVlZGVkIGlzIGEgd2F5IG9mIGNyZWF0aW5nIGEgcGFyYW1ldGVyaXplZCBmdW5jdGlvbiB0aGF0IHdpbGwgaXRzZWxmXHJcbnJldHVybiBhIG5ldyBWYWxpZGF0b3IuICBUaGlzIHJlcXVpcmVzIHRoZSB1c2Ugb2YgYSAnY29udGV4dCcgb2JqZWN0LlxyXG5AZXhhbXBsZVxyXG4gICAgLy8gY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHRha2UgaW4gYSBjb25maWcgb2JqZWN0XHJcbiAgICAvLyBhbmQgd2lsbCByZXR1cm4gYSB2YWxpZGF0b3JcclxuICAgIHZhciBudW1lcmljUmFuZ2VWYWxpZGF0b3IgPSBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHZhbEZuID0gZnVuY3Rpb24odiwgY3R4KSB7XHJcbiAgICAgICAgICAgIGlmICh2ID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mKHYpICE9PSBcIm51bWJlclwiKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChjdHgubWluICE9IG51bGwgJiYgdiA8IGN0eC5taW4pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGN0eC5tYXggIT0gbnVsbCAmJiB2ID4gY3R4Lm1heCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFRoZSBsYXN0IHBhcmFtZXRlciBiZWxvdyBpcyB0aGUgJ2NvbnRleHQnIG9iamVjdCB0aGF0IHdpbGwgYmUgcGFzc2VkIGludG8gdGhlICdjdHgnIHBhcmFtZXRlciBhYm92ZVxyXG4gICAgICAgIC8vIHdoZW4gdGhpcyB2YWxpZGF0b3IgZXhlY3V0ZXMuIFNldmVyYWwgb3RoZXIgcHJvcGVydGllcywgc3VjaCBhcyBkaXNwbGF5TmFtZSB3aWxsIGdldCBhZGRlZCB0byB0aGlzIG9iamVjdCBhcyB3ZWxsLlxyXG4gICAgICAgIHJldHVybiBuZXcgVmFsaWRhdG9yKFwibnVtZXJpY1JhbmdlXCIsIHZhbEZuLCB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VUZW1wbGF0ZTogXCInJWRpc3BsYXlOYW1lJScgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIHRoZSB2YWx1ZXMgb2YgJW1pbiUgYW5kICVtYXglXCIsXHJcbiAgICAgICAgICAgIG1pbjogY29udGV4dC5taW4sXHJcbiAgICAgICAgICAgIG1heDogY29udGV4dC5tYXhcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBBc3N1bWUgdGhhdCBmcmVpZ2h0UHJvcGVydHkgaXMgYSBEYXRhRW50aXR5UHJvcGVydHkgdGhhdCBkZXNjcmliZXMgbnVtZXJpYyB2YWx1ZXMuXHJcbiAgICAvLyByZWdpc3RlciB0aGUgdmFsaWRhdG9yXHJcbiAgICBmcmVpZ2h0UHJvcGVydHkudmFsaWRhdG9ycy5wdXNoKG51bWVyaWNSYW5nZVZhbGlkYXRvcih7IG1pbjogMTAwLCBtYXg6IDUwMCB9KSk7XHJcblxyXG5CcmVlemUgc3Vic3RpdHV0ZXMgY29udGV4dCB2YWx1ZXMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlIHRva2VucyBpbiB0aGUgbWVzc2FnZVRlbXBsYXRlIHdoZW4gcHJlcGFyaW5nIHRoZSBydW50aW1lIGVycm9yIG1lc3NhZ2U7XHJcbidkaXNwbGF5TmFtZScgaXMgYSBwcmUtZGVmaW5lZCBjb250ZXh0IGZ1bmN0aW9uIHRoYXQgaXMgYWx3YXlzIGF2YWlsYWJsZS5cclxuXHJcblBsZWFzZSBub3RlIHRoYXQgQnJlZXplIHN1YnN0aXR1dGVzIHRoZSBlbXB0eSBzdHJpbmcgZm9yIGZhbHNleSBwYXJhbWV0ZXJzLiBUaGF0IHVzdWFsbHkgd29ya3MgaW4geW91ciBmYXZvci5cclxuU29tZXRpbWVzIGl0IGRvZXNuJ3QgYXMgd2hlbiB0aGUgJ21pbicgdmFsdWUgaXMgemVybyBpbiB3aGljaCBjYXNlIHRoZSBtZXNzYWdlIHRleHQgd291bGQgaGF2ZSBhIGhvbGVcclxud2hlcmUgdGhlICdtaW4nIHZhbHVlIGdvZXMsIHNheWluZzogXCIuLi4gYW4gaW50ZWdlciBiZXR3ZWVuIHRoZSB2YWx1ZXMgb2YgYW5kIC4uLlwiLiBUaGF0IGlzIG5vdCB3aGF0IHlvdSB3YW50LlxyXG5cclxuVG8gYXZvaWQgdGhpcyBlZmZlY3QsIHlvdSBtYXkgY2FuIGJha2UgY2VydGFpbiBvZiB0aGUgY29udGV4dCB2YWx1ZXMgaW50byB0aGUgJ21lc3NhZ2VUZW1wbGF0ZScgaXRzZWxmXHJcbmFzIHNob3duIGluIHRoaXMgcmV2aXNpb24gdG8gdGhlIHBlcnRpbmVudCBwYXJ0IG9mIHRoZSBwcmV2aW91cyBleGFtcGxlOlxyXG5AZXhhbXBsZVxyXG4gICAgLy8gLi4uIGFzIGJlZm9yZVxyXG4gICAgLy8gLi4uIGJ1dCBiYWtlIHRoZSBtaW4vbWF4IHZhbHVlcyBpbnRvIHRoZSBtZXNzYWdlIHRlbXBsYXRlLlxyXG4gICAgdmFyIHRlbXBsYXRlID0gYnJlZXplLmNvcmUuZm9ybWF0U3RyaW5nKFxyXG4gICAgICAgIFwiJyVkaXNwbGF5TmFtZSUnIG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiB0aGUgdmFsdWVzIG9mICUxIGFuZCAlMlwiLFxyXG4gICAgICAgIGNvbnRleHQubWluLCBjb250ZXh0Lm1heCk7XHJcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRvcihcIm51bWVyaWNSYW5nZVwiLCB2YWxGbiwge1xyXG4gICAgICAgIG1lc3NhZ2VUZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgbWluOiBjb250ZXh0Lm1pbixcclxuICAgICAgICBtYXg6IGNvbnRleHQubWF4XHJcbiAgICB9KTtcclxuXHJcbkBtZXRob2QgPGN0b3I+IFZhbGlkYXRvclxyXG5AcGFyYW0gbmFtZSB7U3RyaW5nfSBUaGUgbmFtZSBvZiB0aGlzIHZhbGlkYXRvci5cclxuQHBhcmFtIHZhbGlkYXRvckZuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byBwZXJmb3JtIHZhbGlkYXRpb24uXHJcblxyXG52YWxpZGF0b3JGbih2YWx1ZSwgY29udGV4dClcclxuQHBhcmFtIHZhbGlkYXRvckZuLnZhbHVlIHtPYmplY3R9IFZhbHVlIHRvIGJlIHZhbGlkYXRlZFxyXG5AcGFyYW0gdmFsaWRhdG9yRm4uY29udGV4dCB7T2JqZWN0fSBUaGUgc2FtZSBjb250ZXh0IG9iamVjdCBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3Igd2l0aCB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpZiBub3Rcclxub3RoZXJ3aXNlIHNwZWNpZmllZC5cclxuQHBhcmFtIHZhbGlkYXRvckZuLmNvbnRleHQudmFsdWUge09iamVjdH0gVGhlIHZhbHVlIGJlaW5nIHZhbGlkYXRlZC5cclxuQHBhcmFtIHZhbGlkYXRvckZuLmNvbnRleHQubmFtZSB7U3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdmFsaWRhdG9yIGJlaW5nIGV4ZWN1dGVkLlxyXG5AcGFyYW0gdmFsaWRhdG9yRm4uY29udGV4dC5kaXNwbGF5TmFtZSB7U3RyaW5nfSBUaGlzIHdpbGwgYmUgZWl0aGVyIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkncyAnZGlzcGxheU5hbWUnIHByb3BlcnR5IG9yXHJcbnRoZSB2YWx1ZSBvZiBpdHMgJ25hbWUnIHByb3BlcnR5IG9yIHRoZSBzdHJpbmcgJ1ZhbHVlJ1xyXG5AcGFyYW0gdmFsaWRhdG9yRm4uY29udGV4dC5tZXNzYWdlVGVtcGxhdGUge1N0cmluZ30gVGhpcyB3aWxsIGVpdGhlciBiZSB0aGUgdmFsdWUgb2YgVmFsaWRhdG9yLm1lc3NhZ2VUZW1wbGF0ZXNbIHt0aGlzIHZhbGlkYXRvcnMgbmFtZX1dIG9yIG51bGwuIFZhbGlkYXRvci5tZXNzYWdlVGVtcGxhdGVzXHJcbmlzIGFuIG9iamVjdCB0aGF0IGlzIGtleWVkIGJ5IHZhbGlkYXRvciBuYW1lIGFuZCB0aGF0IGNhbiBiZSBhZGRlZCB0byBpbiBvcmRlciB0byAncmVnaXN0ZXInIHlvdXIgb3duIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gdmFsaWRhdG9yLlxyXG5UaGUgZm9sbG93aW5nIHByb3BlcnR5IGNhbiBhbHNvIGJlIHNwZWNpZmllZCBmb3IgYW55IHZhbGlkYXRvciB0byBmb3JjZSBhIHNwZWNpZmljIGVycm9yTWVzc2FnZSBzdHJpbmdcclxuQHBhcmFtIFt2YWxpZGF0b3JGbi5jb250ZXh0Lm1lc3NhZ2VdIHtTdHJpbmd9IElmIHRoaXMgcHJvcGVydHkgaXMgc2V0IGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSAnbWVzc2FnZVRlbXBsYXRlJyBwcm9wZXJ0eSB3aGVuIGFuXHJcbmVycm9yIG1lc3NhZ2UgaXMgZ2VuZXJhdGVkLlxyXG5cclxuQHBhcmFtIFtjb250ZXh0XSB7T2JqZWN0fSBBIGZyZWUgZm9ybSBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyB3aWxsIG1hZGUgYXZhaWxhYmxlIGR1cmluZyB0aGUgdmFsaWRhdGlvbiBhbmQgZXJyb3IgbWVzc2FnZSBjcmVhdGlvbiBwcm9jZXNzLlxyXG5UaGlzIG9iamVjdCB3aWxsIGJlIHBhc3NlZCBpbnRvIHRoZSBWYWxpZGF0b3IncyB2YWxpZGF0aW9uIGZ1bmN0aW9uIHdoZW5ldmVyICd2YWxpZGF0ZScgaXMgY2FsbGVkLiBTZWUgYWJvdmUgZm9yIGEgZGVzY3JpcHRpb25cclxub2YgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoaXMgb2JqZWN0IGlmIG5vdCBvdGhlcndpc2Ugc3BlY2lmaWVkLlxyXG5AZHluYW1pY1xyXG4qKi9cclxuZXhwb3J0IGNsYXNzIFZhbGlkYXRvciB7XHJcbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbiAgXyR0eXBlTmFtZTogc3RyaW5nOyAvLyBvbiBwcm90b1xyXG5cclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgdmFsRm46IFZhbGlkYXRpb25GbjtcclxuICBjb250ZXh0OiBWYWxpZGF0aW9uQ29udGV4dDtcclxuICBjdXJyZW50Q29udGV4dDogYW55O1xyXG4gIHByaXZhdGUgX2Jhc2VDb250ZXh0OiBhbnk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKG5hbWU6IHN0cmluZywgdmFsRm46IFZhbGlkYXRpb25GbiwgY29udGV4dD86IGFueSkge1xyXG4gICAgLy8gX2Jhc2VDb250ZXh0IGlzIHdoYXQgd2lsbCBnZXQgc2VyaWFsaXplZFxyXG4gICAgdGhpcy5fYmFzZUNvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xyXG4gICAgdGhpcy5fYmFzZUNvbnRleHQubmFtZSA9IG5hbWU7XHJcbiAgICBjb250ZXh0ID0gY29yZS5leHRlbmQoT2JqZWN0LmNyZWF0ZShyb290Q29udGV4dCksIHRoaXMuX2Jhc2VDb250ZXh0KTtcclxuICAgIGNvbnRleHQubWVzc2FnZVRlbXBsYXRlID0gY29udGV4dC5tZXNzYWdlVGVtcGxhdGUgfHwgVmFsaWRhdG9yLm1lc3NhZ2VUZW1wbGF0ZXNbbmFtZV07XHJcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgdGhpcy52YWxGbiA9IHZhbEZuO1xyXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFRoZSBuYW1lIG9mIHRoaXMgdmFsaWRhdG9yLlxyXG5cclxuICBfX3JlYWRPbmx5X19cclxuICBAcHJvcGVydHkgbmFtZSB7U3RyaW5nfVxyXG4gICoqL1xyXG5cclxuICAvKipcclxuICBUaGUgY29udGV4dCBmb3IgdGhpcyB2YWxpZGF0b3IuXHJcblxyXG4gIFRoaXMgb2JqZWN0IHdpbGwgdHlwaWNhbGx5IGNvbnRhaW4gYXQgYSBtaW5pbXVtIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcy4gXCJuYW1lXCIsIFwiZGlzcGxheU5hbWVcIiwgYW5kIFwibWVzc2FnZVwiIG9yIFwibWVzc2FnZVRlbXBsYXRlXCIuXHJcbiAgX19yZWFkT25seV9fXHJcbiAgQHByb3BlcnR5IGNvbnRleHQge09iamVjdH1cclxuICAqKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gIFJ1biB0aGlzIHZhbGlkYXRvciBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgdmFsdWUuICBUaGlzIG1ldGhvZCB3aWxsIHVzdWFsbHkgYmUgY2FsbGVkIGludGVybmFsbHkgZWl0aGVyXHJcbiAgYXV0b21hdGljYWxseSBieSBhbiBwcm9wZXJ0eSBjaGFuZ2UsIGVudGl0eSBhdHRhY2gsIHF1ZXJ5IG9yIHNhdmUgb3BlcmF0aW9uLCBvciBtYW51YWxseSBhcyBhIHJlc3VsdCBvZlxyXG4gIGEgdmFsaWRhdGVFbnRpdHkgY2FsbCBvbiB0aGUgRW50aXR5QXNwZWN0LiBUaGUgcmVzdWx0aW5nIFZhbGlkYXRpb25SZXN1bHRzIGFyZSBhdmFpbGFibGUgdmlhIHRoZVxyXG4gIEVudGl0eUFzcGVjdC5nZXRWYWxpZGF0aW9uRXJyb3JzIG1ldGhvZC5cclxuXHJcbiAgSG93ZXZlciwgeW91IGNhbiBhbHNvIGNhbGwgYSB2YWxpZGF0b3IgZGlyZWN0bHkgZWl0aGVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9yIHNvbWUgb3RoZXIgcmVhc29uIGlmIG5lZWRlZC5cclxuICBAZXhhbXBsZVxyXG4gICAgICAvLyB1c2luZyBvbmUgb2YgdGhlIHByZWRlZmluZWQgdmFsaWRhdG9yc1xyXG4gICAgICB2YXIgdmFsaWRhdG9yID0gVmFsaWRhdG9yLm1heExlbmd0aCh7IG1heExlbmd0aDogNSwgZGlzcGxheU5hbWU6IFwiQ2l0eVwiIH0pO1xyXG4gICAgICAvLyBzaG91bGQgYmUgb2sgYmVjYXVzZSBcImFzZGZcIi5sZW5ndGggPCA1XHJcbiAgICAgIHZhciByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGUoXCJhc2RmXCIpO1xyXG4gICAgICBvayhyZXN1bHQgPT09IG51bGwpO1xyXG4gICAgICByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGUoXCJhZGFzZGZhc2RmXCIpO1xyXG4gICAgICAvLyBleHRyYWN0IGFsbCBvZiB0aGUgcHJvcGVydGllcyBvZiB0aGUgJ3Jlc3VsdCdcclxuICAgICAgdmFyIGVyck1zZyA9IHJlc3VsdC5lcnJvck1lc3NhZ2U7XHJcbiAgICAgIHZhciBjb250ZXh0ID0gcmVzdWx0LmNvbnRleHQ7XHJcbiAgICAgIHZhciBzYW1lVmFsaWRhdG9yID0gcmVzdWx0LnZhbGlkYXRvcjtcclxuICBAbWV0aG9kIHZhbGlkYXRlXHJcbiAgQHBhcmFtIHZhbHVlIHtPYmplY3R9IFZhbHVlIHRvIHZhbGlkYXRlXHJcbiAgQHBhcmFtIGFkZGl0aW9uYWxDb250ZXh0IHtPYmplY3R9IEFueSBhZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gdGhhdCB0aGUgVmFsaWRhdG9yXHJcbiAgY2FuIG1ha2UgdXNlIG9mLlxyXG4gIEByZXR1cm4ge1ZhbGlkYXRpb25FcnJvcnxudWxsfSBBIFZhbGlkYXRpb25FcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLCBudWxsIG90aGVyd2lzZVxyXG4gICoqL1xyXG4gIHZhbGlkYXRlKHZhbHVlOiBhbnksIGFkZGl0aW9uYWxDb250ZXh0PzogYW55KSB7XHJcbiAgICBsZXQgY3VycmVudENvbnRleHQ6IFZhbGlkYXRpb25Db250ZXh0OyAvLyB7IHZhbHVlPzogT2JqZWN0IH07XHJcbiAgICBpZiAoYWRkaXRpb25hbENvbnRleHQpIHtcclxuICAgICAgY3VycmVudENvbnRleHQgPSBjb3JlLmV4dGVuZChPYmplY3QuY3JlYXRlKHRoaXMuY29udGV4dCksIGFkZGl0aW9uYWxDb250ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN1cnJlbnRDb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgfVxyXG4gICAgdGhpcy5jdXJyZW50Q29udGV4dCA9IGN1cnJlbnRDb250ZXh0O1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh0aGlzLnZhbEZuKHZhbHVlLCBjdXJyZW50Q29udGV4dCkpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyZW50Q29udGV4dC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmFsaWRhdGlvbkVycm9yKHRoaXMsIGN1cnJlbnRDb250ZXh0LCB0aGlzLmdldE1lc3NhZ2UoKSk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IodGhpcywgY3VycmVudENvbnRleHQsIFwiRXhjZXB0aW9uIG9jY3VyZWQgd2hpbGUgZXhlY3V0aW5nIHRoaXMgdmFsaWRhdG9yOiBcIiArIHRoaXMubmFtZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gY29udGV4dC52YWx1ZSBpcyBub3QgYXZhaWwgdW5sZXNzIHZhbGlkYXRlIHdhcyBjYWxsZWQgZmlyc3QuXHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgdGhlIG1lc3NhZ2UgZ2VuZXJhdGVkIGJ5IHRoZSBtb3N0IHJlY2VudCBleGVjdXRpb24gb2YgdGhpcyBWYWxpZGF0b3IuXHJcbiAgQGV4YW1wbGVcclxuICAgICAgdmFyIHYwID0gVmFsaWRhdG9yLm1heExlbmd0aCh7IG1heExlbmd0aDogNSwgZGlzcGxheU5hbWU6IFwiQ2l0eVwiIH0pO1xyXG4gICAgICB2MC52YWxpZGF0ZShcImFkYXNkZmFzZGZcIik7XHJcbiAgICAgIHZhciBlcnJNZXNzYWdlID0gdjAuZ2V0TWVzc2FnZSgpKTtcclxuICBAbWV0aG9kIGdldE1lc3NhZ2VcclxuICBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgKiovXHJcbiAgZ2V0TWVzc2FnZSgpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5jdXJyZW50Q29udGV4dDtcclxuICAgICAgbGV0IG1lc3NhZ2UgPSBjb250ZXh0Lm1lc3NhZ2U7XHJcbiAgICAgIGlmIChtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAobWVzc2FnZSkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2UoY29udGV4dCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1lc3NhZ2VUZW1wbGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBmb3JtYXRUZW1wbGF0ZShjb250ZXh0Lm1lc3NhZ2VUZW1wbGF0ZSwgY29udGV4dCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFwiaW52YWxpZCB2YWx1ZTogXCIgKyAodGhpcy5uYW1lIHx8IFwie3VubmFtZWQgdmFsaWRhdG9yfVwiKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm4gXCJVbmFibGUgdG8gZm9ybWF0IGVycm9yIG1lc3NhZ2VcIiArIGUudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRvSlNPTigpIHtcclxuICAgIHJldHVybiB0aGlzLl9iYXNlQ29udGV4dDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIENyZWF0ZXMgYSB2YWxpZGF0b3IgaW5zdGFuY2UgZnJvbSBhIEpTT04gb2JqZWN0IG9yIGFuIGFycmF5IG9mIGluc3RhbmNlcyBmcm9tIGFuIGFycmF5IG9mIEpTT04gb2JqZWN0cy5cclxuICBAbWV0aG9kIGZyb21KU09OXHJcbiAgQHN0YXRpY1xyXG4gIEBwYXJhbSBqc29uIHtPYmplY3R9IEpTT04gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIGEgdmFsaWRhdG9yLlxyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgZnJvbUpTT04oanNvbjogYW55KTogYW55IHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XHJcbiAgICAgIHJldHVybiBqc29uLm1hcChmdW5jdGlvbiAoanMpIHtcclxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLmZyb21KU09OKGpzKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoanNvbiBpbnN0YW5jZW9mIFZhbGlkYXRvcikge1xyXG4gICAgICByZXR1cm4ganNvbjtcclxuICAgIH1cclxuICAgIGxldCB2YWxpZGF0b3JOYW1lID0gXCJWYWxpZGF0b3IuXCIgKyBqc29uLm5hbWU7XHJcbiAgICBsZXQgZm4gPSBjb25maWcuZ2V0UmVnaXN0ZXJlZEZ1bmN0aW9uKHZhbGlkYXRvck5hbWUpO1xyXG4gICAgaWYgKCFmbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbG9jYXRlIGEgdmFsaWRhdG9yIG5hbWVkOlwiICsganNvbi5uYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmbihqc29uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gIFJlZ2lzdGVyIGEgdmFsaWRhdG9yIGluc3RhbmNlIHNvIHRoYXQgYW55IGRlc2VyaWFsaXplZCBtZXRhZGF0YSBjYW4gcmVmZXJlbmNlIGl0LlxyXG4gIEBtZXRob2QgcmVnaXN0ZXJcclxuICBAc3RhdGljXHJcbiAgQHBhcmFtIHZhbGlkYXRvciB7VmFsaWRhdG9yfSBWYWxpZGF0b3IgdG8gcmVnaXN0ZXIuXHJcbiAgKiovXHJcbiAgcHVibGljIHN0YXRpYyByZWdpc3Rlcih2YWxpZGF0b3I6IFZhbGlkYXRvcikge1xyXG4gICAgY29uZmlnLnJlZ2lzdGVyRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsaWRhdG9yO1xyXG4gICAgfSwgXCJWYWxpZGF0b3IuXCIgKyB2YWxpZGF0b3IubmFtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICBSZWdpc3RlciBhIHZhbGlkYXRvciBmYWN0b3J5IHNvIHRoYXQgYW55IGRlc2VyaWFsaXplZCBtZXRhZGF0YSBjYW4gcmVmZXJlbmNlIGl0LlxyXG4gIEBtZXRob2QgcmVnaXN0ZXJGYWN0b3J5XHJcbiAgQHN0YXRpY1xyXG4gIEBwYXJhbSB2YWxpZGF0b3JGYWN0b3J5IHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IG9wdGlvbmFsbHkgdGFrZXMgYSBjb250ZXh0IHByb3BlcnR5IGFuZCByZXR1cm5zIGEgVmFsaWRhdG9yIGluc3RhbmNlLlxyXG4gIEBwYXJhbSBuYW1lIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSB2YWxpZGF0b3IuXHJcbiAgKiovXHJcbiAgcHVibGljIHN0YXRpYyByZWdpc3RlckZhY3RvcnkodmFsaWRhdG9yRmFjdG9yeTogKG9wdGlvbnM/OiBhbnkpID0+IFZhbGlkYXRvciwgbmFtZTogc3RyaW5nKSB7XHJcbiAgICBjb25maWcucmVnaXN0ZXJGdW5jdGlvbih2YWxpZGF0b3JGYWN0b3J5LCBcIlZhbGlkYXRvci5cIiArIG5hbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgTWFwIG9mIHN0YW5kYXJkIGVycm9yIG1lc3NhZ2UgdGVtcGxhdGVzIGtleWVkIGJ5IHZhbGlkYXRvciBuYW1lLlxyXG4gIFlvdSBjYW4gYWRkIHRvIG9yIG1vZGlmeSB0aGlzIG9iamVjdCB0byBjdXN0b21pemUgdGhlIHRlbXBsYXRlIHVzZWQgZm9yIGFueSB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2UuXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gdiBpcyB0aGlzIGZ1bmN0aW9uIGlzIHRoZSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWQsIGluIHRoaXMgY2FzZSBhIFwiY291bnRyeVwiIHN0cmluZy5cclxuICAgICAgdmFyIHZhbEZuID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgIGlmICh2ID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgcmV0dXJuIChjb3JlLnN0cmluZ1N0YXJ0c1dpdGgodiwgXCJVU1wiKSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBjb3VudHJ5VmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihcImNvdW50cnlJc1VTXCIsIHZhbEZuLCB7IGRpc3BsYXlOYW1lOiBcIkNvdW50cnlcIiB9KTtcclxuICAgICAgVmFsaWRhdG9yLm1lc3NhZ2VUZW1wbGF0ZXMuY291bnRyeUlzVVMgPSBcIiclZGlzcGxheU5hbWUlJyBtdXN0IHN0YXJ0IHdpdGggJ1VTJ1wiO1xyXG4gICAgICAvLyBUaGlzIHdpbGwgaGF2ZSBhIHNpbWlsYXIgZWZmZWN0IHRvIHRoaXNcclxuICAgICAgdmFyIGNvdW50cnlWYWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKFwiY291bnRyeUlzVVNcIiwgdmFsRm4sIHtcclxuICAgICAgICAgIGRpc3BsYXlOYW1lOiBcIkNvdW50cnlcIiwgXHJcbiAgICAgICAgICBtZXNzYWdlVGVtcGxhdGU6IFwiJyVkaXNwbGF5TmFtZSUnIG11c3Qgc3RhcnQgd2l0aCAnVVMnXCIgXHJcbiAgICAgIH0pO1xyXG4gIEBwcm9wZXJ0eSBtZXNzYWdlVGVtcGxhdGVzIHtPYmplY3R9XHJcbiAgQHN0YXRpY1xyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgbWVzc2FnZVRlbXBsYXRlcyA9IHtcclxuICAgIGJvb2w6IFwiJyVkaXNwbGF5TmFtZSUnIG11c3QgYmUgYSAndHJ1ZScgb3IgJ2ZhbHNlJyB2YWx1ZVwiLFxyXG4gICAgY3JlZGl0Q2FyZDogXCJUaGUgJWRpc3BsYXlOYW1lJSBpcyBub3QgYSB2YWxpZCBjcmVkaXQgY2FyZCBudW1iZXJcIixcclxuICAgIGRhdGU6IFwiJyVkaXNwbGF5TmFtZSUnIG11c3QgYmUgYSBkYXRlXCIsXHJcbiAgICBkdXJhdGlvbjogXCInJWRpc3BsYXlOYW1lJScgbXVzdCBiZSBhIElTTzg2MDEgZHVyYXRpb24gc3RyaW5nLCBzdWNoIGFzICdQM0gyNE02MFMnXCIsXHJcbiAgICBlbWFpbEFkZHJlc3M6IFwiVGhlICVkaXNwbGF5TmFtZSUgJyV2YWx1ZSUnIGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIixcclxuICAgIGd1aWQ6IFwiJyVkaXNwbGF5TmFtZSUnIG11c3QgYmUgYSBHVUlEXCIsXHJcbiAgICBpbnRlZ2VyOiBcIiclZGlzcGxheU5hbWUlJyBtdXN0IGJlIGFuIGludGVnZXJcIixcclxuICAgIGludGVnZXJSYW5nZTogXCInJWRpc3BsYXlOYW1lJScgbXVzdCBiZSBhbiBpbnRlZ2VyIGJldHdlZW4gdGhlIHZhbHVlcyBvZiAlbWluVmFsdWUlIGFuZCAlbWF4VmFsdWUlXCIsXHJcbiAgICBtYXhMZW5ndGg6IFwiJyVkaXNwbGF5TmFtZSUnIG11c3QgYmUgYSBzdHJpbmcgd2l0aCAlbWF4TGVuZ3RoJSBjaGFyYWN0ZXJzIG9yIGxlc3NcIixcclxuICAgIG51bWJlcjogXCInJWRpc3BsYXlOYW1lJScgbXVzdCBiZSBhIG51bWJlclwiLFxyXG4gICAgcGhvbmU6IFwiVGhlICVkaXNwbGF5TmFtZSUgJyV2YWx1ZSUnIGlzIG5vdCBhIHZhbGlkIHBob25lIG51bWJlclwiLFxyXG4gICAgcmVndWxhckV4cHJlc3Npb246IFwiVGhlICVkaXNwbGF5TmFtZSUgJyV2YWx1ZSUnIGRvZXMgbm90IG1hdGNoICclZXhwcmVzc2lvbiUnXCIsXHJcbiAgICByZXF1aXJlZDogXCInJWRpc3BsYXlOYW1lJScgaXMgcmVxdWlyZWRcIixcclxuICAgIHN0cmluZzogXCInJWRpc3BsYXlOYW1lJScgbXVzdCBiZSBhIHN0cmluZ1wiLFxyXG4gICAgc3RyaW5nTGVuZ3RoOiBcIiclZGlzcGxheU5hbWUlJyBtdXN0IGJlIGEgc3RyaW5nIHdpdGggYmV0d2VlbiAlbWluTGVuZ3RoJSBhbmQgJW1heExlbmd0aCUgY2hhcmFjdGVyc1wiLFxyXG4gICAgdXJsOiBcIlRoZSAlZGlzcGxheU5hbWUlICcldmFsdWUlJyBpcyBub3QgYSB2YWxpZCB1cmxcIlxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBzdGFuZGFyZCAncmVxdWlyZWQgdmFsdWUnIFZhbGlkYXRvclxyXG4gIEBleGFtcGxlXHJcbiAgICAgIC8vIEFzc3VtZSBlbTEgaXMgYSBwcmVleGlzdGluZyBFbnRpdHlNYW5hZ2VyLlxyXG4gICAgICB2YXIgY3VzdFR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgICAgIHZhciByZWdpb25Qcm9wZXJ0eSAtIGN1c3RUeXBlLmdldFByb3BlcnR5KFwiUmVnaW9uXCIpO1xyXG4gICAgICAvLyBNYWtlcyBcIlJlZ2lvblwiIG9uIEN1c3RvbWVyIGEgcmVxdWlyZWQgcHJvcGVydHkuXHJcbiAgICAgIHJlZ2lvblByb3BlcnR5LnZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3IucmVxdWlyZWQoKSk7XHJcbiAgICAgIC8vIG9yIHRvIGFsbG93IGVtcHR5IHN0cmluZ3NcclxuICAgICAgcmVnaW9uUHJvcGVydHkudmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvci5yZXF1aXJlZCh7IGFsbG93RW1wdHlTdHJpbmdzOiB0cnVlIH0pOyk7XHJcbiAgQG1ldGhvZCByZXF1aXJlZFxyXG4gIEBzdGF0aWNcclxuICBAcGFyYW0gY29udGV4dCB7T2JqZWN0fVxyXG4gIEBwYXJhbSBbY29udGV4dC5hbGxvd0VtcHR5U3RyaW5nc10ge0Jvb2xlYW59IElmIHRoaXMgcGFyYW1ldGVyIGlzIG9taXR0ZWQgb3IgZmFsc2UgdGhlbiBlbXB0eSBzdHJpbmdzIGRvIE5PVCBwYXNzIHZhbGlkYXRpb24uXHJcbiAgQHJldHVybiB7VmFsaWRhdG9yfSBBIG5ldyBWYWxpZGF0b3JcclxuICAqKi9cclxuICBwdWJsaWMgc3RhdGljIHJlcXVpcmVkID0gZnVuY3Rpb24oY29udGV4dD86IGFueSkge1xyXG4gICAgbGV0IHZhbEZuID0gZnVuY3Rpb24gKHY6IGFueSwgY3R4OiBhbnkpIHtcclxuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgaWYgKGN0eCAmJiBjdHguYWxsb3dFbXB0eVN0cmluZ3MpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIHJldHVybiB2Lmxlbmd0aCA+IDA7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHYgIT0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBuZXcgVmFsaWRhdG9yKFwicmVxdWlyZWRcIiwgdmFsRm4sIGNvbnRleHQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBzdGFuZGFyZCBtYXhpbXVtIHN0cmluZyBsZW5ndGggVmFsaWRhdG9yOyB0aGUgbWF4aW11bSBsZW5ndGggbXVzdCBiZSBzcGVjaWZpZWRcclxuICBAZXhhbXBsZVxyXG4gICAgICAvLyBBc3N1bWUgZW0xIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICAgICAgdmFyIGN1c3RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkN1c3RvbWVyXCIpO1xyXG4gICAgICB2YXIgcmVnaW9uUHJvcGVydHkgLSBjdXN0VHlwZS5nZXRQcm9wZXJ0eShcIlJlZ2lvblwiKTtcclxuICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSBSZWdpb24gcHJvcGVydHkgb24gQ3VzdG9tZXIgd2lsbCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNSBjaGFyYWN0ZXJzLlxyXG4gICAgICByZWdpb25Qcm9wZXJ0eS52YWxpZGF0b3JzLnB1c2goVmFsaWRhdG9yLm1heExlbmd0aCgge21heExlbmd0aDogNX0pKTtcclxuICBAbWV0aG9kIG1heExlbmd0aFxyXG4gIEBzdGF0aWNcclxuICBAcGFyYW0gY29udGV4dCB7T2JqZWN0fVxyXG4gIEBwYXJhbSBjb250ZXh0Lm1heExlbmd0aCB7SW50ZWdlcn1cclxuICBAcmV0dXJuIHtWYWxpZGF0b3J9IEEgbmV3IFZhbGlkYXRvclxyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgbWF4TGVuZ3RoID0gZnVuY3Rpb24oY29udGV4dDogYW55KSB7XHJcbiAgICBsZXQgdmFsRm4gPSBmdW5jdGlvbiAodjogYW55LCBjdHg6IGFueSkge1xyXG4gICAgICBpZiAodiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgaWYgKHR5cGVvZiAodikgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcclxuICAgICAgcmV0dXJuIHYubGVuZ3RoIDw9IGN0eC5tYXhMZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG5ldyBWYWxpZGF0b3IoXCJtYXhMZW5ndGhcIiwgdmFsRm4sIGNvbnRleHQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBzdGFuZGFyZCBzdHJpbmcgbGVuZ3RoIFZhbGlkYXRvcjsgYm90aCBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aHMgbXVzdCBiZSBzcGVjaWZpZWQuXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gQXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgICAgIHZhciBjdXN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJDdXN0b21lclwiKTtcclxuICAgICAgdmFyIHJlZ2lvblByb3BlcnR5IC0gY3VzdFR5cGUuZ2V0UHJvcGVydHkoXCJSZWdpb25cIik7XHJcbiAgICAgIC8vIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBvZiB0aGUgUmVnaW9uIHByb3BlcnR5IG9uIEN1c3RvbWVyIHdpbGwgYmVcclxuICAgICAgLy8gYmV0d2VlbiAyIGFuZCA1IGNoYXJhY3RlcnNcclxuICAgICAgcmVnaW9uUHJvcGVydHkudmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvci5zdHJpbmdMZW5ndGgoIHttaW5MZW5ndGg6IDIsIG1heExlbmd0aDogNX0pO1xyXG4gIEBtZXRob2Qgc3RyaW5nTGVuZ3RoXHJcbiAgQHN0YXRpY1xyXG4gIEBwYXJhbSBjb250ZXh0IHtPYmplY3R9XHJcbiAgQHBhcmFtIGNvbnRleHQubWF4TGVuZ3RoIHtJbnRlZ2VyfVxyXG4gIEBwYXJhbSBjb250ZXh0Lm1pbkxlbmd0aCB7SW50ZWdlcn1cclxuICBAcmV0dXJuIHtWYWxpZGF0b3J9IEEgbmV3IFZhbGlkYXRvclxyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgc3RyaW5nTGVuZ3RoID0gZnVuY3Rpb24gKGNvbnRleHQ6IGFueSkge1xyXG4gICAgbGV0IHZhbEZuID0gZnVuY3Rpb24gKHY6IGFueSwgY3R4OiBhbnkpIHtcclxuICAgICAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICAgIGlmICh0eXBlb2YgKHYpICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChjdHgubWluTGVuZ3RoICE9IG51bGwgJiYgdi5sZW5ndGggPCBjdHgubWluTGVuZ3RoKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmIChjdHgubWF4TGVuZ3RoICE9IG51bGwgJiYgdi5sZW5ndGggPiBjdHgubWF4TGVuZ3RoKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBuZXcgVmFsaWRhdG9yKFwic3RyaW5nTGVuZ3RoXCIsIHZhbEZuLCBjb250ZXh0KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGEgc3RhbmRhcmQgc3RyaW5nIGRhdGFUeXBlIFZhbGlkYXRvci5cclxuICBAZXhhbXBsZVxyXG4gICAgICAvLyBBc3N1bWUgZW0xIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICAgICAgdmFyIGN1c3RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkN1c3RvbWVyXCIpO1xyXG4gICAgICB2YXIgcmVnaW9uUHJvcGVydHkgLSBjdXN0VHlwZS5nZXRQcm9wZXJ0eShcIlJlZ2lvblwiKTtcclxuICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSBSZWdpb24gcHJvcGVydHkgb24gQ3VzdG9tZXIgaXMgYSBzdHJpbmcuXHJcbiAgICAgIHJlZ2lvblByb3BlcnR5LnZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3Iuc3RyaW5nKCkpO1xyXG4gIEBtZXRob2Qgc3RyaW5nXHJcbiAgQHN0YXRpY1xyXG4gIEByZXR1cm4ge1ZhbGlkYXRvcn0gQSBuZXcgVmFsaWRhdG9yXHJcbiAgKiovXHJcbiAgcHVibGljIHN0YXRpYyBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBsZXQgdmFsRm4gPSBmdW5jdGlvbiAodjogYW55KSB7XHJcbiAgICAgIGlmICh2ID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRvcihcInN0cmluZ1wiLCB2YWxGbik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIEd1aWQgZGF0YSB0eXBlIFZhbGlkYXRvci5cclxuICBAZXhhbXBsZVxyXG4gICAgICAvLyBBc3N1bWUgZW0xIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICAgICAgdmFyIGN1c3RUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIkN1c3RvbWVyXCIpO1xyXG4gICAgICB2YXIgY3VzdG9tZXJJZFByb3BlcnR5IC0gY3VzdFR5cGUuZ2V0UHJvcGVydHkoXCJDdXN0b21lcklEXCIpO1xyXG4gICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIEN1c3RvbWVySUQgcHJvcGVydHkgb24gQ3VzdG9tZXIgaXMgYSBHdWlkLlxyXG4gICAgICBjdXN0b21lcklkUHJvcGVydHkudmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvci5ndWlkKCkpO1xyXG4gIEBtZXRob2QgZ3VpZFxyXG4gIEBzdGF0aWNcclxuICBAcmV0dXJuIHtWYWxpZGF0b3J9IEEgbmV3IFZhbGlkYXRvclxyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgZ3VpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGxldCB2YWxGbiA9IGZ1bmN0aW9uICh2OiBhbnkpIHtcclxuICAgICAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICAgIHJldHVybiBjb3JlLmlzR3VpZCh2KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRvcihcImd1aWRcIiwgdmFsRm4pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBJU08gODYwMSBkdXJhdGlvbiBzdHJpbmcgIFZhbGlkYXRvci5cclxuICBAZXhhbXBsZVxyXG4gICAgICAvLyBBc3N1bWUgZW0xIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICAgICAgdmFyIGV2ZW50VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJFdmVudFwiKTtcclxuICAgICAgdmFyIGVsYXBzZWRUaW1lUHJvcGVydHkgLSBldmVudFR5cGUuZ2V0UHJvcGVydHkoXCJFbGFwc2VkVGltZVwiKTtcclxuICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSBFbGFwc2VkVGltZSBwcm9wZXJ0eSBvbiBDdXN0b21lciBpcyBhIGR1cmF0aW9uLlxyXG4gICAgICBlbGFwc2VkVGltZVByb3BlcnR5LnZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3IuZHVyYXRpb24oKSk7XHJcbiAgQG1ldGhvZCBkdXJhdGlvblxyXG4gIEBzdGF0aWNcclxuICBAcmV0dXJuIHtWYWxpZGF0b3J9IEEgbmV3IFZhbGlkYXRvclxyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgZHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBsZXQgdmFsRm4gPSBmdW5jdGlvbiAodjogYW55KSB7XHJcbiAgICAgIGlmICh2ID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgICByZXR1cm4gY29yZS5pc0R1cmF0aW9uKHYpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBuZXcgVmFsaWRhdG9yKFwiZHVyYXRpb25cIiwgdmFsRm4pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBzdGFuZGFyZCBudW1lcmljIGRhdGEgdHlwZSBWYWxpZGF0b3IuXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gQXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgICAgIHZhciBvcmRlclR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiT3JkZXJcIik7XHJcbiAgICAgIHZhciBmcmVpZ2h0UHJvcGVydHkgLSBvcmRlclR5cGUuZ2V0UHJvcGVydHkoXCJGcmVpZ2h0XCIpO1xyXG4gICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIEZyZWlnaHQgcHJvcGVydHkgb24gT3JkZXIgaXMgYSBudW1iZXIuXHJcbiAgICAgIGZyZWlnaHRQcm9wZXJ0eS52YWxpZGF0b3JzLnB1c2goVmFsaWRhdG9yLm51bWJlcigpKTtcclxuICBAbWV0aG9kIG51bWJlclxyXG4gIEBzdGF0aWNcclxuICBAcmV0dXJuIHtWYWxpZGF0b3J9IEEgbmV3IFZhbGlkYXRvclxyXG4gICoqL1xyXG5cclxuICAgIC8vIFRPRE86IG1heSBuZWVkIHRvIGhhdmUgc2VwZXJhdGUgbG9naWMgZm9yIHNpbmdsZS5cclxuICBwdWJsaWMgc3RhdGljIG51bWJlciA9IGZ1bmN0aW9uKGNvbnRleHQ/OiBhbnkpIHtcclxuICAgIGxldCB2YWxGbiA9IGZ1bmN0aW9uICh2OiBhbnksIGN0eDogYW55KSB7XHJcbiAgICAgIGlmICh2ID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgJiYgY3R4ICYmIGN0eC5hbGxvd1N0cmluZykge1xyXG4gICAgICAgIHYgPSBwYXJzZUZsb2F0KHYpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHYpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRvcihcIm51bWJlclwiLCB2YWxGbiwgY29udGV4dCk7XHJcbiAgfTtcclxuICBwdWJsaWMgc3RhdGljIGRvdWJsZSA9IFZhbGlkYXRvci5udW1iZXI7XHJcbiAgcHVibGljIHN0YXRpYyBzaW5nbGUgPSBWYWxpZGF0b3IubnVtYmVyO1xyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGEgc3RhbmRhcmQgbGFyZ2UgaW50ZWdlciBkYXRhIHR5cGUgLSA2NCBiaXQgLSBWYWxpZGF0b3IuXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gQXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgICAgIHZhciBvcmRlclR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiT3JkZXJcIik7XHJcbiAgICAgIHZhciBmcmVpZ2h0UHJvcGVydHkgLSBvcmRlclR5cGUuZ2V0UHJvcGVydHkoXCJGcmVpZ2h0XCIpO1xyXG4gICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIEZyZWlnaHQgcHJvcGVydHkgb24gT3JkZXIgaXMgd2l0aGluIHRoZSByYW5nZSBvZiBhIDY0IGJpdCBpbnRlZ2VyLlxyXG4gICAgICBmcmVpZ2h0UHJvcGVydHkudmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvci5pbnQ2NCgpKTtcclxuICBAbWV0aG9kIGludDY0XHJcbiAgQHN0YXRpY1xyXG4gIEByZXR1cm4ge1ZhbGlkYXRvcn0gQSBuZXcgVmFsaWRhdG9yXHJcbiAgKiovXHJcbiAgcHVibGljIHN0YXRpYyBpbnRlZ2VyID0gZnVuY3Rpb24oY29udGV4dDogYW55KSB7XHJcbiAgICBsZXQgdmFsRm4gPSBmdW5jdGlvbiAodjogYW55LCBjdHg6IGFueSkge1xyXG4gICAgICBpZiAodiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmIGN0eCAmJiBjdHguYWxsb3dTdHJpbmcpIHtcclxuICAgICAgICB2ID0gcGFyc2VJbnQodiwgMTApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIpICYmICghaXNOYU4odikpICYmIE1hdGguZmxvb3IodikgPT09IHY7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG5ldyBWYWxpZGF0b3IoXCJpbnRlZ2VyXCIsIHZhbEZuLCBjb250ZXh0KTtcclxuICB9O1xyXG4gIHB1YmxpYyBzdGF0aWMgaW50NjQgPSBWYWxpZGF0b3IuaW50ZWdlcjtcclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIHN0YW5kYXJkIDMyIGJpdCBpbnRlZ2VyIGRhdGEgdHlwZSBWYWxpZGF0b3IuXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gQXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgICAgIHZhciBvcmRlclR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiT3JkZXJcIik7XHJcbiAgICAgIHZhciBmcmVpZ2h0UHJvcGVydHkgLSBvcmRlclR5cGUuZ2V0UHJvcGVydHkoXCJGcmVpZ2h0XCIpO1xyXG4gICAgICBmcmVpZ2h0UHJvcGVydHkudmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvci5pbnQzMigpKTtcclxuICBAbWV0aG9kIGludDMyXHJcbiAgQHN0YXRpY1xyXG4gIEByZXR1cm4ge1ZhbGlkYXRvcn0gQSBuZXcgVmFsaWRhdG9yXHJcbiAgKiovXHJcbiAgcHVibGljIHN0YXRpYyBpbnQzMiA9IGZ1bmN0aW9uKGNvbnRleHQ6IGFueSkge1xyXG4gICAgcmV0dXJuIGludFJhbmdlVmFsaWRhdG9yQ3RvcihcImludDMyXCIsIElOVDMyX01JTiwgSU5UMzJfTUFYLCBjb250ZXh0KSgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBzdGFuZGFyZCAxNiBiaXQgaW50ZWdlciBkYXRhIHR5cGUgVmFsaWRhdG9yLlxyXG4gIEBleGFtcGxlXHJcbiAgICAgIC8vIEFzc3VtZSBlbTEgaXMgYSBwcmVleGlzdGluZyBFbnRpdHlNYW5hZ2VyLlxyXG4gICAgICB2YXIgb3JkZXJUeXBlID0gZW0xLm1ldGFkYXRhU3RvcmUuZ2V0RW50aXR5VHlwZShcIk9yZGVyXCIpO1xyXG4gICAgICB2YXIgZnJlaWdodFByb3BlcnR5IC0gb3JkZXJUeXBlLmdldFByb3BlcnR5KFwiRnJlaWdodFwiKTtcclxuICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSBGcmVpZ2h0IHByb3BlcnR5IG9uIE9yZGVyIGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgYSAxNiBiaXQgaW50ZWdlci5cclxuICAgICAgZnJlaWdodFByb3BlcnR5LnZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3IuaW50MTYoKSk7XHJcbiAgQG1ldGhvZCBpbnQxNlxyXG4gIEBzdGF0aWNcclxuICBAcmV0dXJuIHtWYWxpZGF0b3J9IEEgbmV3IFZhbGlkYXRvclxyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgaW50MTYgPSBmdW5jdGlvbihjb250ZXh0OiBhbnkpIHtcclxuICAgIHJldHVybiBpbnRSYW5nZVZhbGlkYXRvckN0b3IoXCJpbnQxNlwiLCBJTlQxNl9NSU4sIElOVDE2X01BWCwgY29udGV4dCkoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICBSZXR1cm5zIGEgc3RhbmRhcmQgYnl0ZSBkYXRhIHR5cGUgVmFsaWRhdG9yLiAoVGhpcyBpcyBhIGludGVnZXIgYmV0d2VlbiAwIGFuZCAyNTUgaW5jbHVzaXZlIGZvciBqcyBwdXJwb3NlcykuXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gQXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgICAgIHZhciBvcmRlclR5cGUgPSBlbTEubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiT3JkZXJcIik7XHJcbiAgICAgIHZhciBmcmVpZ2h0UHJvcGVydHkgLSBvcmRlclR5cGUuZ2V0UHJvcGVydHkoXCJGcmVpZ2h0XCIpO1xyXG4gICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIEZyZWlnaHQgcHJvcGVydHkgb24gT3JkZXIgaXMgd2l0aGluIHRoZSByYW5nZSBvZiBhIDE2IGJpdCBpbnRlZ2VyLlxyXG4gICAgICAvLyBQcm9iYWJseSBub3QgYSB2ZXJ5IGdvb2QgdmFsaWRhdGlvbiB0byBwbGFjZSBvbiB0aGUgRnJlaWdodCBwcm9wZXJ0eS5cclxuICAgICAgcmVnaW9uUHJvcGVydHkudmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvci5ieXRlKCkpO1xyXG4gIEBtZXRob2QgYnl0ZVxyXG4gIEBzdGF0aWNcclxuICBAcmV0dXJuIHtWYWxpZGF0b3J9IEEgbmV3IFZhbGlkYXRvclxyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgYnl0ZSA9IGZ1bmN0aW9uKGNvbnRleHQ6IGFueSkge1xyXG4gICAgcmV0dXJuIGludFJhbmdlVmFsaWRhdG9yQ3RvcihcImJ5dGVcIiwgQllURV9NSU4sIEJZVEVfTUFYLCBjb250ZXh0KSgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBzdGFuZGFyZCBib29sZWFuIGRhdGEgdHlwZSBWYWxpZGF0b3IuXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gQXNzdW1lIGVtMSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgICAgIHZhciBwcm9kdWN0VHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJQcm9kdWN0XCIpO1xyXG4gICAgICB2YXIgZGlzY29udGludWVkUHJvcGVydHkgLSBwcm9kdWN0VHlwZS5nZXRQcm9wZXJ0eShcIkRpc2NvbnRpbnVlZFwiKTtcclxuICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSBEaXNjb250aW51ZWQgcHJvcGVydHkgb24gUHJvZHVjdCBpcyBhIGJvb2xlYW5cclxuICAgICAgZGlzY29udGludWVkUHJvcGVydHkudmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvci5ib29sKCkpO1xyXG4gIEBtZXRob2QgYm9vbFxyXG4gIEBzdGF0aWNcclxuICBAcmV0dXJuIHtWYWxpZGF0b3J9IEEgbmV3IFZhbGlkYXRvclxyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgYm9vbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgbGV0IHZhbEZuID0gZnVuY3Rpb24gKHY6IGFueSkge1xyXG4gICAgICBpZiAodiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgcmV0dXJuICh2ID09PSB0cnVlKSB8fCAodiA9PT0gZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBuZXcgVmFsaWRhdG9yKFwiYm9vbFwiLCB2YWxGbik7XHJcbiAgfTtcclxuXHJcbiAgcHVibGljIHN0YXRpYyBub25lID0gZnVuY3Rpb24oKSB7XHJcbiAgICBsZXQgdmFsRm4gPSBmdW5jdGlvbiAodjogYW55KSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBuZXcgVmFsaWRhdG9yKFwibm9uZVwiLCB2YWxGbik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIHN0YW5kYXJkIGRhdGUgZGF0YSB0eXBlIFZhbGlkYXRvci5cclxuICBAZXhhbXBsZVxyXG4gICAgICAvLyBBc3N1bWUgZW0xIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICAgICAgdmFyIG9yZGVyVHlwZSA9IGVtMS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJPcmRlclwiKTtcclxuICAgICAgdmFyIG9yZGVyRGF0ZVByb3BlcnR5IC0gb3JkZXJUeXBlLmdldFByb3BlcnR5KFwiT3JkZXJEYXRlXCIpO1xyXG4gICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIE9yZGVyRGF0ZSBwcm9wZXJ0eSBvbiBPcmRlciBpcyBhIGRhdGVcclxuICAgICAgLy8gUHJvYmFibHkgbm90IGEgdmVyeSBnb29kIHZhbGlkYXRpb24gdG8gcGxhY2Ugb24gdGhlIEZyZWlnaHQgcHJvcGVydHkuXHJcbiAgICAgIG9yZGVyRGF0ZVByb3BlcnR5LnZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3IuZGF0ZSgpKTtcclxuICBAbWV0aG9kIGRhdGVcclxuICBAc3RhdGljXHJcbiAgQHJldHVybiB7VmFsaWRhdG9yfSBBIG5ldyBWYWxpZGF0b3JcclxuICAqKi9cclxuICBwdWJsaWMgc3RhdGljIGRhdGUgPSBmdW5jdGlvbigpIHtcclxuICAgIGxldCB2YWxGbiA9IGZ1bmN0aW9uICh2OiBhbnkpIHtcclxuICAgICAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKERhdGUucGFyc2UodikpO1xyXG4gICAgICAgICAgLy8gb2xkIGNvZGVcclxuICAgICAgICAgIC8vIHJldHVybiBfX2lzRGF0ZShuZXcgRGF0ZSh2KSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY29yZS5pc0RhdGUodik7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRvcihcImRhdGVcIiwgdmFsRm4pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgYSBjcmVkaXQgY2FyZCBudW1iZXIgdmFsaWRhdG9yXHJcbiAgUGVyZm9ybXMgYSBsdWhuIGFsZ29yaXRobSBjaGVja3N1bSB0ZXN0IGZvciBwbGF1c2FiaWxpdHlcclxuICBjYXRjaGVzIHNpbXBsZSBtaXN0YWtlczsgb25seSBzZXJ2aWNlIGtub3dzIGZvciBzdXJlXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gQXNzdW1lIGVtIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICAgICAgdmFyIHBlcnNvblR5cGUgPSBlbS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJQZXJzb25cIik7XHJcbiAgICAgIHZhciBjcmVkaXRDYXJkUHJvcGVydHkgPSBwZXJzb25UeXBlLmdldFByb3BlcnR5KFwiY3JlZGl0Q2FyZFwiKTtcclxuICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSBQZXJzb24uY3JlZGl0Q2FyZCBwcm9wZXJ0eSBpcyBjcmVkaXQgY2FyZC5cclxuICAgICAgY3JlZGl0Q2FyZFByb3BlcnR5LnZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3IuY3JlZGl0Q2FyZCgpKTtcclxuICBAbWV0aG9kIGNyZWRpdENhcmRcclxuICBAc3RhdGljXHJcbiAgQHBhcmFtIFtjb250ZXh0XSB7T2JqZWN0fSBvcHRpb25hbCBwYXJhbWV0ZXJzIHRvIHBhc3MgdGhyb3VnaCB0byB2YWxpZGF0aW9uIGNvbnN0cnVjdG9yXHJcbiAgQHJldHVybiB7VmFsaWRhdG9yfSBBIG5ldyBWYWxpZGF0b3JcclxuICAqKi9cclxuICBwdWJsaWMgc3RhdGljIGNyZWRpdENhcmQgPSBmdW5jdGlvbihjb250ZXh0PzogYW55KSB7XHJcbiAgICBmdW5jdGlvbiB2YWxGbih2OiBhbnkpIHtcclxuICAgICAgaWYgKHYgPT0gbnVsbCB8fCB2ID09PSAnJykgcmV0dXJuIHRydWU7XHJcbiAgICAgIGlmICh0eXBlb2YgKHYpICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB2ID0gdi5yZXBsYWNlKC8oXFwtfFxccykvZywgXCJcIik7IC8vIHJlbW92ZSBkYXNoZXMgYW5kIHNwYWNlc1xyXG4gICAgICBpZiAoIXYgfHwgL1xcRC8udGVzdCh2KSkgcmV0dXJuIGZhbHNlOyAvLyBhbGwgZGlnaXRzLCBub3QgZW1wdHlcclxuICAgICAgcmV0dXJuIGx1aG4odik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFZhbGlkYXRvcignY3JlZGl0Q2FyZCcsIHZhbEZuLCBjb250ZXh0KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgUmV0dXJucyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0b3I7IHRoZSBleHByZXNzaW9uIG11c3QgYmUgc3BlY2lmaWVkXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gQWRkIHZhbGlkYXRvciB0byBhIHByb3BlcnR5LiBBc3N1bWUgZW0gaXMgYSBwcmVleGlzdGluZyBFbnRpdHlNYW5hZ2VyLlxyXG4gICAgICB2YXIgY3VzdG9tZXJUeXBlID0gZW0ubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgICAgIHZhciByZWdpb25Qcm9wZXJ0eSA9IGN1c3RvbWVyVHlwZS5nZXRQcm9wZXJ0eShcIlJlZ2lvblwiKTtcclxuICAgICAgLy8gVmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIG9mIEN1c3RvbWVyLlJlZ2lvbiBpcyAyIGNoYXIgdXBwZXJjYXNlIGFscGhhLlxyXG4gICAgICByZWdpb25Qcm9wZXJ0eS52YWxpZGF0b3JzLnB1c2goVmFsaWRhdG9yLnJlZ3VsYXJFeHByZXNzaW9uKCB7ZXhwcmVzc2lvbjogJ15bQS1aXXsyfSQnfSApO1xyXG4gIEBtZXRob2QgcmVndWxhckV4cHJlc3Npb25cclxuICBAc3RhdGljXHJcbiAgQHBhcmFtIGNvbnRleHQge09iamVjdH1cclxuICBAcGFyYW0gY29udGV4dC5leHByZXNzaW9uIHtTdHJpbmd9IFN0cmluZyBmb3JtIG9mIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gYXBwbHlcclxuICBAcmV0dXJuIHtWYWxpZGF0b3J9IEEgbmV3IFZhbGlkYXRvclxyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgcmVndWxhckV4cHJlc3Npb24gPSBmdW5jdGlvbihjb250ZXh0PzogYW55KSB7XHJcbiAgICBmdW5jdGlvbiB2YWxGbih2OiBhbnksIGN0eDogYW55KSB7XHJcbiAgICAgIC8vIGRvIG5vdCBpbnZhbGlkYXRlIGlmIGVtcHR5OyB1c2UgYSBzZXBhcmF0ZSByZXF1aXJlZCB0ZXN0XHJcbiAgICAgIGlmICh2ID09IG51bGwgfHwgdiA9PT0gJycpIHJldHVybiB0cnVlO1xyXG4gICAgICBpZiAodHlwZW9mICh2KSAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKGN0eC5leHByZXNzaW9uKTtcclxuICAgICAgICByZXR1cm4gcmUudGVzdCh2KTtcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBvciBpbnZhbGlkIGV4cHJlc3Npb24gcGFyYW1ldGVyIHRvIHJlZ0V4cCB2YWxpZGF0b3InKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBWYWxpZGF0b3IoJ3JlZ3VsYXJFeHByZXNzaW9uJywgdmFsRm4sIGNvbnRleHQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgdGhlIGVtYWlsIGFkZHJlc3MgdmFsaWRhdG9yXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gQXNzdW1lIGVtIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICAgICAgdmFyIHBlcnNvblR5cGUgPSBlbS5tZXRhZGF0YVN0b3JlLmdldEVudGl0eVR5cGUoXCJQZXJzb25cIik7XHJcbiAgICAgIHZhciBlbWFpbFByb3BlcnR5ID0gcGVyc29uVHlwZS5nZXRQcm9wZXJ0eShcImVtYWlsXCIpO1xyXG4gICAgICAvLyBWYWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIFBlcnNvbi5lbWFpbCBwcm9wZXJ0eSBpcyBhbiBlbWFpbCBhZGRyZXNzLlxyXG4gICAgICBlbWFpbFByb3BlcnR5LnZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3IuZW1haWxBZGRyZXNzKCkpO1xyXG4gIEBtZXRob2QgZW1haWxBZGRyZXNzXHJcbiAgQHN0YXRpY1xyXG4gIEBwYXJhbSBbY29udGV4dF0ge09iamVjdH0gb3B0aW9uYWwgcGFyYW1ldGVycyB0byBwYXNzIHRocm91Z2ggdG8gdmFsaWRhdGlvbiBjb25zdHJ1Y3RvclxyXG4gIEByZXR1cm4ge1ZhbGlkYXRvcn0gQSBuZXcgVmFsaWRhdG9yXHJcbiAgKiovXHJcbiAgcHVibGljIHN0YXRpYyBlbWFpbEFkZHJlc3MgPSBmdW5jdGlvbihjb250ZXh0PzogYW55KSB7XHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Nya2lya2xhbmQvRGF0YUFubm90YXRpb25zRXh0ZW5zaW9ucy9ibG9iL21hc3Rlci9EYXRhQW5ub3RhdGlvbnNFeHRlbnNpb25zL0VtYWlsQXR0cmlidXRlLmNzXHJcbiAgICBsZXQgcmVFbWFpbEFkZHJlc3MgPSAvXigoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4/JC9pO1xyXG4gICAgcmV0dXJuIG1ha2VSZWdFeHBWYWxpZGF0b3IoJ2VtYWlsQWRkcmVzcycsIHJlRW1haWxBZGRyZXNzLCBudWxsLCBjb250ZXh0KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICBSZXR1cm5zIHRoZSBwaG9uZSB2YWxpZGF0b3JcclxuICBQcm92aWRlcyBiYXNpYyBhc3NlcnRpb25zIG9uIHRoZSBmb3JtYXQgYW5kIHdpbGwgaGVscCB0byBlbGltaW5hdGUgbW9zdCBub25zZW5zZSBpbnB1dFxyXG4gIE1hdGNoZXM6XHJcbiAgSW50ZXJuYXRpb25hbCBkaWFsaW5nIHByZWZpeDoge3t9LCArLCAwLCAwMDAwfSAod2l0aCBvciB3aXRob3V0IGEgdHJhaWxpbmcgYnJlYWsgY2hhcmFjdGVyLCBpZiBub3QgJysnOiBbLS8uIF0pXHJcbiAgPiAoKFxcKyl8KDAoXFxkKyk/Wy0vLlxcc10pKVxyXG4gIENvdW50cnkgY29kZToge3t9LCAxLCAuLi4sIDk5OX0gKHdpdGggb3Igd2l0aG91dCBhIHRyYWlsaW5nIGJyZWFrIGNoYXJhY3RlcjogWy0vLiBdKVxyXG4gID4gWzEtOV1cXGR7LDJ9Wy0vLlxcc10/XHJcbiAgQXJlYSBjb2RlOiB7KDApLCAuLi4sICgwMDAwMDApLCAwLCAuLi4sIDAwMDAwMH0gKHdpdGggb3Igd2l0aG91dCBhIHRyYWlsaW5nIGJyZWFrIGNoYXJhY3RlcjogWy0vLiBdKVxyXG4gID4gKChcXChcXGR7MSw2fVxcKXxcXGR7MSw2fSlbLS8uXFxzXT8pP1xyXG4gIExvY2FsOiB7MCwgLi4ufSsgKHdpdGggb3Igd2l0aG91dCBhIHRyYWlsaW5nIGJyZWFrIGNoYXJhY3RlcjogWy0vLiBdKVxyXG4gID4gKFxcZCtbLS8uXFxzXT8pK1xcZCtcclxuICBAZXhhbXBsZVxyXG4gICAgICAvLyBBc3N1bWUgZW0gaXMgYSBwcmVleGlzdGluZyBFbnRpdHlNYW5hZ2VyLlxyXG4gICAgICB2YXIgY3VzdG9tZXJUeXBlID0gZW0ubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgICAgIHZhciBwaG9uZVByb3BlcnR5ID0gY3VzdG9tZXJUeXBlLmdldFByb3BlcnR5KFwicGhvbmVcIik7XHJcbiAgICAgIC8vIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBvZiB0aGUgQ3VzdG9tZXIucGhvbmUgcHJvcGVydHkgaXMgcGhvbmUuXHJcbiAgICAgIHBob25lUHJvcGVydHkudmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvci5waG9uZSgpKTtcclxuICBAbWV0aG9kIHBob25lXHJcbiAgQHN0YXRpY1xyXG4gIEBwYXJhbSBbY29udGV4dF0ge09iamVjdH0gb3B0aW9uYWwgcGFyYW1ldGVycyB0byBwYXNzIHRocm91Z2ggdG8gdmFsaWRhdGlvbiBjb25zdHJ1Y3RvclxyXG4gIEByZXR1cm4ge1ZhbGlkYXRvcn0gQSBuZXcgVmFsaWRhdG9yXHJcbiAgKiovXHJcbiAgcHVibGljIHN0YXRpYyBwaG9uZSA9IGZ1bmN0aW9uIChjb250ZXh0PzogYW55KSB7XHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Nya2lya2xhbmQvRGF0YUFubm90YXRpb25zRXh0ZW5zaW9ucy9ibG9iL21hc3Rlci9EYXRhQW5ub3RhdGlvbnNFeHRlbnNpb25zL0V4cHJlc3Npb25zLmNzXHJcbiAgICBsZXQgcmVQaG9uZSA9IC9eKChcXCt8KDAoXFxkKyk/Wy0vLlxcc10/KSlbMS05XVxcZHswLDJ9Wy0vLlxcc10/KT8oKFxcKFxcZHsxLDZ9XFwpfFxcZHsxLDZ9KVstLy5cXHNdPyk/KFxcZCtbLS8uXFxzXT8pK1xcZCskLztcclxuICAgIHJldHVybiBtYWtlUmVnRXhwVmFsaWRhdG9yKCdwaG9uZScsIHJlUGhvbmUsIG51bGwsIGNvbnRleHQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gIFJldHVybnMgdGhlIFVSTCAocHJvdG9jb2wgcmVxdWlyZWQpIHZhbGlkYXRvclxyXG4gIEBleGFtcGxlXHJcbiAgICAgIC8vIEFzc3VtZSBlbSBpcyBhIHByZWV4aXN0aW5nIEVudGl0eU1hbmFnZXIuXHJcbiAgICAgIHZhciBwZXJzb25UeXBlID0gZW0ubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiUGVyc29uXCIpO1xyXG4gICAgICB2YXIgd2Vic2l0ZVByb3BlcnR5ID0gcGVyc29uVHlwZS5nZXRQcm9wZXJ0eShcIndlYnNpdGVcIik7XHJcbiAgICAgIC8vIFZhbGlkYXRlcyB0aGF0IHRoZSB2YWx1ZSBvZiB0aGUgUGVyc29uLndlYnNpdGUgcHJvcGVydHkgaXMgYSBVUkwuXHJcbiAgICAgIHdlYnNpdGVQcm9wZXJ0eS52YWxpZGF0b3JzLnB1c2goVmFsaWRhdG9yLnVybCgpKTtcclxuICBAbWV0aG9kIHVybFxyXG4gIEBzdGF0aWNcclxuICBAcGFyYW0gW2NvbnRleHRdIHtPYmplY3R9IG9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gcGFzcyB0aHJvdWdoIHRvIHZhbGlkYXRpb24gY29uc3RydWN0b3JcclxuICBAcmV0dXJuIHtWYWxpZGF0b3J9IEEgbmV3IFZhbGlkYXRvclxyXG4gICoqL1xyXG4gIHB1YmxpYyBzdGF0aWMgdXJsID0gZnVuY3Rpb24gKGNvbnRleHQ/OiBhbnkpIHtcclxuICAgIC8vU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zcmtpcmtsYW5kL0RhdGFBbm5vdGF0aW9uc0V4dGVuc2lvbnMvYmxvYi9tYXN0ZXIvRGF0YUFubm90YXRpb25zRXh0ZW5zaW9ucy9VcmxBdHRyaWJ1dGUuY3NcclxuICAgIGxldCByZVVybFByb3RvY29sUmVxdWlyZWQgPSAvXihodHRwcz98ZnRwKTpcXC9cXC8oKCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mQS1GXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OikqQCk/KCgoXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pKXwoW2EtekEtWl1bXFwtYS16QS1aMC05XSopfCgoKFthLXpBLVpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16QS1aXXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16QS1aXXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2EtekEtWl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2EtekEtWl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16QS1aXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLj8pKDpcXGQqKT8pKFxcLygoKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZkEtRl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkrKFxcLygoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mQS1GXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSopKik/KT8oXFw/KCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mQS1GXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxbXFx1RTAwMC1cXHVGOEZGXXxcXC98XFw/KSopPyhcXCMoKChbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZBLUZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFxcL3xcXD8pKik/JC87XHJcbiAgICByZXR1cm4gbWFrZVJlZ0V4cFZhbGlkYXRvcigndXJsJywgcmVVcmxQcm90b2NvbFJlcXVpcmVkLCBudWxsLCBjb250ZXh0KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICBDcmVhdGVzIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRvciB3aXRoIGEgZml4ZWQgZXhwcmVzc2lvbi5cclxuICBNYW55IG9mIHRoZSBzdG9jayB2YWxpZGF0b3JzIGFyZSBidWlsdCB3aXRoIHRoaXMgZmFjdG9yeSBtZXRob2QuXHJcbiAgVGhlaXIgZXhwcmVzc2lvbnMgYXJlIG9mdGVuIGRlcml2ZWQgZnJvbVxyXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9zcmtpcmtsYW5kL0RhdGFBbm5vdGF0aW9uc0V4dGVuc2lvbnMvYmxvYi9tYXN0ZXIvRGF0YUFubm90YXRpb25zRXh0ZW5zaW9uc1xyXG4gIFlvdSBjYW4gdHJ5IG1hbnkgb2YgdGhlbSBhdCBodHRwOi8vZGF0YWFubm90YXRpb25zZXh0ZW5zaW9ucy5vcmcvXHJcbiAgQGV4YW1wbGVcclxuICAgICAgLy8gTWFrZSBhIHppcGNvZGUgdmFsaWRhdG9yXHJcbiAgICAgIGZ1bmN0aW9uIHppcFZhbGlkYXRvciA9IFZhbGlkYXRvci5tYWtlUmVnRXhwVmFsaWRhdG9yKFxyXG4gICAgICBcInppcFZhbCxcclxuICAgICAgL15cXGR7NX0oW1xcLV1cXGR7NH0pPyQvLFxyXG4gICAgICBcIlRoZSAlZGlzcGxheU5hbWUlICcldmFsdWUlJyBpcyBub3QgYSB2YWxpZCBVLlMuIHppcGNvZGVcIik7XHJcbiAgICAgIC8vIFJlZ2lzdGVyIGl0LlxyXG4gICAgICBWYWxpZGF0b3IucmVnaXN0ZXIoemlwVmFsaWRhdG9yKTtcclxuICAgICAgLy8gQWRkIGl0IHRvIGEgZGF0YSBwcm9wZXJ0eS4gQXNzdW1lIGVtIGlzIGEgcHJlZXhpc3RpbmcgRW50aXR5TWFuYWdlci5cclxuICAgICAgdmFyIGN1c3RUeXBlID0gZW0ubWV0YWRhdGFTdG9yZS5nZXRFbnRpdHlUeXBlKFwiQ3VzdG9tZXJcIik7XHJcbiAgICAgIHZhciB6aXBQcm9wZXJ0eSA9IGN1c3RUeXBlLmdldFByb3BlcnR5KFwiUG9zdGFsQ29kZVwiKTtcclxuICAgICAgemlwUHJvcGVydHkudmFsaWRhdG9ycy5wdXNoKHppcFZhbGlkYXRvcik7XHJcbiAgQG1ldGhvZCBtYWtlUmVnRXhwVmFsaWRhdG9yXHJcbiAgQHN0YXRpY1xyXG4gIEBwYXJhbSB2YWxpZGF0b3JOYW1lIHtTdHJpbmd9IG5hbWUgb2YgdGhpcyB2YWxpZGF0b3JcclxuICBAcGFyYW0gZXhwcmVzc2lvbiB7U3RyaW5nIHwgUmVnRXhwfSByZWd1bGFyIGV4cHJlc3Npb24gdG8gYXBwbHlcclxuICBAcGFyYW0gW2RlZmF1bHRNZXNzYWdlXSB7U3RyaW5nfSBkZWZhdWx0IG1lc3NhZ2UgZm9yIGZhaWxlZCB2YWxpZGF0aW9uc1xyXG4gIEBwYXJhbSBbY29udGV4dF0ge09iamVjdH0gb3B0aW9uYWwgcGFyYW1ldGVycyB0byBwYXNzIHRocm91Z2ggdG8gdmFsaWRhdGlvbiBjb25zdHJ1Y3RvclxyXG4gIEByZXR1cm4ge1ZhbGlkYXRvcn0gQSBuZXcgVmFsaWRhdG9yXHJcbiAgKiovXHJcbiAgcHVibGljIHN0YXRpYyBtYWtlUmVnRXhwVmFsaWRhdG9yID0gbWFrZVJlZ0V4cFZhbGlkYXRvcjtcclxuXHJcbn1cclxuVmFsaWRhdG9yLnByb3RvdHlwZS5fJHR5cGVOYW1lID0gXCJWYWxpZGF0b3JcIjtcclxuXHJcbi8vIHJlZ2lzdGVyIGFsbCB2YWxpZGF0b3JzXHJcbkVycm9yWyd4J10gPSBjb3JlLm9iamVjdEZvckVhY2goVmFsaWRhdG9yLCBmdW5jdGlvbiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcclxuICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoa2V5ID09PSBcImZyb21KU09OXCIgfHwga2V5ID09PSBcInJlZ2lzdGVyXCIgfHxcclxuICAgICAga2V5ID09PSBcInJlZ2lzdGVyRmFjdG9yeVwiIHx8IGtleSA9PT0gXCJtYWtlUmVnRXhwVmFsaWRhdG9yXCIpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGNvbmZpZy5yZWdpc3RlckZ1bmN0aW9uKHZhbHVlLCBcIlZhbGlkYXRvci5cIiArIGtleSk7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gZm9ybWF0VGVtcGxhdGUodGVtcGxhdGU6IHN0cmluZywgdmFyczogT2JqZWN0LCBvd25Qcm9wZXJ0aWVzT25seTogYm9vbGVhbiA9IGZhbHNlKSB7XHJcbiAgaWYgKCF2YXJzKSByZXR1cm4gdGVtcGxhdGU7XHJcbiAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoLyUoW14lXSspJS9nLCBmdW5jdGlvbiAoXywga2V5KSB7XHJcbiAgICBsZXQgdmFsT3JGbjogYW55O1xyXG4gICAgaWYgKG93blByb3BlcnRpZXNPbmx5KSB7XHJcbiAgICAgIHZhbE9yRm4gPSB2YXJzLmhhc093blByb3BlcnR5KGtleSkgPyB2YXJzW2tleV0gOiAnJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhbE9yRm4gPSB2YXJzW2tleV07XHJcbiAgICB9XHJcbiAgICBpZiAodmFsT3JGbiAhPSBudWxsKSB7XHJcbiAgICAgIGlmIChjb3JlLmlzRnVuY3Rpb24odmFsT3JGbikpIHtcclxuICAgICAgICByZXR1cm4gdmFsT3JGbih2YXJzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmFsT3JGbjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGludFJhbmdlVmFsaWRhdG9yQ3Rvcih2YWxpZGF0b3JOYW1lOiBzdHJpbmcsIG1pblZhbHVlOiBudW1iZXIsIG1heFZhbHVlOiBudW1iZXIsIGNvbnRleHQ6IGFueSkge1xyXG4gIGNvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xyXG4gIGlmIChtaW5WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7IGNvbnRleHQubWluID0gbWluVmFsdWU7IH1cclxuICBpZiAobWF4VmFsdWUgIT09IHVuZGVmaW5lZCkgeyBjb250ZXh0Lm1heCA9IG1heFZhbHVlOyB9XHJcbiAgbGV0IHRlbXBsYXRlRXhpc3RzID0gY29udGV4dC5tZXNzYWdlVGVtcGxhdGUgfHwgVmFsaWRhdG9yLm1lc3NhZ2VUZW1wbGF0ZXNbdmFsaWRhdG9yTmFtZV07XHJcbiAgaWYgKCF0ZW1wbGF0ZUV4aXN0cykge1xyXG4gICAgVmFsaWRhdG9yLm1lc3NhZ2VUZW1wbGF0ZXNbdmFsaWRhdG9yTmFtZV0gPSBjb3JlLmZvcm1hdFN0cmluZyhcIiclZGlzcGxheU5hbWUlJyBtdXN0IGJlIGFuIGludGVnZXIgYmV0d2VlbiB0aGUgdmFsdWVzIG9mICUxIGFuZCAlMlwiLFxyXG4gICAgICAgIG1pblZhbHVlLCBtYXhWYWx1ZSk7XHJcbiAgfVxyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICBsZXQgdmFsRm4gPSBmdW5jdGlvbiAodjogYW55LCBjdHg6IGFueSkge1xyXG4gICAgICBpZiAodiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmIGN0eCAmJiBjdHguYWxsb3dTdHJpbmcpIHtcclxuICAgICAgICB2ID0gcGFyc2VJbnQodiwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikgJiYgKCFpc05hTih2KSkgJiYgTWF0aC5mbG9vcih2KSA9PT0gdikge1xyXG4gICAgICAgIGlmIChtaW5WYWx1ZSAhPSBudWxsICYmIHYgPCBtaW5WYWx1ZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4VmFsdWUgIT0gbnVsbCAmJiB2ID4gbWF4VmFsdWUpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG5ldyBWYWxpZGF0b3IodmFsaWRhdG9yTmFtZSwgdmFsRm4sIGNvbnRleHQpO1xyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVnRXhwVmFsaWRhdG9yKHZhbGlkYXRvck5hbWU6IHN0cmluZywgZXhwcmVzc2lvbjogUmVnRXhwLCBkZWZhdWx0TWVzc2FnZT86IHN0cmluZyB8IG51bGwsIGNvbnRleHQ/OiBhbnkpIHtcclxuICBpZiAoZGVmYXVsdE1lc3NhZ2UpIHtcclxuICAgIFZhbGlkYXRvci5tZXNzYWdlVGVtcGxhdGVzW3ZhbGlkYXRvck5hbWVdID0gZGVmYXVsdE1lc3NhZ2U7XHJcbiAgfVxyXG4gIGxldCByZSA9ICh0eXBlb2YgKGV4cHJlc3Npb24pID09PSAnc3RyaW5nJykgPyBuZXcgUmVnRXhwKGV4cHJlc3Npb24pIDogZXhwcmVzc2lvbjtcclxuICBsZXQgdmFsRm4gPSBmdW5jdGlvbiAodjogYW55KSB7XHJcbiAgICAvLyBkbyBub3QgaW52YWxpZGF0ZSBpZiBlbXB0eTsgdXNlIGEgc2VwYXJhdGUgcmVxdWlyZWQgdGVzdFxyXG4gICAgaWYgKHYgPT0gbnVsbCB8fCB2ID09PSAnJykgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAodHlwZW9mICh2KSAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiByZS50ZXN0KHYpO1xyXG4gIH07XHJcbiAgcmV0dXJuIG5ldyBWYWxpZGF0b3IodmFsaWRhdG9yTmFtZSwgdmFsRm4sIGNvbnRleHQpO1xyXG59XHJcblxyXG4vLyBodHRwOi8vcm9zZXR0YWNvZGUub3JnL3dpa2kvTHVobl90ZXN0X29mX2NyZWRpdF9jYXJkX251bWJlcnMjSmF2YVNjcmlwdFxyXG5cclxuLy8gZnVuY3Rpb24gbHVobihhOiBzdHJpbmcsIGI6IG51bWJlciwgYzogbnVtYmVyLCBkOiBudW1iZXIsIGU6IG51bWJlcikge1xyXG4vLyAgIGZvciAoZCA9ICthW2IgPSBhLmxlbmd0aCAtIDFdLCBlID0gMDsgYi0tOyApIHtcclxuLy8gICAgIGMgPSArYVtiXSwgZCArPSArK2UgJSAyID8gMiAqIGMgJSAxMCArIChjID4gNCkgOiBjO1xyXG4vLyAgIH1cclxuLy8gICByZXR1cm4gIShkICUgMTApO1xyXG4vLyB9O1xyXG5cclxubGV0ICBsdWhuID0gKGZ1bmN0aW9uKCkge1xyXG4gIGxldCBsdWhuQXJyID0gWzAsIDIsIDQsIDYsIDgsIDEsIDMsIDUsIDcsIDldO1xyXG4gIHJldHVybiBmdW5jdGlvbihzdHI6IHN0cmluZykgXHR7XHJcbiAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICBsZXQgaW5jTnVtOiBudW1iZXI7XHJcbiAgICBsZXQgb2RkID0gZmFsc2U7XHJcbiAgICBsZXQgdGVtcCA9IFN0cmluZyhzdHIpLnJlcGxhY2UoL1teXFxkXS9nLCBcIlwiKTtcclxuICAgIGlmICggdGVtcC5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcclxuICAgIGZvciAobGV0IGkgPSB0ZW1wLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSAge1xyXG4gICAgICBpbmNOdW0gPSBwYXJzZUludCh0ZW1wLmNoYXJBdChpKSwgMTApO1xyXG4gICAgICBjb3VudGVyICs9IChvZGQgPSAhb2RkKSA/IGluY051bSA6IGx1aG5BcnJbaW5jTnVtXTtcclxuICAgIH1cclxuICAgIHJldHVybiAoY291bnRlciAlIDEwID09PSAwKTtcclxuICB9O1xyXG59KSgpO1xyXG5cclxuLyoqXHJcbkEgVmFsaWRhdGlvbkVycm9yIGlzIHVzZWQgdG8gZGVzY3JpYmUgYSBmYWlsZWQgdmFsaWRhdGlvbi5cclxuXHJcbkBjbGFzcyBWYWxpZGF0aW9uRXJyb3JcclxuKiovXHJcblxyXG4vKipcclxuQ29uc3RydWN0cyBhIG5ldyBWYWxpZGF0aW9uRXJyb3JcclxuQG1ldGhvZCA8Y3Rvcj4gVmFsaWRhdGlvbkVycm9yXHJcblxyXG5AcGFyYW0gdmFsaWRhdG9yIHtWYWxpZGF0b3IgfHwgbnVsbH0gVGhlIFZhbGlkYXRvciB1c2VkIHRvIGNyZWF0ZSB0aGlzIGVycm9yLCBpZiBhbnkuXHJcbkBwYXJhbSBjb250ZXh0IHsgQ29udGV4dE9iamVjdCB8fCBudWxsfSBUaGUgQ29udGV4dCBvYmplY3QgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBWYWxpZGF0b3IgdG8gY3JlYXRlIHRoaXMgZXJyb3IuXHJcbkBwYXJhbSBlcnJvck1lc3NhZ2UgeyBTdHJpbmd9IFRoZSBhY3R1YWwgZXJyb3IgbWVzc2FnZVxyXG5AcGFyYW0gW2tleV0ge1N0cmluZ30gQW4gb3B0aW9uYWwga2V5IHVzZWQgdG8gZGVmaW5lIGEga2V5IGZvciB0aGlzIGVycm9yLiBPbmUgd2lsbCBiZSBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgaWYgbm90IHByb3ZpZGVkIGhlcmUuXHJcbioqL1xyXG5leHBvcnQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIHtcclxuICB2YWxpZGF0b3I/OiBWYWxpZGF0b3I7XHJcbiAga2V5OiBzdHJpbmc7XHJcbiAgY29udGV4dDogYW55O1xyXG4gIGVycm9yTWVzc2FnZTogc3RyaW5nO1xyXG4gIHByb3BlcnR5OiBhbnk7IC8vIElQcm9wZXJ0eVxyXG4gIHByb3BlcnR5TmFtZTogc3RyaW5nO1xyXG4gIGlzU2VydmVyRXJyb3I6IGJvb2xlYW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKHZhbGlkYXRvcjogVmFsaWRhdG9yIHwgbnVsbCwgY29udGV4dDogYW55LCBlcnJvck1lc3NhZ2U6IHN0cmluZywga2V5Pzogc3RyaW5nKSB7XHJcbiAgICAvLyBFcnJvciBpcyB3aXRoIGlzSW5zdGFuY2VPZihWYWxpZGF0b3IpXHJcbiAgICBhc3NlcnRQYXJhbSh2YWxpZGF0b3IsIFwidmFsaWRhdG9yXCIpLmlzT3B0aW9uYWwoKS5pc0luc3RhbmNlT2YoVmFsaWRhdG9yKS5jaGVjaygpO1xyXG4gICAgYXNzZXJ0UGFyYW0oZXJyb3JNZXNzYWdlLCBcImVycm9yTWVzc2FnZVwiKS5pc05vbkVtcHR5U3RyaW5nKCkuY2hlY2soKTtcclxuICAgIGFzc2VydFBhcmFtKGtleSwgXCJrZXlcIikuaXNPcHRpb25hbCgpLmlzTm9uRW1wdHlTdHJpbmcoKS5jaGVjaygpO1xyXG4gICAgdGhpcy52YWxpZGF0b3IgPSB2YWxpZGF0b3IgfHwgdW5kZWZpbmVkO1xyXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwge307XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7XHJcblxyXG4gICAgdGhpcy5wcm9wZXJ0eSA9IGNvbnRleHQucHJvcGVydHk7XHJcbiAgICB0aGlzLnByb3BlcnR5TmFtZSA9IGNvbnRleHQucHJvcGVydHlOYW1lIHx8IChjb250ZXh0LnByb3BlcnR5ICYmIGNvbnRleHQucHJvcGVydHkubmFtZSk7XHJcblxyXG4gICAgaWYgKGtleSkge1xyXG4gICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMua2V5ID0gVmFsaWRhdGlvbkVycm9yLmdldEtleSh2YWxpZGF0b3IgfHwgZXJyb3JNZXNzYWdlLCB0aGlzLnByb3BlcnR5TmFtZSk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmlzU2VydmVyRXJyb3IgPSBmYWxzZTtcclxuICB9XHJcblxyXG5cclxuICAvKipcclxuICBUaGUgVmFsaWRhdG9yIGFzc29jaWF0ZWQgd2l0aCB0aGlzIFZhbGlkYXRpb25FcnJvci5cclxuXHJcbiAgX19yZWFkT25seV9fXHJcbiAgQHByb3BlcnR5IHZhbGlkYXRvciB7VmFsaWRhdG9yfVxyXG4gICoqL1xyXG5cclxuICAvKipcclxuICBBICdjb250ZXh0JyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgVmFsaWRhdGlvbkVycm9yLlxyXG5cclxuICBfX3JlYWRPbmx5X19cclxuICBAcHJvcGVydHkgY29udGV4dCB7T2JqZWN0fVxyXG4gICoqL1xyXG5cclxuICAvKipcclxuICBUaGUgRGF0YVByb3BlcnR5IG9yIE5hdmlnYXRpb25Qcm9wZXJ0eSBhc3NvY2lhdGVkIHdpdGggdGhpcyBWYWxpZGF0aW9uRXJyb3IuXHJcblxyXG4gIF9fcmVhZE9ubHlfX1xyXG4gIEBwcm9wZXJ0eSBwcm9wZXJ0eSB7RGF0YVByb3BlcnR5fE5hdmlnYXRpb25Qcm9wZXJ0eX1cclxuICAqKi9cclxuXHJcbiAgLyoqXHJcbiAgVGhlIHByb3BlcnR5IG5hbWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgVmFsaWRhdGlvbkVycm9yLiBUaGlzIHdpbGwgYmUgYSBcInByb3BlcnR5IHBhdGhcIiBmb3IgYW55IHByb3BlcnRpZXMgb2YgYSBjb21wbGV4IG9iamVjdC5cclxuXHJcbiAgX19yZWFkT25seV9fXHJcbiAgQHByb3BlcnR5IHByb3BlcnR5TmFtZSB7U3RyaW5nfVxyXG4gICoqL1xyXG5cclxuICAvKipcclxuICBUaGUgZXJyb3IgbWVzc2FnZSBhc3NvY2lhdGVkIHdpdGggdGhlIFZhbGlkYXRpb25FcnJvci5cclxuXHJcbiAgX19yZWFkT25seV9fXHJcbiAgQHByb3BlcnR5IGVycm9yTWVzc2FnZSB7c3RyaW5nfVxyXG4gICoqL1xyXG5cclxuICAvKipcclxuICBUaGUga2V5IGJ5IHdoaWNoIHRoaXMgdmFsaWRhdGlvbiBlcnJvciBtYXkgYmUgcmVtb3ZlZCBmcm9tIGEgY29sbGVjdGlvbiBvZiBWYWxpZGF0aW9uRXJyb3JzLlxyXG5cclxuICBfX3JlYWRPbmx5X19cclxuICBAcHJvcGVydHkga2V5IHtzdHJpbmd9XHJcbiAgKiovXHJcblxyXG4gIC8qKlxyXG4gIFdoZXRoZXIgdGhpcyBpcyBhIHNlcnZlciBlcnJvci5cclxuXHJcbiAgX19yZWFkT25seV9fXHJcbiAgQHByb3BlcnR5IGlzU2VydmVyRXJyb3Ige2Jvb2x9XHJcbiAgKiovXHJcblxyXG5cclxuICAvKipcclxuICBDb21wb3NlcyBhIFZhbGlkYXRpb25FcnJvciAna2V5JyBnaXZlbiBhIHZhbGlkYXRvciBvciBhbiBlcnJvck5hbWUgYW5kIGFuIG9wdGlvbmFsIHByb3BlcnR5TmFtZVxyXG4gIEBtZXRob2QgZ2V0S2V5XHJcbiAgQHN0YXRpY1xyXG4gIEBwYXJhbSB2YWxpZGF0b3Ige1ZhbGlkYXRvck9yRXJyb3JLZXl9IEEgVmFsaWRhdG9yIG9yIGFuIFwiZXJyb3IgbmFtZVwiIGlmIG5vIHZhbGlkYXRvciBpcyBhdmFpbGFibGUuXHJcbiAgQHBhcmFtIFtwcm9wZXJ0eU5hbWVdIEEgcHJvcGVydHkgbmFtZVxyXG4gIEByZXR1cm4ge1N0cmluZ30gQSBWYWxpZGF0aW9uRXJyb3IgJ2tleSdcclxuICAqKi9cclxuICBwdWJsaWMgc3RhdGljIGdldEtleSh2YWxpZGF0b3JPckVycm9yTmFtZTogVmFsaWRhdG9yIHwgc3RyaW5nLCBwcm9wZXJ0eU5hbWU/OiBzdHJpbmcpIHtcclxuICAgIGxldCBuYW1lID0gKHR5cGVvZiB2YWxpZGF0b3JPckVycm9yTmFtZSA9PT0gJ3N0cmluZycpID8gdmFsaWRhdG9yT3JFcnJvck5hbWUgOiB2YWxpZGF0b3JPckVycm9yTmFtZS5uYW1lO1xyXG4gICAgcmV0dXJuIG5hbWUgKyAocHJvcGVydHlOYW1lID8gXCI6XCIgKyBwcm9wZXJ0eU5hbWUgOiBcIlwiKTtcclxuICB9XHJcblxyXG59XHJcblxyXG5cclxuIl19