import { core } from './core';
import { EntityKey } from './entity-key';
import { EntityAspect } from './entity-aspect';
import { EntityState } from './entity-state';
import { EntityAction } from './entity-action';
/** @hidden @internal */
export function defaultPropertyInterceptor(property, newValue, rawAccessorFn) {
    // 'this' is the entity itself in this context.
    if (newValue === undefined)
        newValue = null; // remove? to allow assignment to undefined in Babel constructors?
    let oldValue = rawAccessorFn();
    let dataType = property.dataType;
    if (dataType && dataType.parse) {
        // attempts to coerce a value to the correct type - if this fails return the value unchanged
        if (Array.isArray(newValue) && !property.isScalar) {
            newValue = newValue.map(function (nv) {
                return dataType.parse(nv, typeof nv);
            });
        }
        else {
            newValue = dataType.parse(newValue, typeof newValue);
        }
    }
    // exit if no change - extra cruft is because dateTimes don't compare cleanly.
    if (newValue === oldValue || (dataType && dataType.normalize && newValue && oldValue && dataType.normalize(newValue) === dataType.normalize(oldValue))) {
        return;
    }
    // CANNOT DO NEXT LINE because it has the possibility of creating a new property
    // 'entityAspect' on 'this'.  - Not permitted by IE inside of a defined property on a prototype.
    // let entityAspect = new EntityAspect(this);
    let propertyName;
    let entityAspect = this.entityAspect;
    if (entityAspect) {
        propertyName = property.name;
    }
    else {
        let localAspect = this.complexAspect;
        if (localAspect) {
            entityAspect = localAspect.getEntityAspect();
            propertyName = localAspect.getPropertyPath(property.name);
        }
        else {
            // does not yet have an EntityAspect so just set the prop
            rawAccessorFn(newValue);
            return;
        }
    }
    // Note that we need to handle multiple properties in process, not just one in order to avoid recursion.
    // ( except in the case of null propagation with fks where null -> 0 in some cases.)
    // (this may not be needed because of the newValue === oldValue test above)
    let inProcess = entityAspect._inProcess = entityAspect._inProcess || [];
    // check for recursion
    if (inProcess.indexOf(property) >= 0)
        return;
    inProcess.push(property);
    try {
        let context = {
            parent: this,
            property: property,
            newValue: newValue,
            oldValue: oldValue,
            propertyName: propertyName,
            entityAspect: entityAspect
        };
        if (property.isComplexProperty) {
            setDpValueComplex(context, rawAccessorFn);
        }
        else if (property.isDataProperty) {
            setDpValueSimple(context, rawAccessorFn);
        }
        else {
            setNpValue(context, rawAccessorFn);
        }
        postChangeEvents(context);
    }
    finally {
        inProcess.pop();
    }
}
function setDpValueSimple(context, rawAccessorFn) {
    let parent = context.parent;
    let property = context.property;
    let entityAspect = context.entityAspect;
    let oldValue = context.oldValue;
    let newValue = context.newValue;
    let entityManager = entityAspect.entityManager;
    if (!property.isScalar) {
        throw new Error("Nonscalar data properties are readonly - items may be added or removed but the collection may not be changed.");
    }
    // store an original value for this property if not already set
    if (entityAspect.entityState.isUnchangedOrModified()) {
        let propName = property.name;
        // localAspect is not the same as entityAspect for complex props
        let localAspect = EntityAspect.isEntity(parent) ? parent.entityAspect : parent.complexAspect;
        if (localAspect.originalValues[propName] === undefined) {
            // otherwise this entry will be skipped during serialization
            localAspect.originalValues[propName] = oldValue !== undefined ? oldValue : property.defaultValue;
        }
    }
    // if we are changing the key update our internal entityGroup indexes.
    if (property.isPartOfKey && entityManager && !entityManager.isLoading) {
        // 'entityType' on the next line be null for complex properties but it will only be ref'd within this
        // fn when the property is part of the key
        let entityType = parent.entityType;
        let keyProps = entityType.keyProperties;
        let values = keyProps.map(function (p) {
            if (p === property) {
                return newValue;
            }
            else {
                return parent.getProperty(p.name);
            }
        });
        let newKey = new EntityKey(entityType, values);
        if (entityManager.findEntityByKey(newKey)) {
            throw new Error("An entity with this key is already in the cache: " + newKey.toString());
        }
        let oldKey = parent.entityAspect.getKey();
        let eg = entityManager._findEntityGroup(entityType);
        eg._replaceKey(oldKey, newKey);
    }
    // process related updates ( the inverse relationship) first so that collection dups check works properly.
    // update inverse relationship
    let relatedNavProp = property.relatedNavigationProperty;
    if (relatedNavProp && entityManager) {
        // Example: bidirectional fkDataProperty: 1->n: order -> orderDetails
        // orderDetail.orderId <- newOrderId || null
        //    ==> orderDetail.order = lookupOrder(newOrderId)
        //    ==> (see set navProp above)
        //       and
        // Example: bidirectional fkDataProperty: 1->1: order -> internationalOrder
        // internationalOrder.orderId <- newOrderId || null
        //    ==> internationalOrder.order = lookupOrder(newOrderId)
        //    ==> (see set navProp above)
        if (newValue != null) {
            let key = new EntityKey(relatedNavProp.entityType, [newValue]);
            let relatedEntity = entityManager.findEntityByKey(key);
            if (relatedEntity) {
                parent.setProperty(relatedNavProp.name, relatedEntity);
            }
            else {
                // it may not have been fetched yet in which case we want to add it as an unattachedChild.
                entityManager._unattachedChildrenMap.addChild(key, relatedNavProp, parent);
                parent.setProperty(relatedNavProp.name, null);
            }
        }
        else {
            parent.setProperty(relatedNavProp.name, null);
        }
    }
    else if (property.inverseNavigationProperty && entityManager && !entityManager._inKeyFixup) {
        // Example: unidirectional fkDataProperty: 1->n: region -> territories
        // territory.regionId <- newRegionId
        //    ==> lookupRegion(newRegionId).territories.push(territory)
        //                and
        // Example: unidirectional fkDataProperty: 1->1: order -> internationalOrder
        // internationalOrder.orderId <- newOrderId
        //    ==> lookupOrder(newOrderId).internationalOrder = internationalOrder
        //                and
        // Example: unidirectional fkDataProperty: 1->n: region -> territories
        // territory.regionId <- null
        //    ==> lookupRegion(territory.oldRegionId).territories.remove(oldTerritory);
        //                and
        // Example: unidirectional fkDataProperty: 1->1: order -> internationalOrder
        // internationalOrder.orderId <- null
        //    ==> lookupOrder(internationalOrder.oldOrderId).internationalOrder = null;
        let invNavProp = property.inverseNavigationProperty;
        if (oldValue != null) {
            let key = new EntityKey(invNavProp.parentType, [oldValue]);
            let relatedEntity = entityManager.findEntityByKey(key);
            if (relatedEntity) {
                if (invNavProp.isScalar) {
                    relatedEntity.setProperty(invNavProp.name, null);
                }
                else {
                    // remove 'this' from old related nav prop
                    let relatedArray = relatedEntity.getProperty(invNavProp.name);
                    // arr.splice(arr.indexOf(value_to_remove), 1);
                    relatedArray.splice(relatedArray.indexOf(parent), 1);
                }
            }
        }
        if (newValue != null) {
            let key = new EntityKey(invNavProp.parentType, [newValue]);
            let relatedEntity = entityManager.findEntityByKey(key);
            if (relatedEntity) {
                if (invNavProp.isScalar) {
                    relatedEntity.setProperty(invNavProp.name, parent);
                }
                else {
                    relatedEntity.getProperty(invNavProp.name).push(parent);
                }
            }
            else {
                // it may not have been fetched yet in which case we want to add it as an unattachedChild.
                entityManager._unattachedChildrenMap.addChild(key, invNavProp, parent);
            }
        }
    }
    rawAccessorFn(newValue);
    updateStateAndValidate(context);
    // if (property.isPartOfKey && (!this.complexAspect)) {
    if (property.isPartOfKey) {
        // propogate pk change to all related entities;
        let entityType = parent.entityType;
        let propertyIx = entityType.keyProperties.indexOf(property);
        // this part handles order.orderId => orderDetail.orderId
        // but won't handle product.productId => orderDetail.productId because product
        // doesn't have an orderDetails property.
        entityType.navigationProperties.forEach(function (np) {
            let inverseNp = np.inverse;
            let fkNames = inverseNp ? inverseNp.foreignKeyNames : np.invForeignKeyNames;
            if (fkNames.length === 0)
                return;
            let npValue = parent.getProperty(np.name);
            if (!npValue)
                return;
            let fkName = fkNames[propertyIx];
            if (np.isScalar) {
                npValue.setProperty(fkName, newValue);
            }
            else {
                npValue.forEach(function (iv) {
                    iv.setProperty(fkName, newValue);
                });
            }
        });
        // this handles unidirectional problems not covered above.
        if (entityManager) {
            let inverseForeignKeyProperties = entityType.inverseForeignKeyProperties;
            let baseEntityType = entityType.baseEntityType;
            while (baseEntityType) {
                inverseForeignKeyProperties = inverseForeignKeyProperties.concat(baseEntityType.inverseForeignKeyProperties);
                baseEntityType = baseEntityType.baseEntityType;
            }
            inverseForeignKeyProperties.forEach((invFkProp) => {
                if (invFkProp.relatedNavigationProperty.inverse == null) {
                    // this next step may be slow - it iterates over all of the entities in a group;
                    // hopefully it doesn't happen often.
                    entityManager._updateFkVal(invFkProp, oldValue, newValue);
                }
            });
        }
        // insure that cached key is updated.
        entityAspect.getKey(true);
    }
}
function setDpValueComplex(context, rawAccessorFn) {
    let property = context.property;
    let oldValue = context.oldValue;
    let newValue = context.newValue;
    // To get here it must be a ComplexProperty
    // 'dataType' will be a complexType
    let dataType = property.dataType;
    if (property.isScalar) {
        if (!newValue) {
            throw new Error(core.formatString("You cannot set the '%1' property to null because it's datatype is the ComplexType: '%2'", property.name, property.dataType.name));
        }
        if (!oldValue) {
            let ctor = dataType.getCtor();
            oldValue = new ctor();
            rawAccessorFn(oldValue);
        }
        dataType.dataProperties.forEach(function (dp) {
            let pn = dp.name;
            let nv = newValue.getProperty(pn);
            oldValue.setProperty(pn, nv);
        });
    }
    else {
        throw new Error(core.formatString("You cannot set the non-scalar complex property: '%1' on the type: '%2'." +
            "Instead get the property and use array functions like 'push' or 'splice' to change its contents.", property.name, property.parentType.name));
    }
}
function setNpValue(context, rawAccessorFn) {
    let parent = context.parent;
    let property = context.property;
    let entityAspect = context.entityAspect;
    let oldValue = context.oldValue;
    let newValue = context.newValue;
    if (!property.isScalar) {
        throw new Error("Nonscalar navigation properties are readonly - entities can be added or removed but the collection may not be changed.");
    }
    let entityManager = entityAspect.entityManager;
    let inverseProp = property.inverse;
    // manage attachment -
    if (newValue != null) {
        let newAspect = newValue.entityAspect;
        if (entityManager) {
            if (newAspect.entityState.isDetached()) {
                if (!entityManager.isLoading) {
                    entityManager.attachEntity(newValue, EntityState.Added);
                }
            }
            else {
                if (newAspect.entityManager !== entityManager) {
                    throw new Error("An Entity cannot be attached to an entity in another EntityManager. One of the two entities must be detached first.");
                }
            }
        }
        else {
            if (newAspect && newAspect.entityManager) {
                entityManager = newAspect.entityManager;
                if (!entityManager.isLoading) {
                    entityManager.attachEntity(entityAspect.entity, EntityState.Added);
                }
            }
        }
    }
    // process related updates ( the inverse relationship) first so that collection dups check works properly.
    // update inverse relationship
    if (inverseProp) {
        ///
        if (inverseProp.isScalar) {
            // Example: bidirectional navProperty: 1->1: order -> internationalOrder
            // order.internationalOrder <- internationalOrder || null
            //    ==> (oldInternationalOrder.order = null)
            //    ==> internationalOrder.order = order
            if (oldValue != null) {
                // TODO: null -> NullEntity later
                oldValue.setProperty(inverseProp.name, null);
            }
            if (newValue != null) {
                newValue.setProperty(inverseProp.name, parent);
            }
        }
        else {
            // Example: bidirectional navProperty: 1->n: order -> orderDetails
            // orderDetail.order <- newOrder || null
            //    ==> (oldOrder).orderDetails.remove(orderDetail)
            //    ==> order.orderDetails.push(newOrder)
            if (oldValue != null) {
                let oldSiblings = oldValue.getProperty(inverseProp.name);
                let ix = oldSiblings.indexOf(parent);
                if (ix !== -1) {
                    oldSiblings.splice(ix, 1);
                }
            }
            if (newValue != null) {
                let siblings = newValue.getProperty(inverseProp.name);
                // recursion check if already in the collection is performed by the relationArray
                siblings.push(parent);
            }
        }
    }
    else if (property.invForeignKeyNames && entityManager && !entityManager._inKeyFixup) {
        let invForeignKeyNames = property.invForeignKeyNames;
        if (newValue != null) {
            // Example: unidirectional navProperty: 1->1: order -> internationalOrder
            // order.InternationalOrder <- internationalOrder
            //    ==> internationalOrder.orderId = orderId
            //      and
            // Example: unidirectional navProperty: 1->n: order -> orderDetails
            // orderDetail.order <-xxx newOrder
            //    ==> CAN'T HAPPEN because if unidirectional because orderDetail will not have an order prop
            let pkValues = parent.entityAspect.getKey().values;
            invForeignKeyNames.forEach((fkName, i) => {
                newValue.setProperty(fkName, pkValues[i]);
            });
        }
        else {
            // Example: unidirectional navProperty: 1->1: order -> internationalOrder
            // order.internationalOrder <- null
            //    ==> (old internationalOrder).orderId = null
            //        and
            // Example: unidirectional navProperty: 1->n: order -> orderDetails
            // orderDetail.order <-xxx newOrder
            //    ==> CAN'T HAPPEN because if unidirectional because orderDetail will not have an order prop
            if (oldValue != null) {
                invForeignKeyNames.forEach((fkName) => {
                    let fkProp = oldValue.entityType.getProperty(fkName);
                    if (!fkProp.isPartOfKey) {
                        // don't update with null if fk is part of the key
                        oldValue.setProperty(fkName, null);
                    }
                });
            }
        }
    }
    rawAccessorFn(newValue);
    updateStateAndValidate(context);
    // update fk data property - this can only occur if this navProperty has
    // a corresponding fk on this entity.
    if (property.relatedDataProperties) {
        let entityState = entityAspect.entityState;
        // if either side of nav prop is detached don't clear fks. Note: oldValue in next line cannot be null so no check is needed.
        if (newValue == null && (entityState.isDetached() || oldValue.entityAspect.entityState.isDetached()))
            return;
        if (entityState.isDeleted())
            return;
        let inverseKeyProps = property.entityType.keyProperties;
        inverseKeyProps.forEach(function (keyProp, i) {
            let relatedDataProp = property.relatedDataProperties[i];
            // Do not trash related property if it is part of that entity's key
            if (newValue || !relatedDataProp.isPartOfKey) {
                let relatedValue = newValue ? newValue.getProperty(keyProp.name) : relatedDataProp.defaultValue;
                parent.setProperty(relatedDataProp.name, relatedValue);
            }
        });
    }
}
function postChangeEvents(context) {
    let entityAspect = context.entityAspect;
    let entityManager = entityAspect.entityManager;
    let entity = entityAspect.entity;
    let propChangedArgs = { entity: entity, parent: context.parent, property: context.property, propertyName: context.propertyName, oldValue: context.oldValue, newValue: context.newValue };
    if (entityManager) {
        // propertyChanged will be fired during loading but we only want to fire it once per entity, not once per property.
        // so propertyChanged is fired in the entityManager mergeEntity method if not fired here.
        if ((!entityManager.isLoading) && (!entityManager.isRejectingChanges)) {
            entityAspect.propertyChanged.publish(propChangedArgs);
            // don't fire entityChanged event if propertyChanged is suppressed.
            entityManager.entityChanged.publish({ entityAction: EntityAction.PropertyChange, entity: entity, args: propChangedArgs });
        }
    }
    else {
        entityAspect.propertyChanged.publish(propChangedArgs);
    }
}
function updateStateAndValidate(context) {
    let entityAspect = context.entityAspect;
    let entityManager = entityAspect.entityManager;
    if (entityManager == null || entityManager.isLoading)
        return;
    let property = context.property;
    if (entityAspect.entityState.isUnchanged() && !property.isUnmapped) {
        entityAspect.setModified();
    }
    if (entityManager.validationOptions.validateOnPropertyChange) {
        // entityAspect.entity is NOT the same as parent in the code below. It's use is deliberate.
        entityAspect._validateProperty(context.newValue, { entity: entityAspect.entity, property: property, propertyName: context.propertyName, oldValue: context.oldValue });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVmYXVsdC1wcm9wZXJ0eS1pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2JyZWV6ZS1jbGllbnQvIiwic291cmNlcyI6WyJzcmMvZGVmYXVsdC1wcm9wZXJ0eS1pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBRTlCLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDekMsT0FBTyxFQUFFLFlBQVksRUFBMkMsTUFBTSxpQkFBaUIsQ0FBQztBQUN4RixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRS9DLHdCQUF3QjtBQUN4QixNQUFNLFVBQVUsMEJBQTBCLENBQXlCLFFBQXdCLEVBQUUsUUFBYSxFQUFFLGFBQXVCO0lBQ2pJLCtDQUErQztJQUUvQyxJQUFJLFFBQVEsS0FBSyxTQUFTO1FBQUUsUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDLGtFQUFrRTtJQUMvRyxJQUFJLFFBQVEsR0FBRyxhQUFhLEVBQUUsQ0FBQztJQUUvQixJQUFJLFFBQVEsR0FBSSxRQUFnQixDQUFDLFFBQVEsQ0FBQztJQUMxQyxJQUFJLFFBQVEsSUFBSSxRQUFRLENBQUMsS0FBSyxFQUFFO1FBQzlCLDRGQUE0RjtRQUM1RixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFO1lBQ2pELFFBQVEsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRTtnQkFDbEMsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZDLENBQUMsQ0FBQyxDQUFDO1NBQ0o7YUFBTTtZQUNMLFFBQVEsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVEs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QWlCLENBQUMsd0JBQXdCLEVBQUU7UUFDNUQsMkZBQTJGO1FBQzNGLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUMzQyxFQUFFLE1BQU0sRUFBRSxZQUFZLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLE9BQU8sQ0FBQyxZQUFZLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0tBQzFIO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvcmUgfSBmcm9tICcuL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21wbGV4VHlwZSwgRGF0YVByb3BlcnR5LCBOYXZpZ2F0aW9uUHJvcGVydHksIEVudGl0eVByb3BlcnR5IH0gZnJvbSAnLi9lbnRpdHktbWV0YWRhdGEnO1xyXG5pbXBvcnQgeyBFbnRpdHlLZXkgfSBmcm9tICcuL2VudGl0eS1rZXknO1xyXG5pbXBvcnQgeyBFbnRpdHlBc3BlY3QsIENvbXBsZXhBc3BlY3QsIEVudGl0eSwgU3RydWN0dXJhbE9iamVjdCB9IGZyb20gJy4vZW50aXR5LWFzcGVjdCc7XHJcbmltcG9ydCB7IEVudGl0eVN0YXRlIH0gZnJvbSAnLi9lbnRpdHktc3RhdGUnO1xyXG5pbXBvcnQgeyBFbnRpdHlBY3Rpb24gfSBmcm9tICcuL2VudGl0eS1hY3Rpb24nO1xyXG5cclxuLyoqIEBoaWRkZW4gQGludGVybmFsICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UHJvcGVydHlJbnRlcmNlcHRvcih0aGlzOiBTdHJ1Y3R1cmFsT2JqZWN0LCBwcm9wZXJ0eTogRW50aXR5UHJvcGVydHksIG5ld1ZhbHVlOiBhbnksIHJhd0FjY2Vzc29yRm46IEZ1bmN0aW9uKSB7XHJcbiAgLy8gJ3RoaXMnIGlzIHRoZSBlbnRpdHkgaXRzZWxmIGluIHRoaXMgY29udGV4dC5cclxuXHJcbiAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIG5ld1ZhbHVlID0gbnVsbDsgLy8gcmVtb3ZlPyB0byBhbGxvdyBhc3NpZ25tZW50IHRvIHVuZGVmaW5lZCBpbiBCYWJlbCBjb25zdHJ1Y3RvcnM/XHJcbiAgbGV0IG9sZFZhbHVlID0gcmF3QWNjZXNzb3JGbigpO1xyXG5cclxuICBsZXQgZGF0YVR5cGUgPSAocHJvcGVydHkgYXMgYW55KS5kYXRhVHlwZTtcclxuICBpZiAoZGF0YVR5cGUgJiYgZGF0YVR5cGUucGFyc2UpIHtcclxuICAgIC8vIGF0dGVtcHRzIHRvIGNvZXJjZSBhIHZhbHVlIHRvIHRoZSBjb3JyZWN0IHR5cGUgLSBpZiB0aGlzIGZhaWxzIHJldHVybiB0aGUgdmFsdWUgdW5jaGFuZ2VkXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXdWYWx1ZSkgJiYgIXByb3BlcnR5LmlzU2NhbGFyKSB7XHJcbiAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUubWFwKGZ1bmN0aW9uIChudikge1xyXG4gICAgICAgIHJldHVybiBkYXRhVHlwZS5wYXJzZShudiwgdHlwZW9mIG52KTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuZXdWYWx1ZSA9IGRhdGFUeXBlLnBhcnNlKG5ld1ZhbHVlLCB0eXBlb2YgbmV3VmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gZXhpdCBpZiBubyBjaGFuZ2UgLSBleHRyYSBjcnVmdCBpcyBiZWNhdXNlIGRhdGVUaW1lcyBkb24ndCBjb21wYXJlIGNsZWFubHkuXHJcbiAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSB8fCAoZGF0YVR5cGUgJiYgZGF0YVR5cGUubm9ybWFsaXplICYmIG5ld1ZhbHVlICYmIG9sZFZhbHVlICYmIGRhdGFUeXBlLm5vcm1hbGl6ZShuZXdWYWx1ZSkgPT09IGRhdGFUeXBlLm5vcm1hbGl6ZShvbGRWYWx1ZSkpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBDQU5OT1QgRE8gTkVYVCBMSU5FIGJlY2F1c2UgaXQgaGFzIHRoZSBwb3NzaWJpbGl0eSBvZiBjcmVhdGluZyBhIG5ldyBwcm9wZXJ0eVxyXG4gIC8vICdlbnRpdHlBc3BlY3QnIG9uICd0aGlzJy4gIC0gTm90IHBlcm1pdHRlZCBieSBJRSBpbnNpZGUgb2YgYSBkZWZpbmVkIHByb3BlcnR5IG9uIGEgcHJvdG90eXBlLlxyXG4gIC8vIGxldCBlbnRpdHlBc3BlY3QgPSBuZXcgRW50aXR5QXNwZWN0KHRoaXMpO1xyXG5cclxuICBsZXQgcHJvcGVydHlOYW1lOiBzdHJpbmc7XHJcbiAgbGV0IGVudGl0eUFzcGVjdCA9ICh0aGlzIGFzIGFueSkuZW50aXR5QXNwZWN0IGFzIEVudGl0eUFzcGVjdDtcclxuICBpZiAoZW50aXR5QXNwZWN0KSB7XHJcbiAgICBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eS5uYW1lO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgbG9jYWxBc3BlY3QgPSAodGhpcyBhcyBhbnkpLmNvbXBsZXhBc3BlY3QgYXMgQ29tcGxleEFzcGVjdDtcclxuICAgIGlmIChsb2NhbEFzcGVjdCkge1xyXG4gICAgICBlbnRpdHlBc3BlY3QgPSBsb2NhbEFzcGVjdC5nZXRFbnRpdHlBc3BlY3QoKTtcclxuICAgICAgcHJvcGVydHlOYW1lID0gbG9jYWxBc3BlY3QuZ2V0UHJvcGVydHlQYXRoKHByb3BlcnR5Lm5hbWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZG9lcyBub3QgeWV0IGhhdmUgYW4gRW50aXR5QXNwZWN0IHNvIGp1c3Qgc2V0IHRoZSBwcm9wXHJcbiAgICAgIHJhd0FjY2Vzc29yRm4obmV3VmFsdWUpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBOb3RlIHRoYXQgd2UgbmVlZCB0byBoYW5kbGUgbXVsdGlwbGUgcHJvcGVydGllcyBpbiBwcm9jZXNzLCBub3QganVzdCBvbmUgaW4gb3JkZXIgdG8gYXZvaWQgcmVjdXJzaW9uLlxyXG4gIC8vICggZXhjZXB0IGluIHRoZSBjYXNlIG9mIG51bGwgcHJvcGFnYXRpb24gd2l0aCBma3Mgd2hlcmUgbnVsbCAtPiAwIGluIHNvbWUgY2FzZXMuKVxyXG4gIC8vICh0aGlzIG1heSBub3QgYmUgbmVlZGVkIGJlY2F1c2Ugb2YgdGhlIG5ld1ZhbHVlID09PSBvbGRWYWx1ZSB0ZXN0IGFib3ZlKVxyXG4gIGxldCBpblByb2Nlc3MgPSBlbnRpdHlBc3BlY3QuX2luUHJvY2VzcyA9IGVudGl0eUFzcGVjdC5faW5Qcm9jZXNzIHx8IFtdO1xyXG4gIC8vIGNoZWNrIGZvciByZWN1cnNpb25cclxuICBpZiAoaW5Qcm9jZXNzLmluZGV4T2YocHJvcGVydHkpID49IDApIHJldHVybjtcclxuICBpblByb2Nlc3MucHVzaChwcm9wZXJ0eSk7XHJcblxyXG4gIHRyeSB7XHJcblxyXG4gICAgbGV0IGNvbnRleHQ6IElDb250ZXh0ID0ge1xyXG4gICAgICBwYXJlbnQ6IHRoaXMsXHJcbiAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eSxcclxuICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxyXG4gICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXHJcbiAgICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxyXG4gICAgICBlbnRpdHlBc3BlY3Q6IGVudGl0eUFzcGVjdFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoKHByb3BlcnR5IGFzIGFueSkuaXNDb21wbGV4UHJvcGVydHkpIHtcclxuICAgICAgc2V0RHBWYWx1ZUNvbXBsZXgoY29udGV4dCwgcmF3QWNjZXNzb3JGbik7XHJcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5LmlzRGF0YVByb3BlcnR5KSB7XHJcbiAgICAgIHNldERwVmFsdWVTaW1wbGUoY29udGV4dCwgcmF3QWNjZXNzb3JGbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzZXROcFZhbHVlKGNvbnRleHQsIHJhd0FjY2Vzc29yRm4pO1xyXG4gICAgfVxyXG5cclxuICAgIHBvc3RDaGFuZ2VFdmVudHMoY29udGV4dCk7XHJcblxyXG4gIH0gZmluYWxseSB7XHJcbiAgICBpblByb2Nlc3MucG9wKCk7XHJcbiAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgSUNvbnRleHQge1xyXG4gIHBhcmVudDogU3RydWN0dXJhbE9iamVjdDtcclxuICBwcm9wZXJ0eTogRW50aXR5UHJvcGVydHk7XHJcbiAgcHJvcGVydHlOYW1lOiBzdHJpbmc7XHJcbiAgZW50aXR5QXNwZWN0OiBFbnRpdHlBc3BlY3Q7XHJcbiAgb2xkVmFsdWU6IGFueTtcclxuICBuZXdWYWx1ZTogYW55O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzZXREcFZhbHVlU2ltcGxlKGNvbnRleHQ6IElDb250ZXh0LCByYXdBY2Nlc3NvckZuOiBhbnkpIHtcclxuICBsZXQgcGFyZW50ID0gY29udGV4dC5wYXJlbnQ7XHJcbiAgbGV0IHByb3BlcnR5ID0gY29udGV4dC5wcm9wZXJ0eSBhcyBEYXRhUHJvcGVydHk7XHJcbiAgbGV0IGVudGl0eUFzcGVjdCA9IGNvbnRleHQuZW50aXR5QXNwZWN0O1xyXG4gIGxldCBvbGRWYWx1ZSA9IGNvbnRleHQub2xkVmFsdWU7XHJcbiAgbGV0IG5ld1ZhbHVlID0gY29udGV4dC5uZXdWYWx1ZTtcclxuXHJcbiAgbGV0IGVudGl0eU1hbmFnZXIgPSBlbnRpdHlBc3BlY3QuZW50aXR5TWFuYWdlcjtcclxuXHJcbiAgaWYgKCFwcm9wZXJ0eS5pc1NjYWxhcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uc2NhbGFyIGRhdGEgcHJvcGVydGllcyBhcmUgcmVhZG9ubHkgLSBpdGVtcyBtYXkgYmUgYWRkZWQgb3IgcmVtb3ZlZCBidXQgdGhlIGNvbGxlY3Rpb24gbWF5IG5vdCBiZSBjaGFuZ2VkLlwiKTtcclxuICB9XHJcblxyXG4gIC8vIHN0b3JlIGFuIG9yaWdpbmFsIHZhbHVlIGZvciB0aGlzIHByb3BlcnR5IGlmIG5vdCBhbHJlYWR5IHNldFxyXG4gIGlmIChlbnRpdHlBc3BlY3QuZW50aXR5U3RhdGUuaXNVbmNoYW5nZWRPck1vZGlmaWVkKCkpIHtcclxuICAgIGxldCBwcm9wTmFtZSA9IHByb3BlcnR5Lm5hbWU7XHJcbiAgICAvLyBsb2NhbEFzcGVjdCBpcyBub3QgdGhlIHNhbWUgYXMgZW50aXR5QXNwZWN0IGZvciBjb21wbGV4IHByb3BzXHJcbiAgICBsZXQgbG9jYWxBc3BlY3QgPSBFbnRpdHlBc3BlY3QuaXNFbnRpdHkocGFyZW50KSA/IHBhcmVudC5lbnRpdHlBc3BlY3QgOiBwYXJlbnQuY29tcGxleEFzcGVjdDtcclxuICAgIGlmIChsb2NhbEFzcGVjdC5vcmlnaW5hbFZhbHVlc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBvdGhlcndpc2UgdGhpcyBlbnRyeSB3aWxsIGJlIHNraXBwZWQgZHVyaW5nIHNlcmlhbGl6YXRpb25cclxuICAgICAgbG9jYWxBc3BlY3Qub3JpZ2luYWxWYWx1ZXNbcHJvcE5hbWVdID0gb2xkVmFsdWUgIT09IHVuZGVmaW5lZCA/IG9sZFZhbHVlIDogcHJvcGVydHkuZGVmYXVsdFZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gaWYgd2UgYXJlIGNoYW5naW5nIHRoZSBrZXkgdXBkYXRlIG91ciBpbnRlcm5hbCBlbnRpdHlHcm91cCBpbmRleGVzLlxyXG4gIGlmIChwcm9wZXJ0eS5pc1BhcnRPZktleSAmJiBlbnRpdHlNYW5hZ2VyICYmICFlbnRpdHlNYW5hZ2VyLmlzTG9hZGluZykge1xyXG4gICAgLy8gJ2VudGl0eVR5cGUnIG9uIHRoZSBuZXh0IGxpbmUgYmUgbnVsbCBmb3IgY29tcGxleCBwcm9wZXJ0aWVzIGJ1dCBpdCB3aWxsIG9ubHkgYmUgcmVmJ2Qgd2l0aGluIHRoaXNcclxuICAgIC8vIGZuIHdoZW4gdGhlIHByb3BlcnR5IGlzIHBhcnQgb2YgdGhlIGtleVxyXG4gICAgbGV0IGVudGl0eVR5cGUgPSAocGFyZW50IGFzIEVudGl0eSkuZW50aXR5VHlwZTtcclxuICAgIGxldCBrZXlQcm9wcyA9IGVudGl0eVR5cGUua2V5UHJvcGVydGllcztcclxuICAgIGxldCB2YWx1ZXMgPSBrZXlQcm9wcy5tYXAoZnVuY3Rpb24gKHApIHtcclxuICAgICAgaWYgKHAgPT09IHByb3BlcnR5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBwYXJlbnQuZ2V0UHJvcGVydHkocC5uYW1lKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBsZXQgbmV3S2V5ID0gbmV3IEVudGl0eUtleShlbnRpdHlUeXBlLCB2YWx1ZXMpO1xyXG4gICAgaWYgKGVudGl0eU1hbmFnZXIuZmluZEVudGl0eUJ5S2V5KG5ld0tleSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gZW50aXR5IHdpdGggdGhpcyBrZXkgaXMgYWxyZWFkeSBpbiB0aGUgY2FjaGU6IFwiICsgbmV3S2V5LnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IG9sZEtleSA9IChwYXJlbnQgYXMgRW50aXR5KS5lbnRpdHlBc3BlY3QuZ2V0S2V5KCk7XHJcbiAgICBsZXQgZWcgPSBlbnRpdHlNYW5hZ2VyLl9maW5kRW50aXR5R3JvdXAoZW50aXR5VHlwZSk7XHJcbiAgICBlZy5fcmVwbGFjZUtleShvbGRLZXksIG5ld0tleSk7XHJcbiAgfVxyXG5cclxuICAvLyBwcm9jZXNzIHJlbGF0ZWQgdXBkYXRlcyAoIHRoZSBpbnZlcnNlIHJlbGF0aW9uc2hpcCkgZmlyc3Qgc28gdGhhdCBjb2xsZWN0aW9uIGR1cHMgY2hlY2sgd29ya3MgcHJvcGVybHkuXHJcbiAgLy8gdXBkYXRlIGludmVyc2UgcmVsYXRpb25zaGlwXHJcblxyXG4gIGxldCByZWxhdGVkTmF2UHJvcCA9IHByb3BlcnR5LnJlbGF0ZWROYXZpZ2F0aW9uUHJvcGVydHk7XHJcbiAgaWYgKHJlbGF0ZWROYXZQcm9wICYmIGVudGl0eU1hbmFnZXIpIHtcclxuICAgIC8vIEV4YW1wbGU6IGJpZGlyZWN0aW9uYWwgZmtEYXRhUHJvcGVydHk6IDEtPm46IG9yZGVyIC0+IG9yZGVyRGV0YWlsc1xyXG4gICAgLy8gb3JkZXJEZXRhaWwub3JkZXJJZCA8LSBuZXdPcmRlcklkIHx8IG51bGxcclxuICAgIC8vICAgID09PiBvcmRlckRldGFpbC5vcmRlciA9IGxvb2t1cE9yZGVyKG5ld09yZGVySWQpXHJcbiAgICAvLyAgICA9PT4gKHNlZSBzZXQgbmF2UHJvcCBhYm92ZSlcclxuICAgIC8vICAgICAgIGFuZFxyXG4gICAgLy8gRXhhbXBsZTogYmlkaXJlY3Rpb25hbCBma0RhdGFQcm9wZXJ0eTogMS0+MTogb3JkZXIgLT4gaW50ZXJuYXRpb25hbE9yZGVyXHJcbiAgICAvLyBpbnRlcm5hdGlvbmFsT3JkZXIub3JkZXJJZCA8LSBuZXdPcmRlcklkIHx8IG51bGxcclxuICAgIC8vICAgID09PiBpbnRlcm5hdGlvbmFsT3JkZXIub3JkZXIgPSBsb29rdXBPcmRlcihuZXdPcmRlcklkKVxyXG4gICAgLy8gICAgPT0+IChzZWUgc2V0IG5hdlByb3AgYWJvdmUpXHJcblxyXG4gICAgaWYgKG5ld1ZhbHVlICE9IG51bGwpIHtcclxuICAgICAgbGV0IGtleSA9IG5ldyBFbnRpdHlLZXkocmVsYXRlZE5hdlByb3AuZW50aXR5VHlwZSwgW25ld1ZhbHVlXSk7XHJcbiAgICAgIGxldCByZWxhdGVkRW50aXR5ID0gZW50aXR5TWFuYWdlci5maW5kRW50aXR5QnlLZXkoa2V5KTtcclxuXHJcbiAgICAgIGlmIChyZWxhdGVkRW50aXR5KSB7XHJcbiAgICAgICAgcGFyZW50LnNldFByb3BlcnR5KHJlbGF0ZWROYXZQcm9wLm5hbWUsIHJlbGF0ZWRFbnRpdHkpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGl0IG1heSBub3QgaGF2ZSBiZWVuIGZldGNoZWQgeWV0IGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBhZGQgaXQgYXMgYW4gdW5hdHRhY2hlZENoaWxkLlxyXG4gICAgICAgIGVudGl0eU1hbmFnZXIuX3VuYXR0YWNoZWRDaGlsZHJlbk1hcC5hZGRDaGlsZChrZXksIHJlbGF0ZWROYXZQcm9wLCBwYXJlbnQgYXMgRW50aXR5KTtcclxuICAgICAgICBwYXJlbnQuc2V0UHJvcGVydHkocmVsYXRlZE5hdlByb3AubmFtZSwgbnVsbCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhcmVudC5zZXRQcm9wZXJ0eShyZWxhdGVkTmF2UHJvcC5uYW1lLCBudWxsKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHByb3BlcnR5LmludmVyc2VOYXZpZ2F0aW9uUHJvcGVydHkgJiYgZW50aXR5TWFuYWdlciAmJiAhZW50aXR5TWFuYWdlci5faW5LZXlGaXh1cCkge1xyXG4gICAgLy8gRXhhbXBsZTogdW5pZGlyZWN0aW9uYWwgZmtEYXRhUHJvcGVydHk6IDEtPm46IHJlZ2lvbiAtPiB0ZXJyaXRvcmllc1xyXG4gICAgLy8gdGVycml0b3J5LnJlZ2lvbklkIDwtIG5ld1JlZ2lvbklkXHJcbiAgICAvLyAgICA9PT4gbG9va3VwUmVnaW9uKG5ld1JlZ2lvbklkKS50ZXJyaXRvcmllcy5wdXNoKHRlcnJpdG9yeSlcclxuICAgIC8vICAgICAgICAgICAgICAgIGFuZFxyXG4gICAgLy8gRXhhbXBsZTogdW5pZGlyZWN0aW9uYWwgZmtEYXRhUHJvcGVydHk6IDEtPjE6IG9yZGVyIC0+IGludGVybmF0aW9uYWxPcmRlclxyXG4gICAgLy8gaW50ZXJuYXRpb25hbE9yZGVyLm9yZGVySWQgPC0gbmV3T3JkZXJJZFxyXG4gICAgLy8gICAgPT0+IGxvb2t1cE9yZGVyKG5ld09yZGVySWQpLmludGVybmF0aW9uYWxPcmRlciA9IGludGVybmF0aW9uYWxPcmRlclxyXG4gICAgLy8gICAgICAgICAgICAgICAgYW5kXHJcbiAgICAvLyBFeGFtcGxlOiB1bmlkaXJlY3Rpb25hbCBma0RhdGFQcm9wZXJ0eTogMS0+bjogcmVnaW9uIC0+IHRlcnJpdG9yaWVzXHJcbiAgICAvLyB0ZXJyaXRvcnkucmVnaW9uSWQgPC0gbnVsbFxyXG4gICAgLy8gICAgPT0+IGxvb2t1cFJlZ2lvbih0ZXJyaXRvcnkub2xkUmVnaW9uSWQpLnRlcnJpdG9yaWVzLnJlbW92ZShvbGRUZXJyaXRvcnkpO1xyXG4gICAgLy8gICAgICAgICAgICAgICAgYW5kXHJcbiAgICAvLyBFeGFtcGxlOiB1bmlkaXJlY3Rpb25hbCBma0RhdGFQcm9wZXJ0eTogMS0+MTogb3JkZXIgLT4gaW50ZXJuYXRpb25hbE9yZGVyXHJcbiAgICAvLyBpbnRlcm5hdGlvbmFsT3JkZXIub3JkZXJJZCA8LSBudWxsXHJcbiAgICAvLyAgICA9PT4gbG9va3VwT3JkZXIoaW50ZXJuYXRpb25hbE9yZGVyLm9sZE9yZGVySWQpLmludGVybmF0aW9uYWxPcmRlciA9IG51bGw7XHJcblxyXG4gICAgbGV0IGludk5hdlByb3AgPSBwcm9wZXJ0eS5pbnZlcnNlTmF2aWdhdGlvblByb3BlcnR5O1xyXG5cclxuICAgIGlmIChvbGRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIGxldCBrZXkgPSBuZXcgRW50aXR5S2V5KGludk5hdlByb3AucGFyZW50VHlwZSwgW29sZFZhbHVlXSk7XHJcbiAgICAgIGxldCByZWxhdGVkRW50aXR5ID0gZW50aXR5TWFuYWdlci5maW5kRW50aXR5QnlLZXkoa2V5KTtcclxuICAgICAgaWYgKHJlbGF0ZWRFbnRpdHkpIHtcclxuICAgICAgICBpZiAoaW52TmF2UHJvcC5pc1NjYWxhcikge1xyXG4gICAgICAgICAgcmVsYXRlZEVudGl0eS5zZXRQcm9wZXJ0eShpbnZOYXZQcm9wLm5hbWUsIG51bGwpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyByZW1vdmUgJ3RoaXMnIGZyb20gb2xkIHJlbGF0ZWQgbmF2IHByb3BcclxuICAgICAgICAgIGxldCByZWxhdGVkQXJyYXkgPSByZWxhdGVkRW50aXR5LmdldFByb3BlcnR5KGludk5hdlByb3AubmFtZSk7XHJcbiAgICAgICAgICAvLyBhcnIuc3BsaWNlKGFyci5pbmRleE9mKHZhbHVlX3RvX3JlbW92ZSksIDEpO1xyXG4gICAgICAgICAgcmVsYXRlZEFycmF5LnNwbGljZShyZWxhdGVkQXJyYXkuaW5kZXhPZihwYXJlbnQpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAobmV3VmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICBsZXQga2V5ID0gbmV3IEVudGl0eUtleShpbnZOYXZQcm9wLnBhcmVudFR5cGUsIFtuZXdWYWx1ZV0pO1xyXG4gICAgICBsZXQgcmVsYXRlZEVudGl0eSA9IGVudGl0eU1hbmFnZXIuZmluZEVudGl0eUJ5S2V5KGtleSk7XHJcblxyXG4gICAgICBpZiAocmVsYXRlZEVudGl0eSkge1xyXG4gICAgICAgIGlmIChpbnZOYXZQcm9wLmlzU2NhbGFyKSB7XHJcbiAgICAgICAgICByZWxhdGVkRW50aXR5LnNldFByb3BlcnR5KGludk5hdlByb3AubmFtZSwgcGFyZW50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVsYXRlZEVudGl0eS5nZXRQcm9wZXJ0eShpbnZOYXZQcm9wLm5hbWUpLnB1c2gocGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gaXQgbWF5IG5vdCBoYXZlIGJlZW4gZmV0Y2hlZCB5ZXQgaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGFkZCBpdCBhcyBhbiB1bmF0dGFjaGVkQ2hpbGQuXHJcbiAgICAgICAgZW50aXR5TWFuYWdlci5fdW5hdHRhY2hlZENoaWxkcmVuTWFwLmFkZENoaWxkKGtleSwgaW52TmF2UHJvcCwgcGFyZW50IGFzIEVudGl0eSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICByYXdBY2Nlc3NvckZuKG5ld1ZhbHVlKTtcclxuXHJcbiAgdXBkYXRlU3RhdGVBbmRWYWxpZGF0ZShjb250ZXh0KTtcclxuXHJcbiAgLy8gaWYgKHByb3BlcnR5LmlzUGFydE9mS2V5ICYmICghdGhpcy5jb21wbGV4QXNwZWN0KSkge1xyXG4gIGlmIChwcm9wZXJ0eS5pc1BhcnRPZktleSkge1xyXG4gICAgLy8gcHJvcG9nYXRlIHBrIGNoYW5nZSB0byBhbGwgcmVsYXRlZCBlbnRpdGllcztcclxuICAgIGxldCBlbnRpdHlUeXBlID0gKHBhcmVudCBhcyBFbnRpdHkpLmVudGl0eVR5cGU7XHJcbiAgICBsZXQgcHJvcGVydHlJeCA9IGVudGl0eVR5cGUua2V5UHJvcGVydGllcy5pbmRleE9mKHByb3BlcnR5KTtcclxuICAgIC8vIHRoaXMgcGFydCBoYW5kbGVzIG9yZGVyLm9yZGVySWQgPT4gb3JkZXJEZXRhaWwub3JkZXJJZFxyXG4gICAgLy8gYnV0IHdvbid0IGhhbmRsZSBwcm9kdWN0LnByb2R1Y3RJZCA9PiBvcmRlckRldGFpbC5wcm9kdWN0SWQgYmVjYXVzZSBwcm9kdWN0XHJcbiAgICAvLyBkb2Vzbid0IGhhdmUgYW4gb3JkZXJEZXRhaWxzIHByb3BlcnR5LlxyXG4gICAgZW50aXR5VHlwZS5uYXZpZ2F0aW9uUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChucCkge1xyXG4gICAgICBsZXQgaW52ZXJzZU5wID0gbnAuaW52ZXJzZTtcclxuICAgICAgbGV0IGZrTmFtZXMgPSBpbnZlcnNlTnAgPyBpbnZlcnNlTnAuZm9yZWlnbktleU5hbWVzIDogbnAuaW52Rm9yZWlnbktleU5hbWVzO1xyXG5cclxuICAgICAgaWYgKGZrTmFtZXMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcbiAgICAgIGxldCBucFZhbHVlID0gcGFyZW50LmdldFByb3BlcnR5KG5wLm5hbWUpO1xyXG4gICAgICBpZiAoIW5wVmFsdWUpIHJldHVybjtcclxuICAgICAgbGV0IGZrTmFtZSA9IGZrTmFtZXNbcHJvcGVydHlJeF07XHJcbiAgICAgIGlmIChucC5pc1NjYWxhcikge1xyXG4gICAgICAgIG5wVmFsdWUuc2V0UHJvcGVydHkoZmtOYW1lLCBuZXdWYWx1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbnBWYWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChpdjogYW55KSB7XHJcbiAgICAgICAgICBpdi5zZXRQcm9wZXJ0eShma05hbWUsIG5ld1ZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyB0aGlzIGhhbmRsZXMgdW5pZGlyZWN0aW9uYWwgcHJvYmxlbXMgbm90IGNvdmVyZWQgYWJvdmUuXHJcbiAgICBpZiAoZW50aXR5TWFuYWdlcikge1xyXG4gICAgICBsZXQgaW52ZXJzZUZvcmVpZ25LZXlQcm9wZXJ0aWVzID0gZW50aXR5VHlwZS5pbnZlcnNlRm9yZWlnbktleVByb3BlcnRpZXM7XHJcbiAgICAgIGxldCBiYXNlRW50aXR5VHlwZSA9IGVudGl0eVR5cGUuYmFzZUVudGl0eVR5cGU7XHJcbiAgICAgIHdoaWxlIChiYXNlRW50aXR5VHlwZSkge1xyXG4gICAgICAgIGludmVyc2VGb3JlaWduS2V5UHJvcGVydGllcyA9IGludmVyc2VGb3JlaWduS2V5UHJvcGVydGllcy5jb25jYXQoYmFzZUVudGl0eVR5cGUuaW52ZXJzZUZvcmVpZ25LZXlQcm9wZXJ0aWVzKTtcclxuICAgICAgICBiYXNlRW50aXR5VHlwZSA9IGJhc2VFbnRpdHlUeXBlLmJhc2VFbnRpdHlUeXBlO1xyXG4gICAgICB9XHJcbiAgICAgIGludmVyc2VGb3JlaWduS2V5UHJvcGVydGllcy5mb3JFYWNoKChpbnZGa1Byb3ApID0+IHtcclxuICAgICAgICBpZiAoaW52RmtQcm9wLnJlbGF0ZWROYXZpZ2F0aW9uUHJvcGVydHkhLmludmVyc2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgLy8gdGhpcyBuZXh0IHN0ZXAgbWF5IGJlIHNsb3cgLSBpdCBpdGVyYXRlcyBvdmVyIGFsbCBvZiB0aGUgZW50aXRpZXMgaW4gYSBncm91cDtcclxuICAgICAgICAgIC8vIGhvcGVmdWxseSBpdCBkb2Vzbid0IGhhcHBlbiBvZnRlbi5cclxuICAgICAgICAgIGVudGl0eU1hbmFnZXIhLl91cGRhdGVGa1ZhbChpbnZGa1Byb3AsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbnN1cmUgdGhhdCBjYWNoZWQga2V5IGlzIHVwZGF0ZWQuXHJcbiAgICBlbnRpdHlBc3BlY3QuZ2V0S2V5KHRydWUpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2V0RHBWYWx1ZUNvbXBsZXgoY29udGV4dDogSUNvbnRleHQsIHJhd0FjY2Vzc29yRm46IEZ1bmN0aW9uKSB7XHJcbiAgbGV0IHByb3BlcnR5ID0gY29udGV4dC5wcm9wZXJ0eSBhcyBEYXRhUHJvcGVydHk7XHJcbiAgbGV0IG9sZFZhbHVlID0gY29udGV4dC5vbGRWYWx1ZTtcclxuICBsZXQgbmV3VmFsdWUgPSBjb250ZXh0Lm5ld1ZhbHVlO1xyXG5cclxuICAvLyBUbyBnZXQgaGVyZSBpdCBtdXN0IGJlIGEgQ29tcGxleFByb3BlcnR5XHJcbiAgLy8gJ2RhdGFUeXBlJyB3aWxsIGJlIGEgY29tcGxleFR5cGVcclxuICBsZXQgZGF0YVR5cGUgPSBwcm9wZXJ0eS5kYXRhVHlwZSBhcyBDb21wbGV4VHlwZTtcclxuICBpZiAocHJvcGVydHkuaXNTY2FsYXIpIHtcclxuICAgIGlmICghbmV3VmFsdWUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGNvcmUuZm9ybWF0U3RyaW5nKFwiWW91IGNhbm5vdCBzZXQgdGhlICclMScgcHJvcGVydHkgdG8gbnVsbCBiZWNhdXNlIGl0J3MgZGF0YXR5cGUgaXMgdGhlIENvbXBsZXhUeXBlOiAnJTInXCIsIHByb3BlcnR5Lm5hbWUsIHByb3BlcnR5LmRhdGFUeXBlLm5hbWUpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW9sZFZhbHVlKSB7XHJcbiAgICAgIGxldCBjdG9yID0gZGF0YVR5cGUuZ2V0Q3RvcigpO1xyXG4gICAgICBvbGRWYWx1ZSA9IG5ldyBjdG9yKCk7XHJcbiAgICAgIHJhd0FjY2Vzc29yRm4ob2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZGF0YVR5cGUuZGF0YVByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoZHApIHtcclxuICAgICAgbGV0IHBuID0gZHAubmFtZTtcclxuICAgICAgbGV0IG52ID0gbmV3VmFsdWUuZ2V0UHJvcGVydHkocG4pO1xyXG4gICAgICBvbGRWYWx1ZS5zZXRQcm9wZXJ0eShwbiwgbnYpO1xyXG4gICAgfSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihjb3JlLmZvcm1hdFN0cmluZyhcIllvdSBjYW5ub3Qgc2V0IHRoZSBub24tc2NhbGFyIGNvbXBsZXggcHJvcGVydHk6ICclMScgb24gdGhlIHR5cGU6ICclMicuXCIgK1xyXG4gICAgICAgICAgICBcIkluc3RlYWQgZ2V0IHRoZSBwcm9wZXJ0eSBhbmQgdXNlIGFycmF5IGZ1bmN0aW9ucyBsaWtlICdwdXNoJyBvciAnc3BsaWNlJyB0byBjaGFuZ2UgaXRzIGNvbnRlbnRzLlwiLFxyXG4gICAgICAgIHByb3BlcnR5Lm5hbWUsIHByb3BlcnR5LnBhcmVudFR5cGUubmFtZSkpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHNldE5wVmFsdWUoY29udGV4dDogSUNvbnRleHQsIHJhd0FjY2Vzc29yRm46IEZ1bmN0aW9uKSB7XHJcblxyXG4gIGxldCBwYXJlbnQgPSBjb250ZXh0LnBhcmVudCBhcyBFbnRpdHk7XHJcbiAgbGV0IHByb3BlcnR5ID0gY29udGV4dC5wcm9wZXJ0eSBhcyBOYXZpZ2F0aW9uUHJvcGVydHk7XHJcbiAgbGV0IGVudGl0eUFzcGVjdCA9IGNvbnRleHQuZW50aXR5QXNwZWN0O1xyXG4gIGxldCBvbGRWYWx1ZSA9IGNvbnRleHQub2xkVmFsdWU7XHJcbiAgbGV0IG5ld1ZhbHVlID0gY29udGV4dC5uZXdWYWx1ZTtcclxuXHJcbiAgaWYgKCFwcm9wZXJ0eS5pc1NjYWxhcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uc2NhbGFyIG5hdmlnYXRpb24gcHJvcGVydGllcyBhcmUgcmVhZG9ubHkgLSBlbnRpdGllcyBjYW4gYmUgYWRkZWQgb3IgcmVtb3ZlZCBidXQgdGhlIGNvbGxlY3Rpb24gbWF5IG5vdCBiZSBjaGFuZ2VkLlwiKTtcclxuICB9XHJcblxyXG4gIGxldCBlbnRpdHlNYW5hZ2VyID0gZW50aXR5QXNwZWN0LmVudGl0eU1hbmFnZXI7XHJcbiAgbGV0IGludmVyc2VQcm9wID0gcHJvcGVydHkuaW52ZXJzZTtcclxuXHJcbiAgLy8gbWFuYWdlIGF0dGFjaG1lbnQgLVxyXG4gIGlmIChuZXdWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICBsZXQgbmV3QXNwZWN0ID0gbmV3VmFsdWUuZW50aXR5QXNwZWN0O1xyXG4gICAgaWYgKGVudGl0eU1hbmFnZXIpIHtcclxuICAgICAgaWYgKG5ld0FzcGVjdC5lbnRpdHlTdGF0ZS5pc0RldGFjaGVkKCkpIHtcclxuICAgICAgICBpZiAoIWVudGl0eU1hbmFnZXIuaXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICBlbnRpdHlNYW5hZ2VyLmF0dGFjaEVudGl0eShuZXdWYWx1ZSwgRW50aXR5U3RhdGUuQWRkZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAobmV3QXNwZWN0LmVudGl0eU1hbmFnZXIgIT09IGVudGl0eU1hbmFnZXIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIEVudGl0eSBjYW5ub3QgYmUgYXR0YWNoZWQgdG8gYW4gZW50aXR5IGluIGFub3RoZXIgRW50aXR5TWFuYWdlci4gT25lIG9mIHRoZSB0d28gZW50aXRpZXMgbXVzdCBiZSBkZXRhY2hlZCBmaXJzdC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAobmV3QXNwZWN0ICYmIG5ld0FzcGVjdC5lbnRpdHlNYW5hZ2VyKSB7XHJcbiAgICAgICAgZW50aXR5TWFuYWdlciA9IG5ld0FzcGVjdC5lbnRpdHlNYW5hZ2VyO1xyXG4gICAgICAgIGlmICghZW50aXR5TWFuYWdlciEuaXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICBlbnRpdHlNYW5hZ2VyIS5hdHRhY2hFbnRpdHkoZW50aXR5QXNwZWN0LmVudGl0eSEsIEVudGl0eVN0YXRlLkFkZGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHByb2Nlc3MgcmVsYXRlZCB1cGRhdGVzICggdGhlIGludmVyc2UgcmVsYXRpb25zaGlwKSBmaXJzdCBzbyB0aGF0IGNvbGxlY3Rpb24gZHVwcyBjaGVjayB3b3JrcyBwcm9wZXJseS5cclxuICAvLyB1cGRhdGUgaW52ZXJzZSByZWxhdGlvbnNoaXBcclxuICBpZiAoaW52ZXJzZVByb3ApIHtcclxuICAgIC8vL1xyXG4gICAgaWYgKGludmVyc2VQcm9wLmlzU2NhbGFyKSB7XHJcbiAgICAgIC8vIEV4YW1wbGU6IGJpZGlyZWN0aW9uYWwgbmF2UHJvcGVydHk6IDEtPjE6IG9yZGVyIC0+IGludGVybmF0aW9uYWxPcmRlclxyXG4gICAgICAvLyBvcmRlci5pbnRlcm5hdGlvbmFsT3JkZXIgPC0gaW50ZXJuYXRpb25hbE9yZGVyIHx8IG51bGxcclxuICAgICAgLy8gICAgPT0+IChvbGRJbnRlcm5hdGlvbmFsT3JkZXIub3JkZXIgPSBudWxsKVxyXG4gICAgICAvLyAgICA9PT4gaW50ZXJuYXRpb25hbE9yZGVyLm9yZGVyID0gb3JkZXJcclxuICAgICAgaWYgKG9sZFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAvLyBUT0RPOiBudWxsIC0+IE51bGxFbnRpdHkgbGF0ZXJcclxuICAgICAgICBvbGRWYWx1ZS5zZXRQcm9wZXJ0eShpbnZlcnNlUHJvcC5uYW1lLCBudWxsKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmV3VmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIG5ld1ZhbHVlLnNldFByb3BlcnR5KGludmVyc2VQcm9wLm5hbWUsIHBhcmVudCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEV4YW1wbGU6IGJpZGlyZWN0aW9uYWwgbmF2UHJvcGVydHk6IDEtPm46IG9yZGVyIC0+IG9yZGVyRGV0YWlsc1xyXG4gICAgICAvLyBvcmRlckRldGFpbC5vcmRlciA8LSBuZXdPcmRlciB8fCBudWxsXHJcbiAgICAgIC8vICAgID09PiAob2xkT3JkZXIpLm9yZGVyRGV0YWlscy5yZW1vdmUob3JkZXJEZXRhaWwpXHJcbiAgICAgIC8vICAgID09PiBvcmRlci5vcmRlckRldGFpbHMucHVzaChuZXdPcmRlcilcclxuICAgICAgaWYgKG9sZFZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICBsZXQgb2xkU2libGluZ3MgPSBvbGRWYWx1ZS5nZXRQcm9wZXJ0eShpbnZlcnNlUHJvcC5uYW1lKTtcclxuICAgICAgICBsZXQgaXggPSBvbGRTaWJsaW5ncy5pbmRleE9mKHBhcmVudCk7XHJcbiAgICAgICAgaWYgKGl4ICE9PSAtMSkge1xyXG4gICAgICAgICAgb2xkU2libGluZ3Muc3BsaWNlKGl4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG5ld1ZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICBsZXQgc2libGluZ3MgPSBuZXdWYWx1ZS5nZXRQcm9wZXJ0eShpbnZlcnNlUHJvcC5uYW1lKTtcclxuICAgICAgICAvLyByZWN1cnNpb24gY2hlY2sgaWYgYWxyZWFkeSBpbiB0aGUgY29sbGVjdGlvbiBpcyBwZXJmb3JtZWQgYnkgdGhlIHJlbGF0aW9uQXJyYXlcclxuICAgICAgICBzaWJsaW5ncy5wdXNoKHBhcmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHByb3BlcnR5LmludkZvcmVpZ25LZXlOYW1lcyAmJiBlbnRpdHlNYW5hZ2VyICYmICFlbnRpdHlNYW5hZ2VyLl9pbktleUZpeHVwKSB7XHJcbiAgICBsZXQgaW52Rm9yZWlnbktleU5hbWVzID0gcHJvcGVydHkuaW52Rm9yZWlnbktleU5hbWVzO1xyXG4gICAgaWYgKG5ld1ZhbHVlICE9IG51bGwpIHtcclxuICAgICAgLy8gRXhhbXBsZTogdW5pZGlyZWN0aW9uYWwgbmF2UHJvcGVydHk6IDEtPjE6IG9yZGVyIC0+IGludGVybmF0aW9uYWxPcmRlclxyXG4gICAgICAvLyBvcmRlci5JbnRlcm5hdGlvbmFsT3JkZXIgPC0gaW50ZXJuYXRpb25hbE9yZGVyXHJcbiAgICAgIC8vICAgID09PiBpbnRlcm5hdGlvbmFsT3JkZXIub3JkZXJJZCA9IG9yZGVySWRcclxuICAgICAgLy8gICAgICBhbmRcclxuICAgICAgLy8gRXhhbXBsZTogdW5pZGlyZWN0aW9uYWwgbmF2UHJvcGVydHk6IDEtPm46IG9yZGVyIC0+IG9yZGVyRGV0YWlsc1xyXG4gICAgICAvLyBvcmRlckRldGFpbC5vcmRlciA8LXh4eCBuZXdPcmRlclxyXG4gICAgICAvLyAgICA9PT4gQ0FOJ1QgSEFQUEVOIGJlY2F1c2UgaWYgdW5pZGlyZWN0aW9uYWwgYmVjYXVzZSBvcmRlckRldGFpbCB3aWxsIG5vdCBoYXZlIGFuIG9yZGVyIHByb3BcclxuICAgICAgbGV0IHBrVmFsdWVzID0gcGFyZW50LmVudGl0eUFzcGVjdC5nZXRLZXkoKS52YWx1ZXM7XHJcbiAgICAgIGludkZvcmVpZ25LZXlOYW1lcy5mb3JFYWNoKCAoZmtOYW1lLCBpKSA9PiB7XHJcbiAgICAgICAgbmV3VmFsdWUhLnNldFByb3BlcnR5KGZrTmFtZSwgcGtWYWx1ZXNbaV0pO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEV4YW1wbGU6IHVuaWRpcmVjdGlvbmFsIG5hdlByb3BlcnR5OiAxLT4xOiBvcmRlciAtPiBpbnRlcm5hdGlvbmFsT3JkZXJcclxuICAgICAgLy8gb3JkZXIuaW50ZXJuYXRpb25hbE9yZGVyIDwtIG51bGxcclxuICAgICAgLy8gICAgPT0+IChvbGQgaW50ZXJuYXRpb25hbE9yZGVyKS5vcmRlcklkID0gbnVsbFxyXG4gICAgICAvLyAgICAgICAgYW5kXHJcbiAgICAgIC8vIEV4YW1wbGU6IHVuaWRpcmVjdGlvbmFsIG5hdlByb3BlcnR5OiAxLT5uOiBvcmRlciAtPiBvcmRlckRldGFpbHNcclxuICAgICAgLy8gb3JkZXJEZXRhaWwub3JkZXIgPC14eHggbmV3T3JkZXJcclxuICAgICAgLy8gICAgPT0+IENBTidUIEhBUFBFTiBiZWNhdXNlIGlmIHVuaWRpcmVjdGlvbmFsIGJlY2F1c2Ugb3JkZXJEZXRhaWwgd2lsbCBub3QgaGF2ZSBhbiBvcmRlciBwcm9wXHJcbiAgICAgIGlmIChvbGRWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgaW52Rm9yZWlnbktleU5hbWVzLmZvckVhY2goIChma05hbWUpID0+IHtcclxuICAgICAgICAgIGxldCBma1Byb3AgPSBvbGRWYWx1ZS5lbnRpdHlUeXBlLmdldFByb3BlcnR5KGZrTmFtZSk7XHJcbiAgICAgICAgICBpZiAoIWZrUHJvcC5pc1BhcnRPZktleSkge1xyXG4gICAgICAgICAgICAvLyBkb24ndCB1cGRhdGUgd2l0aCBudWxsIGlmIGZrIGlzIHBhcnQgb2YgdGhlIGtleVxyXG4gICAgICAgICAgICBvbGRWYWx1ZS5zZXRQcm9wZXJ0eShma05hbWUsIG51bGwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByYXdBY2Nlc3NvckZuKG5ld1ZhbHVlKTtcclxuXHJcbiAgdXBkYXRlU3RhdGVBbmRWYWxpZGF0ZShjb250ZXh0KTtcclxuXHJcbiAgLy8gdXBkYXRlIGZrIGRhdGEgcHJvcGVydHkgLSB0aGlzIGNhbiBvbmx5IG9jY3VyIGlmIHRoaXMgbmF2UHJvcGVydHkgaGFzXHJcbiAgLy8gYSBjb3JyZXNwb25kaW5nIGZrIG9uIHRoaXMgZW50aXR5LlxyXG4gIGlmIChwcm9wZXJ0eS5yZWxhdGVkRGF0YVByb3BlcnRpZXMpIHtcclxuICAgIGxldCBlbnRpdHlTdGF0ZSA9IGVudGl0eUFzcGVjdC5lbnRpdHlTdGF0ZTtcclxuICAgIC8vIGlmIGVpdGhlciBzaWRlIG9mIG5hdiBwcm9wIGlzIGRldGFjaGVkIGRvbid0IGNsZWFyIGZrcy4gTm90ZTogb2xkVmFsdWUgaW4gbmV4dCBsaW5lIGNhbm5vdCBiZSBudWxsIHNvIG5vIGNoZWNrIGlzIG5lZWRlZC5cclxuICAgIGlmIChuZXdWYWx1ZSA9PSBudWxsICYmIChlbnRpdHlTdGF0ZS5pc0RldGFjaGVkKCkgfHwgb2xkVmFsdWUuZW50aXR5QXNwZWN0LmVudGl0eVN0YXRlLmlzRGV0YWNoZWQoKSkpIHJldHVybjtcclxuICAgIGlmIChlbnRpdHlTdGF0ZS5pc0RlbGV0ZWQoKSkgcmV0dXJuO1xyXG4gICAgbGV0IGludmVyc2VLZXlQcm9wcyA9IHByb3BlcnR5LmVudGl0eVR5cGUua2V5UHJvcGVydGllcztcclxuICAgIGludmVyc2VLZXlQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXlQcm9wLCBpKSB7XHJcbiAgICAgIGxldCByZWxhdGVkRGF0YVByb3AgPSBwcm9wZXJ0eS5yZWxhdGVkRGF0YVByb3BlcnRpZXNbaV07XHJcbiAgICAgIC8vIERvIG5vdCB0cmFzaCByZWxhdGVkIHByb3BlcnR5IGlmIGl0IGlzIHBhcnQgb2YgdGhhdCBlbnRpdHkncyBrZXlcclxuICAgICAgaWYgKG5ld1ZhbHVlIHx8ICFyZWxhdGVkRGF0YVByb3AuaXNQYXJ0T2ZLZXkpIHtcclxuICAgICAgICBsZXQgcmVsYXRlZFZhbHVlID0gbmV3VmFsdWUgPyBuZXdWYWx1ZS5nZXRQcm9wZXJ0eShrZXlQcm9wLm5hbWUpIDogcmVsYXRlZERhdGFQcm9wLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICBwYXJlbnQuc2V0UHJvcGVydHkocmVsYXRlZERhdGFQcm9wLm5hbWUsIHJlbGF0ZWRWYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcG9zdENoYW5nZUV2ZW50cyhjb250ZXh0OiBJQ29udGV4dCkge1xyXG4gIGxldCBlbnRpdHlBc3BlY3QgPSBjb250ZXh0LmVudGl0eUFzcGVjdDtcclxuXHJcbiAgbGV0IGVudGl0eU1hbmFnZXIgPSBlbnRpdHlBc3BlY3QuZW50aXR5TWFuYWdlcjtcclxuICBsZXQgZW50aXR5ID0gZW50aXR5QXNwZWN0LmVudGl0eTtcclxuXHJcbiAgbGV0IHByb3BDaGFuZ2VkQXJncyA9IHsgZW50aXR5OiBlbnRpdHkhLCBwYXJlbnQ6IGNvbnRleHQucGFyZW50LCBwcm9wZXJ0eTogY29udGV4dC5wcm9wZXJ0eSwgcHJvcGVydHlOYW1lOiBjb250ZXh0LnByb3BlcnR5TmFtZSwgb2xkVmFsdWU6IGNvbnRleHQub2xkVmFsdWUsIG5ld1ZhbHVlOiBjb250ZXh0Lm5ld1ZhbHVlIH07XHJcbiAgaWYgKGVudGl0eU1hbmFnZXIpIHtcclxuICAgIC8vIHByb3BlcnR5Q2hhbmdlZCB3aWxsIGJlIGZpcmVkIGR1cmluZyBsb2FkaW5nIGJ1dCB3ZSBvbmx5IHdhbnQgdG8gZmlyZSBpdCBvbmNlIHBlciBlbnRpdHksIG5vdCBvbmNlIHBlciBwcm9wZXJ0eS5cclxuICAgIC8vIHNvIHByb3BlcnR5Q2hhbmdlZCBpcyBmaXJlZCBpbiB0aGUgZW50aXR5TWFuYWdlciBtZXJnZUVudGl0eSBtZXRob2QgaWYgbm90IGZpcmVkIGhlcmUuXHJcbiAgICBpZiAoKCFlbnRpdHlNYW5hZ2VyLmlzTG9hZGluZykgJiYgKCFlbnRpdHlNYW5hZ2VyLmlzUmVqZWN0aW5nQ2hhbmdlcykpIHtcclxuICAgICAgZW50aXR5QXNwZWN0LnByb3BlcnR5Q2hhbmdlZC5wdWJsaXNoKHByb3BDaGFuZ2VkQXJncyk7XHJcbiAgICAgIC8vIGRvbid0IGZpcmUgZW50aXR5Q2hhbmdlZCBldmVudCBpZiBwcm9wZXJ0eUNoYW5nZWQgaXMgc3VwcHJlc3NlZC5cclxuICAgICAgZW50aXR5TWFuYWdlci5lbnRpdHlDaGFuZ2VkLnB1Ymxpc2goeyBlbnRpdHlBY3Rpb246IEVudGl0eUFjdGlvbi5Qcm9wZXJ0eUNoYW5nZSwgZW50aXR5OiBlbnRpdHksIGFyZ3M6IHByb3BDaGFuZ2VkQXJncyB9KTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgZW50aXR5QXNwZWN0LnByb3BlcnR5Q2hhbmdlZC5wdWJsaXNoKHByb3BDaGFuZ2VkQXJncyk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZUFuZFZhbGlkYXRlKGNvbnRleHQ6IElDb250ZXh0KSB7XHJcbiAgbGV0IGVudGl0eUFzcGVjdCA9IGNvbnRleHQuZW50aXR5QXNwZWN0O1xyXG4gIGxldCBlbnRpdHlNYW5hZ2VyID0gZW50aXR5QXNwZWN0LmVudGl0eU1hbmFnZXI7XHJcbiAgaWYgKGVudGl0eU1hbmFnZXIgPT0gbnVsbCB8fCBlbnRpdHlNYW5hZ2VyLmlzTG9hZGluZykgcmV0dXJuO1xyXG4gIGxldCBwcm9wZXJ0eSA9IGNvbnRleHQucHJvcGVydHk7XHJcblxyXG4gIGlmIChlbnRpdHlBc3BlY3QuZW50aXR5U3RhdGUuaXNVbmNoYW5nZWQoKSAmJiAhcHJvcGVydHkuaXNVbm1hcHBlZCkge1xyXG4gICAgZW50aXR5QXNwZWN0LnNldE1vZGlmaWVkKCk7XHJcbiAgfVxyXG5cclxuICBpZiAoZW50aXR5TWFuYWdlci52YWxpZGF0aW9uT3B0aW9ucy52YWxpZGF0ZU9uUHJvcGVydHlDaGFuZ2UpIHtcclxuICAgIC8vIGVudGl0eUFzcGVjdC5lbnRpdHkgaXMgTk9UIHRoZSBzYW1lIGFzIHBhcmVudCBpbiB0aGUgY29kZSBiZWxvdy4gSXQncyB1c2UgaXMgZGVsaWJlcmF0ZS5cclxuICAgIGVudGl0eUFzcGVjdC5fdmFsaWRhdGVQcm9wZXJ0eShjb250ZXh0Lm5ld1ZhbHVlLFxyXG4gICAgICAgIHsgZW50aXR5OiBlbnRpdHlBc3BlY3QuZW50aXR5LCBwcm9wZXJ0eTogcHJvcGVydHksIHByb3BlcnR5TmFtZTogY29udGV4dC5wcm9wZXJ0eU5hbWUsIG9sZFZhbHVlOiBjb250ZXh0Lm9sZFZhbHVlIH0pO1xyXG4gIH1cclxufVxyXG4iXX0=