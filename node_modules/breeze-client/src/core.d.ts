export interface ErrorCallback {
    (error: Error): void;
}
export interface Callback {
    (data: any): void;
}
declare type Predicate<T> = (i: T) => boolean;
declare function objectForEach(obj: Object, kvFn: (key: string, val: any) => any): void;
declare function objectMap(obj: Object, kvFn?: (key: string, val: any) => any): any[];
declare function objectFirst(obj: Object, kvPredicate: (key: string, val: any) => boolean): {
    key: string;
    value: any;
} | null;
declare function arrayFlatMap<T, U>(arr: T[], mapFn: (arg: T) => U[]): U[];
declare function isSettable(obj: Object, propertyName: string): boolean;
declare function getPropDescriptor(obj: Object, propertyName: string): PropertyDescriptor | undefined;
/** can be used like: persons.filter(propEq("firstName", "John")) */
declare function propEq(propertyName: string, value: any): (obj: Object) => boolean;
/** can be used like: persons.filter(propEq("firstName", "FirstName", "John")) */
declare function propsEq(property1Name: string, property2Name: string, value: any): (obj: Object) => boolean;
/** can be used like persons.map(pluck("firstName")) */
declare function pluck(propertyName: any): (obj: Object) => any;
/** Return an array of property values from source */
declare function getOwnPropertyValues(source: Object): any[];
/** Copy properties from source to target. Returns target. */
declare function extend(target: Object, source: Object, propNames?: string[]): Object;
/** Copy properties from defaults iff undefined on target.  Returns target. */
declare function updateWithDefaults(target: Object, defaults: Object): any;
/** Set ctor.defaultInstance to an instance of ctor with properties from target.
    We want to insure that the object returned by ctor.defaultInstance is always immutable
    Use 'target' as the primary template for the ctor.defaultInstance;
    Use current 'ctor.defaultInstance' as the template for any missing properties
    creates a new instance for ctor.defaultInstance
    returns target unchanged */
declare function setAsDefault(target: Object, ctor: {
    new (...args: any[]): any;
    defaultInstance?: any;
}): any;
/**
    'source' is an object that will be transformed into another
    'template' is a map where the
       keys: are the keys to return
         if a key contains ','s then the key is treated as a delimited string with first of the
         keys being the key to return and the others all valid aliases for this key
       'values' are either
           1) the 'default' value of the key
           2) a function that takes in the source value and should return the value to set
         The value from the source is then set on the target,
         after first passing thru the fn, if provided, UNLESS:
           1) it is the default value
           2) it is undefined ( nulls WILL be set)
    'target' is optional
       - if it exists then properties of the target will be set ( overwritten if the exist)
       - if it does not exist then a new object will be created as filled.
    'target is returned.
*/
declare function toJson(source: Object, template: Object, target?: Object): Object;
/** Replacer function for toJSONSafe, when serializing entities.  Excludes entityAspect and other internal properties. */
declare function toJSONSafeReplacer(prop: string, val: any): any;
/** Safely perform toJSON logic on objects with cycles. */
declare function toJSONSafe(obj: any, replacer?: (prop: string, value: any) => any): any;
/** Resolves the values of a list of properties by checking each property in multiple sources until a value is found. */
declare function resolveProperties(sources: Object[], propertyNames: string[]): any;
declare function toArray(item: any): any[];
/** a version of Array.map that doesn't require an array, i.e. works on arrays and scalars. */
declare function map<T>(items: T | T[], fn: (v: T, ix?: number) => any, includeNull?: boolean): any | any[];
/** Return first element matching predicate */
declare function arrayFirst<T>(array: T[], predicate: Predicate<any>): T;
/** Return index of first element matching predicate */
declare function arrayIndexOf<T>(array: T[], predicate: Predicate<any>): number;
/** Add item if not already in array */
declare function arrayAddItemUnique<T>(array: T[], item: T): void;
/** Remove items from the array
 * @param array
 * @param predicateOrItem - item to remove, or function to determine matching item
 * @param shouldRemoveMultiple - true to keep removing after first match, false otherwise
 */
declare function arrayRemoveItem<T>(array: T[], predicateOrItem: T | Predicate<T>, shouldRemoveMultiple?: boolean): boolean;
/** Combine array elements using the callback.  Returns array with length == min(a1.length, a2.length) */
declare function arrayZip(a1: any[], a2: any[], callback: (x1: any, x2: any) => any): any[];
declare function arrayEquals(a1: any[], a2: any[], equalsFn?: (x1: any, x2: any) => boolean): boolean;
/** Returns an array for a source and a prop, and creates the prop if needed. */
declare function getArray(source: Object, propName: string): any[];
/** Calls requireLibCore on semicolon-separated libNames */
declare function requireLib(libNames: string, errMessage?: string): any;
/** Execute fn while obj has tempValue for property */
declare function using(obj: Object, property: string, tempValue: any, fn: () => any): any;
/** Call state = startFn(), call fn(), call endFn(state) */
declare function wrapExecution(startFn: () => any, endFn: (state: any) => any, fn: () => any): any;
/** Remember & return the value of fn() when it was called with its current args */
declare function memoize(fn: any): any;
declare function getUuid(): string;
declare function durationToSeconds(duration: string): number;
declare function noop(): void;
declare function identity(x: any): any;
declare function isDate(o: any): boolean;
declare function isDateString(s: string): boolean;
declare function isFunction(o: any): boolean;
declare function isGuid(value: any): boolean;
declare function isDuration(value: any): boolean;
declare function isEmpty(obj: any): boolean;
declare function isNumeric(n: any): boolean;
declare function stringStartsWith(str: string, prefix: string): boolean;
declare function stringEndsWith(str: string, suffix: string): boolean;
/** format("a %1 and a %2", "cat", "dog") -> "a cat and a dog" */
declare function formatString(str: string, ...params: any[]): string;
declare function titleCaseSpace(text: string): string;
export declare const core: {
    isES5Supported: boolean;
    hasOwnProperty: (obj: Object, key: string) => boolean;
    getOwnPropertyValues: typeof getOwnPropertyValues;
    getPropertyDescriptor: typeof getPropDescriptor;
    objectForEach: typeof objectForEach;
    objectFirst: typeof objectFirst;
    objectMap: typeof objectMap;
    extend: typeof extend;
    propEq: typeof propEq;
    propsEq: typeof propsEq;
    pluck: typeof pluck;
    map: typeof map;
    resolveProperties: typeof resolveProperties;
    setAsDefault: typeof setAsDefault;
    updateWithDefaults: typeof updateWithDefaults;
    getArray: typeof getArray;
    toArray: typeof toArray;
    arrayEquals: typeof arrayEquals;
    arraySlice: (ar: any[], start?: number, end?: number) => any[];
    arrayFirst: typeof arrayFirst;
    arrayIndexOf: typeof arrayIndexOf;
    arrayRemoveItem: typeof arrayRemoveItem;
    arrayZip: typeof arrayZip;
    arrayAddItemUnique: typeof arrayAddItemUnique;
    arrayFlatMap: typeof arrayFlatMap;
    requireLib: typeof requireLib;
    using: typeof using;
    wrapExecution: typeof wrapExecution;
    memoize: typeof memoize;
    getUuid: typeof getUuid;
    durationToSeconds: typeof durationToSeconds;
    isSettable: typeof isSettable;
    isDate: typeof isDate;
    isDateString: typeof isDateString;
    isGuid: typeof isGuid;
    isDuration: typeof isDuration;
    isFunction: typeof isFunction;
    isEmpty: typeof isEmpty;
    isNumeric: typeof isNumeric;
    identity: typeof identity;
    noop: typeof noop;
    stringStartsWith: typeof stringStartsWith;
    stringEndsWith: typeof stringEndsWith;
    formatString: typeof formatString;
    titleCase: typeof titleCaseSpace;
    toJson: typeof toJson;
    toJSONSafe: typeof toJSONSafe;
    toJSONSafeReplacer: typeof toJSONSafeReplacer;
};
export interface ErrorCallback {
    (error: any): void;
}
export {};
