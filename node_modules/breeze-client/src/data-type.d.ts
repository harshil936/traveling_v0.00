import { BreezeEnum } from './enum';
import { Validator } from './validate';
/**
DataType is an 'Enum' containing all of the supported data types.
@dynamic
**/
export declare class DataType extends BreezeEnum {
    /** The default value of this DataType. __Read Only__ **/
    defaultValue?: any;
    /** Whether this is a 'numeric' DataType. __Read Only__ **/
    isNumeric?: boolean;
    /** Whether this is an 'integer' DataType. __Read Only__ **/
    isInteger?: boolean;
    /** Whether to quote the json value when formatting this DataType for OData. */
    quoteJsonOData?: boolean;
    /** The constructor function to create a [[Validator]] to be used in validating instances of this DataType. */
    validatorCtor?(context?: any): Validator;
    /**
    Optional function to normalize a data value for comparison, if its value cannot be used directly.
    Note that this will be called each time a property is changed, so make it fast.
    @return value appropriate for this DataType
    **/
    normalize?(value: any): any;
    /**
    Optional function to convert a raw (server) value from string to this DataType.
    @return value appropriate for this DataType
    **/
    parseRawValue?(value: any): any;
    /**
    Optional function to convert a value from string to this DataType.  Note that this will be called each time a property is changed, so make it fast.
    @return value appropriate for this DataType
    **/
    parse?(source: any, sourceTypeName: string): any;
    /**
    Optional function to format this DataType for OData queries.
    @return value appropriate for OData query
    **/
    fmtOData?(value: any): any;
    /**
    Optional function to get the next value for key generation, if this datatype is used as a key.  Uses an internal table of previous values.
    @return value appropriate for this DataType
    **/
    getNext?(): any;
    /**
    Optional function to get the next value when the datatype is used as a concurrency property.
    @param previousValue
    @return the next concurrency value, which may be a function of the previousValue.
    **/
    getConcurrencyValue?(previousValue?: any): any;
    static parseDateFromServer: (value: any) => any;
    /** @hidden @internal */
    static constants: {
        stringPrefix: string;
        nextNumber: number;
        nextNumberIncrement: number;
    };
    static String: DataType;
    static Int64: DataType;
    static Int32: DataType;
    static Int16: DataType;
    static Byte: DataType;
    static Decimal: DataType;
    static Double: DataType;
    static Single: DataType;
    static DateTime: DataType;
    static DateTimeOffset: DataType;
    static Time: DataType;
    static Boolean: DataType;
    static Guid: DataType;
    static Binary: DataType;
    static Undefined: DataType;
    static getComparableFn(dataType?: DataType): (value: any) => any;
    /** Returns the DataType for a specified EDM type name.
    **/
    static fromEdmDataType(typeName: string): DataType;
    /** Returns the DataType for a specified input. */
    static fromValue(val: any): DataType;
    static parseTimeFromServer(source: any): any;
    static parseDateAsUTC(source: any): any;
    /** Returns a raw value converted to the specified DataType */
    static parseRawValue(val: any, dataType?: DataType): any;
    /** @hidden @internal */
    static _resetConstants(): void;
}
