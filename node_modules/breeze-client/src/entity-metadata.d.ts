import { ErrorCallback } from './core';
import { BreezeEvent } from './event';
import { DataType } from './data-type';
import { Entity, ComplexObject, StructuralObject } from './entity-aspect';
import { EntityKey } from './entity-key';
import { Validator } from './validate';
import { BreezeEnum } from './enum';
import { DataService } from './data-service';
import { NamingConvention } from './naming-convention';
import { LocalQueryComparisonOptions } from './local-query-comparison-options';
export declare type EntityProperty = DataProperty | NavigationProperty;
export declare type StructuralType = EntityType | ComplexType;
/** @hidden @internal */
export interface IStructuralTypeMap {
    [index: string]: StructuralType;
}
/** @hidden @internal */
export interface IMetadataJson {
    metadataVersion: string;
    name: string;
    namingConvention: string;
    localQueryComparisonOptions: string;
    dataServices: Object[];
    structuralTypes: Object[];
    resourceEntityTypeMap: Object[];
    incompleteTypeMap: Object[];
}
/** Configuration info to be passed to the [[MetadataStore]] constructor */
export interface MetadataStoreConfig {
    /** The  [[NamingConvention]] associated with this MetadataStore. */
    namingConvention?: NamingConvention;
    /** The  [[LocalQueryComparisonOptions]] associated with this MetadataStore. */
    localQueryComparisonOptions?: LocalQueryComparisonOptions;
    serializerFn?: (prop: EntityProperty, val: any) => any;
    name?: string;
}
export interface MetadataFetchedEventArgs {
    metadataStore: MetadataStore;
    dataService: DataService | string;
    rawMetadata: any;
}
/**
An instance of the MetadataStore contains all of the metadata about a collection of [[EntityType]]'s.
MetadataStores may be shared across [[EntityManager]]'s.  If an EntityManager is created without an
explicit MetadataStore, the MetadataStore from the MetadataStore.defaultInstance property will be used.
@dynamic
**/
export declare class MetadataStore {
    /** @hidden @internal */
    _$typeName: string;
    /** @hidden @internal */
    static __id: number;
    /** @hidden @internal */
    static ANONTYPE_PREFIX: string;
    /** The version of any MetadataStores created by this class */
    static metadataVersion: string;
    name: string;
    dataServices: DataService[];
    /** The  [[NamingConvention]] associated with this MetadataStore. __Read Only__ */
    namingConvention: NamingConvention;
    /** The  [[LocalQueryComparisonOptions]] associated with this MetadataStore. __Read Only__ */
    localQueryComparisonOptions: LocalQueryComparisonOptions;
    serializerFn?: (prop: EntityProperty, val: any) => any;
    /**
    An [[BreezeEvent]] that fires after a MetadataStore has completed fetching metadata from a remote service.
    
    @eventArgs -
      - metadataStore - The MetadataStore into which the metadata was fetched.
      - dataService - The [[DataService]] that metadata was fetched from.
      - rawMetadata - {Object} The raw metadata returned from the service. (It will have already been processed by this point).
    >      let ms = myEntityManager.metadataStore;
    >      ms.metadataFetched.subscribe(function(args) {
    >          let metadataStore = args.metadataStore;
    >          let dataService = args.dataService;
    >      });
    @event
    **/
    metadataFetched: BreezeEvent<MetadataFetchedEventArgs>;
    /** @hidden @internal */
    _resourceEntityTypeMap: {};
    /** @hidden @internal */
    _entityTypeResourceMap: {};
    /** @hidden @internal */
    _structuralTypeMap: IStructuralTypeMap;
    /** @hidden @internal **/
    _shortNameMap: {};
    /** @hidden @internal **/
    _ctorRegistry: {};
    /** @hidden @internal **/
    _incompleteTypeMap: {};
    /** @hidden @internal **/
    _incompleteComplexTypeMap: {};
    /** @hidden @internal **/
    _deferredTypes: {};
    /** @hidden @internal **/
    _id: number;
    /**
    Constructs a new MetadataStore.
    
    >     let ms = new MetadataStore();
  
    The store can then be associated with an EntityManager
    >     let entityManager = new EntityManager( {
    >         serviceName: "breeze/NorthwindIBModel",
    >         metadataStore: ms
    >     });
  
    or for an existing EntityManager
    >    // Assume em1 is an existing EntityManager
    >    em1.setProperties( { metadataStore: ms });
    
    @param config - Configuration settings .
      - namingConvention - (default=NamingConvention.defaultInstance) NamingConvention to be used in mapping property names
    between client and server. Uses the NamingConvention.defaultInstance if not specified.
      - localQueryComparisonOptions - (default=LocalQueryComparisonOptions.defaultInstance) The LocalQueryComparisonOptions to be
    used when performing "local queries" in order to match the semantics of queries against a remote service.
      - serializerFn - A function that is used to mediate the serialization of instances of this type.
    **/
    constructor(config?: MetadataStoreConfig);
    static normalizeTypeName: any;
    /**
    General purpose property set method
    
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     em1.metadataStore.setProperties( {
    >         version: "6.1.3",
    >         serializerFn: function(prop, value) {
    >         return (prop.isUnmapped) ? undefined : value;
    >         }
    >     )};
    @param config -  An object containing the selected properties and values to set.
    **/
    setProperties(config: MetadataStoreConfig): void;
    /**
    Adds a DataService to this MetadataStore. If a DataService with the same serviceName is already
    in the MetadataStore an exception will be thrown.
    @param dataService - The [[DataService]] to add
    @param shouldOverwrite - (default=false) Permit overwrite of existing DataService rather than throw exception
    **/
    addDataService(dataService: DataService, shouldOverwrite?: boolean): void;
    /** @hidden @internal */
    _getDataServiceIndex(serviceName: string): number;
    /**
    Adds an EntityType to this MetadataStore.  No additional properties may be added to the EntityType after its has
    been added to the MetadataStore.
    @param structuralType - The EntityType or ComplexType to add
    **/
    addEntityType(stype: StructuralType | EntityTypeConfig | ComplexTypeConfig): void;
    /**
    Exports this MetadataStore to a serialized string appropriate for local storage.   This operation is also called
    internally when exporting an EntityManager.
    >      // assume ms is a previously created MetadataStore
    >      let metadataAsString = ms.exportMetadata();
    >      window.localStorage.setItem("metadata", metadataAsString);
    >      // and later, usually in a different session imported
    >      let metadataFromStorage = window.localStorage.getItem("metadata");
    >      let newMetadataStore = new MetadataStore();
    >      newMetadataStore.importMetadata(metadataFromStorage);
    @return A serialized version of this MetadataStore that may be stored locally and later restored.
    **/
    exportMetadata(): string;
    /**
    Imports a previously exported serialized MetadataStore into this MetadataStore.
      
    >      // assume ms is a previously created MetadataStore
    >      let metadataAsString = ms.exportMetadata();
    >      window.localStorage.setItem("metadata", metadataAsString);
    >      // and later, usually in a different session
    >      let metadataFromStorage = window.localStorage.getItem("metadata");
    >      let newMetadataStore = new MetadataStore();
    >      newMetadataStore.importMetadata(metadataFromStorage);
    @param exportedMetadata - A previously exported MetadataStore.
    @param allowMerge -  Allows custom metadata to be merged into existing metadata types.
    @return This MetadataStore.
    @chainable
    **/
    importMetadata(exportedMetadata: string | Object, allowMerge?: boolean): MetadataStore;
    /**
    Creates a new MetadataStore from a previously exported serialized MetadataStore
    >      // assume ms is a previously created MetadataStore
    >      let metadataAsString = ms.exportMetadata();
    >      window.localStorage.setItem("metadata", metadataAsString);
    >      // and later, usually in a different session
    >      let metadataFromStorage = window.localStorage.getItem("metadata");
    >      let newMetadataStore = MetadataStore.importMetadata(metadataFromStorage);
    @param exportedString - A previously exported MetadataStore.
    @return A new MetadataStore.
    **/
    static importMetadata(exportedString: string): MetadataStore;
    /**
    Returns whether Metadata has been retrieved for a specified service name.
    >      // Assume em1 is an existing EntityManager.
    >      if (!em1.metadataStore.hasMetadataFor("breeze/NorthwindIBModel"))) {
    >          // do something interesting
    >      }
    @param serviceName - The service name.
    @return Whether metadata has already been retrieved for the specified service name.
    **/
    hasMetadataFor(serviceName: string): boolean;
    /**
    Returns the DataService for a specified service name
    >      // Assume em1 is an existing EntityManager.
    >      let ds = em1.metadataStore.getDataService("breeze/NorthwindIBModel");
    >      let adapterName = ds.adapterName; // may be null
    @param serviceName - The service name.
    @return The DataService with the specified name.
    **/
    getDataService(serviceName: string): DataService;
    /**
    Fetches the metadata for a specified 'service'. This method is automatically called
    internally by an EntityManager before its first query against a new service. __Async__
  
    Usually you will not actually process the results of a fetchMetadata call directly, but will instead
    ask for the metadata from the EntityManager after the fetchMetadata call returns.
    >      let ms = new MetadataStore();
    >      // or more commonly
    >      // let ms = anEntityManager.metadataStore;
    >      ms.fetchMetadata("breeze/NorthwindIBModel").then(function(rawMetadata) {
    >            // do something with the metadata
    >      }).catch(function(exception) {
    >          // handle exception here
    >      });
    @param dataService -  Either a DataService or just the name of the DataService to fetch metadata for.
    @param callback - Function called on success.
    @param errorCallback - Function called on failure.
    @return Promise
    **/
    fetchMetadata(dataService: string | DataService, callback?: (schema: any) => void, errorCallback?: ErrorCallback): Promise<any>;
    /**
    Used to register a constructor for an EntityType that is not known via standard Metadata discovery;
    i.e. an unmapped type.
    @param entityCtor - The constructor function for the 'unmapped' type.
    @param interceptor - An interceptor function
    **/
    trackUnmappedType(entityCtor: any, interceptor: any): void;
    /**
    Provides a mechanism to register a 'custom' constructor to be used when creating new instances
    of the specified entity type.  If this call is not made, a default constructor is created for
    the entity as needed.
    This call may be made before or after the corresponding EntityType has been discovered via
    Metadata discovery.
    >      let Customer = function () {
    >              this.miscData = "asdf";
    >          };
    >      Customer.prototype.doFoo() {
    >              ...
    >          }
    >      // assume em1 is a preexisting EntityManager;
    >      em1.metadataStore.registerEntityTypeCtor("Customer", Customer);
    >      // any queries or EntityType.create calls from this point on will call the Customer constructor
    >      // registered above.
    @param structuralTypeName - The name of the EntityType or ComplexType.
    @param aCtor - The constructor for this EntityType or ComplexType; may be null if all you want to do is set the next parameter.
    @param initFn - A function or the name of a function on the entity that is to be executed immediately after the entity has been created
    and populated with any initial values. Called with 'initFn(entity)'
    @param noTrackingFn - A function that is executed immediately after a noTracking entity has been created and whose return
    value will be used in place of the noTracking entity.
    **/
    registerEntityTypeCtor(structuralTypeName: string, aCtor?: any, initFn?: Function | string, noTrackingFn?: Function): void;
    /**
    Returns whether this MetadataStore contains any metadata yet.
    >      // assume em1 is a preexisting EntityManager;
    >      if (em1.metadataStore.isEmpty()) {
    >          // do something interesting
    >      }
    **/
    isEmpty(): boolean;
    /**
    Returns an [[EntityType]] or null given its name.
    >      // assume em1 is a preexisting EntityManager
    >      let odType = em1.metadataStore.getAsEntityType("OrderDetail");
  
    or to throw an error if the type is not found
    >      let badType = em1.metadataStore.getAsEntityType("Foo", false);
    >      // badType will not get set and an exception will be thrown.
    @param structuralTypeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    getAsEntityType(typeName: string, okIfNotFound?: boolean): EntityType;
    /**
    Returns an [[EntityType]] or null given its name.
    >      // assume em1 is a preexisting EntityManager
    >      let locType = em1.metadataStore.getAsComplexType("Location");
  
    or to throw an error if the type is not found
    >      let badType = em1.metadataStore.getAsComplexType("Foo", false);
    >      // badType will not get set and an exception will be thrown.
    @param structuralTypeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    getAsComplexType(typeName: string, okIfNotFound?: boolean): ComplexType;
    /**
    Returns an [[EntityType]] or a [[ComplexType]] given its name.
    @deprecated Replaced by getStructuralType but ... it is probably more usefull to call either getAsEntityType or getAsComplexType instead
    @param typeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    getEntityType(typeName: string, okIfNotFound?: boolean): StructuralType;
    /**
    Returns an [[EntityType]] or a [[ComplexType]] given its name.
    >      // assume em1 is a preexisting EntityManager
    >      let odType = em1.metadataStore.getStructuralType("OrderDetail");
  
    or to throw an error if the type is not found
    >      let badType = em1.metadataStore.getStructuralType("Foo", false);
    >      // badType will not get set and an exception will be thrown.
    @deprecated Preferably use either getAsEntityType or getAsComplexType.  Get
    @param typeName - Either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown.
    @param okIfNotFound - (default=false) Whether to throw an error if the specified EntityType is not found.
    @return The EntityType. ComplexType or 'null' if not not found.
    **/
    getStructuralType(typeName: string, okIfNotFound?: boolean): StructuralType;
    /** @hidden @internal */
    _getStructuralType(typeName: string, okIfNotFound?: boolean): StructuralType;
    /**
    Returns an array containing all of the [[EntityType]]s or [[ComplexType]]s in this MetadataStore.
    >      // assume em1 is a preexisting EntityManager
    >      let allTypes = em1.metadataStore.getEntityTypes();
    **/
    getEntityTypes(): StructuralType[];
    getIncompleteNavigationProperties(): any[];
    /**
    Returns a fully qualified entityTypeName for a specified resource name.  The reverse of this operation
    can be obtained via the  [[EntityType.defaultResourceName]] property
    **/
    getEntityTypeNameForResourceName(resourceName: string): any;
    /**
    Associates a resourceName with an entityType.
  
    This method is only needed in those cases where multiple resources return the same
    entityType.  In this case Metadata discovery will only determine a single resource name for
    each entityType.
    @param resourceName - The resource name
    @param entityTypeOrName - If passing a string either the fully qualified name or a short name may be used. If a short name is specified and multiple types share
    that same short name an exception will be thrown. If the entityType has not yet been discovered then a fully qualified name must be used.
    **/
    setEntityTypeForResourceName(resourceName: string, entityTypeOrName: EntityType | string): void;
    /** __Dev Only__ - for use when creating a new MetadataParserAdapter  */
    static parseTypeName(entityTypeName: string): {
        shortTypeName: string;
        namespace: string;
        typeName: string;
    };
    /** __Dev Only__ - for use when creating a new MetadataParserAdapter  */
    static makeTypeHash(shortName: string, ns?: string): {
        shortTypeName: string;
        namespace: string;
        typeName: string;
    };
    /** @hidden @internal */
    _checkEntityType(entity: Entity): void;
}
/** Configuration info to be passed to the [[EntityType]] constructor */
export interface EntityTypeConfig {
    shortName?: string;
    namespace?: string;
    baseTypeName?: string;
    isAbstract?: boolean;
    autoGeneratedKeyType?: AutoGeneratedKeyType;
    defaultResourceName?: string;
    dataProperties?: DataProperty[] | Object[] | Object;
    navigationProperties?: NavigationProperty[] | Object[] | Object;
    serializerFn?: (prop: EntityProperty, val: any) => any;
    custom?: Object;
}
/** Configuration info to be passed to the [[EntityType.setProperties]] method */
export interface EntityTypeSetConfig {
    autoGeneratedKeyType?: AutoGeneratedKeyType;
    defaultResourceName?: string;
    serializerFn?: (prop: EntityProperty, val: any) => any;
    custom?: Object;
}
/** Container for all of the metadata about a specific type of Entity.
**/
export declare class EntityType {
    /** @hidden @internal */
    _$typeName: string;
    /** @hidden @internal */
    static __nextAnonIx: number;
    /** Always false for an EntityType. **/
    isComplexType: boolean;
    /** The [[MetadataStore]] that contains this EntityType. __Read Only__ **/
    metadataStore: MetadataStore;
    /** The DataProperties (see [[DataProperty]] associated with this EntityType. __Read Only__  **/
    dataProperties: DataProperty[];
    /**  The NavigationProperties (see [[NavigationProperty]] associated with this EntityType. __Read Only__  **/
    navigationProperties: NavigationProperty[];
    /**
    The DataProperties associated with this EntityType that make up it's [[EntityKey]]. __Read Only__ **/
    keyProperties: DataProperty[];
    /** The DataProperties associated with this EntityType that are foreign key properties. __Read Only__ **/
    foreignKeyProperties: DataProperty[];
    inverseForeignKeyProperties: DataProperty[];
    /**  The DataProperties associated with this EntityType that are concurrency properties. __Read Only__ **/
    concurrencyProperties: DataProperty[];
    /** The DataProperties for this EntityType that contain instances of a [[ComplexType]]. __Read Only__   **/
    complexProperties: DataProperty[];
    /** The DataProperties associated with this EntityType that are not mapped to any backend datastore. These are effectively free standing
    properties. __Read Only__ **/
    unmappedProperties: DataProperty[];
    /** The fully qualified name of this EntityType. __Read Only__  **/
    name: string;
    /** The short, unqualified, name for this EntityType. __Read Only__  **/
    shortName: string;
    /** The namespace for this EntityType. __Read Only__  **/
    namespace: string;
    /** The name of this EntityType's base EntityType  (if any) */
    baseTypeName?: string;
    /** The base EntityType (if any) for this EntityType. __Read Only__   **/
    baseEntityType: EntityType;
    subtypes: EntityType[];
    /**  Whether this EntityType is abstract. __Read Only__ **/
    isAbstract: boolean;
    /**  Whether this EntityType is anonymous. Anonymous types will never be communicated to or from the server. They are purely for
    client side use and are given an automatically generated name.  __Read Only__ **/
    isAnonymous: boolean;
    /** Whether this EntityType has been 'frozen'.  EntityTypes become frozen after the first instance
    of that type has been created and attached to an EntityManager. */
    isFrozen: boolean;
    /** The [[AutoGeneratedKeyType]] for this EntityType. __Read Only__ **/
    autoGeneratedKeyType: AutoGeneratedKeyType;
    /**   The default resource name associated with this EntityType.  An EntityType may be queried via a variety of 'resource names' but this one
    is used as the default when no resource name is provided.  This will occur when calling [[EntityAspect.loadNavigationProperty]]
    or when executing any [[EntityQuery]] that was created via an [[EntityKey]]. __Read Only__ **/
    defaultResourceName: string;
    /** A function that is used to customize the serialization of any EntityProperties of this type. */
    serializerFn?: (prop: EntityProperty, val: any) => any;
    /**  A free form object that can be used to define any custom metadata for this EntityType. __Read Only__  **/
    custom?: Object;
    /** The entity level validators associated with this EntityType. Validators can be added and
    removed from this collection. __Read Only__.   **/
    validators: Validator[];
    warnings: any[];
    initFn: Function | string;
    noTrackingFn: Function;
    /** @hidden @internal */
    _extra: any;
    /** @hidden @internal */
    _ctor: {
        new (): StructuralObject;
    };
    /** @hidden @internal */
    _mappedPropertiesCount: number;
    /**
    @deprecated Use [[getCtor]] instead.
    */
    getEntityCtor: (forceRefresh?: boolean) => new () => StructuralObject;
    /** @hidden @internal */
    static qualifyTypeName: typeof qualifyTypeName;
    /** EntityType constructor
    >      let entityType = new EntityType( {
    >          shortName: "person",
    >          namespace: "myAppNamespace"
    >      });
    @param config - Configuration settings or a MetadataStore.  If this parameter is just a MetadataStore
    then what will be created is an 'anonymous' type that will never be communicated to or from the server. It is purely for
    client side use and will be given an automatically generated name. Normally, however, you will use a configuration object.
    **/
    constructor(config: MetadataStore | EntityTypeConfig);
    /**
    General purpose property set method
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      custType.setProperties( {
    >          autoGeneratedKeyType: AutoGeneratedKeyType.Identity;
    >          defaultResourceName: "CustomersAndIncludedOrders"
    >      )};
    @param config - a configuration object
    **/
    setProperties(config: EntityTypeSetConfig): void;
    /**
    Returns whether this type is a subtype of a specified type.
    **/
    isSubtypeOf(entityType: EntityType): boolean;
    /**
    Returns an array containing this type and any/all subtypes of this type down thru the hierarchy.
    **/
    getSelfAndSubtypes(): this[];
    getAllValidators(): Validator[];
    /**
    Adds a  [[DataProperty]] or a [[NavigationProperty]] to this EntityType.
    >      // assume myEntityType is a newly constructed EntityType.
    >      myEntityType.addProperty(dataProperty1);
    >      myEntityType.addProperty(dataProperty2);
    >      myEntityType.addProperty(navigationProperty1);
    **/
    addProperty(property: EntityProperty): void;
    /** @hidden @internal */
    _updateFromBase(baseEntityType: EntityType): void;
    /** @hidden @internal */
    _addPropertyCore(property: EntityProperty, shouldResolve?: boolean): void;
    /**
    Create a new entity of this type.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getAsEntityType("Customer");
    >      let cust1 = custType.createEntity();
    >      em1.addEntity(cust1);
    @param initialValues- Configuration object of the properties to set immediately after creation.
    @return The new entity.
    **/
    createEntity(initialValues?: any): any;
    /** @hidden @internal */
    _createInstanceCore(): StructuralObject;
    /** @hidden @internal */
    _initializeInstance(instance: any): void;
    /**
    Returns the constructor for this EntityType.
    @param forceRefresh - Whether to ignore any cached version of this constructor. (default == false)
    @return The constructor for this EntityType.
    **/
    getCtor(forceRefresh?: boolean): {
        new (): StructuralObject;
    };
    /** @hidden @internal */
    _setCtor(aCtor: {
        new (): StructuralObject;
    }, interceptor?: any): void;
    /**
    Adds either an entity or property level validator to this EntityType.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let countryProp = custType.getProperty("Country");
    >      let valFn = function (v) {
    >              if (v == null) return true;
    >              return (core.stringStartsWith(v, "US"));
    >          };
    >      let countryValidator = new Validator("countryIsUS", valFn,
    >      { displayName: "Country", messageTemplate: "'%displayName%' must start with 'US'" });
    >      custType.addValidator(countryValidator, countryProp);
  
    This is the same as adding an entity level validator via the 'validators' property of DataProperty or NavigationProperty
    >      countryProp.validators.push(countryValidator);
  
    Entity level validators can also be added by omitting the 'property' parameter.
    >      custType.addValidator(someEntityLevelValidator);
  
    or
    >      custType.validators.push(someEntityLevelValidator);
    @param validator - Validator to add.
    @param property - Property to add this validator to.  If omitted, the validator is assumed to be an
    entity level validator and is added to the EntityType's 'validators'.
    **/
    addValidator(validator: Validator, property?: EntityProperty | string): void;
    /**
    Returns all of the properties ( dataProperties and navigationProperties) for this EntityType.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let arrayOfProps = custType.getProperties();
    @return An array of Data and Navigation properties.
    **/
    getProperties(): EntityProperty[];
    /**
    Returns all of the property names ( for both dataProperties and navigationProperties) for this EntityType.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let arrayOfPropNames = custType.getPropertyNames();
    **/
    getPropertyNames(): any[];
    /**
    Returns a data property with the specified name or null.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let customerNameDataProp = custType.getDataProperty("CustomerName");
    @return A DataProperty or null if not found.
    **/
    getDataProperty(propertyName: string): DataProperty;
    /**
    Returns a navigation property with the specified name or null.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let customerOrdersNavProp = custType.getDataProperty("Orders");
    @return A NavigationProperty or null if not found.
    **/
    getNavigationProperty(propertyName: string): NavigationProperty;
    /**
    Returns either a DataProperty or a NavigationProperty with the specified name or null.
    
    This method also accepts a '.' delimited property path and will return the 'property' at the
    end of the path.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let companyNameProp = custType.getProperty("CompanyName");
  
    This method can also walk a property path to return a property
    >      let orderDetailType = em1.metadataStore.getEntityType("OrderDetail");
    >      let companyNameProp2 = orderDetailType.getProperty("Order.Customer.CompanyName");
    >      // companyNameProp === companyNameProp2
    @param [throwIfNotFound=false] {Boolean} Whether to throw an exception if not found.
    @return A DataProperty or NavigationProperty or null if not found.
    **/
    getProperty(propertyPath: string, throwIfNotFound?: boolean): EntityProperty;
    /** @hidden @internal */
    getPropertiesOnPath(propertyPath: string, useServerName: boolean | null, throwIfNotFound?: boolean): EntityProperty[];
    /** For use in pluggable adapters. */
    clientPropertyPathToServer(propertyPath: string, delimiter?: string): string;
    /** For use in pluggable adapters. */
    getEntityKeyFromRawEntity(rawEntity: any, rawValueFn: Function): EntityKey;
    /** @hidden @internal */
    _updateTargetFromRaw(target: StructuralObject, raw: any, rawValueFn: Function): void;
    /**
    Returns a string representation of this EntityType.
    **/
    toString(): string;
    toJSON(): Object;
    /** @hidden @internal */
    _updateNames(property: EntityProperty): void;
    /** @hidden @internal */
    _checkNavProperty(navigationProperty: NavigationProperty | string): NavigationProperty;
    /** @hidden @internal */
    _addDataProperty(dp: DataProperty): void;
    /** @hidden @internal */
    _addNavigationProperty(np: NavigationProperty): void;
    /** @hidden @internal */
    _updateCps(): void;
    /** @hidden @internal */
    _updateNps(): void;
}
export interface ComplexTypeConfig {
    shortName?: string;
    namespace?: string;
    dataProperties?: DataProperty[] | Object[] | Object;
    isComplexType?: boolean;
    custom?: Object;
}
/**  Container for all of the metadata about a specific type of Complex object.
>     let complexType = new ComplexType( {
>         shortName: "address",
>         namespace: "myAppNamespace"
>     });
@param config - Configuration settings
**/
export declare class ComplexType {
    /** @hidden @internal */
    _$typeName: string;
    /** For polymorphic purpose only - always true here */
    isComplexType: boolean;
    /** The [[MetadataStore]] containing this ComplexType. */
    metadataStore: MetadataStore;
    /**  The fully qualifed name of this ComplexType. __Read Only__  **/
    name: string;
    /**  The short, unqualified, name for this ComplexType. __Read Only__ **/
    shortName: string;
    /** The namespace for this ComplexType. __Read Only__ **/
    namespace: string;
    /** The DataProperties (see [[DataProperty]] associated with this ComplexType. __Read Only__ */
    dataProperties: DataProperty[];
    /** The DataProperties for this ComplexType that contain instances of a [[ComplexType]]. __Read Only__ */
    complexProperties: DataProperty[];
    /**
    The entity level validators associated with this ComplexType. Validators can be added and
    removed from this collection. __Read Only__  **/
    validators: Validator[];
    /** For polymorphic purpose only - always empty here */
    concurrencyProperties: DataProperty[];
    /** The DataProperties associated with this ComplexType that are not mapped to any backend datastore. These are effectively free standing
    properties. __Read Only__   **/
    unmappedProperties: DataProperty[];
    navigationProperties: DataProperty[];
    keyProperties: DataProperty[];
    warnings: any[];
    serializerFn?: (prop: EntityProperty, val: any) => any;
    /** A free form object that can be used to define any custom metadata for this ComplexType. ***/
    custom?: any;
    /** @hidden @internal */
    _mappedPropertiesCount: number;
    /** @hidden @internal */
    _extra?: any;
    /** See [[EntityType.getCtor]] */
    getCtor: (forceRefresh?: boolean) => new () => StructuralObject;
    createInstance: (initialValues?: any) => any;
    /** See [EntityType.addValidator] */
    addValidator: (validator: Validator, property?: string | DataProperty | NavigationProperty) => void;
    getProperty: (propertyPath: string, throwIfNotFound?: boolean) => EntityProperty;
    getPropertiesOnPath: (propertyPath: string, useServerName: boolean, throwIfNotFound?: boolean) => EntityProperty[];
    getPropertyNames: () => any[];
    /** @hidden @internal */
    _addPropertyCore: (property: EntityProperty, shouldResolve?: boolean) => void;
    /** @hidden @internal */
    _addDataProperty: (dp: DataProperty) => void;
    /** @hidden @internal */
    _updateNames: (property: EntityProperty) => void;
    /** @hidden @internal */
    _updateCps: () => void;
    /** @hidden @internal */
    _initializeInstance: (instance: any) => void;
    /** @hidden @internal */
    _updateTargetFromRaw: (target: StructuralObject, raw: any, rawValueFn: Function) => void;
    /** @hidden @internal */
    _setCtor: (aCtor: new () => StructuralObject, interceptor?: any) => void;
    constructor(config: ComplexTypeConfig);
    /**
    General purpose property set method
    >      // assume em1 is an EntityManager
    >      let addresstType = em1.metadataStore.getEntityType("Address");
    >      addressType.setProperties( {
    >          custom: { foo: 7, bar: "test" }
    >      });
    @param config - Custom config object
    @param config.custom - {Object}
    **/
    setProperties(config: {
        custom?: Object;
    }): void;
    getAllValidators(): Validator[];
    /** @hidden @internal */
    _createInstanceCore(parent: StructuralObject, parentProperty: DataProperty): ComplexObject;
    addProperty(dataProperty: DataProperty): void;
    getProperties(): EntityProperty[];
    toJSON(): Object;
}
export interface DataPropertyConfig {
    name?: string;
    nameOnServer?: string;
    dataType?: DataType | string | ComplexType;
    complexTypeName?: string;
    isNullable?: boolean;
    isScalar?: boolean;
    defaultValue?: any;
    isPartOfKey?: boolean;
    isUnmapped?: boolean;
    isSettable?: boolean;
    concurrencyMode?: string;
    maxLength?: number;
    validators?: Validator[];
    displayName?: string;
    enumType?: any;
    rawTypeName?: string;
    custom?: Object;
}
/**
A DataProperty describes the metadata for a single property of an  [[EntityType]] that contains simple data.

Instances of the DataProperty class are constructed automatically during Metadata retrieval. However it is also possible to construct them
directly via the constructor.
**/
export declare class DataProperty {
    /** @hidden @internal */
    _$typeName: string;
    /** Is this a DataProperty? - always true here. Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
    isDataProperty: boolean;
    /** Is this a NavigationProperty? - always false here.  Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
    isNavigationProperty: boolean;
    /** The name of this property. __Read Only__  **/
    name: string;
    /** The name of this property on the server. __Read Only__ **/
    nameOnServer: string;
    /** The [[DataType]] of this property. __Read Only__ */
    dataType: DataType | ComplexType;
    /** The name of the [[ComplexType]] associated with this property; may be null. __Read Only__ */
    complexTypeName: string;
    /** The [[ComplexType]] associated with this property; may be undefined. __Read Only__ */
    complexType?: ComplexType;
    /**  Whether the contents of this property is an instance of a [[ComplexType]]. __Read Only__ */
    isComplexProperty: boolean;
    /** Whether this property is nullable. __Read Only__ */
    isNullable: boolean;
    /**  Whether this property is scalar (i.e., returns a single value as opposed to an array). __Read Only__ */
    isScalar: boolean;
    /** The default value for this property. __Read Only__ */
    defaultValue: any;
    /**  Whether this property is a 'key' property. __Read Only__ */
    isPartOfKey: boolean;
    /** Whether this property is an 'unmapped' property. __Read Only__ */
    isUnmapped: boolean;
    /** Whether this property is 'settable'. __Read Only__ */
    isSettable: boolean;
    concurrencyMode: string;
    /**  The maximum length for the value of this property. Only meaningful for strings. __Read Only__ */
    maxLength?: number;
    /** The [[Validator]] instances that are associated with this property. Validators can be added and
    removed from this collection. __Read Only__ */
    validators: Validator[];
    /** The display name of this property. __Read Only__ */
    displayName: string;
    enumType?: any;
    /** The raw type name of this property. will only be defined for properties with a DataType of 'Undefined' */
    rawTypeName?: string;
    /**  A free form object that can be used to define any custom metadata for this DataProperty. __Read Only__ */
    custom?: Object;
    inverseNavigationProperty?: NavigationProperty;
    /**
    The navigation property related to this property.  Will only be set if this is a foreign key property. __Read Only__ */
    relatedNavigationProperty?: NavigationProperty;
    /** The parent type that this property belongs to - will be either a [[EntityType]] or a [[ComplexType]]. __Read Only__ */
    parentType: StructuralType;
    /** Property on the base type that this property is inherited from. Will be null if the property is not on the base type. __Read Only__ */
    baseProperty?: DataProperty;
    /** DataProperty constructor
    >      let lastNameProp = new DataProperty( {
    >          name: "lastName",
    >          dataType: DataType.String,
    >          isNullable: true,
    >          maxLength: 20
    >      });
    >      // assuming personEntityType is a newly constructed EntityType
    >      personEntityType.addProperty(lastNameProperty);
    @param config - A configuration Object or a DataProperty
    */
    constructor(config: DataPropertyConfig | DataProperty);
    static getRawValueFromServer(rawEntity: Object, dp: DataProperty): any;
    static getRawValueFromClient(rawEntity: Object, dp: DataProperty): any;
    resolveProperty(propName: string): any;
    formatName(): string;
    /**
    General purpose property set method
    >      // assume em1 is an EntityManager
    >      let prop = myEntityType.getProperty("myProperty");
    >      prop.setProperties( {
    >          custom: { foo: 7, bar: "test" }
    >      });
    @param config - A configuration object.
    **/
    setProperties(config: {
        displayName?: string;
        custom?: Object;
    }): void;
    getAllValidators(): Validator[];
    toJSON(): Object;
    static fromJSON(json: any): DataProperty;
}
export interface NavigationPropertyConfig {
    name?: string;
    nameOnServer?: string;
    entityTypeName?: string;
    isScalar?: boolean;
    associationName?: string;
    foreignKeyNames?: string[];
    foreignKeyNamesOnServer?: string[];
    invForeignKeyNames?: string[];
    invForeignKeyNamesOnServer?: string[];
    validators?: Validator[];
    displayName?: string;
    custom?: Object;
}
/**   A NavigationProperty describes the metadata for a single property of an [[EntityType]] that return instances of other EntityTypes.

Instances of the NavigationProperty class are constructed automatically during Metadata retrieval.   However it is also possible to construct them
directly via the constructor.
**/
export declare class NavigationProperty {
    /** @hidden @internal */
    _$typeName: string;
    /** Is this a DataProperty? - always false here
    Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
    isDataProperty: boolean;
    /** Is this a NavigationProperty? - always true here
    Allows polymorphic treatment of DataProperties and NavigationProperties. __Read Only__ */
    isNavigationProperty: boolean;
    formatName: () => string;
    getAllValidators: () => Validator[];
    resolveProperty: (propName: string) => any;
    /** The [[EntityType]] returned by this property. __Read Only__ */
    entityType: EntityType;
    /** The name of the [[EntityType]] returned by this property. __Read Only__ */
    entityTypeName: string;
    /** The [[EntityType]] that this property belongs to. ( same as entityType). __Read Only__ */
    parentType: EntityType;
    /** The [[EntityType]] that this property belongs to. ( same as entityType). __Read Only__ */
    parentEntityType: EntityType;
    /** Property on the base type that this property is inherited from. Will be null if the property is not on the base type. __Read Only__ */
    baseProperty?: NavigationProperty;
    /** The inverse of this NavigationProperty.  The NavigationProperty that represents a navigation in the opposite direction
    to this NavigationProperty. May be undefined for a undirectional NavigationProperty. __Read Only__ */
    private _inverse?;
    /** The name of this property. __Read Only__ */
    name: string;
    /** The name of this property on the server. __Read Only__ */
    nameOnServer: string;
    /**
    Whether this property returns a single entity as opposed to  an array of entities. __Read Only__ */
    isScalar: boolean;
    /** The name of the association to which that this property belongs.  This associationName will be shared with this
    properties 'inverse'. __Read Only__ */
    associationName: string;
    /** The names of the foreign key DataProperties associated with this NavigationProperty. There will usually only be a single DataProperty associated
    with a Navigation property except in the case of entities with multipart keys. __Read Only__ */
    foreignKeyNames: string[];
    /** The server side names of the foreign key DataProperties associated with this NavigationProperty. There will usually only be a single DataProperty associated
    with a Navigation property except in the case of entities with multipart keys. __Read Only__ */
    foreignKeyNamesOnServer: string[];
    invForeignKeyNames: string[];
    invForeignKeyNamesOnServer: string[];
    /** The 'foreign key' DataProperties associated with this NavigationProperty. There will usually only be a single DataProperty associated
    with a Navigation property except in the case of entities with multipart keys. __Read Only__ */
    relatedDataProperties: DataProperty[];
    /** The [[Validator]] instances that are associated with this property. Validators can be added and
    removed from this collection. __Read Only__ */
    validators: Validator[];
    /** The display name of this property. __Read Only__ */
    displayName: string;
    isUnmapped: boolean;
    /** A free form object that can be used to define any custom metadata for this NavigationProperty.   **/
    custom: Object;
    /** NavigationProperty constructor
    >      let homeAddressProp = new NavigationProperty( {
    >          name: "homeAddress",
    >          entityTypeName: "Address:#myNamespace",
    >          isScalar: true,
    >          associationName: "address_person",
    >          foreignKeyNames: ["homeAddressId"]
    >      });
    >      let homeAddressIdProp = new DataProperty( {
    >          name: "homeAddressId"
    >          dataType: DataType.Integer
    >      });
    >      // assuming personEntityType is a newly constructed EntityType
    >      personEntityType.addProperty(homeAddressProp);
    >      personEntityType.addProperty(homeAddressIdProp);
    @param config - A configuration object.
    **/
    constructor(config: NavigationPropertyConfig);
    /**
    General purpose property set method
    >      // assume myEntityType is an EntityType
    >      let prop = myEntityType.getProperty("myProperty");
    >      prop.setProperties( {
    >          custom: { foo: 7, bar: "test" }
    >      });
    @param config - A config object
    **/
    setProperties(config: {
        displayName?: string;
        foreignKeyNames?: string[];
        invForeignKeyNames?: string[];
        inverse?: NavigationProperty | string;
        custom?: Object;
    }): void;
    /** The inverse of this NavigationProperty.  The NavigationProperty that represents a navigation in the opposite direction
    to this NavigationProperty. May be undefined for a undirectional NavigationProperty. __Read Only__ */
    readonly inverse: NavigationProperty | undefined;
    /** @hidden @internal */
    getInverse(): NavigationProperty | undefined;
    setInverse(inverseNp: NavigationProperty | string): void;
    toJSON(): Object;
    static fromJSON(json: any): NavigationProperty;
    /** @hidden @internal */
    _resolveNp(): void;
}
/**
AutoGeneratedKeyType is an 'Enum' containing all of the valid states for an automatically generated key.
**/
export declare class AutoGeneratedKeyType extends BreezeEnum {
    /**
    This entity does not have an autogenerated key.
    The client must set the key before adding the entity to the EntityManager
    **/
    static None: AutoGeneratedKeyType;
    /**
    This entity's key is an Identity column and is set by the backend database.
    Keys for new entities will be temporary until the entities are saved at which point the keys will
    be converted to their 'real' versions.
    **/
    static Identity: AutoGeneratedKeyType;
    /**
    This entity's key is generated by a KeyGenerator and is set by the backend database.
    Keys for new entities will be temporary until the entities are saved at which point the keys will
    be converted to their 'real' versions.
    **/
    static KeyGenerator: AutoGeneratedKeyType;
}
/** @hidden @internal */
declare module "./assert-param" {
    interface Param {
        isEntity(): Param;
        isEntityProperty(): Param;
    }
}
export declare function qualifyTypeName(shortName: string, ns?: string): string;
