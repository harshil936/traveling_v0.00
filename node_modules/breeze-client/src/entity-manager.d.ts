import { DataServiceAdapter } from './interface-registry';
import { Callback, ErrorCallback } from './core';
import { BreezeEvent } from './event';
import { Entity, StructuralObject, PropertyChangedEventArgs } from './entity-aspect';
import { MetadataStore, EntityType, DataProperty } from './entity-metadata';
import { EntityKey } from './entity-key';
import { EntityAction } from './entity-action';
import { EntityState } from './entity-state';
import { DataService } from './data-service';
import { ValidationError } from './validate';
import { ValidationOptions } from './validation-options';
import { QueryOptions, MergeStrategy } from './query-options';
import { SaveOptions } from './save-options';
import { KeyGenerator } from './key-generator';
import { EntityGroup } from './entity-group';
import { EntityQuery } from './entity-query';
import { UnattachedChildrenMap } from './unattached-children-map';
export interface HttpResponse {
    config: any;
    data: any;
    error?: any;
    saveContext?: any;
    status: number;
    getHeaders(headerName: string): string;
}
export interface ImportResult {
    entities: Entity[];
    tempKeyMapping: ITempKeyMap;
}
/** Base shape of any errors returned from the server. */
export interface ServerError extends Error {
    httpResponse: HttpResponse;
    status: number;
    message: string;
    statusText?: string;
    body?: any;
    url?: string;
}
/** Shape of a save error returned from the server.
For use by breeze plugin authors only. The class is for use in building a [[IDataServiceAdapter]] implementation.
@adapter (see [[IDataServiceAdapter]])
@hidden @internal
*/
export interface SaveErrorFromServer extends ServerError {
    entityErrors: EntityErrorFromServer[];
}
/** Shape of a save error when returned to the client. */
export interface SaveError extends ServerError {
    entityErrors: EntityError[];
}
/**
For use by breeze plugin authors only. The class is for use in building a [[IDataServiceAdapter]] implementation.
@adapter (see [[IDataServiceAdapter]])
@hidden @internal
*/
export interface EntityErrorFromServer {
    entityTypeName: string;
    keyValues: any[];
    errorName: string;
    errorMessage: string;
    propertyName: string;
}
/** Shape of an error on a specific entity.  Part of a [[ISaveError]] */
export interface EntityError {
    entity: Entity;
    errorName: string;
    errorMessage: string;
    propertyName: string;
    isServerError: boolean;
}
/** The shape of the Promise returned by an [[EntityManager.executeQuery]] call. */
export interface QueryResult {
    /** Top level entities returned */
    results: any[];
    /** Query that was executed */
    query: EntityQuery | string;
    /** EntityManager that executed the query */
    entityManager?: EntityManager;
    /** Total number of results available on the server */
    inlineCount?: number;
    /** All entities returned by the query.  Differs from results when an expand is used. */
    retrievedEntities?: Entity[];
    /** Raw response from the server */
    httpResponse?: HttpResponse;
}
export interface QuerySuccessCallback {
    (data: QueryResult): void;
}
export interface QueryErrorCallback {
    (error: {
        query: EntityQuery;
        httpResponse: HttpResponse;
        entityManager: EntityManager;
        message?: string;
        stack?: string;
    }): void;
}
/** Key mapping information returned as part of an [[ISaveResult]]. */
export interface KeyMapping {
    entityTypeName: string;
    tempValue: any;
    realValue: any;
}
interface ITempKeyMap {
    [index: string]: EntityKey;
}
/** Configuration info to be passed to the [[EntityManager.importEntities]] method */
export interface ImportConfig {
    /** If true, merge Added entities (with temp keys) as well.  This can be dangerous. */
    mergeAdds?: boolean;
    mergeStrategy?: MergeStrategy;
    metadataVersionFn?: (arg: {
        metadataVersion: any;
        metadataStoreName: any;
    }) => void;
}
/** The shape of the Promise returned by an [[EntityManager.saveChanges]] call. */
export interface SaveResult {
    entities: Entity[];
    keyMappings: KeyMapping[];
    deletedKeys?: {
        entityTypeName: string;
        keyValues: any[];
    }[];
    httpResponse?: HttpResponse;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IDataServiceAdapter]] implementation.
@adapter (see [[IDataServiceAdapter]])
@hidden
*/
export interface SaveContext {
    entityManager: EntityManager;
    dataService: DataService;
    processSavedEntities: (saveResult: SaveResult) => Entity[];
    resourceName: string;
    adapter?: DataServiceAdapter;
    routePrefix?: string;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IDataServiceAdapter]] implementation.
@adapter (see [[IDataServiceAdapter]])
@hidden
*/
export interface SaveBundle {
    entities: Entity[];
    saveOptions: SaveOptions;
}
/** Configuration info to be passed to the [[EntityManager]] constructor */
export interface EntityManagerConfig {
    /** The service name associated with this EntityManager.  **/
    serviceName?: string;
    /** The DataService associated with this EntityManager. **/
    dataService?: DataService;
    /** The [[QueryOptions]] associated with this EntityManager.  **/
    queryOptions?: QueryOptions;
    /** The [[SaveOptions]] associated with this EntityManager. **/
    saveOptions?: SaveOptions;
    /** The [[ValidationOptions]] associated with this EntityManager.  **/
    validationOptions?: ValidationOptions;
    /** The [[KeyGenerator]] associated with this EntityManager. **/
    keyGenerator?: KeyGenerator;
    /** The [[KeyGenerator]] constructor associated with this EntityManager. **/
    keyGeneratorCtor?: {
        new (): KeyGenerator;
    };
    /** The [[MetadataStore]] associated with this EntityManager. **/
    metadataStore?: MetadataStore;
}
/** The shape returned by callbacks registered with [[EntityManager.entityChanged]] event */
export interface EntityChangedEventArgs {
    entityAction: EntityAction;
    entity?: Entity;
    args?: PropertyChangedEventArgs;
}
export interface ValidationErrorsChangedEventArgs {
    entity: Entity;
    added: ValidationError[];
    removed: ValidationError[];
}
export interface HasChangesChangedEventArgs {
    entityManager: EntityManager;
    hasChanges: boolean;
}
/**
Instances of the EntityManager contain and manage collections of entities, either retrieved from a backend datastore or created on the client.
**/
export declare class EntityManager {
    /** @hidden @internal */
    _$typeName: string;
    /** The service name associated with this EntityManager. __Read Only__ **/
    serviceName: string;
    /** The DataService associated with this EntityManager. __Read Only__ **/
    dataService: DataService;
    /** The [[QueryOptions]] associated with this EntityManager. __Read Only__ **/
    queryOptions: QueryOptions;
    /** The [[SaveOptions]] associated with this EntityManager. __Read Only__ **/
    saveOptions: SaveOptions;
    /** The [[ValidationOptions]] associated with this EntityManager. __Read Only__ **/
    validationOptions: ValidationOptions;
    /** The [[KeyGenerator]] associated with this EntityManager. __Read Only__ **/
    keyGenerator: KeyGenerator;
    /** The [[KeyGenerator]] constructor associated with this EntityManager. __Read Only__ **/
    keyGeneratorCtor: {
        new (): KeyGenerator;
    };
    /** The [[MetadataStore]] associated with this EntityManager. __Read Only__ **/
    metadataStore: MetadataStore;
    isLoading: boolean;
    isRejectingChanges: boolean;
    /**
    A [[BreezeEvent]] that fires whenever a change to any entity in this EntityManager occurs. __Read Only__
  
    @eventArgs -
    - entityAction - The [[EntityAction]] that occured.
    - entity - The entity that changed.  If this is null, then all entities in the entityManager were affected.
    - args - Additional information about this event. This will differ based on the entityAction.
  
    >      let em = new EntityManager( {serviceName: "breeze/NorthwindIBModel" });
    >      em.entityChanged.subscribe(function(changeArgs) {
    >          // This code will be executed any time any entity within the entityManager
    >          // is added, modified, deleted or detached for any reason.
    >          let action = changeArgs.entityAction;
    >          let entity = changeArgs.entity;
    >          // .. do something to this entity when it is changed.
    >      });
    >  });
    @event
    **/
    entityChanged: BreezeEvent<EntityChangedEventArgs>;
    /**
    An [[BreezeEvent]] that fires whenever validationErrors change for any entity in this EntityManager. __Read Only__
    @eventArgs -
      - entity - The entity on which the validation errors have been added or removed.
      - added - An array containing any newly added [[ValidationError]]s
      - removed - An array containing any newly removed [[ValidationError]]s. This is those errors that have been 'fixed'
  
    >      let em = new EntityManager( {serviceName: "breeze/NorthwindIBModel" });
    >      em.validationErrorsChanged.subscribe(function(changeArgs) {
    >              // This code will be executed any time any entity within the entityManager experiences a change to its validationErrors collection.
    >              function (validationChangeArgs) {
    >                  let entity == validationChangeArgs.entity;
    >                  let errorsAdded = validationChangeArgs.added;
    >                  let errorsCleared = validationChangeArgs.removed;
    >                  // ... do something interesting with the order.
    >              });
    >          });
    >      });
    @event
    **/
    validationErrorsChanged: BreezeEvent<ValidationErrorsChangedEventArgs>;
    /**
    A [[BreezeEvent]] that fires whenever an EntityManager transitions to or from having changes. __Read Only__
    @eventArgs -
      - entityManager - The EntityManager whose 'hasChanges' status has changed.
      - hasChanges - Whether or not this EntityManager has changes.
  
    >      let em = new EntityManager( {serviceName: "breeze/NorthwindIBModel" });
    >      em.hasChangesChanged.subscribe(function(args) {
    >              let hasChangesChanged = args.hasChanges;
    >              let entityManager = args.entityManager;
    >          });
    >      });
    @event
    **/
    hasChangesChanged: BreezeEvent<HasChangesChangedEventArgs>;
    /** @hidden @internal */
    _pendingPubs?: any[];
    /** @hidden @internal */
    _hasChangesAction?: (() => boolean);
    /** @hidden @internal */
    _hasChanges: boolean;
    /** @hidden @internal */
    _entityGroupMap: {
        [index: string]: EntityGroup;
    };
    /** @hidden @internal */
    _unattachedChildrenMap: UnattachedChildrenMap;
    /** @hidden @internal */
    _inKeyFixup: boolean;
    helper: {
        unwrapInstance: typeof unwrapInstance;
        unwrapOriginalValues: typeof unwrapOriginalValues;
        unwrapChangedValues: typeof unwrapChangedValues;
    };
    /**
    EntityManager constructor.
  
    At its most basic an EntityManager can be constructed with just a service name
    >     let entityManager = new EntityManager( "breeze/NorthwindIBModel");
  
    This is the same as calling it with the following configuration object
    >     let entityManager = new EntityManager( {serviceName: "breeze/NorthwindIBModel" });
  
    Usually however, configuration objects will contain more than just the 'serviceName';
    >     let metadataStore = new MetadataStore();
    >     let entityManager = new EntityManager( {
    >       serviceName: "breeze/NorthwindIBModel",
    >       metadataStore: metadataStore
    >     });
  
    or
    >     return new QueryOptions({
    >         mergeStrategy: obj,
    >         fetchStrategy: this.fetchStrategy
    >     });
    >     let queryOptions = new QueryOptions({
    >         mergeStrategy: MergeStrategy.OverwriteChanges,
    >         fetchStrategy: FetchStrategy.FromServer
    >     });
    >     let validationOptions = new ValidationOptions({
    >         validateOnAttach: true,
    >         validateOnSave: true,
    >         validateOnQuery: false
    >     });
    >     let entityManager = new EntityManager({
    >         serviceName: "breeze/NorthwindIBModel",
    >         queryOptions: queryOptions,
    >         validationOptions: validationOptions
    >     });
    @param emConfig - Configuration settings or a service name.
    **/
    constructor(emConfig?: EntityManagerConfig | string);
    /**
    General purpose property set method.  Any of the properties in the [[EntityManagerConfig]]
    may be set.
    >      // assume em1 is a previously created EntityManager
    >      // where we want to change some of its settings.
    >      em1.setProperties( {
    >          serviceName: "breeze/foo"
    >      });
    @param config - An object containing the selected properties and values to set.
    **/
    setProperties(config: EntityManagerConfig): void;
    /** @hidden @internal */
    static _updateWithConfig(em: EntityManager, config: EntityManagerConfig, isCtor: boolean): void;
    createEntity(typeName: string, initialValues?: Object, entityState?: EntityState, mergeStrategy?: MergeStrategy): Entity;
    createEntity(entityType: EntityType, initialValues?: Object, entityState?: EntityState, mergeStrategy?: MergeStrategy): Entity;
    static importEntities(exportedString: string, config?: ImportConfig): EntityManager;
    static importEntities(exportedData: Object, config?: ImportConfig): EntityManager;
    /**
    Calls [[EntityAspect.acceptChanges]] on every changed entity in this EntityManager.
    **/
    acceptChanges(): void;
    /**
    Exports selected entities, all entities of selected types, or an entire EntityManager cache.
  
    This method takes a snapshot of an EntityManager that can be stored offline or held in memory.
    Use the [[EntityManager.importEntities]] method to restore or merge the snapshot
    into another EntityManager at some later time.
    >      // let em1 be an EntityManager containing a number of existing entities.
    >     // export every entity in em1.
    >     let bundle = em1.exportEntities();
    >     // save to the browser's local storage
    >     window.localStorage.setItem("myEntityManager", bundle);
    >     // later retrieve the export
    >     let bundleFromStorage = window.localStorage.getItem("myEntityManager");
    >     // import the retrieved export bundle into another manager
    >     let em2 = em1.createEmptyCopy();
    >     em2.importEntities(bundleFromStorage);
    >     // em2 now has a complete, faithful copy of the entities that were in em1
  
    You can also control exactly which entities are exported.
    >     // get em1's unsaved changes (an array) and export them.
    >     let changes = em1.getChanges();
    >     let bundle = em1.exportEntities(changes);
    >     // merge these entities into em2 which may contains some of the same entities.
    >     // do NOT overwrite the entities in em2 if they themselves have unsaved changes.
    >     em2.importEntities(bundle, { mergeStrategy: MergeStrategy.PreserveChanges} );
  
    Metadata are included in an export by default. You may want to exclude the metadata
    especially if you're exporting just a few entities for local storage.
    >     let bundle = em1.exportEntities(arrayOfSelectedEntities, {includeMetadata: false});
    >     window.localStorage.setItem("goodStuff", bundle);
  
    You may still express this option as a boolean value although this older syntax is deprecated.
    >     // Exclude the metadata (deprecated syntax)
    >     let bundle = em1.exportEntities(arrayOfSelectedEntities, false);
  
    You can export all entities of one or more specified EntityTypes.
    >     // Export all Customer and Employee entities (and also exclude metadata)
    >     let bundle = em1.exportEntities(['Customer', 'Employee'], {includeMetadata: false});
  
    All of the above examples return an export bundle as a string which is the default format.
    You can export the bundle as JSON if you prefer by setting the `asString` option to false.
    >     // Export all Customer and Employee entities as JSON and exclude the metadata
    >     let bundle = em1.exportEntities(['Customer', 'Employee'],
    >                                     {asString: false, includeMetadata: false});
    >     // store JSON bundle somewhere ... perhaps indexDb ... and later import as we do here.
    >     em2.importEntities(bundle);
    @param entities - The entities to export or the EntityType(s) of the entities to export;
      all entities are exported if this parameter is omitted or null.
    @param exportConfig - Export configuration options or a boolean
      - asString - (boolean) - If true (default), return export bundle as a string.
      - includeMetadata - (boolean) - If true (default), include metadata in the export bundle.
    @return The export bundle either serialized as a string (default) or as a JSON object.
    The bundle contains the metadata (unless excluded) and the entity data grouped by type.
    The entity data include property values, change-state, and temporary key mappings (if any).
  
    The export bundle internals are deliberately undocumented.  This Breeze-internal representation of entity data is
    suitable for export, storage, and import. The schema and contents of the bundle may change in future versions of Breeze.
    Manipulate it at your own risk with appropriate caution.
    **/
    exportEntities(entities?: Entity[] | EntityType[] | string[], exportConfig?: {
        asString?: boolean;
        includeMetadata?: boolean;
    } | boolean): string | Object;
    importEntities(exportedString: string, config?: ImportConfig): ImportResult;
    importEntities(exportedData: Object, config?: ImportConfig): ImportResult;
    /**
    Clears this EntityManager's cache but keeps all other settings. Note that this
    method is not as fast as creating a new EntityManager via 'new EntityManager'.
    This is because clear actually detaches all of the entities from the EntityManager.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     em1.clear();
    >     // em1 is will now contain no entities, but all other setting will be maintained.
    **/
    clear(): void;
    /**
    Creates an empty copy of this EntityManager but with the same DataService, MetadataStore, QueryOptions, SaveOptions, ValidationOptions, etc.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     let em2 = em1.createEmptyCopy();
    >     // em2 is a new EntityManager with all of em1's settings
    >     // but no entities.
    @return A new EntityManager.
    **/
    createEmptyCopy(): EntityManager;
    /**
    Attaches an entity to this EntityManager with an  [[EntityState]] of 'Added'.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     let custType = em1.metadataStore.getEntityType("Customer");
    >     let cust1 = custType.createEntity();
    >     em1.addEntity(cust1);
  
    Note that this is the same as using 'attachEntity' with an [[EntityState]] of 'Added'.
  
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     let custType = em1.metadataStore.getEntityType("Customer");
    >     let cust1 = custType.createEntity();
    >     em1.attachEntity(cust1, EntityState.Added);
    @param entity - The entity to add.
    @return The added entity.
    **/
    addEntity(entity: Entity): Entity;
    /**
    Attaches an entity to this EntityManager with a specified [[EntityState]].
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     let custType = em1.metadataStore.getEntityType("Customer");
    >     let cust1 = custType.createEntity();
    >     em1.attachEntity(cust1, EntityState.Added);
    @param entity - The entity to add.
    @param entityState - (default=EntityState.Unchanged) The EntityState of the newly attached entity. If omitted this defaults to EntityState.Unchanged.
    @param mergeStrategy - (default = MergeStrategy.Disallowed) How the specified entity should be merged into the EntityManager if this EntityManager already contains an entity with the same key.
    @return The attached entity.
    **/
    attachEntity(entity: Entity, entityState?: EntityState, mergeStrategy?: MergeStrategy): Entity;
    /**
    Detaches an entity from this EntityManager.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     // assume cust1 is a customer Entity previously attached to em1
    >     em1.detachEntity(cust1);
    >     // em1 will now no longer contain cust1 and cust1 will have an
    >     // entityAspect.entityState of EntityState.Detached
    @param entity - The entity to detach.
    @return Whether the entity could be detached. This will return false if the entity is already detached or was never attached.
    **/
    detachEntity(entity: Entity): any;
    /**
    Fetches the metadata associated with the EntityManager's current 'serviceName'.  This call
    occurs internally before the first query to any service if the metadata hasn't already been
    loaded. __Async__
  
    Usually you will not actually process the results of a fetchMetadata call directly, but will instead
    ask for the metadata from the EntityManager after the fetchMetadata call returns.
    >     let em1 = new EntityManager( "breeze/NorthwindIBModel");
    >     em1.fetchMetadata()
    >       .then(function() {
    >           let metadataStore = em1.metadataStore;
    >           // do something with the metadata
    >       }).catch(function(exception) {
    >           // handle exception here
    >       });
    
    @param callback - Function called on success.
    @param errorCallback - Function called on failure.
    @return {Promise}
      - schema {Object} The raw Schema object from metadata provider - Because this schema will differ depending on the metadata provider
          it is usually better to access metadata via the 'metadataStore' property of the EntityManager instead of using this 'raw' data.
    **/
    fetchMetadata(dataService?: DataService, callback?: Callback, errorCallback?: ErrorCallback): Promise<any>;
    executeQuery(query: string, callback?: QuerySuccessCallback, errorCallback?: QueryErrorCallback): Promise<QueryResult>;
    executeQuery(query: EntityQuery, callback?: QuerySuccessCallback, errorCallback?: QueryErrorCallback): Promise<QueryResult>;
    /**
    Executes the specified query against this EntityManager's local cache.
  
    Because this method is executed immediately there is no need for a promise or a callback
    >     let em = new EntityManager(serviceName);
    >     let query = new EntityQuery("Orders");
    >     let orders = em.executeQueryLocally(query);
  
    Note that this can also be accomplished using the 'executeQuery' method with
    a FetchStrategy of FromLocalCache and making use of the Promise or callback
    >     let em = new EntityManager(serviceName);
    >     let query = new EntityQuery("Orders").using(FetchStrategy.FromLocalCache);
    >     em.executeQuery(query).then( function(data) {
    >         let orders = data.results;
    >         ... query results processed here
    >     }).catch( function(err) {
    >         ... query failure processed here
    >     });
    @param query - The [[EntityQuery]] to execute.
    @return  {Array of Entity}  Array of entities from cache that satisfy the query
    **/
    executeQueryLocally(query: EntityQuery): any[];
    /**
    Saves either a list of specified entities or all changed entities within this EntityManager. If there are no changes to any of the entities
    specified then there will be no server side call made but a valid 'empty' saveResult will still be returned. __Async__
  
    Often we will be saving all of the entities within an EntityManager that are either added, modified or deleted
    and we will let the 'saveChanges' call determine which entities these are.
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      // This could include added, modified and deleted entities.
    >      em.saveChanges().then(function(saveResult) {
    >          let savedEntities = saveResult.entities;
    >          let keyMappings = saveResult.keyMappings;
    >      }).catch(function (e) {
    >          // e is any exception that was thrown.
    >      });
  
    But we can also control exactly which entities to save and can specify specific SaveOptions
  
    >      // assume entitiesToSave is an array of entities to save.
    >      let saveOptions = new SaveOptions({ allowConcurrentSaves: true });
    >      em.saveChanges(entitiesToSave, saveOptions).then(function(saveResult) {
    >          let savedEntities = saveResult.entities;
    >          let keyMappings = saveResult.keyMappings;
    >      }).catch(function (e) {
    >          // e is any exception that was thrown.
    >      });
  
    Callback methods can also be used
    >      em.saveChanges(entitiesToSave, null,
    >          function(saveResult) {
    >              let savedEntities = saveResult.entities;
    >              let keyMappings = saveResult.keyMappings;
    >          }, function (e) {
    >              // e is any exception that was thrown.
    >          }
    >      );
  
    @param entities - The list of entities to save.
    Every entity in that list will be sent to the server, whether changed or unchanged,
    as long as it is attached to this EntityManager.
    If this parameter is omitted, null or empty (the usual case),
    every entity with pending changes in this EntityManager will be saved.
    @param saveOptions - [[SaveOptions]] for the save - will default to
    [[EntityManager.saveOptions]] if null.
    @param callback -  Function called on success.
    @param errorCallback - Function called on failure.
    @return {Promise} Promise
    **/
    saveChanges(entities?: Entity[] | null, saveOptions?: SaveOptions, callback?: Function, errorCallback?: Function): Promise<SaveResult>;
    /**
    Run the "saveChanges" pre-save client validation logic.
    
    This is NOT a general purpose validation method.
    It is intended for utilities that must know if saveChanges
    would reject the save due to client validation errors.
    
    It only validates entities if the EntityManager's
    [[ValidationOptions]].validateOnSave is true.
    
    @param entitiesToSave {Array of Entity} The list of entities to save (to validate).
    @return {Error} Validation error or null if no error
    **/
    saveChangesValidateOnClient(entitiesToSave: Entity[]): Error;
    /** @hidden @internal */
    _findEntityGroup(entityType: EntityType): EntityGroup;
    /**
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let employeeType = em1.metadataStore.getEntityType("Employee");
    >      let employeeKey = new EntityKey(employeeType, 1);
    >      let employee = em1.getEntityByKey(employeeKey);
    >      // employee will either be an entity or null.
    **/
    getEntityByKey(entityKey: EntityKey): Entity | null;
    /**
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let employee = em1.getEntityByKey("Employee", 1);
    >      // employee will either be an entity or null.
    **/
    getEntityByKey(typeName: string, keyValues: any | any[]): Entity | null;
    /**
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let employeeType = em1.metadataStore.getEntityType("Employee");
    >      let employee = em1.getEntityByKey(employeeType, 1);
    >      // employee will either be an entity or null.
    **/
    getEntityByKey(type: EntityType, keyValues: any | any[]): Entity | null;
    fetchEntityByKey(typeName: string, keyValues: any | any[], checkLocalCacheFirst?: boolean): Promise<IEntityByKeyResult>;
    fetchEntityByKey(entityType: EntityType, keyValues: any | any[], checkLocalCacheFirst?: boolean): Promise<IEntityByKeyResult>;
    fetchEntityByKey(entityKey: EntityKey, checkLocalCacheFirst?: boolean): Promise<IEntityByKeyResult>;
    /**
    [Deprecated] - Attempts to locate an entity within this EntityManager by its  [[EntityKey]].
    >     // assume em1 is an EntityManager containing a number of preexisting entities.
    >     let employeeType = em1.metadataStore.getEntityType("Employee");
    >     let employeeKey = new EntityKey(employeeType, 1);
    >     let employee = em1.findEntityByKey(employeeKey);
    >     // employee will either be an entity or null.
    @deprecated    Use getEntityByKey instead
    @param entityKey - The  [[EntityKey]] of the Entity to be located.
    @return An Entity or null;
    **/
    findEntityByKey(entityKey: EntityKey): Entity;
    /**
    Generates a temporary key for the specified entity.  This is used to insure that newly
    created entities have unique keys and to register that these keys are temporary and
    need to be automatically replaced with 'real' key values once these entities are saved.
    
    The [[EntityManager.keyGeneratorCtor]] property is used internally by this method to actually generate
    the keys - See the  KeyGenerator interface interface description to see
    how a custom key generator can be plugged in.
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let custType = em1.metadataStore.getEntityType("Customer");
    >      let customer = custType.createEntity();
    >      let customerId = em.generateTempKeyValue(customer);
    >      // The 'customer' entity 'CustomerID' property is now set to a newly generated unique id value
    >      // This property will change again after a successful save of the 'customer' entity.
    >
    >      em1.saveChanges().then( function( data) {
    >          let sameCust1 = data.results[0];
    >          // cust1 === sameCust1;
    >          // but cust1.getProperty("CustomerId") != customerId
    >          // because the server will have generated a new id
    >          // and the client will have been updated with this
    >          // new id.
    >      })
    @param entity - The Entity to generate a key for.
    @return The new key value
    **/
    generateTempKeyValue(entity: Entity): any;
    hasChanges(): boolean;
    hasChanges(entityTypeNames: string | string[]): boolean;
    hasChanges(entityTypes: EntityType | EntityType[]): boolean;
    /** @hidden @internal */
    _hasChangesCore(entityTypes?: EntityType | EntityType[] | string | string[]): boolean;
    getChanges(): Entity[];
    getChanges(entityTypeNames: string | string[]): Entity[];
    getChanges(entityTypes: EntityType | EntityType[]): Entity[];
    /**
    Rejects (reverses the effects) all of the additions, modifications and deletes from this EntityManager.
    Calls [[EntityAspect.rejectChanges]] on every changed entity in this EntityManager.
    >      // assume em1 is an EntityManager containing a number of preexisting entities.
    >      let entities = em1.rejectChanges();
    @return The entities whose changes were rejected. These entities will all have EntityStates of
    either 'Unchanged' or 'Detached'
    **/
    rejectChanges(): Entity[];
    getEntities(entityTypeNames?: string | string[], entityStates?: EntityState | EntityState[]): Entity[];
    getEntities(entityTypes?: EntityType | EntityType[], entityStates?: EntityState | EntityState[]): Entity[];
    /** @hidden @internal */
    _notifyStateChange(entity: Entity, needsSave: boolean): void;
    /** @hidden @internal */
    _setHasChanges(hasChanges?: boolean): void;
    /** @hidden @internal */
    _linkRelatedEntities(entity: Entity): void;
    /** @hidden @internal */
    _attachEntityCore(entity: Entity, entityState: EntityState, mergeStrategy: MergeStrategy): Entity;
    /** @hidden @internal */
    _updateFkVal(fkProp: DataProperty, oldValue: any, newValue: any): void;
}
export interface IEntityByKeyResult {
    entity?: Entity;
    entityKey: EntityKey;
    fromCache: boolean;
}
declare function unwrapInstance(structObj: StructuralObject, transformFn?: (dp: DataProperty, val: any) => any): any;
declare function unwrapOriginalValues(target: StructuralObject, metadataStore: MetadataStore, transformFn?: (dp: DataProperty, val: any) => any): {};
declare function unwrapChangedValues(entity: Entity, metadataStore: MetadataStore, transformFn: (dp: DataProperty, val: any) => any): {};
export {};
