import { Callback, ErrorCallback } from './core';
import { Entity } from './entity-aspect';
import { EntityKey } from './entity-key';
import { BreezeEnum } from './enum';
import { DataService, JsonResultsAdapter } from './data-service';
import { EntityManager, QueryResult } from './entity-manager';
import { MetadataStore, EntityType, NavigationProperty, EntityProperty } from './entity-metadata';
import { QueryOptions, MergeStrategy, FetchStrategy } from './query-options';
import { Predicate } from './predicate';
export interface RecursiveArray<T> {
    [i: number]: T | RecursiveArray<T>;
}
export interface EntityQueryJsonContext {
    entityType?: EntityType;
    propertyPathFn?: Function;
    toNameOnServer?: boolean;
}
/**
An EntityQuery instance is used to query entities either from a remote datasource or from a local [[EntityManager]].

EntityQueries are immutable - this means that all EntityQuery methods that return an EntityQuery actually create a new EntityQuery.  This means that
EntityQueries can be 'modified' without affecting any current instances.
@dynamic
**/
export declare class EntityQuery {
    /** @hidden @internal */
    _$typeName: string;
    /** The resource name used by this query. __Read Only__ */
    resourceName?: string;
    /** The [[EntityType]] that is associated with the 'from' clause ( resourceName) of the query.  This is only guaranteed to be be set AFTER the query
    has been executed because it depends on the [[MetadataStore]] associated with the [[EntityManager]] that the query was executed against.
    This value may be null if the entityType cannot be associated with a resourceName. __Read Only__ */
    fromEntityType?: EntityType;
    /** The 'where' [[Predicate]] used by this query. __Read Only__ */
    wherePredicate: Predicate;
    /** The [[OrderByClause]] used by this query. __Read Only__ */
    orderByClause?: OrderByClause;
    /** The [[ExpandClause]] used by this query. __Read Only__ */
    expandClause?: ExpandClause;
    /** The [[SelectClause]] used by this query. __Read Only__ */
    selectClause?: SelectClause;
    /** The number of entities to 'skip' for this query. __Read Only__ */
    skipCount?: number;
    /** The number of entities to 'take' for this query. __Read Only__ */
    takeCount?: number;
    /** Any additional parameters that were added to the query via the 'withParameters' method. __Read Only__ */
    parameters: Object;
    /** Whether an inline count is returned for this query. __Read Only__ */
    inlineCountEnabled: boolean;
    /** Whether entity tracking has been disabled for this query. __Read Only__ */
    noTrackingEnabled: boolean;
    /** The [[QueryOptions]] for this query. __Read Only__  **/
    queryOptions?: QueryOptions;
    /** The [[DataService]] for this query. __Read Only__  **/
    dataService?: DataService;
    /** The [[EntityManager]] for this query. This may be null and can be set via the 'using' method.  **/
    entityManager?: EntityManager;
    /**  The entityType that will be returned by this query.
    This property will only be set if the 'toType' method was called. __Read Only__ */
    resultEntityType: EntityType | string;
    usesNameOnServer?: boolean;
    /** Constructor
    >    let query = new EntityQuery("Customers")
  
    Usually this constructor will be followed by calls to filtering, ordering or selection methods
    >      let query = new EntityQuery("Customers")
    >        .where("CompanyName", "startsWith", "C")
    >        .orderBy("Region");
    @param resourceName - either a resource name or a serialized EntityQuery ( created by [[EntityQuery.toJSON]])
    **/
    constructor(resourceName?: string | Object);
    /**
    Specifies the resource to query for this EntityQuery.
    >      let query = new EntityQuery()
    >        .from("Customers");
  
    is the same as
    >      let query = new EntityQuery("Customers");
    @param resourceName - The resource to query.
    **/
    from(resourceName: string): EntityQuery;
    /**
    This is a static version of the "from" method and it creates a 'base' entityQuery for the specified resource name.
    >      let query = EntityQuery.from("Customers");
  
    is the same as
    >      let query = new EntityQuery("Customers");
    @param resourceName - The resource to query.
    **/
    static from(resourceName: string): EntityQuery;
    /**
    Specifies the top level EntityType that this query will return.  Only needed when a query returns a json result that does not include type information.
    >      let query = new EntityQuery()
    >        .from("MyCustomMethod")
    >        .toType("Customer")
    @param entityType - The top level EntityType that this query will return.  This method is only needed when a query returns a json result that
    does not include type information.  If the json result consists of more than a simple entity or array of entities, consider using a [[JsonResultsAdapter]] instead.
    **/
    toType(entityType: string | EntityType): EntityQuery;
    where(predicate?: Predicate): EntityQuery;
    where(predicate: Object): EntityQuery;
    where(property: string, operator: string, value: any): EntityQuery;
    where(property: string, operator: FilterQueryOp, value: any): EntityQuery;
    where(property: string, filterop: FilterQueryOp, property2: string, filterop2: FilterQueryOp, value: any): EntityQuery;
    where(property: string, filterop: string, property2: string, filterop2: string, value: any): EntityQuery;
    where(property: string, filterop: string, property2: string, filterop2: string, property3: string, filterop3: string, value: any): EntityQuery;
    where(anArray: RecursiveArray<string | number | FilterQueryOp | Predicate>): EntityQuery;
    orderBy(propertyPaths?: string, isDescending?: boolean): EntityQuery;
    orderBy(propertyPaths: string[], isDescending?: boolean): EntityQuery;
    orderByDesc(propertyPaths: string): EntityQuery;
    orderByDesc(propertyPaths: string[]): EntityQuery;
    /**
    Returns a new query that selects a list of properties from the results of the original query and returns the values of just these properties. This
    will be referred to as a projection.
    If the result of this selection "projection" contains entities, these entities will automatically be added to EntityManager's cache and will
    be made 'observable'.
    Any simple properties, i.e. strings, numbers or dates within a projection will not be cached are will NOT be made 'observable'.
    
    Simple data properties can be projected
    >     let query = new EntityQuery("Customers")
    >         .where("CompanyName", "startsWith", "C")
    >         .select("CompanyName");
  
    This will return an array of objects each with a single "CompanyName" property of type string.
    A similar query could return a navigation property instead
    >     let query = new EntityQuery("Customers")
    >        .where("CompanyName", "startsWith", "C")
    >        .select("Orders");
  
    where the result would be an array of objects each with a single "Orders" property that would itself be an array of "Order" entities.
    Composite projections are also possible:
    >     let query = new EntityQuery("Customers")
    >        .where("CompanyName", "startsWith", "C")
    >        .select("CompanyName, Orders");
  
    As well as projections involving nested property paths
    >     let query = EntityQuery("Orders")
    >        .where("Customer.CompanyName", "startsWith", "C")
    >        .select("Customer.CompanyName, Customer, OrderDate");
    @param propertyPaths - A comma-separated (',') string of property paths or an array of property paths.
    If 'propertyPaths' is either null or omitted then any existing projection on the query is removed.
    **/
    select(propertyPaths?: string | string[]): EntityQuery;
    /**
    Returns a new query that skips the specified number of entities when returning results.
    Any existing 'skip' can be cleared by calling 'skip' with no arguments.
    >     let query = new EntityQuery("Customers")
    >       .where("CompanyName", "startsWith", "C")
    >       .skip(5);
    @param count - The number of entities to skip over. If omitted or null any existing skip count on the query is removed.
    **/
    skip(count?: number): EntityQuery;
    /**
    Returns a new query that returns only the specified number of entities when returning results. - Same as 'take'.
    Any existing 'top' can be cleared by calling 'top' with no arguments.
    >     let query = new EntityQuery("Customers")
    >        .top(5);
    @param count - The number of entities to return.
    If 'count' is either null or omitted then any existing 'top' count on the query is removed.
    **/
    top(count?: number): EntityQuery;
    /**
    Returns a new query that returns only the specified number of entities when returning results - Same as 'top'.
    Any existing take can be cleared by calling take with no arguments.
    >     let query = new EntityQuery("Customers")
    >        .take(5);
    @param count - The number of entities to return.
    If 'count' is either null or omitted then any existing 'take' count on the query is removed.
    **/
    take(count?: number): EntityQuery;
    /**
    Returns a new query that will return related entities nested within its results. The expand method allows you to identify related entities, via navigation property
    names such that a graph of entities may be retrieved with a single request. Any filtering occurs before the results are 'expanded'.
    >     let query = new EntityQuery("Customers")
    >        .where("CompanyName", "startsWith", "C")
    >        .expand("Orders");
  
    will return the filtered customers each with its "Orders" properties fully resolved.
    Multiple paths may be specified by separating the paths by a ','
    >     let query = new EntityQuery("Orders")
    >        .expand("Customer, Employee")
  
    and nested property paths my be specified as well
    >     let query = new EntityQuery("Orders")
    >        .expand("Customer, OrderDetails, OrderDetails.Product")
    @param propertyPaths - A comma-separated list of navigation property names or an array of navigation property names. Each Navigation Property name can be followed
    by a '.' and another navigation property name to enable identifying a multi-level relationship.
    If 'propertyPaths' is either null or omitted then any existing 'expand' clause on the query is removed.
    **/
    expand(propertyPaths?: string | string[]): EntityQuery;
    /**
    Returns a new query that includes a collection of parameters to pass to the server.
    >     let query = EntityQuery.from("EmployeesFilteredByCountryAndBirthdate")
    >        .withParameters({ BirthDate: "1/1/1960", Country: "USA" });
     
    will call the 'EmployeesFilteredByCountryAndBirthdate' method on the server and pass in 2 parameters. This
    query will be uri encoded as
    >      {serviceApi}/EmployeesFilteredByCountryAndBirthdate?birthDate=1%2F1%2F1960&country=USA
  
    Parameters may also be mixed in with other query criteria.
    >     let query = EntityQuery.from("EmployeesFilteredByCountryAndBirthdate")
    >        .withParameters({ BirthDate: "1/1/1960", Country: "USA" })
    >        .where("LastName", "startsWith", "S")
    >        .orderBy("BirthDate");
    @param parameters - A parameters object where the keys are the parameter names and the values are the parameter values.
    **/
    withParameters(parameters: Object): EntityQuery;
    /**
    Returns a query with the 'inlineCount' capability either enabled or disabled.  With 'inlineCount' enabled, an additional 'inlineCount' property
    will be returned with the query results that will contain the number of entities that would have been returned by this
    query with only the 'where'/'filter' clauses applied, i.e. without any 'skip'/'take' operators applied. For local queries this clause is ignored.
    >     let query = new EntityQuery("Customers")
    >        .take(20)
    >        .orderBy("CompanyName")
    >        .inlineCount(true);
  
    will return the first 20 customers as well as a count of all of the customers in the remote store.
    @param enabled - (default = true) Whether or not inlineCount capability should be enabled. If this parameter is omitted, true is assumed.
    **/
    inlineCount(enabled?: boolean): EntityQuery;
    useNameOnServer(usesNameOnServer?: boolean): EntityQuery;
    /**
    Returns a query with the 'noTracking' capability either enabled or disabled.  With 'noTracking' enabled, the results of this query
    will not be coerced into entities but will instead look like raw javascript projections. i.e. simple javascript objects.
    >     let query = new EntityQuery("Customers")
    >         .take(20)
    >         .orderBy("CompanyName")
    >         .noTracking(true);
    @param enabled - (default = true) Whether or not the noTracking capability should be enabled. If this parameter is omitted, true is assumed.
    **/
    noTracking(enabled?: boolean): EntityQuery;
    using(obj: EntityManager): EntityQuery;
    using(obj: DataService): EntityQuery;
    using(obj: JsonResultsAdapter): EntityQuery;
    using(obj: QueryOptions): EntityQuery;
    using(obj: MergeStrategy): EntityQuery;
    using(obj: FetchStrategy): EntityQuery;
    /**
    Executes this query.  This method requires that an EntityManager has been previously specified via the "using" method.
    
    This method can be called using a 'promises' syntax ( recommended)
    >      let em = new EntityManager(serviceName);
    >      let query = new EntityQuery("Orders").using(em);
    >      query.execute().then( function(data) {
    >          ... query results processed here
    >      }).catch( function(err) {
    >          ... query failure processed here
    >      });
  
    or with callbacks
    >      let em = new EntityManager(serviceName);
    >      let query = new EntityQuery("Orders").using(em);
    >      query.execute(
    >        function(data) {
    >                    let orders = data.results;
    >                    ... query results processed here
    >                },
    >        function(err) {
    >                    ... query failure processed here
    >                });
  
    Either way this method is the same as calling the EntityManager 'execute' method.
    >      let em = new EntityManager(serviceName);
    >      let query = new EntityQuery("Orders");
    >      em.executeQuery(query).then( function(data) {
    >         let orders = data.results;
    >          ... query results processed here
    >      }).catch( function(err) {
    >         ... query failure processed here
    >      });
  
    @param callback -  Function called on success.
    @param errorCallback - Function called on failure.
    @return Promise
    **/
    execute(callback?: Callback, errorCallback?: ErrorCallback): Promise<QueryResult>;
    /**
    Executes this query against the local cache.  This method requires that an EntityManager have been previously specified via the "using" method.
    >      // assume em is an entityManager already filled with order entities;
    >      let query = new EntityQuery("Orders").using(em);
    >      let orders = query.executeLocally();
  
    Note that calling this method is the same as calling [[EntityManager.executeQueryLocally]].
    **/
    executeLocally(): any[];
    toJSON(): Object;
    /** Typically only for use when building UriBuilderAdapters.
    @hidden @internal
    */
    toJSONExt(context?: EntityQueryJsonContext): Object;
    static fromEntities(entity: Entity): EntityQuery;
    static fromEntities(entities: Entity[]): EntityQuery;
    /**
    Creates an EntityQuery for the specified [[EntityKey]].
    >      let empType = metadataStore.getEntityType("Employee");
    >      let entityKey = new EntityKey(empType, 1);
    >      let query = EntityQuery.fromEntityKey(entityKey);
  
    or
    >      // 'employee' is a previously queried employee
    >      let entityKey = employee.entityAspect.getKey();
    >      let query = EntityQuery.fromEntityKey(entityKey);
    @param entityKey - The [[EntityKey]] for which a query will be created.
    **/
    static fromEntityKey(entityKey: EntityKey): EntityQuery;
    /**
    Creates an EntityQuery for the specified entity and [[NavigationProperty]].
    >      // 'employee' is a previously queried employee
    >      let ordersNavProp = employee.entityType.getProperty("Orders");
    >      let query = EntityQuery.fromEntityNavigation(employee, ordersNavProp);
  
    will return a query for the "Orders" of the specified 'employee'.
    @param entity - The Entity whose navigation property will be queried.
    @param navigationProperty - The [[NavigationProperty]] or name of the NavigationProperty to be queried.
    **/
    static fromEntityNavigation: (entity: Entity, navigationProperty: string | NavigationProperty) => EntityQuery;
    /** @hidden @internal */
    _getFromEntityType(metadataStore: MetadataStore, throwErrorIfNotFound?: boolean): EntityType;
    /** @hidden @internal */
    _getToEntityType(metadataStore: MetadataStore, skipFromCheck?: boolean): EntityType | undefined;
    /** @hidden @internal */
    _toUri(em: EntityManager): string;
}
/** Base class for BooleanQueryOp and FilterQueryOp */
export interface QueryOp {
    /** The operator for this enum. */
    operator: string;
}
/**
FilterQueryOp is an 'Enum' containing all of the valid  [[Predicate]]
filter operators for an [[EntityQuery]].
**/
export declare class FilterQueryOp extends BreezeEnum implements QueryOp {
    /** The operator for this enum. */
    operator: string;
    /** Aliases: "eq", "==" **/
    static Equals: FilterQueryOp;
    /**  Aliases: "ne", "!="  **/
    static NotEquals: FilterQueryOp;
    /** Aliases: "gt", ">"   **/
    static GreaterThan: FilterQueryOp;
    /** Aliases: "lt", "<"  **/
    static LessThan: FilterQueryOp;
    /**  Aliases: "ge", ">="  **/
    static GreaterThanOrEqual: FilterQueryOp;
    /**  Aliases: "le", "<="  **/
    static LessThanOrEqual: FilterQueryOp;
    /**  String operation: Is a string a substring of another string.  Aliases: "substringof"   **/
    static Contains: FilterQueryOp;
    /** No aliases */
    static StartsWith: FilterQueryOp;
    /** No aliases */
    static EndsWith: FilterQueryOp;
    /**  Aliases: "some"  **/
    static Any: FilterQueryOp;
    /**  Aliases: "every"  **/
    static All: FilterQueryOp;
    /** No aliases */
    static In: FilterQueryOp;
    /** No aliases */
    static IsTypeOf: FilterQueryOp;
}
/**
 BooleanQueryOp is an 'Enum' containing all of the valid  boolean
operators for an [[EntityQuery]].
**/
export declare class BooleanQueryOp extends BreezeEnum implements QueryOp {
    /** The operator for this enum. */
    operator: string;
    static And: BooleanQueryOp;
    static Or: BooleanQueryOp;
    static Not: BooleanQueryOp;
}
/** For use by breeze plugin authors only.  The class is used in most [[IUriBuilderAdapter]] implementations
@adapter (see [[IUriBuilderAdapter]])
@hidden

An OrderByClause is a description of the properties and direction that the result
of a query should be sorted in.  OrderByClauses are immutable, which means that any
method that would modify an OrderByClause actually returns a new OrderByClause.

For example for an Employee object with properties of 'Company' and 'LastName' the following would be valid expressions:
>     let obc = new OrderByClause("Company.CompanyName, LastName")

or
>     let obc = new OrderByClause("Company.CompanyName desc, LastName")

or
>     let obc = new OrderByClause("Company.CompanyName, LastName", true);
*/
export declare class OrderByClause {
    /** @hidden @internal */
    items: OrderByItem[];
    constructor(propertyPaths: string[] | OrderByClause[], isDesc?: boolean);
    validate(entityType: EntityType): void;
    getComparer(entityType: EntityType): (entity1: any, entity2: any) => number;
    toJSONExt(context: EntityQueryJsonContext): string[];
}
/** @hidden @internal */
export declare class OrderByItem {
    propertyPath: string;
    isDesc: boolean;
    lastProperty: EntityProperty;
    constructor(propertyPath: string, isDesc?: boolean);
    validate(entityType: EntityType): EntityProperty | undefined;
    getComparer(entityType: EntityType): (entity1: any, entity2: any) => 0 | 1 | -1;
}
/** For use by breeze plugin authors only.  The class is used in most [[IUriBuilderAdapter]] implementations
@adapter (see [[IUriBuilderAdapter]])
@hidden
**/
export declare class SelectClause {
    propertyPaths: string[];
    /** @hidden @internal */
    _pathNames: string[];
    constructor(propertyPaths: string[]);
    validate(entityType: EntityType): void;
    toFunction(): (entity: Entity) => {};
    toJSONExt(context: EntityQueryJsonContext): any[];
}
/** For use by breeze plugin authors only.  The class is used in most [[IUriBuilderAdapter]] implementations
@adapter (see [[IUriBuilderAdapter]])
@hidden
**/
export declare class ExpandClause {
    propertyPaths: string[];
    constructor(propertyPaths: string[]);
    toJSONExt(context: EntityQueryJsonContext): any[];
}
