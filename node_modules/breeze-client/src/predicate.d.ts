import { EntityType, StructuralType } from './entity-metadata';
import { QueryOp } from './entity-query';
import { DataType } from './data-type';
export interface Op {
    key: string;
    aliases?: string[];
    isFunction?: boolean;
}
/** @hidden @internal */
export interface OpMap {
    [key: string]: Op;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export interface Visitor {
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export interface VisitContext {
    entityType?: EntityType;
    toNameOnServer?: boolean;
    useExplicitDataType?: boolean;
    visitor?: Visitor;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export interface ExpressionContext {
    entityType?: EntityType;
    usesNameOnServer?: boolean;
    dataType?: DataType | string;
    isRHS?: boolean;
    isFnArg?: boolean;
}
/**
Used to define a 'where' predicate for an [[EntityQuery]].  Predicates are immutable, which means that any
method that would modify a Predicate actually returns a new Predicate.
**/
export declare class Predicate {
    op: Op;
    /** @hidden @internal */
    _entityType?: EntityType;
    /** @hidden @internal */
    aliasMap: OpMap;
    visitorMethodName: string;
    /**
    Predicate constructor
    >     let p1 = new Predicate("CompanyName", "StartsWith", "B");
    >     let query = new EntityQuery("Customers").where(p1);
  
    or
    >     let p2 = new Predicate("Region", FilterQueryOp.Equals, null);
    >     let query = new EntityQuery("Customers").where(p2);
    @param property - A property name, a nested property name or an expression involving a property name.
    @param operator -
    @param value - This will be treated as either a property expression or a literal depending on context.  In general,
    if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal.
    In most cases this works well, but you can also force the interpretation by making the value argument itself an object with a 'value'
    property and an 'isLiteral' property set to either true or false.  Breeze also tries to infer the dataType of any
    literal based on context, if this fails you can force this inference by making the value argument an object with a
    'value' property and a 'dataType' property set to one of the breeze.DataType enumeration instances.
    **/
    constructor(...args: any[]);
    /**
    Same as using the ctor.
    >      // so
    >      let p = Predicate.create(a, b, c);
    >      // is the same as
    >      let p = new Predicate(a, b, c);
    @param property -  A property name, a nested property name or an expression involving a property name.
    @param operator - the filter query operator.
    @param value - This will be treated as either a property expression or a literal depending on context.  In general,
    if the value can be interpreted as a property expression it will be, otherwise it will be treated as a literal.
    In most cases this works well, but you can also force the interpretation by making the value argument itself an object with a 'value'
    property and an 'isLiteral' property set to either true or false.  Breeze also tries to infer the dataType of any
    literal based on context, if this fails you can force this inference by making the value argument an object with a
    'value' property and a 'dataType' property set to one of the breeze.DataType enumeration instances.
    **/
    static create(...args: any[]): Predicate;
    /** @hidden @internal */
    _validate(entityType: EntityType | undefined, usesNameOnServer?: boolean): void;
    /**
    Creates a 'composite' Predicate by 'and'ing a set of specified Predicates together.
    >      let dt = new Date(88, 9, 12);
    >      let p1 = Predicate.create("OrderDate", "ne", dt);
    >      let p2 = Predicate.create("ShipCity", "startsWith", "C");
    >      let p3 = Predicate.create("Freight", ">", 100);
    >      let newPred = Predicate.and(p1, p2, p3);
  
    or
    >      let preds = [p1, p2, p3];
    >      let newPred = Predicate.and(preds);
    @param predicates - multiple Predicates or an array of Predicate.
    Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.
    **/
    static and(...args: any[]): AndOrPredicate;
    /**
    Creates a 'composite' Predicate by 'or'ing a set of specified Predicates together.
    >      let dt = new Date(88, 9, 12);
    >      let p1 = Predicate.create("OrderDate", "ne", dt);
    >      let p2 = Predicate.create("ShipCity", "startsWith", "C");
    >      let p3 = Predicate.create("Freight", ">", 100);
    >      let newPred = Predicate.or(p1, p2, p3);
  
    or
    >      let preds = [p1, p2, p3];
    >      let newPred = Predicate.or(preds);
    @param predicates - multiple Predicates or an array of Predicate.
    Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.
    **/
    static or(...args: any[]): AndOrPredicate;
    /**
    Creates a 'composite' Predicate by 'negating' a specified predicate.
    >      let p1 = Predicate.create("Freight", "gt", 100);
    >      let not_p1 = Predicate.not(p1);
  
    This can also be accomplished using the 'instance' version of the 'not' method
    >      let not_p1 = p1.not();
  
    Both of which would be the same as
    >      let not_p1 = Predicate.create("Freight", "le", 100);
    **/
    static not(pred: Predicate): UnaryPredicate;
    /**
    'And's this Predicate with one or more other Predicates and returns a new 'composite' Predicate
    >      let dt = new Date(88, 9, 12);
    >      let p1 = Predicate.create("OrderDate", "ne", dt);
    >      let p2 = Predicate.create("ShipCity", "startsWith", "C");
    >      let p3 = Predicate.create("Freight", ">", 100);
    >      let newPred = p1.and(p2, p3);
  
    or
    >      let preds = [p2, p3];
    >      let newPred = p1.and(preds);
  
    The 'and' method is also used to write "fluent" expressions
    >      let p4 = Predicate.create("ShipCity", "startswith", "F")
    >        .and("Size", "gt", 2000);
    @param predicates - multiple Predicates or an array of Predicates.
    Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.
    **/
    and(...args: any[]): AndOrPredicate;
    /**
    'Or's this Predicate with one or more other Predicates and returns a new 'composite' Predicate
    >      let dt = new Date(88, 9, 12);
    >      let p1 = Predicate.create("OrderDate", "ne", dt);
    >      let p2 = Predicate.create("ShipCity", "startsWith", "C");
    >      let p3 = Predicate.create("Freight", ">", 100);
    >      let newPred = p1.or(p2, p3);
  
    or
    >      let preds = [p2, p3];
    >      let newPred = p1.or(preds);
  
    The 'or' method is also used to write "fluent" expressions
    >      let p4 = Predicate.create("ShipCity", "startswith", "F")
    >        .or("Size", "gt", 2000);
    @param predicates - multiple Predicates or an array of Predicates.
    Any null or undefined values passed in will be automatically filtered out before constructing the composite predicate.
    **/
    or(...args: any[]): AndOrPredicate;
    /**
    Returns the 'negated' version of this Predicate
    >      let p1 = Predicate.create("Freight", "gt", 100);
    >      let not_p1 = p1.not();
  
    This can also be accomplished using the 'static' version of the 'not' method
    >      let p1 = Predicate.create("Freight", "gt", 100);
    >      let not_p1 = Predicate.not(p1);
  
    which would be the same as
    >      let not_p1 = Predicate.create("Freight", "le", 100);
    **/
    not(): UnaryPredicate;
    toJSON(): any;
    /** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
    @adapter (see [[IUriBuilderAdapter]])
    @hidden @internal
    */
    toJSONExt(context: VisitContext): any;
    /** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
    @adapter (see [[IUriBuilderAdapter]])
    @hidden @internal
    */
    toFunction(context: VisitContext): any;
    toString(): string;
    /** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
    @adapter (see [[IUriBuilderAdapter]])
    @hidden @internal
    */
    visit(context: VisitContext, visitor?: Visitor): any;
    /** @hidden @internal */
    _initialize(visitorMethodName: string, opMap?: {
        [key: string]: {
            aliases?: string[];
            isFunction?: boolean;
        };
    }): void;
    /** @hidden @internal */
    _resolveOp(op: string | QueryOp, okIfNotFound?: boolean): Op;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export declare class UnaryPredicate extends Predicate {
    op: Op;
    pred: Predicate;
    constructor(op: string | QueryOp, ...args: any[]);
    _validate(entityType: EntityType, usesNameOnServer?: boolean): void;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export declare class BinaryPredicate extends Predicate {
    op: Op;
    expr1Source: any;
    expr2Source: any;
    expr1?: PredicateExpression;
    expr2?: PredicateExpression;
    constructor(op: string | QueryOp, expr1: any, expr2: any);
    _validate(entityType: EntityType, usesNameOnServer?: boolean): void;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export declare class AndOrPredicate extends Predicate {
    op: Op;
    preds: Predicate[];
    constructor(op: string | QueryOp, preds: any[]);
    _validate(entityType: EntityType, usesNameOnServer?: boolean): void;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export declare class AnyAllPredicate extends Predicate {
    op: Op;
    /** @internal */
    expr: PredicateExpression;
    exprSource: string;
    pred: Predicate;
    constructor(op: string | QueryOp, expr: string, pred: any);
    _validate(entityType: EntityType, usesNameOnServer: boolean): void;
}
/** @hidden */
export declare class PredicateExpression {
    visitorMethodName: string;
    visit: Function;
    dataType?: DataType | StructuralType;
    constructor(visitorMethodName: string);
    _validate(entityType: EntityType | undefined, usesNameOnServer?: boolean): void;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export declare class LitExpr extends PredicateExpression {
    value: any;
    dataType: DataType;
    hasExplicitDataType: boolean;
    constructor(value: any, dataType: string | DataType | undefined, hasExplicitDataType?: boolean);
    toString(): string;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden
*/
export declare class PropExpr extends PredicateExpression {
    propertyPath: string;
    dataType: DataType | StructuralType;
    constructor(propertyPath: string);
    toString(): string;
    _validate(entityType: EntityType | undefined, usesNameOnServer?: boolean): void;
}
/** For use by breeze plugin authors only. The class is for use in building a [[IUriBuilderAdapter]] implementation.
@adapter (see [[IUriBuilderAdapter]])
@hidden @dynamic
*/
export declare class FnExpr extends PredicateExpression {
    fnName: string;
    exprs: PredicateExpression[];
    localFn: any;
    dataType: DataType;
    constructor(fnName: string, exprs: PredicateExpression[]);
    toString(): string;
    _validate(entityType: EntityType | undefined, usesNameOnServer?: boolean): void;
    static _funcMap: {
        toupper: {
            fn: (source: string) => string;
            dataType: DataType;
        };
        tolower: {
            fn: (source: string) => string;
            dataType: DataType;
        };
        substring: {
            fn: (source: string, pos: number, length: number) => string;
            dataType: DataType;
        };
        substringof: {
            fn: (find: string, source: string) => boolean;
            dataType: DataType;
        };
        length: {
            fn: (source: any) => any;
            dataType: DataType;
        };
        trim: {
            fn: (source: string) => string;
            dataType: DataType;
        };
        concat: {
            fn: (s1: string, s2: string) => string;
            dataType: DataType;
        };
        replace: {
            fn: (source: string, find: string, replace: string) => string;
            dataType: DataType;
        };
        startswith: {
            fn: (source: string, find: string) => boolean;
            dataType: DataType;
        };
        endswith: {
            fn: (source: string, find: string) => boolean;
            dataType: DataType;
        };
        indexof: {
            fn: (source: any, find: any) => any;
            dataType: DataType;
        };
        round: {
            fn: (source: number) => number;
            dataType: DataType;
        };
        ceiling: {
            fn: (source: number) => number;
            dataType: DataType;
        };
        floor: {
            fn: (source: number) => number;
            dataType: DataType;
        };
        second: {
            fn: (source: Date) => number;
            dataType: DataType;
        };
        minute: {
            fn: (source: Date) => number;
            dataType: DataType;
        };
        day: {
            fn: (source: Date) => number;
            dataType: DataType;
        };
        month: {
            fn: (source: Date) => number;
            dataType: DataType;
        };
        year: {
            fn: (source: Date) => number;
            dataType: DataType;
        };
    };
}
