import { BreezeEvent } from './event';
import { EntityState } from './entity-state';
import { EntityType, ComplexType, DataProperty, NavigationProperty, EntityProperty } from './entity-metadata';
import { EntityKey } from './entity-key';
import { EntityGroup } from './entity-group';
import { EntityManager, QueryResult, QueryErrorCallback, QuerySuccessCallback } from './entity-manager';
import { ValidationError } from './validate';
export interface Entity {
    entityAspect: EntityAspect;
    entityType: EntityType;
    /** @internal */
    getProperty?(prop: string): any;
    /** @internal */
    setProperty?(prop: any, value: any): void;
    /** @hidden @internal */
    prototype?: {
        _$typeName: string;
    };
    /** @hidden @internal */
    _$entityType?: EntityType;
}
export interface ComplexObject {
    complexAspect: ComplexAspect;
    complexType: ComplexType;
    getProperty(prop: string): any;
    setProperty(prop: any, value: any): void;
    /** @hidden @internal */
    prototype?: {
        _$typeName: string;
    };
}
export declare type StructuralObject = Entity | ComplexObject;
export interface PropertyChangedEventArgs {
    entity: Entity;
    propertyName: string | null;
    parent?: StructuralObject;
    property?: EntityProperty;
    oldValue?: any;
    newValue?: any;
}
export interface ValidationErrorsChangedEventArgs {
    entity: Entity;
    added: ValidationError[];
    removed: ValidationError[];
}
/**
An EntityAspect instance is associated with every attached entity and is accessed via the entity's 'entityAspect' property.

The EntityAspect itself provides properties to determine and modify the EntityState of the entity and has methods
that provide a variety of services including validation and change tracking.

An EntityAspect will almost never need to be constructed directly. You will usually get an EntityAspect by accessing
an entities 'entityAspect' property.  This property will be automatically attached when an entity is created via either
a query, import or [[EntityManager.createEntity]] call.
>      // assume order is an order entity attached to an EntityManager.
>      var aspect = order.entityAspect;
>      var currentState = aspect.entityState;

**/
export declare class EntityAspect {
    /** The Entity that this aspect is associated with. __Read Only__  **/
    entity?: Entity;
    /** The [[EntityManager]] that contains this entity. __Read Only__ **/
    entityManager?: EntityManager;
    /**  @hidden @internal */
    entityGroup?: EntityGroup;
    /** The [[EntityState]] of this entity. __Read Only__ **/
    entityState: EntityState;
    /**   Whether this entity is in the process of being saved. __Read Only__ */
    isBeingSaved: boolean;
    /** The 'original values' of this entity where they are different from the 'current values'.
    This is a map where the key is a property name and the value is the 'original value' of the property. */
    originalValues: {};
    /**  Whether this entity has any validation errors. __Read Only__ */
    hasValidationErrors: boolean;
    /** Whether this entity has a temporary [[EntityKey]]. */
    hasTempKey: boolean;
    /** Whether this entity was created by being loaded from the database */
    wasLoaded?: boolean;
    /** Extra metadata about this entity such as the entity's etag.
    You may extend this object with your own metadata information.
    Breeze (de)serializes this object when importing/exporting the entity. **/
    extraMetadata?: any;
    /**
    A [[BreezeEvent]] that fires whenever any of the validation errors on this entity change.
    Note that this might be the removal of an error when some data on the entity is fixed.
    @eventArgs -
      - entity - The entity on which the validation errors are being added or removed.
      - added - An array containing any newly added [[ValidationError]]s
      - removed - An array containing any newly removed [[ValidationError]]s. This is those
        errors that have been 'fixed'.
  
  >      // assume order is an order entity attached to an EntityManager.
  >      order.entityAspect.validationErrorsChanged.subscribe(
  >      function (validationChangeArgs) {
  >          // this code will be executed anytime a property value changes on the 'order' entity.
  >          var entity == validationChangeArgs.entity; // Note: entity === order
  >          var errorsAdded = validationChangeArgs.added;
  >          var errorsCleared = validationChangeArgs.removed;
  >      });
    @event
    **/
    validationErrorsChanged: BreezeEvent<ValidationErrorsChangedEventArgs>;
    /**
    A [[BreezeEvent]] that fires whenever a value of one of this entity's properties change.
    @eventArgs -
      - entity - The entity whose property has changed.
      - property - The [[DataProperty]] that changed.
      - propertyName - The name of the property that changed. This value will be 'null' for operations that replace the entire entity.  This includes
        queries, imports and saves that require a merge. The remaining parameters will not exist in this case either. This will actually be a "property path"
        for any properties of a complex type.
      - oldValue - The old value of this property before the change.
      - newValue - The new value of this property after the change.
      - parent - The immediate parent object for the changed property.  This will be a ComplexType instance as opposed to an Entity
        for any complex type or nested complex type properties.
  
    >      // assume order is an order entity attached to an EntityManager.
    >      order.entityAspect.propertyChanged.subscribe(
    >      function (propertyChangedArgs) {
    >          // this code will be executed anytime a property value changes on the 'order' entity.
    >          var entity = propertyChangedArgs.entity; // Note: entity === order
    >          var propertyNameChanged = propertyChangedArgs.propertyName;
    >          var oldValue = propertyChangedArgs.oldValue;
    >          var newValue = propertyChangedArgs.newValue;
    >      });
    @event
    **/
    propertyChanged: BreezeEvent<PropertyChangedEventArgs>;
    /** @hidden @internal */
    _validationErrors: {
        [index: string]: ValidationError;
    };
    /** @hidden @internal */
    _pendingValidationResult: any;
    /** @hidden @internal */
    _entityKey: EntityKey;
    /** @hidden @internal */
    _loadedNps: any[];
    /** @hidden @internal */
    _initialized?: boolean;
    /** @hidden @internal */
    _inProcess: any[];
    /** @hidden @internal */
    _inProcessEntity?: Entity;
    /** @hidden @internal */
    static _nullInstance: EntityAspect;
    /** @hidden @internal */
    constructor(entity?: Entity);
    /** @hidden */
    static isEntity(obj: StructuralObject): obj is Entity;
    /**
    Returns the value of a specified 'property path' for a specified entity.
  
    The propertyPath can be either a string delimited with '.' or a string array.
    **/
    static getPropertyPathValue(obj: Entity, propertyPath: string | string[]): any;
    /**
    Returns the [[EntityKey]] for this Entity.
    >      // assume order is an order entity attached to an EntityManager.
    >      var entityKey = order.entityAspect.getKey();
    @param forceRefresh - (boolean=false) Forces the recalculation of the key.  This should normally be unnecessary.
    @return The [[EntityKey]] associated with this Entity.
    **/
    getKey(forceRefresh?: boolean): EntityKey;
    /**
    Returns the entity to an [[EntityState]] of 'Unchanged' by committing all changes made since the entity was last queried
    had 'acceptChanges' called on it.
    >      // assume order is an order entity attached to an EntityManager.
    >      order.entityAspect.acceptChanges();
    >      // The 'order' entity will now be in an 'Unchanged' state with any changes committed.
    **/
    acceptChanges(): void;
    /**
    Returns the entity to an [[EntityState]] of 'Unchanged' by rejecting all changes made to it since the entity was last queried
    had 'rejectChanges' called on it.
    >      // assume order is an order entity attached to an EntityManager.
    >      order.entityAspect.rejectChanges();
    >      // The 'order' entity will now be in an 'Unchanged' state with any changes rejected.
    **/
    rejectChanges(): void;
    /**  @hidden @internal */
    getPropertyPath(propName: string): string;
    /**
    Sets the entity to an EntityState of 'Added'.  This is NOT the equivalent of calling [[EntityManager.addEntity]]
    because no key generation will occur for autogenerated keys as a result of this operation. As a result this operation can be problematic
    unless you are certain that the entity being marked 'Added' does not already exist in the database and does not have an autogenerated key.
    The same operation can be performed by calling [[EntityAspect.setEntityState]].
    >      // assume order is an order entity attached to an EntityManager.
    >      order.entityAspect.setAdded();
    >      // The 'order' entity will now be in an 'Added' state.
    **/
    setAdded(): boolean;
    /**
    Sets the entity to an EntityState of 'Unchanged'.  This is also the equivalent of calling [[EntityAspect.acceptChanges]].
    The same operation can be performed by calling [[EntityAspect.setEntityState]].
    >      // assume order is an order entity attached to an EntityManager.
    >      order.entityAspect.setUnchanged();
    >      // The 'order' entity will now be in an 'Unchanged' state with any changes committed.
    **/
    setUnchanged: () => any;
    /**
    Sets the entity to an EntityState of 'Modified'.  This can also be achieved by changing the value of any property on an 'Unchanged' entity.
    The same operation can be performed by calling [[EntityAspect.setEntityState]].
    >      // assume order is an order entity attached to an EntityManager.
    >      order.entityAspect.setModified();
    >      // The 'order' entity will now be in a 'Modified' state.
    **/
    setModified: () => any;
    /**
    Sets the entity to an EntityState of 'Deleted'.  This both marks the entity as being scheduled for deletion during the next 'Save' call
    but also removes the entity from all of its related entities.
    The same operation can be performed by calling [[EntityAspect.setEntityState]].
    >      // assume order is an order entity attached to an EntityManager.
    >      order.entityAspect.setDeleted();
    >      // The 'order' entity will now be in a 'Deleted' state and it will no longer have any 'related' entities.
    **/
    setDeleted: () => any;
    /**
    Sets the entity to an EntityState of 'Detached'.  This removes the entity from all of its related entities, but does NOT change the EntityState of any existing entities.
    The same operation can be performed by calling [[EntityAspect.setEntityState]].
    >      // assume order is an order entity attached to an EntityManager.
    >      order.entityAspect.setDetached();
    >      // The 'order' entity will now be in a 'Detached' state and it will no longer have any 'related' entities.
    **/
    setDetached: () => any;
    /**
    Sets the entity to the specified EntityState. See also 'setUnchanged', 'setModified', 'setDetached', etc.
    >      // assume order is an order entity attached to an EntityManager.
    >      order.entityAspect.setEntityState(EntityState.Unchanged);
    >      // The 'order' entity will now be in a 'Unchanged' state.
    **/
    setEntityState(entityState: EntityState): boolean;
    loadNavigationProperty(navigationProperty: string, callback?: QuerySuccessCallback, errorCallback?: QueryErrorCallback): Promise<QueryResult>;
    loadNavigationProperty(navigationProperty: NavigationProperty, callback?: QuerySuccessCallback, errorCallback?: QueryErrorCallback): Promise<QueryResult>;
    /**
    Marks this navigationProperty on this entity as already having been loaded.
    >      emp.entityAspect.markNavigationPropertyAsLoaded("Orders");
    @param navigationProperty - The NavigationProperty or name of NavigationProperty to 'load'.
    **/
    markNavigationPropertyAsLoaded(navigationProperty: NavigationProperty | string): void;
    isNavigationPropertyLoaded(navigationProperty: string): boolean;
    isNavigationPropertyLoaded(navigationProperty: NavigationProperty): boolean;
    /** @hidden @internal */
    _markAsLoaded(navPropName: string): void;
    /**
    Performs validation on the entity, any errors encountered during the validation are available via the
    [[EntityAspect.getValidationErrors]] method. Validating an entity means executing
    all of the validators on both the entity itself as well as those on each of its properties.
    >      // assume order is an order entity attached to an EntityManager.
    >      var isOk = order.entityAspect.validateEntity();
    >      // isOk will be 'true' if there are no errors on the entity.
    >      if (!isOk) {
    >          var errors = order.entityAspect.getValidationErrors();
    >      }
    @return Whether the entity passed validation.
    **/
    validateEntity(): boolean;
    validateProperty(property: string, context?: any): boolean;
    validateProperty(property: DataProperty, context?: any): boolean;
    validateProperty(property: NavigationProperty, context?: any): boolean;
    getValidationErrors(): ValidationError[];
    getValidationErrors(property: string): ValidationError[];
    getValidationErrors(property: EntityProperty): ValidationError[];
    /**
    Adds a validation error.
    **/
    addValidationError(validationError: ValidationError): void;
    removeValidationError(validationError: ValidationError): void;
    removeValidationError(validationKey: string): void;
    /**
    Removes all of the validation errors for a specified entity
    **/
    clearValidationErrors(): void;
    /**
    Returns an [[EntityKey]] for the entity pointed to by the specified scalar NavigationProperty.
    This only returns an EntityKey if the current entity is a 'child' entity along the specified NavigationProperty.
    i.e. has a single parent.
  
    @param navigationProperty - The [[NavigationProperty]] ( pointing to a parent).
    @returns Either a parent EntityKey if this is a 'child' entity or null;
    */
    getParentKey(navigationProperty: NavigationProperty): EntityKey;
    /**
    Returns the value of a specified DataProperty or NavigationProperty or 'property path'.
    **/
    getPropertyValue(property: string | DataProperty | NavigationProperty): any;
    /** @hidden @internal */
    _checkOperation(operationName: string): this;
    /** @hidden @internal */
    _detach(): void;
    /** @hidden @internal */
    _validateProperty(value: any, context: any): boolean;
    /** @hidden @internal */
    _processValidationOpAndPublish(validationFn: any): void;
    /** @hidden @internal */
    _addValidationError(validationError: any): void;
    /** @hidden @internal */
    _removeValidationError(key: string): void;
}
/**
An ComplexAspect instance is associated with every complex object instance and is accessed via the complex object's 'complexAspect' property.

The ComplexAspect itself provides properties to determine the parent object, parent property and original values for the complex object.

A ComplexAspect will almost never need to be constructed directly. You will usually get an ComplexAspect by accessing
an entities 'complexAspect' property.  This property will be automatically attached when an complex object is created as part of an
entity via either a query, import or EntityManager.createEntity call.
>      // assume address is a complex property on the 'Customer' type
>      var aspect = aCustomer.address.complexAspect;
>      // aCustomer === aspect.parent;
**/
export declare class ComplexAspect {
    /** The complex object that this aspect is associated with. __Read Only__ */
    complexObject: ComplexObject;
    /** The 'original values' of this complex object where they are different from the 'current values'.
    This is a map where the key is a property name and the value is the 'original value' of the property.
    __Read Only__ */
    originalValues: {};
    /** The parent object that to which this aspect belongs; this will either be an entity or another complex object. __Read Only__ */
    parent?: StructuralObject;
    /** The [[DataProperty]] on the 'parent' that contains this complex object. __Read Only__ */
    parentProperty?: DataProperty;
    extraMetadata?: any;
    /** You will rarely, if ever, create a ComplexAspect directly. */
    constructor(complexObject: ComplexObject, parent: StructuralObject, parentProperty: DataProperty);
    /**
    Returns the EntityAspect for the top level entity that contains this complex object.
    **/
    getEntityAspect(): any;
    /**  @hidden @internal */
    getPropertyPath(propName: string): any;
}
