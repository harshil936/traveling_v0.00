import { EntityType, MetadataStore } from './entity-metadata';
/**
An EntityKey is an object that represents the unique identity of an entity.  EntityKey's are immutable.


**/
export declare class EntityKey {
    /** @hidden @internal */
    _$typeName: string;
    /** @hidden @internal */
    static ENTITY_KEY_DELIMITER: string;
    /**  The 'EntityType' that this is a key for. __Read Only__ */
    entityType: EntityType;
    /**  An array of the values for this key. This will usually only have a single element,
    unless the entity type has a multipart key. __Read Only__ */
    values: any[];
    /** @hidden @internal */
    _keyInGroup: string;
    /** @hidden @internal */
    _subtypes: EntityType[];
    /**
    Constructs a new EntityKey.  Each entity within an EntityManager will have a unique EntityKey.
    >     // assume em1 is an EntityManager containing a number of existing entities.
    >     var empType = em1.metadataStore.getEntityType("Employee");
    >     var entityKey = new EntityKey(empType, 1);
  
    EntityKey's may also be found by calling EntityAspect.getKey()
    >     // assume employee1 is an existing Employee entity
    >     var empKey = employee1.entityAspect.getKey();
  
    Multipart keys are created by passing an array as the 'keyValues' parameter
    >     var empTerrType = em1.metadataStore.getEntityType("EmployeeTerritory");
    >     var empTerrKey = new EntityKey(empTerrType, [ 1, 77]);
    >     // The order of the properties in the 'keyValues' array must be the same as that
    >     // returned by empTerrType.keyProperties
    @param entityType - The [[EntityType]] of the entity.
    @param keyValues - A single value or an array of values.
    */
    constructor(entityType: EntityType, keyValues: any);
    toJSON(): {
        entityType: string;
        values: any[];
    };
    static fromJSON(json: any, metadataStore: MetadataStore): EntityKey;
    /**
    Used to compare EntityKeys are determine if they refer to the same Entity.
    There is also an static version of 'equals' with the same functionality.
    
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      var empType = em1.metadataStore.getEntityType("Employee");
    >      var empKey1 = new EntityKey(empType, 1);
    >      // assume employee1 is an existing Employee entity
    >      var empKey2 = employee1.entityAspect.getKey();
    >      if (empKey1.equals(empKey2)) {
    >          // do something  ...
    >      }
    **/
    equals(entityKey: EntityKey): boolean;
    toString(altEntityType?: EntityType): string;
    /**
    Used to compare EntityKeys are determine if they refer to the same Entity.
    There is also an instance version of 'equals' with the same functionality.
    >      // assume em1 is an EntityManager containing a number of existing entities.
    >      var empType = em1.metadataStore.getEntityType("Employee");
    >      var empKey1 = new EntityKey(empType, 1);
    >      // assume employee1 is an existing Employee entity
    >      var empKey2 = employee1.entityAspect.getKey();
    >      if (EntityKey.equals(empKey1, empKey2)) {
    >          // do something  ...
    >      }
    **/
    static equals(k1: EntityKey, k2: EntityKey): boolean;
    /** @hidden @internal */
    _isEmpty(): boolean;
    /** hidden */
    static createKeyString(keyValues: any[]): string;
}
